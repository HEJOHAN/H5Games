function _typeof(e) {
    return (_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e) {
        return typeof e;
    }
    : function(e) {
        return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
    }
    )(e);
}
function set(e, t, r, n) {
    return (set = "undefined" != typeof Reflect && Reflect.set ? Reflect.set : function(e, t, r, n) {
        var i, a = _superPropBase(e, t);
        if (a) {
            if ((i = Object.getOwnPropertyDescriptor(a, t)).set)
                return i.set.call(n, r),
                !0;
            if (!i.writable)
                return !1;
        }
        if (i = Object.getOwnPropertyDescriptor(n, t)) {
            if (!i.writable)
                return !1;
            i.value = r,
            Object.defineProperty(n, t, i);
        } else
            _defineProperty(n, t, r);
        return !0;
    }
    )(e, t, r, n);
}
function _set(e, t, r, n, i) {
    if (!set(e, t, r, n || e) && i)
        throw new Error("failed to set property");
    return r;
}
function _defineProperty(e, t, r) {
    return t in e ? Object.defineProperty(e, t, {
        value: r,
        enumerable: !0,
        configurable: !0,
        writable: !0
    }) : e[t] = r,
    e;
}
function _possibleConstructorReturn(e, t) {
    return !t || "object" !== _typeof(t) && "function" != typeof t ? _assertThisInitialized(e) : t;
}
function _assertThisInitialized(e) {
    if (void 0 === e)
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return e;
}
function _get(e, t, r) {
    return (_get = "undefined" != typeof Reflect && Reflect.get ? Reflect.get : function(e, t, r) {
        var n = _superPropBase(e, t);
        if (n) {
            var i = Object.getOwnPropertyDescriptor(n, t);
            return i.get ? i.get.call(r) : i.value;
        }
    }
    )(e, t, r || e);
}
function _superPropBase(e, t) {
    for (; !Object.prototype.hasOwnProperty.call(e, t) && null !== (e = _getPrototypeOf(e)); )
        ;
    return e;
}
function _getPrototypeOf(e) {
    return (_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function(e) {
        return e.__proto__ || Object.getPrototypeOf(e);
    }
    )(e);
}
function _inherits(e, t) {
    if ("function" != typeof t && null !== t)
        throw new TypeError("Super expression must either be null or a function");
    e.prototype = Object.create(t && t.prototype, {
        constructor: {
            value: e,
            writable: !0,
            configurable: !0
        }
    }),
    t && _setPrototypeOf(e, t);
}
function _setPrototypeOf(e, t) {
    return (_setPrototypeOf = Object.setPrototypeOf || function(e, t) {
        return e.__proto__ = t,
        e;
    }
    )(e, t);
}
function _classCallCheck(e, t) {
    if (!(e instanceof t))
        throw new TypeError("Cannot call a class as a function");
}
function _defineProperties(e, t) {
    for (var r = 0; r < t.length; r++) {
        var n = t[r];
        n.enumerable = n.enumerable || !1,
        n.configurable = !0,
        "value"in n && (n.writable = !0),
        Object.defineProperty(e, n.key, n);
    }
}
function _createClass(e, t, r) {
    return t && _defineProperties(e.prototype, t),
    r && _defineProperties(e, r),
    e;
}
!function(e, t) {
    var r = function() {
        function MathUtils3D() {
            _classCallCheck(this, MathUtils3D);
        }
        return _createClass(MathUtils3D, null, [{
            key: "isZero",
            value: function(e) {
                return Math.abs(e) < MathUtils3D.zeroTolerance;
            }
        }, {
            key: "nearEqual",
            value: function(e, t) {
                return !!MathUtils3D.isZero(e - t);
            }
        }, {
            key: "fastInvSqrt",
            value: function(e) {
                return MathUtils3D.isZero(e) ? e : 1 / Math.sqrt(e);
            }
        }]),
        MathUtils3D;
    }();
    r.zeroTolerance = 1e-6,
    r.MaxValue = 3.40282347e38,
    r.MinValue = -3.40282347e38;
    var n = function() {
        function Vector2() {
            var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0
              , t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
            _classCallCheck(this, Vector2),
            this.x = e,
            this.y = t;
        }
        return _createClass(Vector2, [{
            key: "setValue",
            value: function(e, t) {
                this.x = e,
                this.y = t;
            }
        }, {
            key: "fromArray",
            value: function(e) {
                var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
                this.x = e[t + 0],
                this.y = e[t + 1];
            }
        }, {
            key: "cloneTo",
            value: function(e) {
                var t = e;
                t.x = this.x,
                t.y = this.y;
            }
        }, {
            key: "clone",
            value: function() {
                var e = new Vector2();
                return this.cloneTo(e),
                e;
            }
        }, {
            key: "forNativeElement",
            value: function() {
                var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null;
                e ? (this.elements = e,
                this.elements[0] = this.x,
                this.elements[1] = this.y) : this.elements = new Float32Array([this.x, this.y]),
                Vector2.rewriteNumProperty(this, "x", 0),
                Vector2.rewriteNumProperty(this, "y", 1);
            }
        }], [{
            key: "scale",
            value: function(e, t, r) {
                r.x = e.x * t,
                r.y = e.y * t;
            }
        }, {
            key: "dot",
            value: function(e, t) {
                return e.x * t.x + e.y * t.y;
            }
        }, {
            key: "normalize",
            value: function(e, t) {
                var r = e.x
                  , n = e.y
                  , i = r * r + n * n;
                i > 0 && (i = 1 / Math.sqrt(i),
                t.x = r * i,
                t.y = n * i);
            }
        }, {
            key: "scalarLength",
            value: function(e) {
                var t = e.x
                  , r = e.y;
                return Math.sqrt(t * t + r * r);
            }
        }, {
            key: "rewriteNumProperty",
            value: function(e, t, r) {
                Object.defineProperty(e, t, {
                    get: function() {
                        return this.elements[r];
                    },
                    set: function(e) {
                        this.elements[r] = e;
                    }
                });
            }
        }]),
        Vector2;
    }();
    n.ZERO = new n(0,0),
    n.ONE = new n(1,1);
    var i = function() {
        function Vector4() {
            var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0
              , t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0
              , r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0
              , n = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 0;
            _classCallCheck(this, Vector4),
            this.x = e,
            this.y = t,
            this.z = r,
            this.w = n;
        }
        return _createClass(Vector4, [{
            key: "setValue",
            value: function(e, t, r, n) {
                this.x = e,
                this.y = t,
                this.z = r,
                this.w = n;
            }
        }, {
            key: "fromArray",
            value: function(e) {
                var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
                this.x = e[t + 0],
                this.y = e[t + 1],
                this.z = e[t + 2],
                this.w = e[t + 3];
            }
        }, {
            key: "cloneTo",
            value: function(e) {
                var t = e;
                t.x = this.x,
                t.y = this.y,
                t.z = this.z,
                t.w = this.w;
            }
        }, {
            key: "clone",
            value: function() {
                var e = new Vector4();
                return this.cloneTo(e),
                e;
            }
        }, {
            key: "length",
            value: function() {
                return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
            }
        }, {
            key: "lengthSquared",
            value: function() {
                return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
            }
        }, {
            key: "forNativeElement",
            value: function() {
                var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null;
                e ? (this.elements = e,
                this.elements[0] = this.x,
                this.elements[1] = this.y,
                this.elements[2] = this.z,
                this.elements[3] = this.w) : this.elements = new Float32Array([this.x, this.y, this.z, this.w]),
                n.rewriteNumProperty(this, "x", 0),
                n.rewriteNumProperty(this, "y", 1),
                n.rewriteNumProperty(this, "z", 2),
                n.rewriteNumProperty(this, "w", 3);
            }
        }], [{
            key: "lerp",
            value: function(e, t, r, n) {
                var i = e.x
                  , a = e.y
                  , o = e.z
                  , s = e.w;
                n.x = i + r * (t.x - i),
                n.y = a + r * (t.y - a),
                n.z = o + r * (t.z - o),
                n.w = s + r * (t.w - s);
            }
        }, {
            key: "transformByM4x4",
            value: function(e, t, r) {
                var n = e.x
                  , i = e.y
                  , a = e.z
                  , o = e.w
                  , s = t.elements;
                r.x = n * s[0] + i * s[4] + a * s[8] + o * s[12],
                r.y = n * s[1] + i * s[5] + a * s[9] + o * s[13],
                r.z = n * s[2] + i * s[6] + a * s[10] + o * s[14],
                r.w = n * s[3] + i * s[7] + a * s[11] + o * s[15];
            }
        }, {
            key: "equals",
            value: function(e, t) {
                return r.nearEqual(Math.abs(e.x), Math.abs(t.x)) && r.nearEqual(Math.abs(e.y), Math.abs(t.y)) && r.nearEqual(Math.abs(e.z), Math.abs(t.z)) && r.nearEqual(Math.abs(e.w), Math.abs(t.w));
            }
        }, {
            key: "normalize",
            value: function(e, t) {
                var r = e.length();
                if (r > 0) {
                    var n = 1 / r;
                    t.x = e.x * n,
                    t.y = e.y * n,
                    t.z = e.z * n,
                    t.w = e.w * n;
                }
            }
        }, {
            key: "add",
            value: function(e, t, r) {
                r.x = e.x + t.x,
                r.y = e.y + t.y,
                r.z = e.z + t.z,
                r.w = e.w + t.w;
            }
        }, {
            key: "subtract",
            value: function(e, t, r) {
                r.x = e.x - t.x,
                r.y = e.y - t.y,
                r.z = e.z - t.z,
                r.w = e.w - t.w;
            }
        }, {
            key: "multiply",
            value: function(e, t, r) {
                r.x = e.x * t.x,
                r.y = e.y * t.y,
                r.z = e.z * t.z,
                r.w = e.w * t.w;
            }
        }, {
            key: "scale",
            value: function(e, t, r) {
                r.x = e.x * t,
                r.y = e.y * t,
                r.z = e.z * t,
                r.w = e.w * t;
            }
        }, {
            key: "Clamp",
            value: function(e, t, r, n) {
                var i = e.x
                  , a = e.y
                  , o = e.z
                  , s = e.w
                  , l = t.x
                  , u = t.y
                  , c = t.z
                  , h = t.w
                  , _ = r.x
                  , d = r.y
                  , f = r.z
                  , m = r.w;
                i = (i = i > _ ? _ : i) < l ? l : i,
                a = (a = a > d ? d : a) < u ? u : a,
                o = (o = o > f ? f : o) < c ? c : o,
                s = (s = s > m ? m : s) < h ? h : s,
                n.x = i,
                n.y = a,
                n.z = o,
                n.w = s;
            }
        }, {
            key: "distanceSquared",
            value: function(e, t) {
                var r = e.x - t.x
                  , n = e.y - t.y
                  , i = e.z - t.z
                  , a = e.w - t.w;
                return r * r + n * n + i * i + a * a;
            }
        }, {
            key: "distance",
            value: function(e, t) {
                var r = e.x - t.x
                  , n = e.y - t.y
                  , i = e.z - t.z
                  , a = e.w - t.w;
                return Math.sqrt(r * r + n * n + i * i + a * a);
            }
        }, {
            key: "dot",
            value: function(e, t) {
                return e.x * t.x + e.y * t.y + e.z * t.z + e.w * t.w;
            }
        }, {
            key: "min",
            value: function(e, t, r) {
                r.x = Math.min(e.x, t.x),
                r.y = Math.min(e.y, t.y),
                r.z = Math.min(e.z, t.z),
                r.w = Math.min(e.w, t.w);
            }
        }, {
            key: "max",
            value: function(e, t, r) {
                r.x = Math.max(e.x, t.x),
                r.y = Math.max(e.y, t.y),
                r.z = Math.max(e.z, t.z),
                r.w = Math.max(e.w, t.w);
            }
        }]),
        Vector4;
    }();
    i.ZERO = new i(),
    i.ONE = new i(1,1,1,1),
    i.UnitX = new i(1,0,0,0),
    i.UnitY = new i(0,1,0,0),
    i.UnitZ = new i(0,0,1,0),
    i.UnitW = new i(0,0,0,1);
    var a, o = function() {
        function Vector3() {
            var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0
              , t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0
              , r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0;
            arguments.length > 3 && void 0 !== arguments[3] && arguments[3];
            _classCallCheck(this, Vector3),
            this.x = e,
            this.y = t,
            this.z = r;
        }
        return _createClass(Vector3, [{
            key: "setValue",
            value: function(e, t, r) {
                this.x = e,
                this.y = t,
                this.z = r;
            }
        }, {
            key: "fromArray",
            value: function(e) {
                var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
                this.x = e[t + 0],
                this.y = e[t + 1],
                this.z = e[t + 2];
            }
        }, {
            key: "cloneTo",
            value: function(e) {
                var t = e;
                t.x = this.x,
                t.y = this.y,
                t.z = this.z;
            }
        }, {
            key: "clone",
            value: function() {
                var e = new Vector3();
                return this.cloneTo(e),
                e;
            }
        }, {
            key: "toDefault",
            value: function() {
                this.x = 0,
                this.y = 0,
                this.z = 0;
            }
        }, {
            key: "forNativeElement",
            value: function() {
                var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null;
                e ? (this.elements = e,
                this.elements[0] = this.x,
                this.elements[1] = this.y,
                this.elements[2] = this.z) : this.elements = new Float32Array([this.x, this.y, this.z]),
                n.rewriteNumProperty(this, "x", 0),
                n.rewriteNumProperty(this, "y", 1),
                n.rewriteNumProperty(this, "z", 2);
            }
        }], [{
            key: "distanceSquared",
            value: function(e, t) {
                var r = e.x - t.x
                  , n = e.y - t.y
                  , i = e.z - t.z;
                return r * r + n * n + i * i;
            }
        }, {
            key: "distance",
            value: function(e, t) {
                var r = e.x - t.x
                  , n = e.y - t.y
                  , i = e.z - t.z;
                return Math.sqrt(r * r + n * n + i * i);
            }
        }, {
            key: "min",
            value: function(e, t, r) {
                r.x = Math.min(e.x, t.x),
                r.y = Math.min(e.y, t.y),
                r.z = Math.min(e.z, t.z);
            }
        }, {
            key: "max",
            value: function(e, t, r) {
                r.x = Math.max(e.x, t.x),
                r.y = Math.max(e.y, t.y),
                r.z = Math.max(e.z, t.z);
            }
        }, {
            key: "transformQuat",
            value: function(e, t, r) {
                var n = e.x
                  , i = e.y
                  , a = e.z
                  , o = t.x
                  , s = t.y
                  , l = t.z
                  , u = t.w
                  , c = u * n + s * a - l * i
                  , h = u * i + l * n - o * a
                  , _ = u * a + o * i - s * n
                  , d = -o * n - s * i - l * a;
                r.x = c * u + d * -o + h * -l - _ * -s,
                r.y = h * u + d * -s + _ * -o - c * -l,
                r.z = _ * u + d * -l + c * -s - h * -o;
            }
        }, {
            key: "scalarLength",
            value: function(e) {
                var t = e.x
                  , r = e.y
                  , n = e.z;
                return Math.sqrt(t * t + r * r + n * n);
            }
        }, {
            key: "scalarLengthSquared",
            value: function(e) {
                var t = e.x
                  , r = e.y
                  , n = e.z;
                return t * t + r * r + n * n;
            }
        }, {
            key: "normalize",
            value: function(e, t) {
                var r = e.x
                  , n = e.y
                  , i = e.z
                  , a = r * r + n * n + i * i;
                a > 0 && (a = 1 / Math.sqrt(a),
                t.x = r * a,
                t.y = n * a,
                t.z = i * a);
            }
        }, {
            key: "multiply",
            value: function(e, t, r) {
                r.x = e.x * t.x,
                r.y = e.y * t.y,
                r.z = e.z * t.z;
            }
        }, {
            key: "scale",
            value: function(e, t, r) {
                r.x = e.x * t,
                r.y = e.y * t,
                r.z = e.z * t;
            }
        }, {
            key: "lerp",
            value: function(e, t, r, n) {
                var i = e.x
                  , a = e.y
                  , o = e.z;
                n.x = i + r * (t.x - i),
                n.y = a + r * (t.y - a),
                n.z = o + r * (t.z - o);
            }
        }, {
            key: "transformV3ToV3",
            value: function(e, t, r) {
                var n = Vector3._tempVector4;
                Vector3.transformV3ToV4(e, t, n),
                r.x = n.x,
                r.y = n.y,
                r.z = n.z;
            }
        }, {
            key: "transformV3ToV4",
            value: function(e, t, r) {
                var n = e.x
                  , i = e.y
                  , a = e.z
                  , o = t.elements;
                r.x = n * o[0] + i * o[4] + a * o[8] + o[12],
                r.y = n * o[1] + i * o[5] + a * o[9] + o[13],
                r.z = n * o[2] + i * o[6] + a * o[10] + o[14],
                r.w = n * o[3] + i * o[7] + a * o[11] + o[15];
            }
        }, {
            key: "TransformNormal",
            value: function(e, t, r) {
                var n = e.x
                  , i = e.y
                  , a = e.z
                  , o = t.elements;
                r.x = n * o[0] + i * o[4] + a * o[8],
                r.y = n * o[1] + i * o[5] + a * o[9],
                r.z = n * o[2] + i * o[6] + a * o[10];
            }
        }, {
            key: "transformCoordinate",
            value: function(e, t, r) {
                var n = e.x
                  , i = e.y
                  , a = e.z
                  , o = t.elements
                  , s = n * o[3] + i * o[7] + a * o[11] + o[15];
                r.x = n * o[0] + i * o[4] + a * o[8] + o[12] / s,
                r.y = n * o[1] + i * o[5] + a * o[9] + o[13] / s,
                r.z = n * o[2] + i * o[6] + a * o[10] + o[14] / s;
            }
        }, {
            key: "Clamp",
            value: function(e, t, r, n) {
                var i = e.x
                  , a = e.y
                  , o = e.z
                  , s = t.x
                  , l = t.y
                  , u = t.z
                  , c = r.x
                  , h = r.y
                  , _ = r.z;
                i = (i = i > c ? c : i) < s ? s : i,
                a = (a = a > h ? h : a) < l ? l : a,
                o = (o = o > _ ? _ : o) < u ? u : o,
                n.x = i,
                n.y = a,
                n.z = o;
            }
        }, {
            key: "add",
            value: function(e, t, r) {
                r.x = e.x + t.x,
                r.y = e.y + t.y,
                r.z = e.z + t.z;
            }
        }, {
            key: "subtract",
            value: function(e, t, r) {
                r.x = e.x - t.x,
                r.y = e.y - t.y,
                r.z = e.z - t.z;
            }
        }, {
            key: "cross",
            value: function(e, t, r) {
                var n = e.x
                  , i = e.y
                  , a = e.z
                  , o = t.x
                  , s = t.y
                  , l = t.z;
                r.x = i * l - a * s,
                r.y = a * o - n * l,
                r.z = n * s - i * o;
            }
        }, {
            key: "dot",
            value: function(e, t) {
                return e.x * t.x + e.y * t.y + e.z * t.z;
            }
        }, {
            key: "equals",
            value: function(e, t) {
                return r.nearEqual(e.x, t.x) && r.nearEqual(e.y, t.y) && r.nearEqual(e.z, t.z);
            }
        }]),
        Vector3;
    }();
    o._tempVector4 = new i(),
    o._ZERO = new o(0,0,0),
    o._ONE = new o(1,1,1),
    o._NegativeUnitX = new o(-1,0,0),
    o._UnitX = new o(1,0,0),
    o._UnitY = new o(0,1,0),
    o._UnitZ = new o(0,0,1),
    o._ForwardRH = new o(0,0,-1),
    o._ForwardLH = new o(0,0,1),
    o._Up = new o(0,1,0),
    (a = e.PBRRenderQuality || (e.PBRRenderQuality = {}))[a.High = 0] = "High",
    a[a.Low = 1] = "Low";
    var s = function() {
        function Config3D() {
            _classCallCheck(this, Config3D),
            this._defaultPhysicsMemory = 16,
            this._maxLightCount = 32,
            this._lightClusterCount = new o(12,12,12),
            this._editerEnvironment = !1,
            this.isAntialias = !0,
            this.isAlpha = !1,
            this.premultipliedAlpha = !0,
            this.isStencil = !0,
            this.enableMultiLight = !0,
            this.octreeCulling = !1,
            this.octreeInitialSize = 64,
            this.octreeInitialCenter = new o(0,0,0),
            this.octreeMinNodeSize = 2,
            this.octreeLooseness = 1.25,
            this.debugFrustumCulling = !1,
            this.pbrRenderQuality = e.PBRRenderQuality.High,
            this._maxAreaLightCountPerClusterAverage = Math.min(4 * Math.floor(2048 / this._lightClusterCount.z - 1), this._maxLightCount);
        }
        return _createClass(Config3D, [{
            key: "cloneTo",
            value: function(e) {
                var t = e;
                t._defaultPhysicsMemory = this._defaultPhysicsMemory,
                t._editerEnvironment = this._editerEnvironment,
                t.isAntialias = this.isAntialias,
                t.isAlpha = this.isAlpha,
                t.premultipliedAlpha = this.premultipliedAlpha,
                t.isStencil = this.isStencil,
                t.octreeCulling = this.octreeCulling,
                this.octreeInitialCenter.cloneTo(t.octreeInitialCenter),
                t.octreeInitialSize = this.octreeInitialSize,
                t.octreeMinNodeSize = this.octreeMinNodeSize,
                t.octreeLooseness = this.octreeLooseness,
                t.debugFrustumCulling = this.debugFrustumCulling,
                t.maxLightCount = this.maxLightCount,
                t.enableMultiLight = this.enableMultiLight;
                var r = t.lightClusterCount;
                this.lightClusterCount.cloneTo(r),
                t.lightClusterCount = r,
                t.pbrRenderQuality = this.pbrRenderQuality;
            }
        }, {
            key: "clone",
            value: function() {
                var e = new Config3D();
                return this.cloneTo(e),
                e;
            }
        }, {
            key: "defaultPhysicsMemory",
            get: function() {
                return this._defaultPhysicsMemory;
            },
            set: function(e) {
                if (e < 16)
                    throw "defaultPhysicsMemory must large than 16M";
                this._defaultPhysicsMemory = e;
            }
        }, {
            key: "maxLightCount",
            get: function() {
                return this._maxLightCount;
            },
            set: function(e) {
                e > 2048 ? (this._maxLightCount = 2048,
                console.warn("Config3D: maxLightCount must less equal 2048.")) : this._maxLightCount = e;
            }
        }, {
            key: "lightClusterCount",
            get: function() {
                return this._lightClusterCount;
            },
            set: function(e) {
                e.x > 128 || e.y > 128 || e.z > 128 ? (this._lightClusterCount.setValue(Math.min(e.x, 128), Math.min(e.y, 128), Math.min(e.z, 128)),
                console.warn("Config3D: lightClusterCount X and Y、Z must less equal 128.")) : e.cloneTo(this._lightClusterCount);
                var t = 4 * Math.floor(2048 / this._lightClusterCount.z - 1);
                t < this._maxLightCount && console.warn("Config3D: if the area light(PointLight、SpotLight) count is large than " + t + ",maybe the far away culster will ingonre some light."),
                this._maxAreaLightCountPerClusterAverage = Math.min(t, this._maxLightCount);
            }
        }]),
        Config3D;
    }();
    s._config = new s(),
    window.Config3D = s;
    var l = function ILaya3D() {
        _classCallCheck(this, ILaya3D);
    };
    l.Shader3D = null,
    l.Scene3D = null,
    l.MeshRenderStaticBatchManager = null,
    l.MeshRenderDynamicBatchManager = null,
    l.SubMeshDynamicBatch = null,
    l.Laya3D = null,
    l.Matrix4x4 = null;
    var u = function() {
        function KeyframeNode() {
            _classCallCheck(this, KeyframeNode),
            this._ownerPath = [],
            this._propertys = [],
            this._keyFrames = [];
        }
        return _createClass(KeyframeNode, [{
            key: "_setOwnerPathCount",
            value: function(e) {
                this._ownerPath.length = e;
            }
        }, {
            key: "_setOwnerPathByIndex",
            value: function(e, t) {
                this._ownerPath[e] = t;
            }
        }, {
            key: "_joinOwnerPath",
            value: function(e) {
                return this._ownerPath.join(e);
            }
        }, {
            key: "_setPropertyCount",
            value: function(e) {
                this._propertys.length = e;
            }
        }, {
            key: "_setPropertyByIndex",
            value: function(e, t) {
                this._propertys[e] = t;
            }
        }, {
            key: "_joinProperty",
            value: function(e) {
                return this._propertys.join(e);
            }
        }, {
            key: "_setKeyframeCount",
            value: function(e) {
                this._keyFrames.length = e;
            }
        }, {
            key: "_setKeyframeByIndex",
            value: function(e, t) {
                this._keyFrames[e] = t;
            }
        }, {
            key: "getOwnerPathByIndex",
            value: function(e) {
                return this._ownerPath[e];
            }
        }, {
            key: "getPropertyByIndex",
            value: function(e) {
                return this._propertys[e];
            }
        }, {
            key: "getKeyframeByIndex",
            value: function(e) {
                return this._keyFrames[e];
            }
        }, {
            key: "ownerPathCount",
            get: function() {
                return this._ownerPath.length;
            }
        }, {
            key: "propertyCount",
            get: function() {
                return this._propertys.length;
            }
        }, {
            key: "keyFramesCount",
            get: function() {
                return this._keyFrames.length;
            }
        }]),
        KeyframeNode;
    }()
      , c = function AnimationEvent() {
        _classCallCheck(this, AnimationEvent);
    }
      , h = function() {
        function Keyframe() {
            _classCallCheck(this, Keyframe);
        }
        return _createClass(Keyframe, [{
            key: "cloneTo",
            value: function(e) {
                e.time = this.time;
            }
        }, {
            key: "clone",
            value: function() {
                var e = new Keyframe();
                return this.cloneTo(e),
                e;
            }
        }]),
        Keyframe;
    }()
      , _ = function(e) {
        function FloatKeyframe() {
            return _classCallCheck(this, FloatKeyframe),
            _possibleConstructorReturn(this, _getPrototypeOf(FloatKeyframe).call(this));
        }
        return _inherits(FloatKeyframe, h),
        _createClass(FloatKeyframe, [{
            key: "cloneTo",
            value: function(e) {
                _get(_getPrototypeOf(FloatKeyframe.prototype), "cloneTo", this).call(this, e);
                var t = e;
                t.inTangent = this.inTangent,
                t.outTangent = this.outTangent,
                t.value = this.value;
            }
        }]),
        FloatKeyframe;
    }()
      , d = function() {
        function Matrix3x3() {
            _classCallCheck(this, Matrix3x3);
            var e = this.elements = new Float32Array(9);
            e[0] = 1,
            e[1] = 0,
            e[2] = 0,
            e[3] = 0,
            e[4] = 1,
            e[5] = 0,
            e[6] = 0,
            e[7] = 0,
            e[8] = 1;
        }
        return _createClass(Matrix3x3, [{
            key: "determinant",
            value: function() {
                var e = this.elements
                  , t = e[0]
                  , r = e[1]
                  , n = e[2]
                  , i = e[3]
                  , a = e[4]
                  , o = e[5]
                  , s = e[6]
                  , l = e[7]
                  , u = e[8];
                return t * (u * a - o * l) + r * (-u * i + o * s) + n * (l * i - a * s);
            }
        }, {
            key: "translate",
            value: function(e, t) {
                var r = t.elements
                  , n = this.elements
                  , i = n[0]
                  , a = n[1]
                  , o = n[2]
                  , s = n[3]
                  , l = n[4]
                  , u = n[5]
                  , c = n[6]
                  , h = n[7]
                  , _ = n[8]
                  , d = e.x
                  , f = e.y;
                r[0] = i,
                r[1] = a,
                r[2] = o,
                r[3] = s,
                r[4] = l,
                r[5] = u,
                r[6] = d * i + f * s + c,
                r[7] = d * a + f * l + h,
                r[8] = d * o + f * u + _;
            }
        }, {
            key: "rotate",
            value: function(e, t) {
                var r = t.elements
                  , n = this.elements
                  , i = n[0]
                  , a = n[1]
                  , o = n[2]
                  , s = n[3]
                  , l = n[4]
                  , u = n[5]
                  , c = n[6]
                  , h = n[7]
                  , _ = n[8]
                  , d = Math.sin(e)
                  , f = Math.cos(e);
                r[0] = f * i + d * s,
                r[1] = f * a + d * l,
                r[2] = f * o + d * u,
                r[3] = f * s - d * i,
                r[4] = f * l - d * a,
                r[5] = f * u - d * o,
                r[6] = c,
                r[7] = h,
                r[8] = _;
            }
        }, {
            key: "scale",
            value: function(e, t) {
                var r = t.elements
                  , n = this.elements
                  , i = e.x
                  , a = e.y;
                r[0] = i * n[0],
                r[1] = i * n[1],
                r[2] = i * n[2],
                r[3] = a * n[3],
                r[4] = a * n[4],
                r[5] = a * n[5],
                r[6] = n[6],
                r[7] = n[7],
                r[8] = n[8];
            }
        }, {
            key: "invert",
            value: function(e) {
                var t = e.elements
                  , r = this.elements
                  , n = r[0]
                  , i = r[1]
                  , a = r[2]
                  , o = r[3]
                  , s = r[4]
                  , l = r[5]
                  , u = r[6]
                  , c = r[7]
                  , h = r[8]
                  , _ = h * s - l * c
                  , d = -h * o + l * u
                  , f = c * o - s * u
                  , m = n * _ + i * d + a * f;
                m || (e = null),
                m = 1 / m,
                t[0] = _ * m,
                t[1] = (-h * i + a * c) * m,
                t[2] = (l * i - a * s) * m,
                t[3] = d * m,
                t[4] = (h * n - a * u) * m,
                t[5] = (-l * n + a * o) * m,
                t[6] = f * m,
                t[7] = (-c * n + i * u) * m,
                t[8] = (s * n - i * o) * m;
            }
        }, {
            key: "transpose",
            value: function(e) {
                var t = e.elements
                  , r = this.elements;
                if (e === this) {
                    var n = r[1]
                      , i = r[2]
                      , a = r[5];
                    t[1] = r[3],
                    t[2] = r[6],
                    t[3] = n,
                    t[5] = r[7],
                    t[6] = i,
                    t[7] = a;
                } else
                    t[0] = r[0],
                    t[1] = r[3],
                    t[2] = r[6],
                    t[3] = r[1],
                    t[4] = r[4],
                    t[5] = r[7],
                    t[6] = r[2],
                    t[7] = r[5],
                    t[8] = r[8];
            }
        }, {
            key: "identity",
            value: function() {
                var e = this.elements;
                e[0] = 1,
                e[1] = 0,
                e[2] = 0,
                e[3] = 0,
                e[4] = 1,
                e[5] = 0,
                e[6] = 0,
                e[7] = 0,
                e[8] = 1;
            }
        }, {
            key: "cloneTo",
            value: function(e) {
                var t, r, n;
                if ((r = this.elements) !== (n = e.elements))
                    for (t = 0; t < 9; ++t)
                        n[t] = r[t];
            }
        }, {
            key: "clone",
            value: function() {
                var e = new Matrix3x3();
                return this.cloneTo(e),
                e;
            }
        }], [{
            key: "createRotationQuaternion",
            value: function(e, t) {
                var r = e.x
                  , n = e.y
                  , i = e.z
                  , a = e.w
                  , o = r * r
                  , s = n * n
                  , l = i * i
                  , u = r * n
                  , c = i * a
                  , h = i * r
                  , _ = n * a
                  , d = n * i
                  , f = r * a
                  , m = t.elements;
                m[0] = 1 - 2 * (s + l),
                m[1] = 2 * (u + c),
                m[2] = 2 * (h - _),
                m[3] = 2 * (u - c),
                m[4] = 1 - 2 * (l + o),
                m[5] = 2 * (d + f),
                m[6] = 2 * (h + _),
                m[7] = 2 * (d - f),
                m[8] = 1 - 2 * (s + o);
            }
        }, {
            key: "createFromTranslation",
            value: function(e, t) {
                var r = t.elements;
                r[0] = 1,
                r[1] = 0,
                r[2] = 0,
                r[3] = 0,
                r[4] = 1,
                r[5] = 0,
                r[6] = e.x,
                r[7] = e.y,
                r[8] = 1;
            }
        }, {
            key: "createFromRotation",
            value: function(e, t) {
                var r = t.elements
                  , n = Math.sin(e)
                  , i = Math.cos(e);
                r[0] = i,
                r[1] = n,
                r[2] = 0,
                r[3] = -n,
                r[4] = i,
                r[5] = 0,
                r[6] = 0,
                r[7] = 0,
                r[8] = 1;
            }
        }, {
            key: "createFromScaling",
            value: function(e, t) {
                var r = t.elements;
                r[0] = e.x,
                r[1] = 0,
                r[2] = 0,
                r[3] = 0,
                r[4] = e.y,
                r[5] = 0,
                r[6] = 0,
                r[7] = 0,
                r[8] = e.z;
            }
        }, {
            key: "createFromMatrix4x4",
            value: function(e, t) {
                var r = e.elements
                  , n = t.elements;
                n[0] = r[0],
                n[1] = r[1],
                n[2] = r[2],
                n[3] = r[4],
                n[4] = r[5],
                n[5] = r[6],
                n[6] = r[8],
                n[7] = r[9],
                n[8] = r[10];
            }
        }, {
            key: "multiply",
            value: function(e, t, r) {
                var n = e.elements
                  , i = t.elements
                  , a = r.elements
                  , o = n[0]
                  , s = n[1]
                  , l = n[2]
                  , u = n[3]
                  , c = n[4]
                  , h = n[5]
                  , _ = n[6]
                  , d = n[7]
                  , f = n[8]
                  , m = i[0]
                  , p = i[1]
                  , v = i[2]
                  , T = i[3]
                  , E = i[4]
                  , y = i[5]
                  , g = i[6]
                  , S = i[7]
                  , R = i[8];
                a[0] = m * o + p * u + v * _,
                a[1] = m * s + p * c + v * S,
                a[2] = m * l + p * h + v * f,
                a[3] = T * o + E * u + y * _,
                a[4] = T * s + E * c + y * d,
                a[5] = T * l + E * h + y * f,
                a[6] = g * o + S * u + R * _,
                a[7] = g * s + S * c + R * d,
                a[8] = g * l + S * h + R * f;
            }
        }, {
            key: "lookAt",
            value: function(e, t, r, n) {
                o.subtract(e, t, Matrix3x3._tempV30),
                o.normalize(Matrix3x3._tempV30, Matrix3x3._tempV30),
                o.cross(r, Matrix3x3._tempV30, Matrix3x3._tempV31),
                o.normalize(Matrix3x3._tempV31, Matrix3x3._tempV31),
                o.cross(Matrix3x3._tempV30, Matrix3x3._tempV31, Matrix3x3._tempV32);
                var i = Matrix3x3._tempV30
                  , a = Matrix3x3._tempV31
                  , s = Matrix3x3._tempV32
                  , l = n.elements;
                l[0] = a.x,
                l[3] = a.y,
                l[6] = a.z,
                l[1] = s.x,
                l[4] = s.y,
                l[7] = s.z,
                l[2] = i.x,
                l[5] = i.y,
                l[8] = i.z;
            }
        }]),
        Matrix3x3;
    }();
    d.DEFAULT = new d(),
    d._tempV30 = new o(),
    d._tempV31 = new o(),
    d._tempV32 = new o();
    var f = function() {
        function Quaternion() {
            var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0
              , t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0
              , r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0
              , n = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 1;
            arguments.length > 4 && void 0 !== arguments[4] && arguments[4];
            _classCallCheck(this, Quaternion),
            this.x = e,
            this.y = t,
            this.z = r,
            this.w = n;
        }
        return _createClass(Quaternion, [{
            key: "scaling",
            value: function(e, t) {
                t.x = this.x * e,
                t.y = this.y * e,
                t.z = this.z * e,
                t.w = this.w * e;
            }
        }, {
            key: "normalize",
            value: function(e) {
                var t = this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
                t > 0 && (t = 1 / Math.sqrt(t),
                e.x = this.x * t,
                e.y = this.y * t,
                e.z = this.z * t,
                e.w = this.w * t);
            }
        }, {
            key: "length",
            value: function() {
                return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
            }
        }, {
            key: "rotateX",
            value: function(e, t) {
                e *= .5;
                var r = Math.sin(e)
                  , n = Math.cos(e);
                t.x = this.x * n + this.w * r,
                t.y = this.y * n + this.z * r,
                t.z = this.z * n - this.y * r,
                t.w = this.w * n - this.x * r;
            }
        }, {
            key: "rotateY",
            value: function(e, t) {
                e *= .5;
                var r = Math.sin(e)
                  , n = Math.cos(e);
                t.x = this.x * n - this.z * r,
                t.y = this.y * n + this.w * r,
                t.z = this.z * n + this.x * r,
                t.w = this.w * n - this.y * r;
            }
        }, {
            key: "rotateZ",
            value: function(e, t) {
                e *= .5;
                var r = Math.sin(e)
                  , n = Math.cos(e);
                t.x = this.x * n + this.y * r,
                t.y = this.y * n - this.x * r,
                t.z = this.z * n + this.w * r,
                t.w = this.w * n - this.z * r;
            }
        }, {
            key: "getYawPitchRoll",
            value: function(e) {
                o.transformQuat(o._ForwardRH, this, Quaternion.TEMPVector31),
                o.transformQuat(o._Up, this, Quaternion.TEMPVector32);
                var t = Quaternion.TEMPVector32;
                Quaternion.angleTo(o._ZERO, Quaternion.TEMPVector31, Quaternion.TEMPVector33);
                var r = Quaternion.TEMPVector33;
                r.x == Math.PI / 2 ? (r.y = Quaternion.arcTanAngle(t.z, t.x),
                r.z = 0) : r.x == -Math.PI / 2 ? (r.y = Quaternion.arcTanAngle(-t.z, -t.x),
                r.z = 0) : (l.Matrix4x4.createRotationY(-r.y, l.Matrix4x4.TEMPMatrix0),
                l.Matrix4x4.createRotationX(-r.x, l.Matrix4x4.TEMPMatrix1),
                o.transformCoordinate(Quaternion.TEMPVector32, l.Matrix4x4.TEMPMatrix0, Quaternion.TEMPVector32),
                o.transformCoordinate(Quaternion.TEMPVector32, l.Matrix4x4.TEMPMatrix1, Quaternion.TEMPVector32),
                r.z = Quaternion.arcTanAngle(t.y, -t.x)),
                r.y <= -Math.PI && (r.y = Math.PI),
                r.z <= -Math.PI && (r.z = Math.PI),
                r.y >= Math.PI && r.z >= Math.PI && (r.y = 0,
                r.z = 0,
                r.x = Math.PI - r.x);
                var n = e;
                n.x = r.y,
                n.y = r.x,
                n.z = r.z;
            }
        }, {
            key: "invert",
            value: function(e) {
                var t = this.x
                  , r = this.y
                  , n = this.z
                  , i = this.w
                  , a = t * t + r * r + n * n + i * i
                  , o = a ? 1 / a : 0;
                e.x = -t * o,
                e.y = -r * o,
                e.z = -n * o,
                e.w = i * o;
            }
        }, {
            key: "identity",
            value: function() {
                this.x = 0,
                this.y = 0,
                this.z = 0,
                this.w = 1;
            }
        }, {
            key: "fromArray",
            value: function(e) {
                var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
                this.x = e[t + 0],
                this.y = e[t + 1],
                this.z = e[t + 2],
                this.w = e[t + 3];
            }
        }, {
            key: "cloneTo",
            value: function(e) {
                this !== e && (e.x = this.x,
                e.y = this.y,
                e.z = this.z,
                e.w = this.w);
            }
        }, {
            key: "clone",
            value: function() {
                var e = new Quaternion();
                return this.cloneTo(e),
                e;
            }
        }, {
            key: "equals",
            value: function(e) {
                return r.nearEqual(this.x, e.x) && r.nearEqual(this.y, e.y) && r.nearEqual(this.z, e.z) && r.nearEqual(this.w, e.w);
            }
        }, {
            key: "lengthSquared",
            value: function() {
                return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
            }
        }, {
            key: "forNativeElement",
            value: function() {
                var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null;
                e ? (this.elements = e,
                this.elements[0] = this.x,
                this.elements[1] = this.y,
                this.elements[2] = this.z,
                this.elements[3] = this.w) : this.elements = new Float32Array([this.x, this.y, this.z, this.w]),
                n.rewriteNumProperty(this, "x", 0),
                n.rewriteNumProperty(this, "y", 1),
                n.rewriteNumProperty(this, "z", 2),
                n.rewriteNumProperty(this, "w", 3);
            }
        }], [{
            key: "createFromYawPitchRoll",
            value: function(e, t, r, n) {
                var i = .5 * r
                  , a = .5 * t
                  , o = .5 * e
                  , s = Math.sin(i)
                  , l = Math.cos(i)
                  , u = Math.sin(a)
                  , c = Math.cos(a)
                  , h = Math.sin(o)
                  , _ = Math.cos(o);
                n.x = _ * u * l + h * c * s,
                n.y = h * c * l - _ * u * s,
                n.z = _ * c * s - h * u * l,
                n.w = _ * c * l + h * u * s;
            }
        }, {
            key: "multiply",
            value: function(e, t, r) {
                var n = e.x
                  , i = e.y
                  , a = e.z
                  , o = e.w
                  , s = t.x
                  , l = t.y
                  , u = t.z
                  , c = t.w
                  , h = i * u - a * l
                  , _ = a * s - n * u
                  , d = n * l - i * s
                  , f = n * s + i * l + a * u;
                r.x = n * c + s * o + h,
                r.y = i * c + l * o + _,
                r.z = a * c + u * o + d,
                r.w = o * c - f;
            }
        }, {
            key: "arcTanAngle",
            value: function(e, t) {
                return 0 == e ? 1 == t ? Math.PI / 2 : -Math.PI / 2 : e > 0 ? Math.atan(t / e) : e < 0 ? t > 0 ? Math.atan(t / e) + Math.PI : Math.atan(t / e) - Math.PI : 0;
            }
        }, {
            key: "angleTo",
            value: function(e, t, r) {
                o.subtract(t, e, Quaternion.TEMPVector30),
                o.normalize(Quaternion.TEMPVector30, Quaternion.TEMPVector30),
                r.x = Math.asin(Quaternion.TEMPVector30.y),
                r.y = Quaternion.arcTanAngle(-Quaternion.TEMPVector30.z, -Quaternion.TEMPVector30.x);
            }
        }, {
            key: "createFromAxisAngle",
            value: function(e, t, r) {
                t *= .5;
                var n = Math.sin(t);
                r.x = n * e.x,
                r.y = n * e.y,
                r.z = n * e.z,
                r.w = Math.cos(t);
            }
        }, {
            key: "createFromMatrix4x4",
            value: function(e, t) {
                var r, n, i = e.elements, a = i[0] + i[5] + i[10];
                a > 0 ? (r = Math.sqrt(a + 1),
                t.w = .5 * r,
                r = .5 / r,
                t.x = (i[6] - i[9]) * r,
                t.y = (i[8] - i[2]) * r,
                t.z = (i[1] - i[4]) * r) : i[0] >= i[5] && i[0] >= i[10] ? (n = .5 / (r = Math.sqrt(1 + i[0] - i[5] - i[10])),
                t.x = .5 * r,
                t.y = (i[1] + i[4]) * n,
                t.z = (i[2] + i[8]) * n,
                t.w = (i[6] - i[9]) * n) : i[5] > i[10] ? (n = .5 / (r = Math.sqrt(1 + i[5] - i[0] - i[10])),
                t.x = (i[4] + i[1]) * n,
                t.y = .5 * r,
                t.z = (i[9] + i[6]) * n,
                t.w = (i[8] - i[2]) * n) : (n = .5 / (r = Math.sqrt(1 + i[10] - i[0] - i[5])),
                t.x = (i[8] + i[2]) * n,
                t.y = (i[9] + i[6]) * n,
                t.z = .5 * r,
                t.w = (i[1] - i[4]) * n);
            }
        }, {
            key: "slerp",
            value: function(e, t, r, n) {
                var i, a, o, s, l, u = e.x, c = e.y, h = e.z, _ = e.w, d = t.x, f = t.y, m = t.z, p = t.w;
                return (a = u * d + c * f + h * m + _ * p) < 0 && (a = -a,
                d = -d,
                f = -f,
                m = -m,
                p = -p),
                1 - a > 1e-6 ? (i = Math.acos(a),
                o = Math.sin(i),
                s = Math.sin((1 - r) * i) / o,
                l = Math.sin(r * i) / o) : (s = 1 - r,
                l = r),
                n.x = s * u + l * d,
                n.y = s * c + l * f,
                n.z = s * h + l * m,
                n.w = s * _ + l * p,
                n;
            }
        }, {
            key: "lerp",
            value: function(e, t, r, n) {
                var i = 1 - r;
                Quaternion.dot(e, t) >= 0 ? (n.x = i * e.x + r * t.x,
                n.y = i * e.y + r * t.y,
                n.z = i * e.z + r * t.z,
                n.w = i * e.w + r * t.w) : (n.x = i * e.x - r * t.x,
                n.y = i * e.y - r * t.y,
                n.z = i * e.z - r * t.z,
                n.w = i * e.w - r * t.w),
                n.normalize(n);
            }
        }, {
            key: "add",
            value: function(e, t, r) {
                r.x = e.x + t.x,
                r.y = e.y + t.y,
                r.z = e.z + t.z,
                r.w = e.w + t.w;
            }
        }, {
            key: "dot",
            value: function(e, t) {
                return e.x * t.x + e.y * t.y + e.z * t.z + e.w * t.w;
            }
        }, {
            key: "rotationLookAt",
            value: function(e, t, r) {
                Quaternion.lookAt(o._ZERO, e, t, r);
            }
        }, {
            key: "lookAt",
            value: function(e, t, r, n) {
                d.lookAt(e, t, r, Quaternion._tempMatrix3x3),
                Quaternion.rotationMatrix(Quaternion._tempMatrix3x3, n);
            }
        }, {
            key: "invert",
            value: function(e, t) {
                var n = e.lengthSquared();
                r.isZero(n) || (n = 1 / n,
                t.x = -e.x * n,
                t.y = -e.y * n,
                t.z = -e.z * n,
                t.w = e.w * n);
            }
        }, {
            key: "rotationMatrix",
            value: function(e, t) {
                var r, n, i = e.elements, a = i[0], o = i[1], s = i[2], l = i[3], u = i[4], c = i[5], h = i[6], _ = i[7], d = i[8], f = a + u + d;
                f > 0 ? (r = Math.sqrt(f + 1),
                t.w = .5 * r,
                r = .5 / r,
                t.x = (c - _) * r,
                t.y = (h - s) * r,
                t.z = (o - l) * r) : a >= u && a >= d ? (n = .5 / (r = Math.sqrt(1 + a - u - d)),
                t.x = .5 * r,
                t.y = (o + l) * n,
                t.z = (s + h) * n,
                t.w = (c - _) * n) : u > d ? (n = .5 / (r = Math.sqrt(1 + u - a - d)),
                t.x = (l + o) * n,
                t.y = .5 * r,
                t.z = (_ + c) * n,
                t.w = (h - s) * n) : (n = .5 / (r = Math.sqrt(1 + d - a - u)),
                t.x = (h + s) * n,
                t.y = (_ + c) * n,
                t.z = .5 * r,
                t.w = (o - l) * n);
            }
        }]),
        Quaternion;
    }();
    f.TEMPVector30 = new o(),
    f.TEMPVector31 = new o(),
    f.TEMPVector32 = new o(),
    f.TEMPVector33 = new o(),
    f._tempMatrix3x3 = new d(),
    f.DEFAULT = new f(),
    f.NAN = new f(NaN,NaN,NaN,NaN);
    var m = function(e) {
        function QuaternionKeyframe() {
            var e;
            return _classCallCheck(this, QuaternionKeyframe),
            (e = _possibleConstructorReturn(this, _getPrototypeOf(QuaternionKeyframe).call(this))).inTangent = new i(),
            e.outTangent = new i(),
            e.value = new f(),
            e;
        }
        return _inherits(QuaternionKeyframe, h),
        _createClass(QuaternionKeyframe, [{
            key: "cloneTo",
            value: function(e) {
                _get(_getPrototypeOf(QuaternionKeyframe.prototype), "cloneTo", this).call(this, e);
                var t = e;
                this.inTangent.cloneTo(t.inTangent),
                this.outTangent.cloneTo(t.outTangent),
                this.value.cloneTo(t.value);
            }
        }]),
        QuaternionKeyframe;
    }()
      , p = function(e) {
        function Vector3Keyframe() {
            var e;
            return _classCallCheck(this, Vector3Keyframe),
            (e = _possibleConstructorReturn(this, _getPrototypeOf(Vector3Keyframe).call(this))).inTangent = new o(),
            e.outTangent = new o(),
            e.value = new o(),
            e;
        }
        return _inherits(Vector3Keyframe, h),
        _createClass(Vector3Keyframe, [{
            key: "cloneTo",
            value: function(e) {
                _get(_getPrototypeOf(Vector3Keyframe.prototype), "cloneTo", this).call(this, e);
                var t = e;
                this.inTangent.cloneTo(t.inTangent),
                this.outTangent.cloneTo(t.outTangent),
                this.value.cloneTo(t.value);
            }
        }]),
        Vector3Keyframe;
    }()
      , v = function() {
        function AnimationClipParser03() {
            _classCallCheck(this, AnimationClipParser03);
        }
        return _createClass(AnimationClipParser03, null, [{
            key: "READ_DATA",
            value: function() {
                AnimationClipParser03._DATA.offset = AnimationClipParser03._reader.getUint32(),
                AnimationClipParser03._DATA.size = AnimationClipParser03._reader.getUint32();
            }
        }, {
            key: "READ_BLOCK",
            value: function() {
                for (var e = AnimationClipParser03._BLOCK.count = AnimationClipParser03._reader.getUint16(), t = AnimationClipParser03._BLOCK.blockStarts = [], r = AnimationClipParser03._BLOCK.blockLengths = [], n = 0; n < e; n++)
                    t.push(AnimationClipParser03._reader.getUint32()),
                    r.push(AnimationClipParser03._reader.getUint32());
            }
        }, {
            key: "READ_STRINGS",
            value: function() {
                var e = AnimationClipParser03._reader.getUint32()
                  , t = AnimationClipParser03._reader.getUint16()
                  , r = AnimationClipParser03._reader.pos;
                AnimationClipParser03._reader.pos = e + AnimationClipParser03._DATA.offset;
                for (var n = 0; n < t; n++)
                    AnimationClipParser03._strings[n] = AnimationClipParser03._reader.readUTFString();
                AnimationClipParser03._reader.pos = r;
            }
        }, {
            key: "parse",
            value: function(e, t) {
                AnimationClipParser03._animationClip = e,
                AnimationClipParser03._reader = t;
                t.__getBuffer();
                AnimationClipParser03.READ_DATA(),
                AnimationClipParser03.READ_BLOCK(),
                AnimationClipParser03.READ_STRINGS();
                for (var r = 0, n = AnimationClipParser03._BLOCK.count; r < n; r++) {
                    var i = t.getUint16()
                      , a = AnimationClipParser03._strings[i]
                      , o = AnimationClipParser03["READ_" + a];
                    if (null == o)
                        throw new Error("model file err,no this function:" + i + " " + a);
                    o.call(null);
                }
            }
        }, {
            key: "READ_ANIMATIONS",
            value: function() {
                var e, r, n, i = AnimationClipParser03._reader, a = (i.__getBuffer(),
                []), o = i.getUint16();
                for (a.length = o,
                e = 0; e < o; e++)
                    a[e] = i.getFloat32();
                var s = AnimationClipParser03._animationClip;
                s.name = AnimationClipParser03._strings[i.getUint16()];
                var l = s._duration = i.getFloat32();
                s.islooping = !!i.getByte(),
                s._frameRate = i.getInt16();
                var h = i.getInt16()
                  , d = s._nodes;
                d.count = h;
                var f = s._nodesMap = {}
                  , v = s._nodesDic = {};
                for (e = 0; e < h; e++) {
                    n = new u(),
                    d.setNodeByIndex(e, n),
                    n._indexInList = e;
                    var T = n.type = i.getUint8()
                      , E = i.getUint16();
                    for (n._setOwnerPathCount(E),
                    r = 0; r < E; r++)
                        n._setOwnerPathByIndex(r, AnimationClipParser03._strings[i.getUint16()]);
                    var y = n._joinOwnerPath("/")
                      , g = f[y];
                    g || (f[y] = g = []),
                    g.push(n),
                    n.propertyOwner = AnimationClipParser03._strings[i.getUint16()];
                    var S = i.getUint16();
                    for (n._setPropertyCount(S),
                    r = 0; r < S; r++)
                        n._setPropertyByIndex(r, AnimationClipParser03._strings[i.getUint16()]);
                    var R = y + "." + n.propertyOwner + "." + n._joinProperty(".");
                    v[R] = n,
                    n.fullPath = R;
                    var C = i.getUint16();
                    for (n._setKeyframeCount(C),
                    r = 0; r < C; r++)
                        switch (T) {
                        case 0:
                            var M = new _();
                            n._setKeyframeByIndex(r, M),
                            M.time = a[i.getUint16()],
                            M.inTangent = i.getFloat32(),
                            M.outTangent = i.getFloat32(),
                            M.value = i.getFloat32();
                            break;
                        case 1:
                        case 3:
                        case 4:
                            var D = new p();
                            if (n._setKeyframeByIndex(r, D),
                            D.time = a[i.getUint16()],
                            t.Render.supportWebGLPlusAnimation) {
                                for (var x = D.data = new Float32Array(9), A = 0; A < 3; A++)
                                    x[A] = i.getFloat32();
                                for (A = 0; A < 3; A++)
                                    x[3 + A] = i.getFloat32();
                                for (A = 0; A < 3; A++)
                                    x[6 + A] = i.getFloat32();
                            } else {
                                var I = D.inTangent
                                  , L = D.outTangent
                                  , P = D.value;
                                I.x = i.getFloat32(),
                                I.y = i.getFloat32(),
                                I.z = i.getFloat32(),
                                L.x = i.getFloat32(),
                                L.y = i.getFloat32(),
                                L.z = i.getFloat32(),
                                P.x = i.getFloat32(),
                                P.y = i.getFloat32(),
                                P.z = i.getFloat32();
                            }
                            break;
                        case 2:
                            var O = new m();
                            if (n._setKeyframeByIndex(r, O),
                            O.time = a[i.getUint16()],
                            t.Render.supportWebGLPlusAnimation) {
                                for (x = O.data = new Float32Array(12),
                                A = 0; A < 4; A++)
                                    x[A] = i.getFloat32();
                                for (A = 0; A < 4; A++)
                                    x[4 + A] = i.getFloat32();
                                for (A = 0; A < 4; A++)
                                    x[8 + A] = i.getFloat32();
                            } else {
                                var N = O.inTangent
                                  , b = O.outTangent
                                  , k = O.value;
                                N.x = i.getFloat32(),
                                N.y = i.getFloat32(),
                                N.z = i.getFloat32(),
                                N.w = i.getFloat32(),
                                b.x = i.getFloat32(),
                                b.y = i.getFloat32(),
                                b.z = i.getFloat32(),
                                b.w = i.getFloat32(),
                                k.x = i.getFloat32(),
                                k.y = i.getFloat32(),
                                k.z = i.getFloat32(),
                                k.w = i.getFloat32();
                            }
                            break;
                        default:
                            throw "AnimationClipParser03:unknown type.";
                        }
                }
                var V = i.getUint16();
                for (e = 0; e < V; e++) {
                    var B, w = new c();
                    w.time = Math.min(l, i.getFloat32()),
                    w.eventName = AnimationClipParser03._strings[i.getUint16()];
                    var F = i.getUint16();
                    for (F > 0 && (w.params = B = []),
                    r = 0; r < F; r++) {
                        switch (i.getByte()) {
                        case 0:
                            B.push(!!i.getByte());
                            break;
                        case 1:
                            B.push(i.getInt32());
                            break;
                        case 2:
                            B.push(i.getFloat32());
                            break;
                        case 3:
                            B.push(AnimationClipParser03._strings[i.getUint16()]);
                            break;
                        default:
                            throw new Error("unknown type.");
                        }
                    }
                    s.addEvent(w);
                }
            }
        }]),
        AnimationClipParser03;
    }();
    v._strings = [],
    v._BLOCK = {
        count: 0
    },
    v._DATA = {
        offset: 0,
        size: 0
    };
    var T = function() {
        function HalfFloatUtils() {
            _classCallCheck(this, HalfFloatUtils);
        }
        return _createClass(HalfFloatUtils, null, [{
            key: "__init__",
            value: function() {
                for (var e = 0; e < 256; ++e) {
                    var t = e - 127;
                    t < -27 ? (HalfFloatUtils._baseTable[0 | e] = 0,
                    HalfFloatUtils._baseTable[256 | e] = 32768,
                    HalfFloatUtils._shiftTable[0 | e] = 24,
                    HalfFloatUtils._shiftTable[256 | e] = 24) : t < -14 ? (HalfFloatUtils._baseTable[0 | e] = 1024 >> -t - 14,
                    HalfFloatUtils._baseTable[256 | e] = 1024 >> -t - 14 | 32768,
                    HalfFloatUtils._shiftTable[0 | e] = -t - 1,
                    HalfFloatUtils._shiftTable[256 | e] = -t - 1) : t <= 15 ? (HalfFloatUtils._baseTable[0 | e] = t + 15 << 10,
                    HalfFloatUtils._baseTable[256 | e] = t + 15 << 10 | 32768,
                    HalfFloatUtils._shiftTable[0 | e] = 13,
                    HalfFloatUtils._shiftTable[256 | e] = 13) : t < 128 ? (HalfFloatUtils._baseTable[0 | e] = 31744,
                    HalfFloatUtils._baseTable[256 | e] = 64512,
                    HalfFloatUtils._shiftTable[0 | e] = 24,
                    HalfFloatUtils._shiftTable[256 | e] = 24) : (HalfFloatUtils._baseTable[0 | e] = 31744,
                    HalfFloatUtils._baseTable[256 | e] = 64512,
                    HalfFloatUtils._shiftTable[0 | e] = 13,
                    HalfFloatUtils._shiftTable[256 | e] = 13);
                }
                for (HalfFloatUtils._mantissaTable[0] = 0,
                e = 1; e < 1024; ++e) {
                    var r = e << 13;
                    for (t = 0; 0 == (8388608 & r); )
                        t -= 8388608,
                        r <<= 1;
                    r &= -8388609,
                    t += 947912704,
                    HalfFloatUtils._mantissaTable[e] = r | t;
                }
                for (e = 1024; e < 2048; ++e)
                    HalfFloatUtils._mantissaTable[e] = 939524096 + (e - 1024 << 13);
                for (HalfFloatUtils._exponentTable[0] = 0,
                e = 1; e < 31; ++e)
                    HalfFloatUtils._exponentTable[e] = e << 23;
                for (HalfFloatUtils._exponentTable[31] = 1199570944,
                HalfFloatUtils._exponentTable[32] = 2147483648,
                e = 33; e < 63; ++e)
                    HalfFloatUtils._exponentTable[e] = 2147483648 + (e - 32 << 23);
                for (HalfFloatUtils._exponentTable[63] = 3347054592,
                HalfFloatUtils._offsetTable[0] = 0,
                e = 1; e < 64; ++e)
                    HalfFloatUtils._offsetTable[e] = 32 === e ? 0 : 1024;
            }
        }, {
            key: "roundToFloat16Bits",
            value: function(e) {
                HalfFloatUtils._floatView[0] = e;
                var t = HalfFloatUtils._uint32View[0]
                  , r = t >> 23 & 511;
                return HalfFloatUtils._baseTable[r] + ((8388607 & t) >> HalfFloatUtils._shiftTable[r]);
            }
        }, {
            key: "convertToNumber",
            value: function(e) {
                var t = e >> 10;
                return HalfFloatUtils._uint32View[0] = HalfFloatUtils._mantissaTable[HalfFloatUtils._offsetTable[t] + (1023 & e)] + HalfFloatUtils._exponentTable[t],
                HalfFloatUtils._floatView[0];
            }
        }]),
        HalfFloatUtils;
    }();
    T._buffer = new ArrayBuffer(4),
    T._floatView = new Float32Array(T._buffer),
    T._uint32View = new Uint32Array(T._buffer),
    T._baseTable = new Uint32Array(512),
    T._shiftTable = new Uint32Array(512),
    T._mantissaTable = new Uint32Array(2048),
    T._exponentTable = new Uint32Array(64),
    T._offsetTable = new Uint32Array(64);
    var E = function() {
        function AnimationClipParser04() {
            _classCallCheck(this, AnimationClipParser04);
        }
        return _createClass(AnimationClipParser04, null, [{
            key: "READ_DATA",
            value: function() {
                AnimationClipParser04._DATA.offset = AnimationClipParser04._reader.getUint32(),
                AnimationClipParser04._DATA.size = AnimationClipParser04._reader.getUint32();
            }
        }, {
            key: "READ_BLOCK",
            value: function() {
                for (var e = AnimationClipParser04._BLOCK.count = AnimationClipParser04._reader.getUint16(), t = AnimationClipParser04._BLOCK.blockStarts = [], r = AnimationClipParser04._BLOCK.blockLengths = [], n = 0; n < e; n++)
                    t.push(AnimationClipParser04._reader.getUint32()),
                    r.push(AnimationClipParser04._reader.getUint32());
            }
        }, {
            key: "READ_STRINGS",
            value: function() {
                var e = AnimationClipParser04._reader.getUint32()
                  , t = AnimationClipParser04._reader.getUint16()
                  , r = AnimationClipParser04._reader.pos;
                AnimationClipParser04._reader.pos = e + AnimationClipParser04._DATA.offset;
                for (var n = 0; n < t; n++)
                    AnimationClipParser04._strings[n] = AnimationClipParser04._reader.readUTFString();
                AnimationClipParser04._reader.pos = r;
            }
        }, {
            key: "parse",
            value: function(e, t, r) {
                AnimationClipParser04._animationClip = e,
                AnimationClipParser04._reader = t,
                AnimationClipParser04._version = r,
                AnimationClipParser04.READ_DATA(),
                AnimationClipParser04.READ_BLOCK(),
                AnimationClipParser04.READ_STRINGS();
                for (var n = 0, i = AnimationClipParser04._BLOCK.count; n < i; n++) {
                    var a = t.getUint16()
                      , o = AnimationClipParser04._strings[a]
                      , s = AnimationClipParser04["READ_" + o];
                    if (null == s)
                        throw new Error("model file err,no this function:" + a + " " + o);
                    s.call(null);
                }
                AnimationClipParser04._version = null,
                AnimationClipParser04._reader = null,
                AnimationClipParser04._animationClip = null;
            }
        }, {
            key: "READ_ANIMATIONS",
            value: function() {
                var e, r, n, i = AnimationClipParser04._reader, a = (i.__getBuffer(),
                []), o = i.getUint16();
                for (a.length = o,
                e = 0; e < o; e++)
                    a[e] = i.getFloat32();
                var s = AnimationClipParser04._animationClip;
                s.name = AnimationClipParser04._strings[i.getUint16()];
                var l = s._duration = i.getFloat32();
                s.islooping = !!i.getByte(),
                s._frameRate = i.getInt16();
                var h = i.getInt16()
                  , d = s._nodes;
                d.count = h;
                var f = s._nodesMap = {}
                  , v = s._nodesDic = {};
                for (e = 0; e < h; e++) {
                    n = new u(),
                    d.setNodeByIndex(e, n),
                    n._indexInList = e;
                    var E = n.type = i.getUint8()
                      , y = i.getUint16();
                    for (n._setOwnerPathCount(y),
                    r = 0; r < y; r++)
                        n._setOwnerPathByIndex(r, AnimationClipParser04._strings[i.getUint16()]);
                    var g = n._joinOwnerPath("/")
                      , S = f[g];
                    S || (f[g] = S = []),
                    S.push(n),
                    n.propertyOwner = AnimationClipParser04._strings[i.getUint16()];
                    var R = i.getUint16();
                    for (n._setPropertyCount(R),
                    r = 0; r < R; r++)
                        n._setPropertyByIndex(r, AnimationClipParser04._strings[i.getUint16()]);
                    var C = g + "." + n.propertyOwner + "." + n._joinProperty(".");
                    v[C] = n,
                    n.fullPath = C;
                    var M = i.getUint16();
                    switch (n._setKeyframeCount(M),
                    AnimationClipParser04._version) {
                    case "LAYAANIMATION:04":
                        for (r = 0; r < M; r++)
                            switch (E) {
                            case 0:
                                var D = new _();
                                n._setKeyframeByIndex(r, D),
                                D.time = a[i.getUint16()],
                                D.inTangent = i.getFloat32(),
                                D.outTangent = i.getFloat32(),
                                D.value = i.getFloat32();
                                break;
                            case 1:
                            case 3:
                            case 4:
                                var x = new p();
                                if (n._setKeyframeByIndex(r, x),
                                x.time = a[i.getUint16()],
                                t.Render.supportWebGLPlusAnimation) {
                                    for (var A = x.data = new Float32Array(9), I = 0; I < 3; I++)
                                        A[I] = i.getFloat32();
                                    for (I = 0; I < 3; I++)
                                        A[3 + I] = i.getFloat32();
                                    for (I = 0; I < 3; I++)
                                        A[6 + I] = i.getFloat32();
                                } else {
                                    var L = x.inTangent
                                      , P = x.outTangent
                                      , O = x.value;
                                    L.x = i.getFloat32(),
                                    L.y = i.getFloat32(),
                                    L.z = i.getFloat32(),
                                    P.x = i.getFloat32(),
                                    P.y = i.getFloat32(),
                                    P.z = i.getFloat32(),
                                    O.x = i.getFloat32(),
                                    O.y = i.getFloat32(),
                                    O.z = i.getFloat32();
                                }
                                break;
                            case 2:
                                var N = new m();
                                if (n._setKeyframeByIndex(r, N),
                                N.time = a[i.getUint16()],
                                t.Render.supportWebGLPlusAnimation) {
                                    for (A = N.data = new Float32Array(12),
                                    I = 0; I < 4; I++)
                                        A[I] = i.getFloat32();
                                    for (I = 0; I < 4; I++)
                                        A[4 + I] = i.getFloat32();
                                    for (I = 0; I < 4; I++)
                                        A[8 + I] = i.getFloat32();
                                } else {
                                    var b = N.inTangent
                                      , k = N.outTangent
                                      , V = N.value;
                                    b.x = i.getFloat32(),
                                    b.y = i.getFloat32(),
                                    b.z = i.getFloat32(),
                                    b.w = i.getFloat32(),
                                    k.x = i.getFloat32(),
                                    k.y = i.getFloat32(),
                                    k.z = i.getFloat32(),
                                    k.w = i.getFloat32(),
                                    V.x = i.getFloat32(),
                                    V.y = i.getFloat32(),
                                    V.z = i.getFloat32(),
                                    V.w = i.getFloat32();
                                }
                                break;
                            default:
                                throw "AnimationClipParser04:unknown type.";
                            }
                        break;
                    case "LAYAANIMATION:COMPRESSION_04":
                        for (r = 0; r < M; r++)
                            switch (E) {
                            case 0:
                                D = new _(),
                                n._setKeyframeByIndex(r, D),
                                D.time = a[i.getUint16()],
                                D.inTangent = T.convertToNumber(i.getUint16()),
                                D.outTangent = T.convertToNumber(i.getUint16()),
                                D.value = T.convertToNumber(i.getUint16());
                                break;
                            case 1:
                            case 3:
                            case 4:
                                if (x = new p(),
                                n._setKeyframeByIndex(r, x),
                                x.time = a[i.getUint16()],
                                t.Render.supportWebGLPlusAnimation) {
                                    for (A = x.data = new Float32Array(9),
                                    I = 0; I < 3; I++)
                                        A[I] = T.convertToNumber(i.getUint16());
                                    for (I = 0; I < 3; I++)
                                        A[3 + I] = T.convertToNumber(i.getUint16());
                                    for (I = 0; I < 3; I++)
                                        A[6 + I] = T.convertToNumber(i.getUint16());
                                } else
                                    L = x.inTangent,
                                    P = x.outTangent,
                                    O = x.value,
                                    L.x = T.convertToNumber(i.getUint16()),
                                    L.y = T.convertToNumber(i.getUint16()),
                                    L.z = T.convertToNumber(i.getUint16()),
                                    P.x = T.convertToNumber(i.getUint16()),
                                    P.y = T.convertToNumber(i.getUint16()),
                                    P.z = T.convertToNumber(i.getUint16()),
                                    O.x = T.convertToNumber(i.getUint16()),
                                    O.y = T.convertToNumber(i.getUint16()),
                                    O.z = T.convertToNumber(i.getUint16());
                                break;
                            case 2:
                                if (N = new m(),
                                n._setKeyframeByIndex(r, N),
                                N.time = a[i.getUint16()],
                                t.Render.supportWebGLPlusAnimation) {
                                    for (A = N.data = new Float32Array(12),
                                    I = 0; I < 4; I++)
                                        A[I] = T.convertToNumber(i.getUint16());
                                    for (I = 0; I < 4; I++)
                                        A[4 + I] = T.convertToNumber(i.getUint16());
                                    for (I = 0; I < 4; I++)
                                        A[8 + I] = T.convertToNumber(i.getUint16());
                                } else
                                    b = N.inTangent,
                                    k = N.outTangent,
                                    V = N.value,
                                    b.x = T.convertToNumber(i.getUint16()),
                                    b.y = T.convertToNumber(i.getUint16()),
                                    b.z = T.convertToNumber(i.getUint16()),
                                    b.w = T.convertToNumber(i.getUint16()),
                                    k.x = T.convertToNumber(i.getUint16()),
                                    k.y = T.convertToNumber(i.getUint16()),
                                    k.z = T.convertToNumber(i.getUint16()),
                                    k.w = T.convertToNumber(i.getUint16()),
                                    V.x = T.convertToNumber(i.getUint16()),
                                    V.y = T.convertToNumber(i.getUint16()),
                                    V.z = T.convertToNumber(i.getUint16()),
                                    V.w = T.convertToNumber(i.getUint16());
                                break;
                            default:
                                throw "AnimationClipParser04:unknown type.";
                            }
                    }
                }
                var B = i.getUint16();
                for (e = 0; e < B; e++) {
                    var w, F = new c();
                    F.time = Math.min(l, i.getFloat32()),
                    F.eventName = AnimationClipParser04._strings[i.getUint16()];
                    var U = i.getUint16();
                    for (U > 0 && (F.params = w = []),
                    r = 0; r < U; r++) {
                        switch (i.getByte()) {
                        case 0:
                            w.push(!!i.getByte());
                            break;
                        case 1:
                            w.push(i.getInt32());
                            break;
                        case 2:
                            w.push(i.getFloat32());
                            break;
                        case 3:
                            w.push(AnimationClipParser04._strings[i.getUint16()]);
                            break;
                        default:
                            throw new Error("unknown type.");
                        }
                    }
                    s.addEvent(F);
                }
            }
        }]),
        AnimationClipParser04;
    }();
    E._strings = [],
    E._BLOCK = {
        count: 0
    },
    E._DATA = {
        offset: 0,
        size: 0
    };
    var y = function() {
        function KeyframeNodeList() {
            _classCallCheck(this, KeyframeNodeList),
            this._nodes = [];
        }
        return _createClass(KeyframeNodeList, [{
            key: "getNodeByIndex",
            value: function(e) {
                return this._nodes[e];
            }
        }, {
            key: "setNodeByIndex",
            value: function(e, t) {
                this._nodes[e] = t;
            }
        }, {
            key: "count",
            get: function() {
                return this._nodes.length;
            },
            set: function(e) {
                this._nodes.length = e;
            }
        }]),
        KeyframeNodeList;
    }()
      , g = function() {
        function TextureGenerator() {
            _classCallCheck(this, TextureGenerator);
        }
        return _createClass(TextureGenerator, null, [{
            key: "lightAttenTexture",
            value: function(e, t, r, n, i, a) {
                var o = e / r
                  , s = 1 / (1 + 25 * o);
                o >= .64 && (o > 1 ? s = 0 : s *= 1 - (o - .64) / .36),
                a[i] = Math.floor(255 * s + .5);
            }
        }, {
            key: "haloTexture",
            value: function(e, t, r, n, i, a) {
                var o = (e - (r >>= 1)) / r
                  , s = (t - (n >>= 1)) / n
                  , l = o * o + s * s;
                l > 1 && (l = 1),
                a[i] = Math.floor(255 * (1 - l) + .5);
            }
        }, {
            key: "_generateTexture2D",
            value: function(e, r, n, i) {
                var a = 0
                  , o = 0;
                switch (e.format) {
                case t.TextureFormat.R8G8B8:
                    o = 3;
                    break;
                case t.TextureFormat.R8G8B8A8:
                    o = 4;
                    break;
                case t.TextureFormat.Alpha8:
                    o = 1;
                    break;
                default:
                    throw "GeneratedTexture._generateTexture: unkonw texture format.";
                }
                for (var s = new Uint8Array(r * n * o), l = 0; l < n; l++)
                    for (var u = 0; u < r; u++)
                        i(u, l, r, n, a, s),
                        a += o;
                e.setPixels(s);
            }
        }]),
        TextureGenerator;
    }()
      , S = function Physics3D() {
        _classCallCheck(this, Physics3D);
    };
    S._bullet = null,
    S._enablePhysics = !1;
    var R = function() {
        function Utils3D() {
            _classCallCheck(this, Utils3D);
        }
        return _createClass(Utils3D, null, [{
            key: "_createFloatTextureBuffer",
            value: function(e, r) {
                var n = new t.Texture2D(e,r,t.TextureFormat.R32G32B32A32,!1,!1);
                return n.filterMode = t.FilterMode.Point,
                n.wrapModeU = t.WarpMode.Clamp,
                n.wrapModeV = t.WarpMode.Clamp,
                n.anisoLevel = 0,
                n;
            }
        }, {
            key: "_convertToLayaVec3",
            value: function(e, t, r) {
                var n = S._bullet;
                t.x = r ? -n.btVector3_x(e) : n.btVector3_x(e),
                t.y = n.btVector3_y(e),
                t.z = n.btVector3_z(e);
            }
        }, {
            key: "_convertToBulletVec3",
            value: function(e, t, r) {
                S._bullet.btVector3_setValue(t, r ? -e.x : e.x, e.y, e.z);
            }
        }, {
            key: "_rotationTransformScaleSkinAnimation",
            value: function(e, t, r, n, i, a, o, s, l, u, c, h) {
                var _, d, f, m, p, v = Utils3D._tempArray16_0, T = Utils3D._tempArray16_1, E = Utils3D._tempArray16_2, y = n + n, g = i + i, S = a + a, R = n * y, C = i * y, M = i * g, D = a * y, x = a * g, A = a * S, I = o * y, L = o * g, P = o * S;
                for (v[15] = 1,
                v[0] = 1 - M - A,
                v[1] = C + P,
                v[2] = D - L,
                v[4] = C - P,
                v[5] = 1 - R - A,
                v[6] = x + I,
                v[8] = D + L,
                v[9] = x - I,
                v[10] = 1 - R - M,
                T[15] = 1,
                T[0] = s,
                T[5] = l,
                T[10] = u,
                _ = 0; _ < 4; _++)
                    d = v[_],
                    f = v[_ + 4],
                    m = v[_ + 8],
                    p = v[_ + 12],
                    E[_] = d,
                    E[_ + 4] = f,
                    E[_ + 8] = m,
                    E[_ + 12] = d * e + f * t + m * r + p;
                for (_ = 0; _ < 4; _++)
                    d = E[_],
                    f = E[_ + 4],
                    m = E[_ + 8],
                    p = E[_ + 12],
                    c[_ + h] = d * T[0] + f * T[1] + m * T[2] + p * T[3],
                    c[_ + h + 4] = d * T[4] + f * T[5] + m * T[6] + p * T[7],
                    c[_ + h + 8] = d * T[8] + f * T[9] + m * T[10] + p * T[11],
                    c[_ + h + 12] = d * T[12] + f * T[13] + m * T[14] + p * T[15];
            }
        }, {
            key: "_computeBoneAndAnimationDatasByBindPoseMatrxix",
            value: function(e, t, r, n, i, a) {
                var o, s, l = 0, u = 0, c = e.length;
                for (o = 0; o < c; l += e[o].keyframeWidth,
                u += 16,
                o++)
                    Utils3D._rotationTransformScaleSkinAnimation(t[l + 0], t[l + 1], t[l + 2], t[l + 3], t[l + 4], t[l + 5], t[l + 6], t[l + 7], t[l + 8], t[l + 9], n, u),
                    0 != o && (s = 16 * e[o].parentIndex,
                    Utils3D.mulMatrixByArray(n, s, n, u, n, u));
                var h = r.length;
                for (o = 0; o < h; o++)
                    Utils3D.mulMatrixByArrayAndMatrixFast(n, 16 * a[o], r[o], i, 16 * o);
            }
        }, {
            key: "_computeAnimationDatasByArrayAndMatrixFast",
            value: function(e, t, r, n) {
                for (var i = 0, a = e.length; i < a; i++)
                    Utils3D.mulMatrixByArrayAndMatrixFast(t, 16 * n[i], e[i], r, 16 * i);
            }
        }, {
            key: "_computeBoneAndAnimationDatasByBindPoseMatrxixOld",
            value: function(e, t, r, n, i) {
                var a, o, s = 0, l = 0, u = e.length;
                for (a = 0; a < u; s += e[a].keyframeWidth,
                l += 16,
                a++)
                    Utils3D._rotationTransformScaleSkinAnimation(t[s + 7], t[s + 8], t[s + 9], t[s + 3], t[s + 4], t[s + 5], t[s + 6], t[s + 0], t[s + 1], t[s + 2], n, l),
                    0 != a && (o = 16 * e[a].parentIndex,
                    Utils3D.mulMatrixByArray(n, o, n, l, n, l));
                var c = r.length;
                for (a = 0; a < c; a++) {
                    var h = 16 * a;
                    Utils3D.mulMatrixByArrayAndMatrixFast(n, h, r[a], i, h);
                }
            }
        }, {
            key: "_computeAnimationDatasByArrayAndMatrixFastOld",
            value: function(e, t, r) {
                for (var n = e.length, i = 0; i < n; i++) {
                    var a = 16 * i;
                    Utils3D.mulMatrixByArrayAndMatrixFast(t, a, e[i], r, a);
                }
            }
        }, {
            key: "_computeRootAnimationData",
            value: function(e, t, r) {
                for (var n = 0, i = 0, a = 0, o = e.length; n < o; i += e[n].keyframeWidth,
                a += 16,
                n++)
                    Utils3D.createAffineTransformationArray(t[i + 0], t[i + 1], t[i + 2], t[i + 3], t[i + 4], t[i + 5], t[i + 6], t[i + 7], t[i + 8], t[i + 9], r, a);
            }
        }, {
            key: "transformVector3ArrayByQuat",
            value: function(e, t, r, n, i) {
                var a = e[t]
                  , o = e[t + 1]
                  , s = e[t + 2]
                  , l = r.x
                  , u = r.y
                  , c = r.z
                  , h = r.w
                  , _ = h * a + u * s - c * o
                  , d = h * o + c * a - l * s
                  , f = h * s + l * o - u * a
                  , m = -l * a - u * o - c * s;
                n[i] = _ * h + m * -l + d * -c - f * -u,
                n[i + 1] = d * h + m * -u + f * -l - _ * -c,
                n[i + 2] = f * h + m * -c + _ * -u - d * -l;
            }
        }, {
            key: "mulMatrixByArray",
            value: function(e, t, r, n, i, a) {
                var o, s, l, u, c;
                if (i === r) {
                    for (r = Utils3D._tempArray16_3,
                    o = 0; o < 16; ++o)
                        r[o] = i[a + o];
                    n = 0;
                }
                for (o = 0; o < 4; o++)
                    s = e[t + o],
                    l = e[t + o + 4],
                    u = e[t + o + 8],
                    c = e[t + o + 12],
                    i[a + o] = s * r[n + 0] + l * r[n + 1] + u * r[n + 2] + c * r[n + 3],
                    i[a + o + 4] = s * r[n + 4] + l * r[n + 5] + u * r[n + 6] + c * r[n + 7],
                    i[a + o + 8] = s * r[n + 8] + l * r[n + 9] + u * r[n + 10] + c * r[n + 11],
                    i[a + o + 12] = s * r[n + 12] + l * r[n + 13] + u * r[n + 14] + c * r[n + 15];
            }
        }, {
            key: "mulMatrixByArrayFast",
            value: function(e, t, r, n, i, a) {
                var o, s, l, u, c;
                for (o = 0; o < 4; o++)
                    s = e[t + o],
                    l = e[t + o + 4],
                    u = e[t + o + 8],
                    c = e[t + o + 12],
                    i[a + o] = s * r[n + 0] + l * r[n + 1] + u * r[n + 2] + c * r[n + 3],
                    i[a + o + 4] = s * r[n + 4] + l * r[n + 5] + u * r[n + 6] + c * r[n + 7],
                    i[a + o + 8] = s * r[n + 8] + l * r[n + 9] + u * r[n + 10] + c * r[n + 11],
                    i[a + o + 12] = s * r[n + 12] + l * r[n + 13] + u * r[n + 14] + c * r[n + 15];
            }
        }, {
            key: "mulMatrixByArrayAndMatrixFast",
            value: function(e, t, r, n, i) {
                var a, o, s, l, u, c = r.elements, h = c[0], _ = c[1], d = c[2], f = c[3], m = c[4], p = c[5], v = c[6], T = c[7], E = c[8], y = c[9], g = c[10], S = c[11], R = c[12], C = c[13], M = c[14], D = c[15], x = t, A = t + 4, I = t + 8, L = t + 12, P = i, O = i + 4, N = i + 8, b = i + 12;
                for (a = 0; a < 4; a++)
                    o = e[x + a],
                    s = e[A + a],
                    l = e[I + a],
                    u = e[L + a],
                    n[P + a] = o * h + s * _ + l * d + u * f,
                    n[O + a] = o * m + s * p + l * v + u * T,
                    n[N + a] = o * E + s * y + l * g + u * S,
                    n[b + a] = o * R + s * C + l * M + u * D;
            }
        }, {
            key: "createAffineTransformationArray",
            value: function(e, t, r, n, i, a, o, s, l, u, c, h) {
                var _ = n + n
                  , d = i + i
                  , f = a + a
                  , m = n * _
                  , p = n * d
                  , v = n * f
                  , T = i * d
                  , E = i * f
                  , y = a * f
                  , g = o * _
                  , S = o * d
                  , R = o * f;
                c[h + 0] = (1 - (T + y)) * s,
                c[h + 1] = (p + R) * s,
                c[h + 2] = (v - S) * s,
                c[h + 3] = 0,
                c[h + 4] = (p - R) * l,
                c[h + 5] = (1 - (m + y)) * l,
                c[h + 6] = (E + g) * l,
                c[h + 7] = 0,
                c[h + 8] = (v + S) * u,
                c[h + 9] = (E - g) * u,
                c[h + 10] = (1 - (m + T)) * u,
                c[h + 11] = 0,
                c[h + 12] = e,
                c[h + 13] = t,
                c[h + 14] = r,
                c[h + 15] = 1;
            }
        }, {
            key: "transformVector3ArrayToVector3ArrayCoordinate",
            value: function(e, t, r, n, i) {
                var a = e[t + 0]
                  , o = e[t + 1]
                  , s = e[t + 2]
                  , l = r.elements
                  , u = a * l[3] + o * l[7] + s * l[11] + l[15];
                n[i] = a * l[0] + o * l[4] + s * l[8] + l[12] / u,
                n[i + 1] = a * l[1] + o * l[5] + s * l[9] + l[13] / u,
                n[i + 2] = a * l[2] + o * l[6] + s * l[10] + l[14] / u;
            }
        }, {
            key: "transformVector3ArrayToVector3ArrayNormal",
            value: function(e, t, r, n, i) {
                var a = e[t + 0]
                  , o = e[t + 1]
                  , s = e[t + 2]
                  , l = r.elements;
                n[i] = a * l[0] + o * l[4] + s * l[8],
                n[i + 1] = a * l[1] + o * l[5] + s * l[9],
                n[i + 2] = a * l[2] + o * l[6] + s * l[10];
            }
        }, {
            key: "transformLightingMapTexcoordArray",
            value: function(e, t, r, n, i) {
                n[i + 0] = e[t + 0] * r.x + r.z,
                n[i + 1] = 1 - ((1 - e[t + 1]) * r.y + r.w);
            }
        }, {
            key: "getURLVerion",
            value: function(e) {
                var t = e.indexOf("?");
                return t >= 0 ? e.substr(t) : null;
            }
        }, {
            key: "_createAffineTransformationArray",
            value: function(e, t, r, n) {
                var i = t.x
                  , a = t.y
                  , o = t.z
                  , s = t.w
                  , l = i + i
                  , u = a + a
                  , c = o + o
                  , h = i * l
                  , _ = i * u
                  , d = i * c
                  , f = a * u
                  , m = a * c
                  , p = o * c
                  , v = s * l
                  , T = s * u
                  , E = s * c
                  , y = r.x
                  , g = r.y
                  , S = r.z;
                n[0] = (1 - (f + p)) * y,
                n[1] = (_ + E) * y,
                n[2] = (d - T) * y,
                n[3] = 0,
                n[4] = (_ - E) * g,
                n[5] = (1 - (h + p)) * g,
                n[6] = (m + v) * g,
                n[7] = 0,
                n[8] = (d + T) * S,
                n[9] = (m - v) * S,
                n[10] = (1 - (h + f)) * S,
                n[11] = 0,
                n[12] = e.x,
                n[13] = e.y,
                n[14] = e.z,
                n[15] = 1;
            }
        }, {
            key: "_mulMatrixArray",
            value: function(e, t, r, n) {
                var i, a, o, s, l, u = t.elements, c = u[0], h = u[1], _ = u[2], d = u[3], f = u[4], m = u[5], p = u[6], v = u[7], T = u[8], E = u[9], y = u[10], g = u[11], S = u[12], R = u[13], C = u[14], M = u[15], D = n, x = n + 4, A = n + 8, I = n + 12;
                for (i = 0; i < 4; i++)
                    a = e[i],
                    o = e[i + 4],
                    s = e[i + 8],
                    l = e[i + 12],
                    r[D + i] = a * c + o * h + s * _ + l * d,
                    r[x + i] = a * f + o * m + s * p + l * v,
                    r[A + i] = a * T + o * E + s * y + l * g,
                    r[I + i] = a * S + o * R + s * C + l * M;
            }
        }, {
            key: "arcTanAngle",
            value: function(e, t) {
                return 0 == e ? 1 == t ? Math.PI / 2 : -Math.PI / 2 : e > 0 ? Math.atan(t / e) : e < 0 ? t > 0 ? Math.atan(t / e) + Math.PI : Math.atan(t / e) - Math.PI : 0;
            }
        }, {
            key: "angleTo",
            value: function(e, t, r) {
                o.subtract(t, e, f.TEMPVector30),
                o.normalize(f.TEMPVector30, f.TEMPVector30),
                r.x = Math.asin(f.TEMPVector30.y),
                r.y = Utils3D.arcTanAngle(-f.TEMPVector30.z, -f.TEMPVector30.x);
            }
        }, {
            key: "transformQuat",
            value: function(e, t, r) {
                var n = t
                  , i = e.x
                  , a = e.y
                  , o = e.z
                  , s = n[0]
                  , l = n[1]
                  , u = n[2]
                  , c = n[3]
                  , h = c * i + l * o - u * a
                  , _ = c * a + u * i - s * o
                  , d = c * o + s * a - l * i
                  , f = -s * i - l * a - u * o;
                r.x = h * c + f * -s + _ * -u - d * -l,
                r.y = _ * c + f * -l + d * -s - h * -u,
                r.z = d * c + f * -u + h * -l - _ * -s;
            }
        }, {
            key: "quaternionWeight",
            value: function(e, t, r) {
                r.x = e.x * t,
                r.y = e.y * t,
                r.z = e.z * t,
                r.w = e.w;
            }
        }, {
            key: "quaternionConjugate",
            value: function(e, t) {
                t.x = -e.x,
                t.y = -e.y,
                t.z = -e.z,
                t.w = e.w;
            }
        }, {
            key: "scaleWeight",
            value: function(e, t, r) {
                var n = e.x
                  , i = e.y
                  , a = e.z;
                r.x = n > 0 ? Math.pow(Math.abs(n), t) : -Math.pow(Math.abs(n), t),
                r.y = i > 0 ? Math.pow(Math.abs(i), t) : -Math.pow(Math.abs(i), t),
                r.z = a > 0 ? Math.pow(Math.abs(a), t) : -Math.pow(Math.abs(a), t);
            }
        }, {
            key: "scaleBlend",
            value: function(e, t, r, n) {
                var i = Utils3D._tempVector3_0
                  , a = Utils3D._tempVector3_1;
                Utils3D.scaleWeight(e, 1 - r, i),
                Utils3D.scaleWeight(t, r, a);
                var o = r > .5 ? t : e;
                n.x = o.x > 0 ? Math.abs(i.x * a.x) : -Math.abs(i.x * a.x),
                n.y = o.y > 0 ? Math.abs(i.y * a.y) : -Math.abs(i.y * a.y),
                n.z = o.z > 0 ? Math.abs(i.z * a.z) : -Math.abs(i.z * a.z);
            }
        }, {
            key: "matrix4x4MultiplyFFF",
            value: function(e, t, r) {
                var n, i, a, o, s;
                if (r === t)
                    for (t = new Float32Array(16),
                    n = 0; n < 16; ++n)
                        t[n] = r[n];
                var l = t[0]
                  , u = t[1]
                  , c = t[2]
                  , h = t[3]
                  , _ = t[4]
                  , d = t[5]
                  , f = t[6]
                  , m = t[7]
                  , p = t[8]
                  , v = t[9]
                  , T = t[10]
                  , E = t[11]
                  , y = t[12]
                  , g = t[13]
                  , S = t[14]
                  , R = t[15];
                for (n = 0; n < 4; n++)
                    i = e[n],
                    a = e[n + 4],
                    o = e[n + 8],
                    s = e[n + 12],
                    r[n] = i * l + a * u + o * c + s * h,
                    r[n + 4] = i * _ + a * d + o * f + s * m,
                    r[n + 8] = i * p + a * v + o * T + s * E,
                    r[n + 12] = i * y + a * g + o * S + s * R;
            }
        }, {
            key: "matrix4x4MultiplyFFFForNative",
            value: function(e, r, n) {
                t.LayaGL.instance.matrix4x4Multiply(e, r, n);
            }
        }, {
            key: "matrix4x4MultiplyMFM",
            value: function(e, t, r) {
                Utils3D.matrix4x4MultiplyFFF(e.elements, t, r.elements);
            }
        }, {
            key: "_buildTexture2D",
            value: function(e, r, n, i) {
                var a = arguments.length > 4 && void 0 !== arguments[4] && arguments[4]
                  , o = new t.Texture2D(e,r,n,a,!0);
                return o.anisoLevel = 1,
                o.filterMode = t.FilterMode.Point,
                g._generateTexture2D(o, e, r, i),
                o;
            }
        }, {
            key: "_drawBound",
            value: function(e, t, r) {
                e.lineCount + 12 > e.maxLineCount && (e.maxLineCount += 12);
                var n = Utils3D._tempVector3_0
                  , i = Utils3D._tempVector3_1
                  , a = t.min
                  , o = t.max;
                n.setValue(a.x, a.y, a.z),
                i.setValue(o.x, a.y, a.z),
                e.addLine(n, i, r, r),
                n.setValue(a.x, a.y, a.z),
                i.setValue(a.x, a.y, o.z),
                e.addLine(n, i, r, r),
                n.setValue(o.x, a.y, a.z),
                i.setValue(o.x, a.y, o.z),
                e.addLine(n, i, r, r),
                n.setValue(a.x, a.y, o.z),
                i.setValue(o.x, a.y, o.z),
                e.addLine(n, i, r, r),
                n.setValue(a.x, a.y, a.z),
                i.setValue(a.x, o.y, a.z),
                e.addLine(n, i, r, r),
                n.setValue(a.x, a.y, o.z),
                i.setValue(a.x, o.y, o.z),
                e.addLine(n, i, r, r),
                n.setValue(o.x, a.y, a.z),
                i.setValue(o.x, o.y, a.z),
                e.addLine(n, i, r, r),
                n.setValue(o.x, a.y, o.z),
                i.setValue(o.x, o.y, o.z),
                e.addLine(n, i, r, r),
                n.setValue(a.x, o.y, a.z),
                i.setValue(o.x, o.y, a.z),
                e.addLine(n, i, r, r),
                n.setValue(a.x, o.y, a.z),
                i.setValue(a.x, o.y, o.z),
                e.addLine(n, i, r, r),
                n.setValue(o.x, o.y, a.z),
                i.setValue(o.x, o.y, o.z),
                e.addLine(n, i, r, r),
                n.setValue(a.x, o.y, o.z),
                i.setValue(o.x, o.y, o.z),
                e.addLine(n, i, r, r);
            }
        }, {
            key: "_getHierarchyPath",
            value: function(e, t, r) {
                r.length = 0;
                for (var n = t; n !== e; ) {
                    var i = n._parent;
                    if (!i)
                        return null;
                    r.push(i.getChildIndex(n)),
                    n = i;
                }
                return r;
            }
        }, {
            key: "_getNodeByHierarchyPath",
            value: function(e, t) {
                for (var r = e, n = t.length - 1; n >= 0; n--)
                    r = r.getChildAt(t[n]);
                return r;
            }
        }]),
        Utils3D;
    }();
    R._tempVector3_0 = new o(),
    R._tempVector3_1 = new o(),
    R._tempArray16_0 = new Float32Array(16),
    R._tempArray16_1 = new Float32Array(16),
    R._tempArray16_2 = new Float32Array(16),
    R._tempArray16_3 = new Float32Array(16),
    R._compIdToNode = new Object();
    var C = function(e) {
        function AnimationClip() {
            var e;
            return _classCallCheck(this, AnimationClip),
            (e = _possibleConstructorReturn(this, _getPrototypeOf(AnimationClip).call(this)))._nodes = new y(),
            e._animationEvents = [],
            e;
        }
        return _inherits(AnimationClip, t.Resource),
        _createClass(AnimationClip, [{
            key: "duration",
            value: function() {
                return this._duration;
            }
        }, {
            key: "_hermiteInterpolate",
            value: function(e, t, r, n) {
                var i = e.outTangent
                  , a = t.inTangent;
                if (Number.isFinite(i) && Number.isFinite(a)) {
                    var o = r * r
                      , s = o * r
                      , l = s - 2 * o + r
                      , u = s - o
                      , c = -2 * s + 3 * o;
                    return (2 * s - 3 * o + 1) * e.value + l * i * n + u * a * n + c * t.value;
                }
                return e.value;
            }
        }, {
            key: "_hermiteInterpolateVector3",
            value: function(e, t, r, n, i) {
                var a = e.value
                  , o = e.outTangent
                  , s = t.value
                  , l = t.inTangent
                  , u = r * r
                  , c = u * r
                  , h = 2 * c - 3 * u + 1
                  , _ = c - 2 * u + r
                  , d = c - u
                  , f = -2 * c + 3 * u
                  , m = o.x
                  , p = l.x;
                Number.isFinite(m) && Number.isFinite(p) ? i.x = h * a.x + _ * m * n + d * p * n + f * s.x : i.x = a.x,
                m = o.y,
                p = l.y,
                Number.isFinite(m) && Number.isFinite(p) ? i.y = h * a.y + _ * m * n + d * p * n + f * s.y : i.y = a.y,
                m = o.z,
                p = l.z,
                Number.isFinite(m) && Number.isFinite(p) ? i.z = h * a.z + _ * m * n + d * p * n + f * s.z : i.z = a.z;
            }
        }, {
            key: "_hermiteInterpolateQuaternion",
            value: function(e, t, r, n, i) {
                var a = e.value
                  , o = e.outTangent
                  , s = t.value
                  , l = t.inTangent
                  , u = r * r
                  , c = u * r
                  , h = 2 * c - 3 * u + 1
                  , _ = c - 2 * u + r
                  , d = c - u
                  , f = -2 * c + 3 * u
                  , m = o.x
                  , p = l.x;
                Number.isFinite(m) && Number.isFinite(p) ? i.x = h * a.x + _ * m * n + d * p * n + f * s.x : i.x = a.x,
                m = o.y,
                p = l.y,
                Number.isFinite(m) && Number.isFinite(p) ? i.y = h * a.y + _ * m * n + d * p * n + f * s.y : i.y = a.y,
                m = o.z,
                p = l.z,
                Number.isFinite(m) && Number.isFinite(p) ? i.z = h * a.z + _ * m * n + d * p * n + f * s.z : i.z = a.z,
                m = o.w,
                p = l.w,
                Number.isFinite(m) && Number.isFinite(p) ? i.w = h * a.w + _ * m * n + d * p * n + f * s.w : i.w = a.w;
            }
        }, {
            key: "_evaluateClipDatasRealTime",
            value: function(e, t, r, n, i, a) {
                for (var o = 0, s = e.count; o < s; o++) {
                    var l, u = e.getNodeByIndex(o), c = u.type, h = u._keyFrames, _ = h.length, d = r[o];
                    if (i)
                        for (-1 !== d && t < h[d].time && (d = -1,
                        r[o] = d),
                        l = d + 1; l < _ && !(h[l].time > t); )
                            d++,
                            l++,
                            r[o] = d;
                    else
                        for ((l = d + 1) !== _ && t > h[l].time && (d = _ - 1,
                        r[o] = d),
                        l = d + 1; d > -1 && !(h[d].time < t); )
                            d--,
                            l--,
                            r[o] = d;
                    var m = l === _;
                    switch (c) {
                    case 0:
                        if (-1 !== d) {
                            var p = h[d];
                            if (m)
                                a[o] = p.value;
                            else {
                                var v, T = h[l], E = T.time - p.time;
                                v = 0 !== E ? (t - p.time) / E : 0,
                                a[o] = this._hermiteInterpolate(p, T, v, E);
                            }
                        } else
                            a[o] = h[0].value;
                        n && (a[o] = a[o] - h[0].value);
                        break;
                    case 1:
                    case 4:
                        var y = a[o];
                        if (this._evaluateFrameNodeVector3DatasRealTime(h, d, m, t, y),
                        n) {
                            var g = h[0].value;
                            y.x -= g.x,
                            y.y -= g.y,
                            y.z -= g.z;
                        }
                        break;
                    case 2:
                        var S = a[o];
                        if (this._evaluateFrameNodeQuaternionDatasRealTime(h, d, m, t, S),
                        n) {
                            var C = AnimationClip._tempQuaternion0
                              , M = h[0].value;
                            R.quaternionConjugate(M, C),
                            f.multiply(C, S, S);
                        }
                        break;
                    case 3:
                        y = a[o],
                        this._evaluateFrameNodeVector3DatasRealTime(h, d, m, t, y),
                        n && (g = h[0].value,
                        y.x /= g.x,
                        y.y /= g.y,
                        y.z /= g.z);
                        break;
                    default:
                        throw "AnimationClip:unknown node type.";
                    }
                }
            }
        }, {
            key: "_evaluateClipDatasRealTimeForNative",
            value: function(e, r, n, i) {
                t.LayaGL.instance.evaluateClipDatasRealTime(e._nativeObj, r, n, i);
            }
        }, {
            key: "_evaluateFrameNodeVector3DatasRealTime",
            value: function(e, t, r, n, i) {
                if (-1 !== t) {
                    var a = e[t];
                    if (r) {
                        var o = a.value;
                        i.x = o.x,
                        i.y = o.y,
                        i.z = o.z;
                    } else {
                        var s, l = e[t + 1], u = a.time, c = l.time - u;
                        s = 0 !== c ? (n - u) / c : 0,
                        this._hermiteInterpolateVector3(a, l, s, c, i);
                    }
                } else {
                    var h = e[0].value;
                    i.x = h.x,
                    i.y = h.y,
                    i.z = h.z;
                }
            }
        }, {
            key: "_evaluateFrameNodeQuaternionDatasRealTime",
            value: function(e, t, r, n, i) {
                if (-1 !== t) {
                    var a = e[t];
                    if (r) {
                        var o = a.value;
                        i.x = o.x,
                        i.y = o.y,
                        i.z = o.z,
                        i.w = o.w;
                    } else {
                        var s, l = e[t + 1], u = a.time, c = l.time - u;
                        s = 0 !== c ? (n - u) / c : 0,
                        this._hermiteInterpolateQuaternion(a, l, s, c, i);
                    }
                } else {
                    var h = e[0].value;
                    i.x = h.x,
                    i.y = h.y,
                    i.z = h.z,
                    i.w = h.w;
                }
            }
        }, {
            key: "_binarySearchEventIndex",
            value: function(e) {
                for (var t, r = 0, n = this._animationEvents.length - 1; r <= n; ) {
                    t = Math.floor((r + n) / 2);
                    var i = this._animationEvents[t].time;
                    if (i == e)
                        return t;
                    i > e ? n = t - 1 : r = t + 1;
                }
                return r;
            }
        }, {
            key: "addEvent",
            value: function(e) {
                var t = this._binarySearchEventIndex(e.time);
                this._animationEvents.splice(t, 0, e);
            }
        }, {
            key: "_disposeResource",
            value: function() {
                this._nodes = null,
                this._nodesMap = null;
            }
        }], [{
            key: "_parse",
            value: function(e) {
                arguments.length > 1 && void 0 !== arguments[1] && arguments[1],
                arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
                var r = new AnimationClip()
                  , n = new t.Byte(e)
                  , i = n.readUTFString();
                switch (i) {
                case "LAYAANIMATION:03":
                    v.parse(r, n);
                    break;
                case "LAYAANIMATION:04":
                case "LAYAANIMATION:COMPRESSION_04":
                    E.parse(r, n, i);
                    break;
                default:
                    throw "unknown animationClip version.";
                }
                return r;
            }
        }, {
            key: "load",
            value: function(e, r) {
                t.ILaya.loader.create(e, r, null, AnimationClip.ANIMATIONCLIP);
            }
        }]),
        AnimationClip;
    }();
    C.ANIMATIONCLIP = "ANIMATIONCLIP",
    C._tempQuaternion0 = new f();
    var M = function() {
        function AnimatorPlayState() {
            _classCallCheck(this, AnimatorPlayState),
            this._currentState = null;
        }
        return _createClass(AnimatorPlayState, [{
            key: "_resetPlayState",
            value: function(e) {
                this._finish = !1,
                this._startPlayTime = e,
                this._elapsedTime = e,
                this._playEventIndex = 0,
                this._lastIsFront = !0;
            }
        }, {
            key: "_cloneTo",
            value: function(e) {
                e._finish = this._finish,
                e._startPlayTime = this._startPlayTime,
                e._elapsedTime = this._elapsedTime,
                e._normalizedTime = this._normalizedTime,
                e._normalizedPlayTime = this._normalizedPlayTime,
                e._playEventIndex = this._playEventIndex,
                e._lastIsFront = this._lastIsFront;
            }
        }, {
            key: "normalizedTime",
            get: function() {
                return this._normalizedTime;
            }
        }, {
            key: "duration",
            get: function() {
                return this._duration;
            }
        }, {
            key: "animatorState",
            get: function() {
                return this._currentState;
            }
        }]),
        AnimatorPlayState;
    }()
      , D = function() {
        function AnimatorControllerLayer(e) {
            _classCallCheck(this, AnimatorControllerLayer),
            this._defaultState = null,
            this._referenceCount = 0,
            this._playType = -1,
            this._crossDuration = -1,
            this._crossMark = 0,
            this._crossNodesOwnersCount = 0,
            this._crossNodesOwners = [],
            this._crossNodesOwnersIndicesMap = {},
            this._srcCrossClipNodeIndices = [],
            this._destCrossClipNodeIndices = [],
            this._statesMap = {},
            this._states = [],
            this._playStateInfo = new M(),
            this._crossPlayStateInfo = new M(),
            this.blendingMode = AnimatorControllerLayer.BLENDINGMODE_OVERRIDE,
            this.defaultWeight = 1,
            this.playOnWake = !0,
            this.name = e;
        }
        return _createClass(AnimatorControllerLayer, [{
            key: "_removeClip",
            value: function(e, t, r, n) {
                var i = n._clip
                  , a = e[r];
                if (e.splice(r, 1),
                delete t[n.name],
                this._animator) {
                    var o = i._nodes
                      , s = a._nodeOwners;
                    i._removeReference();
                    for (var l = 0, u = o.count; l < u; l++)
                        this._animator._removeKeyframeNodeOwner(s, o.getNodeByIndex(l));
                }
            }
        }, {
            key: "_getReferenceCount",
            value: function() {
                return this._referenceCount;
            }
        }, {
            key: "_addReference",
            value: function() {
                for (var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 1, t = 0, r = this._states.length; t < r; t++)
                    this._states[t]._addReference(e);
                this._referenceCount += e;
            }
        }, {
            key: "_removeReference",
            value: function() {
                for (var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 1, t = 0, r = this._states.length; t < r; t++)
                    this._states[t]._removeReference(e);
                this._referenceCount -= e;
            }
        }, {
            key: "_clearReference",
            value: function() {
                this._removeReference(-this._referenceCount);
            }
        }, {
            key: "getCurrentPlayState",
            value: function() {
                return this._playStateInfo;
            }
        }, {
            key: "getAnimatorState",
            value: function(e) {
                var t = this._statesMap[e];
                return t || null;
            }
        }, {
            key: "addState",
            value: function(e) {
                var t = e.name;
                if (this._statesMap[t])
                    throw "AnimatorControllerLayer:this stat's name has exist.";
                this._statesMap[t] = e,
                this._states.push(e),
                this._animator && (e._clip._addReference(),
                this._animator._getOwnersByClip(e));
            }
        }, {
            key: "removeState",
            value: function(e) {
                for (var t = this._states, r = -1, n = 0, i = t.length; n < i; n++)
                    if (t[n] === e) {
                        r = n;
                        break;
                    }
                -1 !== r && this._removeClip(t, this._statesMap, r, e);
            }
        }, {
            key: "destroy",
            value: function() {
                this._clearReference(),
                this._statesMap = null,
                this._states = null,
                this._playStateInfo = null,
                this._crossPlayStateInfo = null,
                this._defaultState = null;
            }
        }, {
            key: "cloneTo",
            value: function(e) {
                var t = e;
                t.name = this.name,
                t.blendingMode = this.blendingMode,
                t.defaultWeight = this.defaultWeight,
                t.playOnWake = this.playOnWake;
            }
        }, {
            key: "clone",
            value: function() {
                var e = new AnimatorControllerLayer(this.name);
                return this.cloneTo(e),
                e;
            }
        }, {
            key: "defaultState",
            get: function() {
                return this._defaultState;
            },
            set: function(e) {
                this._defaultState = e,
                this._statesMap[e.name] = e;
            }
        }]),
        AnimatorControllerLayer;
    }();
    D.BLENDINGMODE_OVERRIDE = 0,
    D.BLENDINGMODE_ADDTIVE = 1;
    var x = function() {
        function ConchVector4() {
            var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0
              , t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0
              , r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0
              , n = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 0;
            _classCallCheck(this, ConchVector4);
            var i = this.elements = new Float32Array(4);
            i[0] = e,
            i[1] = t,
            i[2] = r,
            i[3] = n;
        }
        return _createClass(ConchVector4, [{
            key: "fromArray",
            value: function(e) {
                var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
                this.elements[0] = e[t + 0],
                this.elements[1] = e[t + 1],
                this.elements[2] = e[t + 2],
                this.elements[3] = e[t + 3];
            }
        }, {
            key: "cloneTo",
            value: function(e) {
                var t = e.elements
                  , r = this.elements;
                t[0] = r[0],
                t[1] = r[1],
                t[2] = r[2],
                t[3] = r[3];
            }
        }, {
            key: "clone",
            value: function() {
                var e = new ConchVector4();
                return this.cloneTo(e),
                e;
            }
        }, {
            key: "length",
            value: function() {
                return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
            }
        }, {
            key: "lengthSquared",
            value: function() {
                return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
            }
        }, {
            key: "x",
            get: function() {
                return this.elements[0];
            },
            set: function(e) {
                this.elements[0] = e;
            }
        }, {
            key: "y",
            get: function() {
                return this.elements[1];
            },
            set: function(e) {
                this.elements[1] = e;
            }
        }, {
            key: "z",
            get: function() {
                return this.elements[2];
            },
            set: function(e) {
                this.elements[2] = e;
            }
        }, {
            key: "w",
            get: function() {
                return this.elements[3];
            },
            set: function(e) {
                this.elements[3] = e;
            }
        }], [{
            key: "lerp",
            value: function(e, t, r, n) {
                var i = n.elements
                  , a = e.elements
                  , o = t.elements
                  , s = a[0]
                  , l = a[1]
                  , u = a[2]
                  , c = a[3];
                i[0] = s + r * (o[0] - s),
                i[1] = l + r * (o[1] - l),
                i[2] = u + r * (o[2] - u),
                i[3] = c + r * (o[3] - c);
            }
        }, {
            key: "transformByM4x4",
            value: function(e, t, r) {
                var n = e.elements
                  , i = n[0]
                  , a = n[1]
                  , o = n[2]
                  , s = n[3]
                  , l = t.elements
                  , u = r.elements;
                u[0] = i * l[0] + a * l[4] + o * l[8] + s * l[12],
                u[1] = i * l[1] + a * l[5] + o * l[9] + s * l[13],
                u[2] = i * l[2] + a * l[6] + o * l[10] + s * l[14],
                u[3] = i * l[3] + a * l[7] + o * l[11] + s * l[15];
            }
        }, {
            key: "equals",
            value: function(e, t) {
                var n = e.elements
                  , i = t.elements;
                return r.nearEqual(Math.abs(n[0]), Math.abs(i[0])) && r.nearEqual(Math.abs(n[1]), Math.abs(i[1])) && r.nearEqual(Math.abs(n[2]), Math.abs(i[2])) && r.nearEqual(Math.abs(n[3]), Math.abs(i[3]));
            }
        }, {
            key: "normalize",
            value: function(e, t) {
                var r = e.elements
                  , n = t.elements
                  , i = e.length();
                i > 0 && (n[0] = r[0] * i,
                n[1] = r[1] * i,
                n[2] = r[2] * i,
                n[3] = r[3] * i);
            }
        }, {
            key: "add",
            value: function(e, t, r) {
                var n = r.elements
                  , i = e.elements
                  , a = t.elements;
                n[0] = i[0] + a[0],
                n[1] = i[1] + a[1],
                n[2] = i[2] + a[2],
                n[3] = i[3] + a[3];
            }
        }, {
            key: "subtract",
            value: function(e, t, r) {
                var n = r.elements
                  , i = e.elements
                  , a = t.elements;
                n[0] = i[0] - a[0],
                n[1] = i[1] - a[1],
                n[2] = i[2] - a[2],
                n[3] = i[3] - a[3];
            }
        }, {
            key: "multiply",
            value: function(e, t, r) {
                var n = r.elements
                  , i = e.elements
                  , a = t.elements;
                n[0] = i[0] * a[0],
                n[1] = i[1] * a[1],
                n[2] = i[2] * a[2],
                n[3] = i[3] * a[3];
            }
        }, {
            key: "scale",
            value: function(e, t, r) {
                var n = r.elements
                  , i = e.elements;
                n[0] = i[0] * t,
                n[1] = i[1] * t,
                n[2] = i[2] * t,
                n[3] = i[3] * t;
            }
        }, {
            key: "Clamp",
            value: function(e, t, r, n) {
                var i = e.elements
                  , a = i[0]
                  , o = i[1]
                  , s = i[2]
                  , l = i[3]
                  , u = t.elements
                  , c = u[0]
                  , h = u[1]
                  , _ = u[2]
                  , d = u[3]
                  , f = r.elements
                  , m = f[0]
                  , p = f[1]
                  , v = f[2]
                  , T = f[3]
                  , E = n.elements;
                a = (a = a > m ? m : a) < c ? c : a,
                o = (o = o > p ? p : o) < h ? h : o,
                s = (s = s > v ? v : s) < _ ? _ : s,
                l = (l = l > T ? T : l) < d ? d : l,
                E[0] = a,
                E[1] = o,
                E[2] = s,
                E[3] = l;
            }
        }, {
            key: "distanceSquared",
            value: function(e, t) {
                var r = e.elements
                  , n = t.elements
                  , i = r[0] - n[0]
                  , a = r[1] - n[1]
                  , o = r[2] - n[2]
                  , s = r[3] - n[3];
                return i * i + a * a + o * o + s * s;
            }
        }, {
            key: "distance",
            value: function(e, t) {
                var r = e.elements
                  , n = t.elements
                  , i = r[0] - n[0]
                  , a = r[1] - n[1]
                  , o = r[2] - n[2]
                  , s = r[3] - n[3];
                return Math.sqrt(i * i + a * a + o * o + s * s);
            }
        }, {
            key: "dot",
            value: function(e, t) {
                var r = e.elements
                  , n = t.elements;
                return r[0] * n[0] + r[1] * n[1] + r[2] * n[2] + r[3] * n[3];
            }
        }, {
            key: "min",
            value: function(e, t, r) {
                var n = r.elements
                  , i = e.elements
                  , a = t.elements;
                n[0] = Math.min(i[0], a[0]),
                n[1] = Math.min(i[1], a[1]),
                n[2] = Math.min(i[2], a[2]),
                n[3] = Math.min(i[3], a[3]);
            }
        }, {
            key: "max",
            value: function(e, t, r) {
                var n = r.elements
                  , i = e.elements
                  , a = t.elements;
                n[0] = Math.max(i[0], a[0]),
                n[1] = Math.max(i[1], a[1]),
                n[2] = Math.max(i[2], a[2]),
                n[3] = Math.max(i[3], a[3]);
            }
        }]),
        ConchVector4;
    }();
    x.ZERO = new x(),
    x.ONE = new x(1,1,1,1),
    x.UnitX = new x(1,0,0,0),
    x.UnitY = new x(0,1,0,0),
    x.UnitZ = new x(0,0,1,0),
    x.UnitW = new x(0,0,0,1);
    var A = function() {
        function ConchVector3() {
            var e, t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0, r = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0, n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0, i = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : null;
            _classCallCheck(this, ConchVector3),
            e = i || new Float32Array(3),
            this.elements = e,
            e[0] = t,
            e[1] = r,
            e[2] = n;
        }
        return _createClass(ConchVector3, [{
            key: "setValue",
            value: function(e, t, r) {
                this.elements[0] = e,
                this.elements[1] = t,
                this.elements[2] = r;
            }
        }, {
            key: "fromArray",
            value: function(e) {
                var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
                this.elements[0] = e[t + 0],
                this.elements[1] = e[t + 1],
                this.elements[2] = e[t + 2];
            }
        }, {
            key: "cloneTo",
            value: function(e) {
                var t = e.elements
                  , r = this.elements;
                t[0] = r[0],
                t[1] = r[1],
                t[2] = r[2];
            }
        }, {
            key: "clone",
            value: function() {
                var e = new ConchVector3();
                return this.cloneTo(e),
                e;
            }
        }, {
            key: "toDefault",
            value: function() {
                this.elements[0] = 0,
                this.elements[1] = 0,
                this.elements[2] = 0;
            }
        }, {
            key: "x",
            get: function() {
                return this.elements[0];
            },
            set: function(e) {
                this.elements[0] = e;
            }
        }, {
            key: "y",
            get: function() {
                return this.elements[1];
            },
            set: function(e) {
                this.elements[1] = e;
            }
        }, {
            key: "z",
            get: function() {
                return this.elements[2];
            },
            set: function(e) {
                this.elements[2] = e;
            }
        }], [{
            key: "distanceSquared",
            value: function(e, t) {
                var r = e.elements
                  , n = t.elements
                  , i = r[0] - n[0]
                  , a = r[1] - n[1]
                  , o = r[2] - n[2];
                return i * i + a * a + o * o;
            }
        }, {
            key: "distance",
            value: function(e, t) {
                var r = e.elements
                  , n = t.elements
                  , i = r[0] - n[0]
                  , a = r[1] - n[1]
                  , o = r[2] - n[2];
                return Math.sqrt(i * i + a * a + o * o);
            }
        }, {
            key: "min",
            value: function(e, t, r) {
                var n = r.elements
                  , i = e.elements
                  , a = t.elements;
                n[0] = Math.min(i[0], a[0]),
                n[1] = Math.min(i[1], a[1]),
                n[2] = Math.min(i[2], a[2]);
            }
        }, {
            key: "max",
            value: function(e, t, r) {
                var n = r.elements
                  , i = e.elements
                  , a = t.elements;
                n[0] = Math.max(i[0], a[0]),
                n[1] = Math.max(i[1], a[1]),
                n[2] = Math.max(i[2], a[2]);
            }
        }, {
            key: "transformQuat",
            value: function(e, t, r) {
                var n = r.elements
                  , i = e.elements
                  , a = t.elements
                  , o = i[0]
                  , s = i[1]
                  , l = i[2]
                  , u = a[0]
                  , c = a[1]
                  , h = a[2]
                  , _ = a[3]
                  , d = _ * o + c * l - h * s
                  , f = _ * s + h * o - u * l
                  , m = _ * l + u * s - c * o
                  , p = -u * o - c * s - h * l;
                n[0] = d * _ + p * -u + f * -h - m * -c,
                n[1] = f * _ + p * -c + m * -u - d * -h,
                n[2] = m * _ + p * -h + d * -c - f * -u;
            }
        }, {
            key: "scalarLength",
            value: function(e) {
                var t = e.elements
                  , r = t[0]
                  , n = t[1]
                  , i = t[2];
                return Math.sqrt(r * r + n * n + i * i);
            }
        }, {
            key: "scalarLengthSquared",
            value: function(e) {
                var t = e.elements
                  , r = t[0]
                  , n = t[1]
                  , i = t[2];
                return r * r + n * n + i * i;
            }
        }, {
            key: "normalize",
            value: function(e, t) {
                var r = e.elements
                  , n = t.elements
                  , i = r[0]
                  , a = r[1]
                  , o = r[2]
                  , s = i * i + a * a + o * o;
                s > 0 && (s = 1 / Math.sqrt(s),
                n[0] = r[0] * s,
                n[1] = r[1] * s,
                n[2] = r[2] * s);
            }
        }, {
            key: "multiply",
            value: function(e, t, r) {
                var n = r.elements
                  , i = e.elements
                  , a = t.elements;
                n[0] = i[0] * a[0],
                n[1] = i[1] * a[1],
                n[2] = i[2] * a[2];
            }
        }, {
            key: "scale",
            value: function(e, t, r) {
                var n = r.elements
                  , i = e.elements;
                n[0] = i[0] * t,
                n[1] = i[1] * t,
                n[2] = i[2] * t;
            }
        }, {
            key: "lerp",
            value: function(e, t, r, n) {
                var i = n.elements
                  , a = e.elements
                  , o = t.elements
                  , s = a[0]
                  , l = a[1]
                  , u = a[2];
                i[0] = s + r * (o[0] - s),
                i[1] = l + r * (o[1] - l),
                i[2] = u + r * (o[2] - u);
            }
        }, {
            key: "transformV3ToV3",
            value: function(e, t, r) {
                var n = ConchVector3._tempVector4;
                ConchVector3.transformV3ToV4(e, t, n);
                var i = n.elements
                  , a = r.elements;
                a[0] = i[0],
                a[1] = i[1],
                a[2] = i[2];
            }
        }, {
            key: "transformV3ToV4",
            value: function(e, t, r) {
                var n = e.elements
                  , i = n[0]
                  , a = n[1]
                  , o = n[2]
                  , s = t.elements
                  , l = r.elements;
                l[0] = i * s[0] + a * s[4] + o * s[8] + s[12],
                l[1] = i * s[1] + a * s[5] + o * s[9] + s[13],
                l[2] = i * s[2] + a * s[6] + o * s[10] + s[14],
                l[3] = i * s[3] + a * s[7] + o * s[11] + s[15];
            }
        }, {
            key: "TransformNormal",
            value: function(e, t, r) {
                var n = e.elements
                  , i = n[0]
                  , a = n[1]
                  , o = n[2]
                  , s = t.elements
                  , l = r.elements;
                l[0] = i * s[0] + a * s[4] + o * s[8],
                l[1] = i * s[1] + a * s[5] + o * s[9],
                l[2] = i * s[2] + a * s[6] + o * s[10];
            }
        }, {
            key: "transformCoordinate",
            value: function(e, t, r) {
                var n = e.elements
                  , i = n[0]
                  , a = n[1]
                  , o = n[2]
                  , s = t.elements
                  , l = i * s[3] + a * s[7] + o * s[11] + s[15]
                  , u = r.elements;
                u[0] = i * s[0] + a * s[4] + o * s[8] + s[12] / l,
                u[1] = i * s[1] + a * s[5] + o * s[9] + s[13] / l,
                u[2] = i * s[2] + a * s[6] + o * s[10] + s[14] / l;
            }
        }, {
            key: "Clamp",
            value: function(e, t, r, n) {
                var i = e.elements
                  , a = i[0]
                  , o = i[1]
                  , s = i[2]
                  , l = t.elements
                  , u = l[0]
                  , c = l[1]
                  , h = l[2]
                  , _ = r.elements
                  , d = _[0]
                  , f = _[1]
                  , m = _[2]
                  , p = n.elements;
                a = (a = a > d ? d : a) < u ? u : a,
                o = (o = o > f ? f : o) < c ? c : o,
                s = (s = s > m ? m : s) < h ? h : s,
                p[0] = a,
                p[1] = o,
                p[2] = s;
            }
        }, {
            key: "add",
            value: function(e, t, r) {
                var n = r.elements
                  , i = e.elements
                  , a = t.elements;
                n[0] = i[0] + a[0],
                n[1] = i[1] + a[1],
                n[2] = i[2] + a[2];
            }
        }, {
            key: "subtract",
            value: function(e, t, r) {
                var n = r.elements
                  , i = e.elements
                  , a = t.elements;
                n[0] = i[0] - a[0],
                n[1] = i[1] - a[1],
                n[2] = i[2] - a[2];
            }
        }, {
            key: "cross",
            value: function(e, t, r) {
                var n = e.elements
                  , i = t.elements
                  , a = r.elements
                  , o = n[0]
                  , s = n[1]
                  , l = n[2]
                  , u = i[0]
                  , c = i[1]
                  , h = i[2];
                a[0] = s * h - l * c,
                a[1] = l * u - o * h,
                a[2] = o * c - s * u;
            }
        }, {
            key: "dot",
            value: function(e, t) {
                var r = e.elements
                  , n = t.elements;
                return r[0] * n[0] + r[1] * n[1] + r[2] * n[2];
            }
        }, {
            key: "equals",
            value: function(e, t) {
                var n = e.elements
                  , i = t.elements;
                return r.nearEqual(n[0], i[0]) && r.nearEqual(n[1], i[1]) && r.nearEqual(n[2], i[2]);
            }
        }]),
        ConchVector3;
    }();
    A._tempVector4 = new x(),
    A.ZERO = new A(0,0,0),
    A.ONE = new A(1,1,1),
    A.NegativeUnitX = new A(-1,0,0),
    A.UnitX = new A(1,0,0),
    A.UnitY = new A(0,1,0),
    A.UnitZ = new A(0,0,1),
    A.ForwardRH = new A(0,0,-1),
    A.ForwardLH = new A(0,0,1),
    A.Up = new A(0,1,0),
    A.NAN = new A(NaN,NaN,NaN);
    var I = function() {
        function Matrix4x4() {
            var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 1
              , t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0
              , r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0
              , n = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 0
              , i = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : 0
              , a = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : 1
              , o = arguments.length > 6 && void 0 !== arguments[6] ? arguments[6] : 0
              , s = arguments.length > 7 && void 0 !== arguments[7] ? arguments[7] : 0
              , l = arguments.length > 8 && void 0 !== arguments[8] ? arguments[8] : 0
              , u = arguments.length > 9 && void 0 !== arguments[9] ? arguments[9] : 0
              , c = arguments.length > 10 && void 0 !== arguments[10] ? arguments[10] : 1
              , h = arguments.length > 11 && void 0 !== arguments[11] ? arguments[11] : 0
              , _ = arguments.length > 12 && void 0 !== arguments[12] ? arguments[12] : 0
              , d = arguments.length > 13 && void 0 !== arguments[13] ? arguments[13] : 0
              , f = arguments.length > 14 && void 0 !== arguments[14] ? arguments[14] : 0
              , m = arguments.length > 15 && void 0 !== arguments[15] ? arguments[15] : 1
              , p = arguments.length > 16 && void 0 !== arguments[16] ? arguments[16] : null;
            _classCallCheck(this, Matrix4x4);
            var v = this.elements = p || new Float32Array(16);
            v[0] = e,
            v[1] = t,
            v[2] = r,
            v[3] = n,
            v[4] = i,
            v[5] = a,
            v[6] = o,
            v[7] = s,
            v[8] = l,
            v[9] = u,
            v[10] = c,
            v[11] = h,
            v[12] = _,
            v[13] = d,
            v[14] = f,
            v[15] = m;
        }
        return _createClass(Matrix4x4, [{
            key: "setRotation",
            value: function(e) {
                var t = e.x
                  , r = e.y
                  , n = e.z
                  , i = e.w
                  , a = t * t
                  , o = r * r
                  , s = n * n
                  , l = t * r
                  , u = n * i
                  , c = n * t
                  , h = r * i
                  , _ = r * n
                  , d = t * i
                  , f = this.elements;
                f[0] = 1 - 2 * (o + s),
                f[1] = 2 * (l + u),
                f[2] = 2 * (c - h),
                f[4] = 2 * (l - u),
                f[5] = 1 - 2 * (s + a),
                f[6] = 2 * (_ + d),
                f[8] = 2 * (c + h),
                f[9] = 2 * (_ - d),
                f[10] = 1 - 2 * (o + a);
            }
        }, {
            key: "setPosition",
            value: function(e) {
                var t = this.elements;
                t[12] = e.x,
                t[13] = e.y,
                t[14] = e.z;
            }
        }, {
            key: "getElementByRowColumn",
            value: function(e, t) {
                if (e < 0 || e > 3)
                    throw new Error("row Rows and columns for matrices run from 0 to 3, inclusive.");
                if (t < 0 || t > 3)
                    throw new Error("column Rows and columns for matrices run from 0 to 3, inclusive.");
                return this.elements[4 * e + t];
            }
        }, {
            key: "setElementByRowColumn",
            value: function(e, t, r) {
                if (e < 0 || e > 3)
                    throw new Error("row Rows and columns for matrices run from 0 to 3, inclusive.");
                if (t < 0 || t > 3)
                    throw new Error("column Rows and columns for matrices run from 0 to 3, inclusive.");
                this.elements[4 * e + t] = r;
            }
        }, {
            key: "equalsOtherMatrix",
            value: function(e) {
                var t = this.elements
                  , n = e.elements;
                return r.nearEqual(t[0], n[0]) && r.nearEqual(t[1], n[1]) && r.nearEqual(t[2], n[2]) && r.nearEqual(t[3], n[3]) && r.nearEqual(t[4], n[4]) && r.nearEqual(t[5], n[5]) && r.nearEqual(t[6], n[6]) && r.nearEqual(t[7], n[7]) && r.nearEqual(t[8], n[8]) && r.nearEqual(t[9], n[9]) && r.nearEqual(t[10], n[10]) && r.nearEqual(t[11], n[11]) && r.nearEqual(t[12], n[12]) && r.nearEqual(t[13], n[13]) && r.nearEqual(t[14], n[14]) && r.nearEqual(t[15], n[15]);
            }
        }, {
            key: "decomposeTransRotScale",
            value: function(e, t, r) {
                var n = Matrix4x4._tempMatrix4x4;
                return this.decomposeTransRotMatScale(e, n, r) ? (f.createFromMatrix4x4(n, t),
                !0) : (t.identity(),
                !1);
            }
        }, {
            key: "decomposeTransRotMatScale",
            value: function(e, t, n) {
                var i = this.elements
                  , a = e
                  , s = t.elements
                  , l = n;
                a.x = i[12],
                a.y = i[13],
                a.z = i[14];
                var u = i[0]
                  , c = i[1]
                  , h = i[2]
                  , _ = i[4]
                  , d = i[5]
                  , f = i[6]
                  , m = i[8]
                  , p = i[9]
                  , v = i[10]
                  , T = l.x = Math.sqrt(u * u + c * c + h * h)
                  , E = l.y = Math.sqrt(_ * _ + d * d + f * f)
                  , y = l.z = Math.sqrt(m * m + p * p + v * v);
                if (r.isZero(T) || r.isZero(E) || r.isZero(y))
                    return s[1] = s[2] = s[3] = s[4] = s[6] = s[7] = s[8] = s[9] = s[11] = s[12] = s[13] = s[14] = 0,
                    s[0] = s[5] = s[10] = s[15] = 1,
                    !1;
                var g = Matrix4x4._tempVector0;
                g.x = m / y,
                g.y = p / y,
                g.z = v / y;
                var S = Matrix4x4._tempVector1;
                S.x = u / T,
                S.y = c / T,
                S.z = h / T;
                var R = Matrix4x4._tempVector2;
                o.cross(g, S, R);
                var C = Matrix4x4._tempVector1;
                return o.cross(R, g, C),
                s[3] = s[7] = s[11] = s[12] = s[13] = s[14] = 0,
                s[15] = 1,
                s[0] = C.x,
                s[1] = C.y,
                s[2] = C.z,
                s[4] = R.x,
                s[5] = R.y,
                s[6] = R.z,
                s[8] = g.x,
                s[9] = g.y,
                s[10] = g.z,
                s[0] * u + s[1] * c + s[2] * h < 0 && (l.x = -T),
                s[4] * _ + s[5] * d + s[6] * f < 0 && (l.y = -E),
                s[8] * m + s[9] * p + s[10] * v < 0 && (l.z = -y),
                !0;
            }
        }, {
            key: "decomposeYawPitchRoll",
            value: function(e) {
                var t = Math.asin(-this.elements[9]);
                e.y = t,
                Math.cos(t) > r.zeroTolerance ? (e.z = Math.atan2(this.elements[1], this.elements[5]),
                e.x = Math.atan2(this.elements[8], this.elements[10])) : (e.z = Math.atan2(-this.elements[4], this.elements[0]),
                e.x = 0);
            }
        }, {
            key: "normalize",
            value: function() {
                var e = this.elements
                  , t = e[0]
                  , r = e[1]
                  , n = e[2]
                  , i = Math.sqrt(t * t + r * r + n * n);
                if (!i)
                    return e[0] = 0,
                    e[1] = 0,
                    void (e[2] = 0);
                1 != i && (i = 1 / i,
                e[0] = t * i,
                e[1] = r * i,
                e[2] = n * i);
            }
        }, {
            key: "transpose",
            value: function() {
                var e, t;
                return t = (e = this.elements)[1],
                e[1] = e[4],
                e[4] = t,
                t = e[2],
                e[2] = e[8],
                e[8] = t,
                t = e[3],
                e[3] = e[12],
                e[12] = t,
                t = e[6],
                e[6] = e[9],
                e[9] = t,
                t = e[7],
                e[7] = e[13],
                e[13] = t,
                t = e[11],
                e[11] = e[14],
                e[14] = t,
                this;
            }
        }, {
            key: "invert",
            value: function(e) {
                var t = this.elements
                  , r = e.elements
                  , n = t[0]
                  , i = t[1]
                  , a = t[2]
                  , o = t[3]
                  , s = t[4]
                  , l = t[5]
                  , u = t[6]
                  , c = t[7]
                  , h = t[8]
                  , _ = t[9]
                  , d = t[10]
                  , f = t[11]
                  , m = t[12]
                  , p = t[13]
                  , v = t[14]
                  , T = t[15]
                  , E = n * l - i * s
                  , y = n * u - a * s
                  , g = n * c - o * s
                  , S = i * u - a * l
                  , R = i * c - o * l
                  , C = a * c - o * u
                  , M = h * p - _ * m
                  , D = h * v - d * m
                  , x = h * T - f * m
                  , A = _ * v - d * p
                  , I = _ * T - f * p
                  , L = d * T - f * v
                  , P = E * L - y * I + g * A + S * x - R * D + C * M;
                0 !== Math.abs(P) && (P = 1 / P,
                r[0] = (l * L - u * I + c * A) * P,
                r[1] = (a * I - i * L - o * A) * P,
                r[2] = (p * C - v * R + T * S) * P,
                r[3] = (d * R - _ * C - f * S) * P,
                r[4] = (u * x - s * L - c * D) * P,
                r[5] = (n * L - a * x + o * D) * P,
                r[6] = (v * g - m * C - T * y) * P,
                r[7] = (h * C - d * g + f * y) * P,
                r[8] = (s * I - l * x + c * M) * P,
                r[9] = (i * x - n * I - o * M) * P,
                r[10] = (m * R - p * g + T * E) * P,
                r[11] = (_ * g - h * R - f * E) * P,
                r[12] = (l * D - s * A - u * M) * P,
                r[13] = (n * A - i * D + a * M) * P,
                r[14] = (p * y - m * S - v * E) * P,
                r[15] = (h * S - _ * y + d * E) * P);
            }
        }, {
            key: "identity",
            value: function() {
                var e = this.elements;
                e[1] = e[2] = e[3] = e[4] = e[6] = e[7] = e[8] = e[9] = e[11] = e[12] = e[13] = e[14] = 0,
                e[0] = e[5] = e[10] = e[15] = 1;
            }
        }, {
            key: "cloneTo",
            value: function(e) {
                var t, r, n;
                if ((r = this.elements) !== (n = e.elements))
                    for (t = 0; t < 16; ++t)
                        n[t] = r[t];
            }
        }, {
            key: "clone",
            value: function() {
                var e = new Matrix4x4();
                return this.cloneTo(e),
                e;
            }
        }, {
            key: "getTranslationVector",
            value: function(e) {
                var t = this.elements;
                e.x = t[12],
                e.y = t[13],
                e.z = t[14];
            }
        }, {
            key: "setTranslationVector",
            value: function(e) {
                var t = this.elements
                  , r = e;
                t[12] = r.x,
                t[13] = r.y,
                t[14] = r.z;
            }
        }, {
            key: "getForward",
            value: function(e) {
                var t = this.elements;
                e.x = -t[8],
                e.y = -t[9],
                e.z = -t[10];
            }
        }, {
            key: "setForward",
            value: function(e) {
                var t = this.elements;
                t[8] = -e.x,
                t[9] = -e.y,
                t[10] = -e.z;
            }
        }], [{
            key: "createRotationX",
            value: function(e, t) {
                var r = t.elements
                  , n = Math.sin(e)
                  , i = Math.cos(e);
                r[1] = r[2] = r[3] = r[4] = r[7] = r[8] = r[11] = r[12] = r[13] = r[14] = 0,
                r[0] = r[15] = 1,
                r[5] = r[10] = i,
                r[6] = n,
                r[9] = -n;
            }
        }, {
            key: "createRotationY",
            value: function(e, t) {
                var r = t.elements
                  , n = Math.sin(e)
                  , i = Math.cos(e);
                r[1] = r[3] = r[4] = r[6] = r[7] = r[9] = r[11] = r[12] = r[13] = r[14] = 0,
                r[5] = r[15] = 1,
                r[0] = r[10] = i,
                r[2] = -n,
                r[8] = n;
            }
        }, {
            key: "createRotationZ",
            value: function(e, t) {
                var r = t.elements
                  , n = Math.sin(e)
                  , i = Math.cos(e);
                r[2] = r[3] = r[6] = r[7] = r[8] = r[9] = r[11] = r[12] = r[13] = r[14] = 0,
                r[10] = r[15] = 1,
                r[0] = r[5] = i,
                r[1] = n,
                r[4] = -n;
            }
        }, {
            key: "createRotationYawPitchRoll",
            value: function(e, t, r, n) {
                f.createFromYawPitchRoll(e, t, r, Matrix4x4._tempQuaternion),
                Matrix4x4.createRotationQuaternion(Matrix4x4._tempQuaternion, n);
            }
        }, {
            key: "createRotationAxis",
            value: function(e, t, r) {
                var n = e.x
                  , i = e.y
                  , a = e.z
                  , o = Math.cos(t)
                  , s = Math.sin(t)
                  , l = n * n
                  , u = i * i
                  , c = a * a
                  , h = n * i
                  , _ = n * a
                  , d = i * a
                  , f = r.elements;
                f[3] = f[7] = f[11] = f[12] = f[13] = f[14] = 0,
                f[15] = 1,
                f[0] = l + o * (1 - l),
                f[1] = h - o * h + s * a,
                f[2] = _ - o * _ - s * i,
                f[4] = h - o * h - s * a,
                f[5] = u + o * (1 - u),
                f[6] = d - o * d + s * n,
                f[8] = _ - o * _ + s * i,
                f[9] = d - o * d - s * n,
                f[10] = c + o * (1 - c);
            }
        }, {
            key: "createRotationQuaternion",
            value: function(e, t) {
                var r = t.elements
                  , n = e.x
                  , i = e.y
                  , a = e.z
                  , o = e.w
                  , s = n * n
                  , l = i * i
                  , u = a * a
                  , c = n * i
                  , h = a * o
                  , _ = a * n
                  , d = i * o
                  , f = i * a
                  , m = n * o;
                r[3] = r[7] = r[11] = r[12] = r[13] = r[14] = 0,
                r[15] = 1,
                r[0] = 1 - 2 * (l + u),
                r[1] = 2 * (c + h),
                r[2] = 2 * (_ - d),
                r[4] = 2 * (c - h),
                r[5] = 1 - 2 * (u + s),
                r[6] = 2 * (f + m),
                r[8] = 2 * (_ + d),
                r[9] = 2 * (f - m),
                r[10] = 1 - 2 * (l + s);
            }
        }, {
            key: "createTranslate",
            value: function(e, t) {
                var r = t.elements;
                r[4] = r[8] = r[1] = r[9] = r[2] = r[6] = r[3] = r[7] = r[11] = 0,
                r[0] = r[5] = r[10] = r[15] = 1,
                r[12] = e.x,
                r[13] = e.y,
                r[14] = e.z;
            }
        }, {
            key: "createScaling",
            value: function(e, t) {
                var r = t.elements;
                r[0] = e.x,
                r[5] = e.y,
                r[10] = e.z,
                r[1] = r[4] = r[8] = r[12] = r[9] = r[13] = r[2] = r[6] = r[14] = r[3] = r[7] = r[11] = 0,
                r[15] = 1;
            }
        }, {
            key: "multiply",
            value: function(e, t, r) {
                var n = t.elements
                  , i = e.elements
                  , a = r.elements
                  , o = n[0]
                  , s = n[1]
                  , l = n[2]
                  , u = n[3]
                  , c = n[4]
                  , h = n[5]
                  , _ = n[6]
                  , d = n[7]
                  , f = n[8]
                  , m = n[9]
                  , p = n[10]
                  , v = n[11]
                  , T = n[12]
                  , E = n[13]
                  , y = n[14]
                  , g = n[15]
                  , S = i[0]
                  , R = i[1]
                  , C = i[2]
                  , M = i[3]
                  , D = i[4]
                  , x = i[5]
                  , A = i[6]
                  , I = i[7]
                  , L = i[8]
                  , P = i[9]
                  , O = i[10]
                  , N = i[11]
                  , b = i[12]
                  , k = i[13]
                  , V = i[14]
                  , B = i[15];
                a[0] = o * S + s * D + l * L + u * b,
                a[1] = o * R + s * x + l * P + u * k,
                a[2] = o * C + s * A + l * O + u * V,
                a[3] = o * M + s * I + l * N + u * B,
                a[4] = c * S + h * D + _ * L + d * b,
                a[5] = c * R + h * x + _ * P + d * k,
                a[6] = c * C + h * A + _ * O + d * V,
                a[7] = c * M + h * I + _ * N + d * B,
                a[8] = f * S + m * D + p * L + v * b,
                a[9] = f * R + m * x + p * P + v * k,
                a[10] = f * C + m * A + p * O + v * V,
                a[11] = f * M + m * I + p * N + v * B,
                a[12] = T * S + E * D + y * L + g * b,
                a[13] = T * R + E * x + y * P + g * k,
                a[14] = T * C + E * A + y * O + g * V,
                a[15] = T * M + E * I + y * N + g * B;
            }
        }, {
            key: "multiplyForNative",
            value: function(e, r, n) {
                t.LayaGL.instance.matrix4x4Multiply(e.elements, r.elements, n.elements);
            }
        }, {
            key: "createFromQuaternion",
            value: function(e, t) {
                var r = t.elements
                  , n = e.x
                  , i = e.y
                  , a = e.z
                  , o = e.w
                  , s = n + n
                  , l = i + i
                  , u = a + a
                  , c = n * s
                  , h = i * s
                  , _ = i * l
                  , d = a * s
                  , f = a * l
                  , m = a * u
                  , p = o * s
                  , v = o * l
                  , T = o * u;
                r[0] = 1 - _ - m,
                r[1] = h + T,
                r[2] = d - v,
                r[3] = 0,
                r[4] = h - T,
                r[5] = 1 - c - m,
                r[6] = f + p,
                r[7] = 0,
                r[8] = d + v,
                r[9] = f - p,
                r[10] = 1 - c - _,
                r[11] = 0,
                r[12] = 0,
                r[13] = 0,
                r[14] = 0,
                r[15] = 1;
            }
        }, {
            key: "createAffineTransformation",
            value: function(e, t, r, n) {
                var i = n.elements
                  , a = t.x
                  , o = t.y
                  , s = t.z
                  , l = t.w
                  , u = a + a
                  , c = o + o
                  , h = s + s
                  , _ = a * u
                  , d = a * c
                  , f = a * h
                  , m = o * c
                  , p = o * h
                  , v = s * h
                  , T = l * u
                  , E = l * c
                  , y = l * h
                  , g = r.x
                  , S = r.y
                  , R = r.z;
                i[0] = (1 - (m + v)) * g,
                i[1] = (d + y) * g,
                i[2] = (f - E) * g,
                i[3] = 0,
                i[4] = (d - y) * S,
                i[5] = (1 - (_ + v)) * S,
                i[6] = (p + T) * S,
                i[7] = 0,
                i[8] = (f + E) * R,
                i[9] = (p - T) * R,
                i[10] = (1 - (_ + m)) * R,
                i[11] = 0,
                i[12] = e.x,
                i[13] = e.y,
                i[14] = e.z,
                i[15] = 1;
            }
        }, {
            key: "createLookAt",
            value: function(e, t, r, n) {
                var i = n.elements
                  , a = Matrix4x4._tempVector0
                  , s = Matrix4x4._tempVector1
                  , l = Matrix4x4._tempVector2;
                o.subtract(e, t, l),
                o.normalize(l, l),
                o.cross(r, l, a),
                o.normalize(a, a),
                o.cross(l, a, s),
                n.identity(),
                i[0] = a.x,
                i[4] = a.y,
                i[8] = a.z,
                i[1] = s.x,
                i[5] = s.y,
                i[9] = s.z,
                i[2] = l.x,
                i[6] = l.y,
                i[10] = l.z,
                i[12] = -o.dot(a, e),
                i[13] = -o.dot(s, e),
                i[14] = -o.dot(l, e);
            }
        }, {
            key: "createPerspective",
            value: function(e, t, r, n, i) {
                var a = 1 / Math.tan(.5 * e)
                  , o = r / (a / t)
                  , s = r / a;
                Matrix4x4.createPerspectiveOffCenter(-o, o, -s, s, r, n, i);
            }
        }, {
            key: "createPerspectiveOffCenter",
            value: function(e, t, r, n, i, a, o) {
                var s = o.elements
                  , l = a / (a - i);
                s[1] = s[2] = s[3] = s[4] = s[6] = s[7] = s[12] = s[13] = s[15] = 0,
                s[0] = 2 * i / (t - e),
                s[5] = 2 * i / (n - r),
                s[8] = (e + t) / (t - e),
                s[9] = (n + r) / (n - r),
                s[10] = -l,
                s[11] = -1,
                s[14] = -i * l;
            }
        }, {
            key: "createOrthoOffCenter",
            value: function(e, t, r, n, i, a, o) {
                var s = o.elements
                  , l = 1 / (a - i);
                s[1] = s[2] = s[3] = s[4] = s[6] = s[8] = s[7] = s[9] = s[11] = 0,
                s[15] = 1,
                s[0] = 2 / (t - e),
                s[5] = 2 / (n - r),
                s[10] = -l,
                s[12] = (e + t) / (e - t),
                s[13] = (n + r) / (r - n),
                s[14] = -i * l;
            }
        }, {
            key: "billboard",
            value: function(e, t, n, i, a, s) {
                o.subtract(e, t, Matrix4x4._tempVector0);
                var l = o.scalarLengthSquared(Matrix4x4._tempVector0);
                r.isZero(l) ? (o.scale(a, -1, Matrix4x4._tempVector1),
                Matrix4x4._tempVector1.cloneTo(Matrix4x4._tempVector0)) : o.scale(Matrix4x4._tempVector0, 1 / Math.sqrt(l), Matrix4x4._tempVector0),
                o.cross(i, Matrix4x4._tempVector0, Matrix4x4._tempVector2),
                o.normalize(Matrix4x4._tempVector2, Matrix4x4._tempVector2),
                o.cross(Matrix4x4._tempVector0, Matrix4x4._tempVector2, Matrix4x4._tempVector3);
                var u = Matrix4x4._tempVector2
                  , c = Matrix4x4._tempVector3
                  , h = Matrix4x4._tempVector0
                  , _ = e
                  , d = s.elements;
                d[0] = u.x,
                d[1] = u.y,
                d[2] = u.z,
                d[3] = 0,
                d[4] = c.x,
                d[5] = c.y,
                d[6] = c.z,
                d[7] = 0,
                d[8] = h.x,
                d[9] = h.y,
                d[10] = h.z,
                d[11] = 0,
                d[12] = _.x,
                d[13] = _.y,
                d[14] = _.z,
                d[15] = 1;
            }
        }, {
            key: "translation",
            value: function(e, t) {
                var r = t.elements;
                r[0] = r[5] = r[10] = r[15] = 1,
                r[12] = e.x,
                r[13] = e.y,
                r[14] = e.z;
            }
        }]),
        Matrix4x4;
    }();
    I._tempMatrix4x4 = new I(),
    I.TEMPMatrix0 = new I(),
    I.TEMPMatrix1 = new I(),
    I._tempVector0 = new o(),
    I._tempVector1 = new o(),
    I._tempVector2 = new o(),
    I._tempVector3 = new o(),
    I._tempQuaternion = new f(),
    I.DEFAULT = new I(),
    I.ZERO = new I(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);
    var L = function() {
        function ConchQuaternion() {
            var e, t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0, r = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0, n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0, i = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 1, a = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : null;
            _classCallCheck(this, ConchQuaternion),
            (e = a || new Float32Array(4))[0] = t,
            e[1] = r,
            e[2] = n,
            e[3] = i,
            this.elements = e;
        }
        return _createClass(ConchQuaternion, [{
            key: "scaling",
            value: function(e, t) {
                var r = t.elements
                  , n = this.elements;
                r[0] = n[0] * e,
                r[1] = n[1] * e,
                r[2] = n[2] * e,
                r[3] = n[3] * e;
            }
        }, {
            key: "normalize",
            value: function(e) {
                ConchQuaternion._normalizeArray(this.elements, e.elements);
            }
        }, {
            key: "length",
            value: function() {
                var e = this.elements
                  , t = e[0]
                  , r = e[1]
                  , n = e[2]
                  , i = e[3];
                return Math.sqrt(t * t + r * r + n * n + i * i);
            }
        }, {
            key: "rotateX",
            value: function(e, t) {
                var r = t.elements
                  , n = this.elements;
                e *= .5;
                var i = n[0]
                  , a = n[1]
                  , o = n[2]
                  , s = n[3]
                  , l = Math.sin(e)
                  , u = Math.cos(e);
                r[0] = i * u + s * l,
                r[1] = a * u + o * l,
                r[2] = o * u - a * l,
                r[3] = s * u - i * l;
            }
        }, {
            key: "rotateY",
            value: function(e, t) {
                var r = t.elements
                  , n = this.elements;
                e *= .5;
                var i = n[0]
                  , a = n[1]
                  , o = n[2]
                  , s = n[3]
                  , l = Math.sin(e)
                  , u = Math.cos(e);
                r[0] = i * u - o * l,
                r[1] = a * u + s * l,
                r[2] = o * u + i * l,
                r[3] = s * u - a * l;
            }
        }, {
            key: "rotateZ",
            value: function(e, t) {
                var r = t.elements
                  , n = this.elements;
                e *= .5;
                var i = n[0]
                  , a = n[1]
                  , o = n[2]
                  , s = n[3]
                  , l = Math.sin(e)
                  , u = Math.cos(e);
                r[0] = i * u + a * l,
                r[1] = a * u - i * l,
                r[2] = o * u + s * l,
                r[3] = s * u - o * l;
            }
        }, {
            key: "getYawPitchRoll",
            value: function(e) {
                A.transformQuat(A.ForwardRH, this, ConchQuaternion.TEMPVector31),
                A.transformQuat(A.Up, this, ConchQuaternion.TEMPVector32);
                var t = ConchQuaternion.TEMPVector32.elements;
                ConchQuaternion.angleTo(A.ZERO, ConchQuaternion.TEMPVector31, ConchQuaternion.TEMPVector33);
                var r = ConchQuaternion.TEMPVector33.elements;
                r[0] == Math.PI / 2 ? (r[1] = ConchQuaternion.arcTanAngle(t[2], t[0]),
                r[2] = 0) : r[0] == -Math.PI / 2 ? (r[1] = ConchQuaternion.arcTanAngle(-t[2], -t[0]),
                r[2] = 0) : (I.createRotationY(-r[1], ConchQuaternion.TEMPMatrix0),
                I.createRotationX(-r[0], ConchQuaternion.TEMPMatrix1),
                A.transformCoordinate(ConchQuaternion.TEMPVector32, ConchQuaternion.TEMPMatrix0, ConchQuaternion.TEMPVector32),
                A.transformCoordinate(ConchQuaternion.TEMPVector32, ConchQuaternion.TEMPMatrix1, ConchQuaternion.TEMPVector32),
                r[2] = ConchQuaternion.arcTanAngle(t[1], -t[0])),
                r[1] <= -Math.PI && (r[1] = Math.PI),
                r[2] <= -Math.PI && (r[2] = Math.PI),
                r[1] >= Math.PI && r[2] >= Math.PI && (r[1] = 0,
                r[2] = 0,
                r[0] = Math.PI - r[0]);
                var n = e.elements;
                n[0] = r[1],
                n[1] = r[0],
                n[2] = r[2];
            }
        }, {
            key: "invert",
            value: function(e) {
                var t = e.elements
                  , r = this.elements
                  , n = r[0]
                  , i = r[1]
                  , a = r[2]
                  , o = r[3]
                  , s = n * n + i * i + a * a + o * o
                  , l = s ? 1 / s : 0;
                t[0] = -n * l,
                t[1] = -i * l,
                t[2] = -a * l,
                t[3] = o * l;
            }
        }, {
            key: "identity",
            value: function() {
                var e = this.elements;
                e[0] = 0,
                e[1] = 0,
                e[2] = 0,
                e[3] = 1;
            }
        }, {
            key: "fromArray",
            value: function(e) {
                var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
                this.elements[0] = e[t + 0],
                this.elements[1] = e[t + 1],
                this.elements[2] = e[t + 2],
                this.elements[3] = e[t + 3];
            }
        }, {
            key: "cloneTo",
            value: function(e) {
                var t, r, n;
                if ((r = this.elements) !== (n = e.elements))
                    for (t = 0; t < 4; ++t)
                        n[t] = r[t];
            }
        }, {
            key: "clone",
            value: function() {
                var e = new ConchQuaternion();
                return this.cloneTo(e),
                e;
            }
        }, {
            key: "equals",
            value: function(e) {
                var t = this.elements
                  , n = e.elements;
                return r.nearEqual(t[0], n[0]) && r.nearEqual(t[1], n[1]) && r.nearEqual(t[2], n[2]) && r.nearEqual(t[3], n[3]);
            }
        }, {
            key: "lengthSquared",
            value: function() {
                var e = this.elements[0]
                  , t = this.elements[1]
                  , r = this.elements[2]
                  , n = this.elements[3];
                return e * e + t * t + r * r + n * n;
            }
        }, {
            key: "x",
            get: function() {
                return this.elements[0];
            },
            set: function(e) {
                this.elements[0] = e;
            }
        }, {
            key: "y",
            get: function() {
                return this.elements[1];
            },
            set: function(e) {
                this.elements[1] = e;
            }
        }, {
            key: "z",
            get: function() {
                return this.elements[2];
            },
            set: function(e) {
                this.elements[2] = e;
            }
        }, {
            key: "w",
            get: function() {
                return this.elements[3];
            },
            set: function(e) {
                this.elements[3] = e;
            }
        }], [{
            key: "_dotArray",
            value: function(e, t) {
                return e[0] * t[0] + e[1] * t[1] + e[2] * t[2] + e[3] * t[3];
            }
        }, {
            key: "_normalizeArray",
            value: function(e, t) {
                var r = e[0]
                  , n = e[1]
                  , i = e[2]
                  , a = e[3]
                  , o = r * r + n * n + i * i + a * a;
                o > 0 && (o = 1 / Math.sqrt(o),
                t[0] = r * o,
                t[1] = n * o,
                t[2] = i * o,
                t[3] = a * o);
            }
        }, {
            key: "_lerpArray",
            value: function(e, t, r, n) {
                var i = 1 - r;
                ConchQuaternion._dotArray(e, t) >= 0 ? (n[0] = i * e[0] + r * t[0],
                n[1] = i * e[1] + r * t[1],
                n[2] = i * e[2] + r * t[2],
                n[3] = i * e[3] + r * t[3]) : (n[0] = i * e[0] - r * t[0],
                n[1] = i * e[1] - r * t[1],
                n[2] = i * e[2] - r * t[2],
                n[3] = i * e[3] - r * t[3]),
                ConchQuaternion._normalizeArray(n, n);
            }
        }, {
            key: "createFromYawPitchRoll",
            value: function(e, t, r, n) {
                var i = .5 * r
                  , a = .5 * t
                  , o = .5 * e
                  , s = Math.sin(i)
                  , l = Math.cos(i)
                  , u = Math.sin(a)
                  , c = Math.cos(a)
                  , h = Math.sin(o)
                  , _ = Math.cos(o)
                  , d = n.elements;
                d[0] = _ * u * l + h * c * s,
                d[1] = h * c * l - _ * u * s,
                d[2] = _ * c * s - h * u * l,
                d[3] = _ * c * l + h * u * s;
            }
        }, {
            key: "multiply",
            value: function(e, t, r) {
                var n = e.elements
                  , i = t.elements
                  , a = r.elements
                  , o = n[0]
                  , s = n[1]
                  , l = n[2]
                  , u = n[3]
                  , c = i[0]
                  , h = i[1]
                  , _ = i[2]
                  , d = i[3]
                  , f = s * _ - l * h
                  , m = l * c - o * _
                  , p = o * h - s * c
                  , v = o * c + s * h + l * _;
                a[0] = o * d + c * u + f,
                a[1] = s * d + h * u + m,
                a[2] = l * d + _ * u + p,
                a[3] = u * d - v;
            }
        }, {
            key: "arcTanAngle",
            value: function(e, t) {
                return 0 == e ? 1 == t ? Math.PI / 2 : -Math.PI / 2 : e > 0 ? Math.atan(t / e) : e < 0 ? t > 0 ? Math.atan(t / e) + Math.PI : Math.atan(t / e) - Math.PI : 0;
            }
        }, {
            key: "angleTo",
            value: function(e, t, r) {
                A.subtract(t, e, ConchQuaternion.TEMPVector30),
                A.normalize(ConchQuaternion.TEMPVector30, ConchQuaternion.TEMPVector30),
                r.elements[0] = Math.asin(ConchQuaternion.TEMPVector30.y),
                r.elements[1] = ConchQuaternion.arcTanAngle(-ConchQuaternion.TEMPVector30.z, -ConchQuaternion.TEMPVector30.x);
            }
        }, {
            key: "createFromAxisAngle",
            value: function(e, t, r) {
                var n = r.elements
                  , i = e.elements;
                t *= .5;
                var a = Math.sin(t);
                n[0] = a * i[0],
                n[1] = a * i[1],
                n[2] = a * i[2],
                n[3] = Math.cos(t);
            }
        }, {
            key: "createFromMatrix3x3",
            value: function(e, t) {
                var r, n = t.elements, i = e.elements, a = i[0] + i[4] + i[8];
                if (a > 0)
                    r = Math.sqrt(a + 1),
                    n[3] = .5 * r,
                    r = .5 / r,
                    n[0] = (i[5] - i[7]) * r,
                    n[1] = (i[6] - i[2]) * r,
                    n[2] = (i[1] - i[3]) * r;
                else {
                    var o = 0;
                    i[4] > i[0] && (o = 1),
                    i[8] > i[3 * o + o] && (o = 2);
                    var s = (o + 1) % 3
                      , l = (o + 2) % 3;
                    r = Math.sqrt(i[3 * o + o] - i[3 * s + s] - i[3 * l + l] + 1),
                    n[o] = .5 * r,
                    r = .5 / r,
                    n[3] = (i[3 * s + l] - i[3 * l + s]) * r,
                    n[s] = (i[3 * s + o] + i[3 * o + s]) * r,
                    n[l] = (i[3 * l + o] + i[3 * o + l]) * r;
                }
            }
        }, {
            key: "createFromMatrix4x4",
            value: function(e, t) {
                var r, n, i = e.elements, a = t.elements, o = i[0] + i[5] + i[10];
                o > 0 ? (r = Math.sqrt(o + 1),
                a[3] = .5 * r,
                r = .5 / r,
                a[0] = (i[6] - i[9]) * r,
                a[1] = (i[8] - i[2]) * r,
                a[2] = (i[1] - i[4]) * r) : i[0] >= i[5] && i[0] >= i[10] ? (n = .5 / (r = Math.sqrt(1 + i[0] - i[5] - i[10])),
                a[0] = .5 * r,
                a[1] = (i[1] + i[4]) * n,
                a[2] = (i[2] + i[8]) * n,
                a[3] = (i[6] - i[9]) * n) : i[5] > i[10] ? (n = .5 / (r = Math.sqrt(1 + i[5] - i[0] - i[10])),
                a[0] = (i[4] + i[1]) * n,
                a[1] = .5 * r,
                a[2] = (i[9] + i[6]) * n,
                a[3] = (i[8] - i[2]) * n) : (n = .5 / (r = Math.sqrt(1 + i[10] - i[0] - i[5])),
                a[0] = (i[8] + i[2]) * n,
                a[1] = (i[9] + i[6]) * n,
                a[2] = .5 * r,
                a[3] = (i[1] - i[4]) * n);
            }
        }, {
            key: "slerp",
            value: function(e, t, r, n) {
                var i, a, o, s, l, u = e.elements, c = t.elements, h = n.elements, _ = u[0], d = u[1], f = u[2], m = u[3], p = c[0], v = c[1], T = c[2], E = c[3];
                return (a = _ * p + d * v + f * T + m * E) < 0 && (a = -a,
                p = -p,
                v = -v,
                T = -T,
                E = -E),
                1 - a > 1e-6 ? (i = Math.acos(a),
                o = Math.sin(i),
                s = Math.sin((1 - r) * i) / o,
                l = Math.sin(r * i) / o) : (s = 1 - r,
                l = r),
                h[0] = s * _ + l * p,
                h[1] = s * d + l * v,
                h[2] = s * f + l * T,
                h[3] = s * m + l * E,
                h;
            }
        }, {
            key: "lerp",
            value: function(e, t, r, n) {
                ConchQuaternion._lerpArray(e.elements, t.elements, r, n.elements);
            }
        }, {
            key: "add",
            value: function(e, t, r) {
                var n = r.elements
                  , i = e.elements
                  , a = t.elements;
                n[0] = i[0] + a[0],
                n[1] = i[1] + a[1],
                n[2] = i[2] + a[2],
                n[3] = i[3] + a[3];
            }
        }, {
            key: "dot",
            value: function(e, t) {
                return ConchQuaternion._dotArray(e.elements, t.elements);
            }
        }, {
            key: "rotationLookAt",
            value: function(e, t, r) {
                ConchQuaternion.lookAt(A.ZERO, e, t, r);
            }
        }, {
            key: "lookAt",
            value: function(e, t, r, n) {
                d.lookAt(e, t, r, ConchQuaternion._tempMatrix3x3),
                ConchQuaternion.rotationMatrix(ConchQuaternion._tempMatrix3x3, n);
            }
        }, {
            key: "invert",
            value: function(e, t) {
                var n = e.elements
                  , i = t.elements
                  , a = e.lengthSquared();
                r.isZero(a) || (a = 1 / a,
                i[0] = -n[0] * a,
                i[1] = -n[1] * a,
                i[2] = -n[2] * a,
                i[3] = n[3] * a);
            }
        }, {
            key: "rotationMatrix",
            value: function(e, t) {
                var r, n, i = e.elements, a = i[0], o = i[1], s = i[2], l = i[3], u = i[4], c = i[5], h = i[6], _ = i[7], d = i[8], f = t.elements, m = a + u + d;
                m > 0 ? (r = Math.sqrt(m + 1),
                f[3] = .5 * r,
                r = .5 / r,
                f[0] = (c - _) * r,
                f[1] = (h - s) * r,
                f[2] = (o - l) * r) : a >= u && a >= d ? (n = .5 / (r = Math.sqrt(1 + a - u - d)),
                f[0] = .5 * r,
                f[1] = (o + l) * n,
                f[2] = (s + h) * n,
                f[3] = (c - _) * n) : u > d ? (n = .5 / (r = Math.sqrt(1 + u - a - d)),
                f[0] = (l + o) * n,
                f[1] = .5 * r,
                f[2] = (_ + c) * n,
                f[3] = (h - s) * n) : (n = .5 / (r = Math.sqrt(1 + d - a - u)),
                f[0] = (h + s) * n,
                f[1] = (_ + c) * n,
                f[2] = .5 * r,
                f[3] = (o - l) * n);
            }
        }]),
        ConchQuaternion;
    }();
    L.TEMPVector30 = new A(),
    L.TEMPVector31 = new A(),
    L.TEMPVector32 = new A(),
    L.TEMPVector33 = new A(),
    L.TEMPMatrix0 = new I(),
    L.TEMPMatrix1 = new I(),
    L._tempMatrix3x3 = new d(),
    L.DEFAULT = new L(),
    L.NAN = new L(NaN,NaN,NaN,NaN);
    var P = function() {
        function AnimatorState() {
            _classCallCheck(this, AnimatorState),
            this._referenceCount = 0,
            this._clip = null,
            this._nodeOwners = [],
            this._currentFrameIndices = null,
            this._realtimeDatas = [],
            this._scripts = null,
            this.speed = 1,
            this.clipStart = 0,
            this.clipEnd = 1;
        }
        return _createClass(AnimatorState, [{
            key: "_getReferenceCount",
            value: function() {
                return this._referenceCount;
            }
        }, {
            key: "_addReference",
            value: function() {
                var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 1;
                this._clip && this._clip._addReference(e),
                this._referenceCount += e;
            }
        }, {
            key: "_removeReference",
            value: function() {
                var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 1;
                this._clip && this._clip._removeReference(e),
                this._referenceCount -= e;
            }
        }, {
            key: "_clearReference",
            value: function() {
                this._removeReference(-this._referenceCount);
            }
        }, {
            key: "_resetFrameIndices",
            value: function() {
                for (var e = 0, t = this._currentFrameIndices.length; e < t; e++)
                    this._currentFrameIndices[e] = -1;
            }
        }, {
            key: "addScript",
            value: function(e) {
                var t = new e();
                return this._scripts = this._scripts || [],
                this._scripts.push(t),
                t;
            }
        }, {
            key: "getScript",
            value: function(e) {
                if (this._scripts)
                    for (var t = 0, r = this._scripts.length; t < r; t++) {
                        var n = this._scripts[t];
                        if (n instanceof e)
                            return n;
                    }
                return null;
            }
        }, {
            key: "getScripts",
            value: function(e) {
                var t;
                if (this._scripts)
                    for (var r = 0, n = this._scripts.length; r < n; r++) {
                        var i = this._scripts[r];
                        i instanceof e && (t = t || []).push(i);
                    }
                return t;
            }
        }, {
            key: "cloneTo",
            value: function(e) {
                var t = e;
                t.name = this.name,
                t.speed = this.speed,
                t.clipStart = this.clipStart,
                t.clipEnd = this.clipEnd,
                t.clip = this._clip;
            }
        }, {
            key: "clone",
            value: function() {
                var e = new AnimatorState();
                return this.cloneTo(e),
                e;
            }
        }, {
            key: "clip",
            get: function() {
                return this._clip;
            },
            set: function(e) {
                if (this._clip !== e) {
                    if (this._clip && this._referenceCount > 0 && this._clip._removeReference(this._referenceCount),
                    e) {
                        var r = this._realtimeDatas
                          , n = e._nodes
                          , i = n.count;
                        this._currentFrameIndices = new Int16Array(i),
                        this._resetFrameIndices(),
                        this._referenceCount > 0 && e._addReference(this._referenceCount),
                        this._realtimeDatas.length = i;
                        for (var a = 0; a < i; a++)
                            switch (n.getNodeByIndex(a).type) {
                            case 0:
                                break;
                            case 1:
                            case 3:
                            case 4:
                                r[a] = t.Render.supportWebGLPlusAnimation ? new A() : new o();
                                break;
                            case 2:
                                r[a] = t.Render.supportWebGLPlusAnimation ? new L() : new f();
                                break;
                            default:
                                throw "AnimationClipParser04:unknown type.";
                            }
                    }
                    this._clip = e;
                }
            }
        }]),
        AnimatorState;
    }()
      , O = function() {
        function KeyframeNodeOwner() {
            _classCallCheck(this, KeyframeNodeOwner),
            this.indexInList = -1,
            this.referenceCount = 0,
            this.updateMark = -1,
            this.type = -1,
            this.fullPath = null,
            this.propertyOwner = null,
            this.property = null,
            this.defaultValue = null,
            this.value = null,
            this.crossFixedValue = null;
        }
        return _createClass(KeyframeNodeOwner, [{
            key: "saveCrossFixedValue",
            value: function() {
                if (this.propertyOwner)
                    switch (this.type) {
                    case 0:
                        this.crossFixedValue = this.value;
                        break;
                    case 1:
                    case 3:
                    case 4:
                    case 2:
                        this.value.cloneTo(this.crossFixedValue);
                        break;
                    default:
                        throw "Animator:unknown type.";
                    }
            }
        }]),
        KeyframeNodeOwner;
    }()
      , N = function(e) {
        function Animator() {
            var e;
            return _classCallCheck(this, Animator),
            (e = _possibleConstructorReturn(this, _getPrototypeOf(Animator).call(this)))._keyframeNodeOwners = [],
            e._linkAvatarSpritesData = {},
            e._linkAvatarSprites = [],
            e._renderableSprites = [],
            e.cullingMode = Animator.CULLINGMODE_CULLCOMPLETELY,
            e._controllerLayers = [],
            e._linkSprites = {},
            e._speed = 1,
            e._keyframeNodeOwnerMap = {},
            e._updateMark = 0,
            e;
        }
        return _inherits(Animator, t.Component),
        _createClass(Animator, [{
            key: "_linkToSprites",
            value: function(e) {
                for (var t in e) {
                    for (var r = this.owner, n = e[t], i = 0, a = n.length; i < a; i++) {
                        var o = n[i];
                        if ("" === o)
                            break;
                        if (!(r = r.getChildByName(o)))
                            break;
                    }
                    r && this.linkSprite3DToAvatarNode(t, r);
                }
            }
        }, {
            key: "_addKeyframeNodeOwner",
            value: function(e, t, r) {
                var n = t._indexInList
                  , i = t.fullPath
                  , a = this._keyframeNodeOwnerMap[i];
                if (a)
                    a.referenceCount++,
                    e[n] = a;
                else {
                    for (var o = r, s = 0, l = t.propertyCount; s < l && (o = o[t.getPropertyByIndex(s)]); s++)
                        ;
                    (a = this._keyframeNodeOwnerMap[i] = new O()).fullPath = i,
                    a.indexInList = this._keyframeNodeOwners.length,
                    a.referenceCount = 1,
                    a.propertyOwner = r;
                    var u = t.propertyCount
                      , c = [];
                    for (s = 0; s < u; s++)
                        c[s] = t.getPropertyByIndex(s);
                    if (a.property = c,
                    a.type = t.type,
                    o)
                        if (0 === t.type)
                            a.defaultValue = o;
                        else {
                            var h = new o.constructor();
                            o.cloneTo(h),
                            a.defaultValue = h,
                            a.value = new o.constructor(),
                            a.crossFixedValue = new o.constructor();
                        }
                    this._keyframeNodeOwners.push(a),
                    e[n] = a;
                }
            }
        }, {
            key: "_removeKeyframeNodeOwner",
            value: function(e, t) {
                var r = t.fullPath
                  , n = this._keyframeNodeOwnerMap[r];
                n && (n.referenceCount--,
                0 === n.referenceCount && (delete this._keyframeNodeOwnerMap[r],
                this._keyframeNodeOwners.splice(this._keyframeNodeOwners.indexOf(n), 1)),
                e[t._indexInList] = null);
            }
        }, {
            key: "_getOwnersByClip",
            value: function(e) {
                var t = e._clip._nodes
                  , r = t.count
                  , n = e._nodeOwners;
                n.length = r;
                for (var i = 0; i < r; i++) {
                    for (var a = t.getNodeByIndex(i), o = this._avatar ? this._avatarNodeMap[this._avatar._rootNode.name] : this.owner, s = 0, l = a.ownerPathCount; s < l; s++) {
                        var u = a.getOwnerPathByIndex(s);
                        if ("" === u)
                            break;
                        if (!(o = o.getChildByName(u)))
                            break;
                    }
                    if (o) {
                        var c = a.propertyOwner;
                        c && (o = o[c]),
                        o && this._addKeyframeNodeOwner(n, a, o);
                    }
                }
            }
        }, {
            key: "_updatePlayer",
            value: function(e, t, r, n) {
                var i = e._clip._duration * (e.clipEnd - e.clipStart)
                  , a = t._elapsedTime
                  , o = a + r;
                t._lastElapsedTime = a,
                t._elapsedTime = o;
                var s = o / i;
                t._normalizedTime = s;
                var l = s % 1;
                t._normalizedPlayTime = l < 0 ? l + 1 : l,
                t._duration = i;
                var u = e._scripts;
                if (!n && o >= i) {
                    if (t._finish = !0,
                    t._elapsedTime = i,
                    t._normalizedPlayTime = 1,
                    u)
                        for (var c = 0, h = u.length; c < h; c++)
                            u[c].onStateExit();
                } else if (u)
                    for (c = 0,
                    h = u.length; c < h; c++)
                        u[c].onStateUpdate();
            }
        }, {
            key: "_eventScript",
            value: function(e, t, r, n, i) {
                if (i)
                    for (var a = t.length; r < a; r++) {
                        var o = t[r];
                        if (!(o.time <= n))
                            break;
                        for (var s = 0, l = e.length; s < l; s++) {
                            var u = e[s]
                              , c = u[o.eventName];
                            c && c.apply(u, o.params);
                        }
                    }
                else
                    for (; r >= 0 && (o = t[r]).time >= n; r--)
                        for (s = 0,
                        l = e.length; s < l; s++)
                            (c = (u = e[s])[o.eventName]) && c.apply(u, o.params);
                return r;
            }
        }, {
            key: "_updateEventScript",
            value: function(e, t) {
                var r = this.owner._scripts;
                if (r) {
                    var n = e._clip
                      , i = n._animationEvents
                      , a = n._duration
                      , o = t._elapsedTime
                      , s = o % a
                      , l = Math.abs(Math.floor(o / a) - Math.floor(t._lastElapsedTime / a))
                      , u = t._elapsedTime >= t._lastElapsedTime;
                    if (t._lastIsFront !== u && (u ? t._playEventIndex++ : t._playEventIndex--,
                    t._lastIsFront = u),
                    u) {
                        t._playEventIndex = this._eventScript(r, i, t._playEventIndex, l > 0 ? a : s, !0);
                        for (var c = 0, h = l - 1; c < h; c++)
                            this._eventScript(r, i, 0, a, !0);
                        l > 0 && s > 0 && (t._playEventIndex = this._eventScript(r, i, 0, s, !0));
                    } else {
                        t._playEventIndex = this._eventScript(r, i, t._playEventIndex, l > 0 ? 0 : s, !1);
                        var _ = i.length - 1;
                        for (c = 0,
                        h = l - 1; c < h; c++)
                            this._eventScript(r, i, _, 0, !1);
                        l > 0 && s > 0 && (t._playEventIndex = this._eventScript(r, i, _, s, !1));
                    }
                }
            }
        }, {
            key: "_updateClipDatas",
            value: function(e, t, r, n) {
                var i = e._clip
                  , a = i._duration
                  , o = e.clipStart * a + r._normalizedPlayTime * r._duration
                  , s = e._currentFrameIndices
                  , l = r._elapsedTime > r._lastElapsedTime;
                i._evaluateClipDatasRealTime(i._nodes, o, s, t, l, e._realtimeDatas);
            }
        }, {
            key: "_applyFloat",
            value: function(e, t, r, n, i, a, o) {
                if (r.updateMark === this._updateMark)
                    if (n)
                        e[t] += i * o;
                    else {
                        var s = e[t];
                        e[t] = s + i * (o - s);
                    }
                else if (a)
                    e[t] = n ? r.defaultValue + o : o;
                else if (n)
                    e[t] = r.defaultValue + i * o;
                else {
                    var l = r.defaultValue;
                    e[t] = l + i * (o - l);
                }
            }
        }, {
            key: "_applyPositionAndRotationEuler",
            value: function(e, t, r, n, i, a) {
                if (e.updateMark === this._updateMark)
                    if (t)
                        a.x += r * i.x,
                        a.y += r * i.y,
                        a.z += r * i.z;
                    else {
                        var o = a.x
                          , s = a.y
                          , l = a.z;
                        a.x = o + r * (i.x - o),
                        a.y = s + r * (i.y - s),
                        a.z = l + r * (i.z - l);
                    }
                else if (n)
                    if (t) {
                        var u = e.defaultValue;
                        a.x = u.x + i.x,
                        a.y = u.y + i.y,
                        a.z = u.z + i.z;
                    } else
                        a.x = i.x,
                        a.y = i.y,
                        a.z = i.z;
                else if (u = e.defaultValue,
                t)
                    a.x = u.x + r * i.x,
                    a.y = u.y + r * i.y,
                    a.z = u.z + r * i.z;
                else {
                    var c = u.x
                      , h = u.y
                      , _ = u.z;
                    a.x = c + r * (i.x - c),
                    a.y = h + r * (i.y - h),
                    a.z = _ + r * (i.z - _);
                }
            }
        }, {
            key: "_applyRotation",
            value: function(e, t, r, n, i, a) {
                if (e.updateMark === this._updateMark)
                    if (t) {
                        var o = Animator._tempQuaternion1;
                        R.quaternionWeight(i, r, o),
                        o.normalize(o),
                        f.multiply(a, o, a);
                    } else
                        f.lerp(a, i, r, a);
                else if (n)
                    if (t) {
                        var s = e.defaultValue;
                        f.multiply(s, i, a);
                    } else
                        a.x = i.x,
                        a.y = i.y,
                        a.z = i.z,
                        a.w = i.w;
                else
                    s = e.defaultValue,
                    t ? (o = Animator._tempQuaternion1,
                    R.quaternionWeight(i, r, o),
                    o.normalize(o),
                    f.multiply(s, o, a)) : f.lerp(s, i, r, a);
            }
        }, {
            key: "_applyScale",
            value: function(e, t, r, n, i, a) {
                if (e.updateMark === this._updateMark)
                    if (t) {
                        var o = Animator._tempVector31;
                        R.scaleWeight(i, r, o),
                        a.x = a.x * o.x,
                        a.y = a.y * o.y,
                        a.z = a.z * o.z;
                    } else
                        R.scaleBlend(a, i, r, a);
                else if (n)
                    if (t) {
                        var s = e.defaultValue;
                        a.x = s.x * i.x,
                        a.y = s.y * i.y,
                        a.z = s.z * i.z;
                    } else
                        a.x = i.x,
                        a.y = i.y,
                        a.z = i.z;
                else
                    s = e.defaultValue,
                    t ? (o = Animator._tempVector31,
                    R.scaleWeight(i, r, o),
                    a.x = s.x * o.x,
                    a.y = s.y * o.y,
                    a.z = s.z * o.z) : R.scaleBlend(s, i, r, a);
            }
        }, {
            key: "_applyCrossData",
            value: function(e, t, r, n, i, a, o) {
                var s = e.propertyOwner;
                if (s) {
                    switch (e.type) {
                    case 0:
                        for (var l = e.property, u = l.length - 1, c = 0; c < u && (s = s[l[c]]); c++)
                            ;
                        var h = i + o * (a - i);
                        e.value = h,
                        this._applyFloat(s, l[u], e, t, r, n, h);
                        break;
                    case 1:
                        var _ = s.localPosition
                          , d = e.value
                          , m = i.x
                          , p = i.y
                          , v = i.z;
                        d.x = m + o * (a.x - m),
                        d.y = p + o * (a.y - p),
                        d.z = v + o * (a.z - v),
                        this._applyPositionAndRotationEuler(e, t, r, n, d, _),
                        s.localPosition = _;
                        break;
                    case 2:
                        var T = s.localRotation
                          , E = e.value;
                        f.lerp(i, a, o, E),
                        this._applyRotation(e, t, r, n, E, T),
                        s.localRotation = T;
                        break;
                    case 3:
                        var y = s.localScale
                          , g = e.value;
                        R.scaleBlend(i, a, o, g),
                        this._applyScale(e, t, r, n, g, y),
                        s.localScale = y;
                        break;
                    case 4:
                        var S = s.localRotationEuler
                          , C = e.value;
                        m = i.x,
                        p = i.y,
                        v = i.z,
                        C.x = m + o * (a.x - m),
                        C.y = p + o * (a.y - p),
                        C.z = v + o * (a.z - v),
                        this._applyPositionAndRotationEuler(e, t, r, n, C, S),
                        s.localRotationEuler = S;
                    }
                    e.updateMark = this._updateMark;
                }
            }
        }, {
            key: "_setClipDatasToNode",
            value: function(e, t, r, n) {
                for (var i = e._realtimeDatas, a = e._clip._nodes, o = e._nodeOwners, s = 0, l = a.count; s < l; s++) {
                    var u = o[s];
                    if (u) {
                        var c = u.propertyOwner;
                        if (c) {
                            switch (u.type) {
                            case 0:
                                for (var h = u.property, _ = h.length - 1, d = 0; d < _ && (c = c[h[d]]); d++)
                                    ;
                                this._applyFloat(c, h[_], u, t, r, n, i[s]);
                                break;
                            case 1:
                                var f = c.localPosition;
                                this._applyPositionAndRotationEuler(u, t, r, n, i[s], f),
                                c.localPosition = f;
                                break;
                            case 2:
                                var m = c.localRotation;
                                this._applyRotation(u, t, r, n, i[s], m),
                                c.localRotation = m;
                                break;
                            case 3:
                                var p = c.localScale;
                                this._applyScale(u, t, r, n, i[s], p),
                                c.localScale = p;
                                break;
                            case 4:
                                var v = c.localRotationEuler;
                                this._applyPositionAndRotationEuler(u, t, r, n, i[s], v),
                                c.localRotationEuler = v;
                            }
                            u.updateMark = this._updateMark;
                        }
                    }
                }
            }
        }, {
            key: "_setCrossClipDatasToNode",
            value: function(e, t, r, n, i) {
                for (var a = e._crossNodesOwners, o = e._crossNodesOwnersCount, s = e.blendingMode !== D.BLENDINGMODE_OVERRIDE, l = e.defaultWeight, u = r._realtimeDatas, c = e._destCrossClipNodeIndices, h = r._nodeOwners, _ = t._realtimeDatas, d = e._srcCrossClipNodeIndices, f = t._nodeOwners, m = 0; m < o; m++) {
                    var p = a[m];
                    if (p) {
                        var v = d[m]
                          , T = c[m]
                          , E = -1 !== v ? _[v] : h[T].defaultValue
                          , y = -1 !== T ? u[T] : f[v].defaultValue;
                        this._applyCrossData(p, s, l, i, E, y, n);
                    }
                }
            }
        }, {
            key: "_setFixedCrossClipDatasToNode",
            value: function(e, t, r, n) {
                for (var i = e._crossNodesOwners, a = e._crossNodesOwnersCount, o = e.blendingMode !== D.BLENDINGMODE_OVERRIDE, s = e.defaultWeight, l = t._realtimeDatas, u = e._destCrossClipNodeIndices, c = 0; c < a; c++) {
                    var h = i[c];
                    if (h) {
                        var _ = u[c]
                          , d = h.crossFixedValue
                          , f = -1 !== _ ? l[_] : h.defaultValue;
                        this._applyCrossData(h, o, s, n, d, f, r);
                    }
                }
            }
        }, {
            key: "_revertDefaultKeyframeNodes",
            value: function(e) {
                for (var t = e._nodeOwners, r = 0, n = t.length; r < n; r++) {
                    var i = t[r];
                    if (i) {
                        var a = i.propertyOwner;
                        if (a)
                            switch (i.type) {
                            case 0:
                                for (var o = i.property, s = o.length - 1, l = 0; l < s && (a = a[o[l]]); l++)
                                    ;
                                a[o[s]] = i.defaultValue;
                                break;
                            case 1:
                                var u = a.localPosition
                                  , c = i.defaultValue;
                                u.x = c.x,
                                u.y = c.y,
                                u.z = c.z,
                                a.localPosition = u;
                                break;
                            case 2:
                                var h = a.localRotation
                                  , _ = i.defaultValue;
                                h.x = _.x,
                                h.y = _.y,
                                h.z = _.z,
                                h.w = _.w,
                                a.localRotation = h;
                                break;
                            case 3:
                                var d = a.localScale;
                                c = i.defaultValue,
                                d.x = c.x,
                                d.y = c.y,
                                d.z = c.z,
                                a.localScale = d;
                                break;
                            case 4:
                                var f = a.localRotationEuler;
                                c = i.defaultValue,
                                f.x = c.x,
                                f.y = c.y,
                                f.z = c.z,
                                a.localRotationEuler = f;
                                break;
                            default:
                                throw "Animator:unknown type.";
                            }
                    }
                }
            }
        }, {
            key: "_onAdded",
            value: function() {
                var e = this.owner._parent;
                this.owner._setHierarchyAnimator(this, e ? e._hierarchyAnimator : null),
                this.owner._changeAnimatorToLinkSprite3DNoAvatar(this, !0, []);
            }
        }, {
            key: "_onDestroy",
            value: function() {
                for (var e = 0, t = this._controllerLayers.length; e < t; e++)
                    this._controllerLayers[e]._removeReference();
                var r = this.owner._parent;
                this.owner._clearHierarchyAnimator(this, r ? r._hierarchyAnimator : null);
            }
        }, {
            key: "_onEnable",
            value: function() {
                this.owner._scene._animatorPool.add(this);
                for (var e = 0, t = this._controllerLayers.length; e < t; e++) {
                    if (this._controllerLayers[e].playOnWake)
                        this.getDefaultState(e) && this.play(null, e, 0);
                }
            }
        }, {
            key: "_onDisable",
            value: function() {
                this.owner._scene._animatorPool.remove(this);
            }
        }, {
            key: "_handleSpriteOwnersBySprite",
            value: function(e, t, r) {
                for (var n = 0, i = this._controllerLayers.length; n < i; n++)
                    for (var a = this._controllerLayers[n]._states, o = 0, s = a.length; o < s; o++) {
                        var l = a[o]
                          , u = l._clip
                          , c = t.join("/")
                          , h = u._nodesMap[c];
                        if (h)
                            for (var _ = l._nodeOwners, d = 0, f = h.length; d < f; d++)
                                e ? this._addKeyframeNodeOwner(_, h[d], r) : this._removeKeyframeNodeOwner(_, h[d]);
                    }
            }
        }, {
            key: "_parse",
            value: function(e) {
                var r = e.avatar;
                if (r) {
                    this.avatar = t.Loader.getRes(r.path);
                    var n = r.linkSprites;
                    this._linkSprites = n,
                    this._linkToSprites(n);
                }
                e.clipPaths;
                for (var i = e.playOnWake, a = e.layers, o = 0; o < a.length; o++) {
                    var s = a[o]
                      , l = new D(s.name);
                    l.defaultWeight = 0 === o ? 1 : s.weight;
                    var u = s.blendingMode;
                    u && (l.blendingMode = u),
                    this.addControllerLayer(l);
                    for (var c = s.states, h = 0, _ = c.length; h < _; h++) {
                        var d = c[h]
                          , f = d.clipPath;
                        if (f) {
                            var m, p = d.name;
                            if (m = t.Loader.getRes(f)) {
                                var v = new P();
                                v.name = p,
                                v.clip = m,
                                l.addState(v),
                                0 === h && (this.getControllerLayer(o).defaultState = v);
                            }
                        }
                    }
                    void 0 !== i && (l.playOnWake = i);
                }
                var T = e.cullingMode;
                void 0 !== T && (this.cullingMode = T);
            }
        }, {
            key: "_update",
            value: function() {
                var e = this.owner._scene.timer
                  , r = e._delta / 1e3;
                if (0 !== this._speed && 0 !== r) {
                    var n;
                    if (this.cullingMode === Animator.CULLINGMODE_CULLCOMPLETELY) {
                        n = !1;
                        for (var i = 0, a = this._renderableSprites.length; i < a; i++)
                            if (this._renderableSprites[i]._render.isRender) {
                                n = !0;
                                break;
                            }
                    } else
                        n = !0;
                    this._updateMark++;
                    var o = e.scale;
                    for (i = 0,
                    a = this._controllerLayers.length; i < a; i++) {
                        var s = this._controllerLayers[i]
                          , l = s._playStateInfo
                          , u = s._crossPlayStateInfo;
                        switch (f = s.blendingMode !== D.BLENDINGMODE_OVERRIDE,
                        s._playType) {
                        case 0:
                            var c = l._currentState
                              , h = c._clip
                              , _ = this._speed * c.speed
                              , d = l._finish;
                            if (d || this._updatePlayer(c, l, r * _, h.islooping),
                            n) {
                                var f = s.blendingMode !== D.BLENDINGMODE_OVERRIDE;
                                this._updateClipDatas(c, f, l, o * _),
                                this._setClipDatasToNode(c, f, s.defaultWeight, 0 === i),
                                d || this._updateEventScript(c, l);
                            }
                            break;
                        case 1:
                            h = (c = l._currentState)._clip;
                            var m = s._crossPlayState
                              , p = m._clip
                              , v = s._crossDuration
                              , T = u._startPlayTime
                              , E = p._duration - T
                              , y = v > E ? E / v : 1
                              , g = this._speed * m.speed;
                            this._updatePlayer(m, u, r * y * g, p.islooping);
                            var S = (u._elapsedTime - T) / y / v;
                            S >= 1 ? n && (this._updateClipDatas(m, f, u, o * g),
                            this._setClipDatasToNode(m, f, s.defaultWeight, 0 === i),
                            s._playType = 0,
                            l._currentState = m,
                            u._cloneTo(l)) : (l._finish || (_ = this._speed * c.speed,
                            this._updatePlayer(c, l, r * _, h.islooping),
                            n && this._updateClipDatas(c, f, l, o * _)),
                            n && (this._updateClipDatas(m, f, u, o * y * g),
                            this._setCrossClipDatasToNode(s, c, m, S, 0 === i))),
                            n && (this._updateEventScript(c, l),
                            this._updateEventScript(m, u));
                            break;
                        case 2:
                            p = (m = s._crossPlayState)._clip,
                            v = s._crossDuration,
                            T = u._startPlayTime,
                            y = v > (E = p._duration - T) ? E / v : 1,
                            g = this._speed * m.speed,
                            this._updatePlayer(m, u, r * y * g, p.islooping),
                            n && ((S = (u._elapsedTime - T) / y / v) >= 1 ? (this._updateClipDatas(m, f, u, o * g),
                            this._setClipDatasToNode(m, f, 1, 0 === i),
                            s._playType = 0,
                            l._currentState = m,
                            u._cloneTo(l)) : (this._updateClipDatas(m, f, u, o * y * g),
                            this._setFixedCrossClipDatasToNode(s, m, S, 0 === i)),
                            this._updateEventScript(m, u));
                        }
                    }
                    n && this._avatar && (t.Render.supportWebGLPlusAnimation && this._updateAnimationNodeWorldMatix(this._animationNodeLocalPositions, this._animationNodeLocalRotations, this._animationNodeLocalScales, this._animationNodeWorldMatrixs, this._animationNodeParentIndices),
                    this._updateAvatarNodesToSprite());
                }
            }
        }, {
            key: "_cloneTo",
            value: function(e) {
                var t = e;
                t.avatar = this.avatar,
                t.cullingMode = this.cullingMode;
                for (var r = 0, n = this._controllerLayers.length; r < n; r++) {
                    var i = this._controllerLayers[r];
                    t.addControllerLayer(i.clone());
                    for (var a = i._states, o = 0, s = a.length; o < s; o++) {
                        var l = a[o].clone()
                          , u = t.getControllerLayer(r);
                        u.addState(l),
                        0 == o && (u.defaultState = l);
                    }
                }
                t._linkSprites = this._linkSprites,
                t._linkToSprites(this._linkSprites);
            }
        }, {
            key: "getDefaultState",
            value: function() {
                var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0;
                return this._controllerLayers[e].defaultState;
            }
        }, {
            key: "addState",
            value: function(e) {
                var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
                this._controllerLayers[t].addState(e),
                console.warn("Animator:this function is discard,please use animatorControllerLayer.addState() instead.");
            }
        }, {
            key: "removeState",
            value: function(e) {
                var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
                this._controllerLayers[t].removeState(e),
                console.warn("Animator:this function is discard,please use animatorControllerLayer.removeState() instead.");
            }
        }, {
            key: "addControllerLayer",
            value: function(e) {
                this._controllerLayers.push(e),
                e._animator = this,
                e._addReference();
                for (var t = e._states, r = 0, n = t.length; r < n; r++)
                    this._getOwnersByClip(t[r]);
            }
        }, {
            key: "getControllerLayer",
            value: function() {
                var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0;
                return this._controllerLayers[e];
            }
        }, {
            key: "play",
            value: function() {
                var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null
                  , t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0
                  , r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : Number.NEGATIVE_INFINITY
                  , n = this._controllerLayers[t];
                if (n) {
                    var i = n.defaultState;
                    if (!e && !i)
                        throw new Error("Animator:must have default clip value,please set clip property.");
                    var a = n._playStateInfo
                      , o = a._currentState
                      , s = e ? n._statesMap[e] : i
                      , l = s._clip._duration;
                    o !== s ? (r !== Number.NEGATIVE_INFINITY ? a._resetPlayState(l * r) : a._resetPlayState(0),
                    null !== o && o !== s && this._revertDefaultKeyframeNodes(o),
                    n._playType = 0,
                    a._currentState = s) : r !== Number.NEGATIVE_INFINITY && (a._resetPlayState(l * r),
                    n._playType = 0);
                    var u = s._scripts;
                    if (u)
                        for (var c = 0, h = u.length; c < h; c++)
                            u[c].onStateEnter();
                } else
                    console.warn("Invalid layerIndex " + t + ".");
            }
        }, {
            key: "crossFade",
            value: function(e, t) {
                var r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0
                  , n = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : Number.NEGATIVE_INFINITY
                  , i = this._controllerLayers[r];
                if (i) {
                    var a = i._statesMap[e];
                    if (a) {
                        var o = i._playType;
                        if (-1 === o)
                            return void this.play(e, r, n);
                        var s = i._crossPlayStateInfo
                          , l = i._crossNodesOwners
                          , u = i._crossNodesOwnersIndicesMap
                          , c = i._playStateInfo._currentState
                          , h = a._nodeOwners
                          , _ = i._destCrossClipNodeIndices
                          , d = a._clip
                          , f = d._nodes
                          , m = d._nodesDic;
                        switch (o) {
                        case 0:
                            var p = c._nodeOwners
                              , v = i._srcCrossClipNodeIndices
                              , T = c._clip
                              , E = T._nodes
                              , y = T._nodesDic;
                            i._playType = 1;
                            for (var g = ++i._crossMark, S = i._crossNodesOwnersCount = 0, R = 0, C = E.count; R < C; R++) {
                                var M = E.getNodeByIndex(R)
                                  , D = M._indexInList
                                  , x = p[D];
                                if (x) {
                                    var A = M.fullPath;
                                    v[S] = D;
                                    var I = m[A];
                                    _[S] = I ? I._indexInList : -1,
                                    u[A] = g,
                                    l[S] = x,
                                    S++;
                                }
                            }
                            for (R = 0,
                            C = f.count; R < C; R++) {
                                var L = (I = f.getNodeByIndex(R))._indexInList
                                  , P = h[L];
                                if (P) {
                                    var O = I.fullPath;
                                    y[O] || (v[S] = -1,
                                    _[S] = L,
                                    u[O] = g,
                                    l[S] = P,
                                    S++);
                                }
                            }
                            break;
                        case 1:
                        case 2:
                            for (i._playType = 2,
                            R = 0,
                            C = l.length; R < C; R++) {
                                var N = l[R];
                                N.saveCrossFixedValue(),
                                I = m[N.fullPath],
                                _[R] = I ? I._indexInList : -1;
                            }
                            for (S = i._crossNodesOwnersCount,
                            g = i._crossMark,
                            R = 0,
                            C = f.count; R < C; R++)
                                (P = h[L = (I = f.getNodeByIndex(R))._indexInList]) && u[O = I.fullPath] !== g && (_[S] = L,
                                u[O] = g,
                                N = h[L],
                                l[S] = N,
                                N.saveCrossFixedValue(),
                                S++);
                        }
                        i._crossNodesOwnersCount = S,
                        i._crossPlayState = a,
                        i._crossDuration = c._clip._duration * t,
                        n !== Number.NEGATIVE_INFINITY ? s._resetPlayState(d._duration * n) : s._resetPlayState(0);
                        var b = a._scripts;
                        if (b)
                            for (R = 0,
                            C = b.length; R < C; R++)
                                b[R].onStateEnter();
                    } else
                        console.warn("Invalid name " + r + ".");
                } else
                    console.warn("Invalid layerIndex " + r + ".");
            }
        }, {
            key: "getCurrentAnimatorPlayState",
            value: function() {
                var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0;
                return this._controllerLayers[e]._playStateInfo;
            }
        }, {
            key: "_isLinkSpriteToAnimationNodeData",
            value: function(e, t, r) {
                var n = this._linkAvatarSpritesData[t];
                if (r)
                    n || (this._linkAvatarSpritesData[t] = n = []),
                    n.push(e);
                else {
                    var i = n.indexOf(e);
                    n.splice(i, 1);
                }
            }
        }, {
            key: "_getAvatarOwnersAndInitDatasAsync",
            value: function() {
                for (var e = 0, t = this._controllerLayers.length; e < t; e++)
                    for (var r = this._controllerLayers[e]._states, n = 0, i = r.length; n < i; n++)
                        this._getOwnersByClip(r[n]);
                for (var a in this._avatar._cloneDatasToAnimator(this),
                this._linkAvatarSpritesData) {
                    var o = this._linkAvatarSpritesData[a];
                    if (o)
                        for (var s = 0, l = o.length; s < l; s++)
                            this._isLinkSpriteToAnimationNode(o[s], a, !0);
                }
            }
        }, {
            key: "_isLinkSpriteToAnimationNode",
            value: function(e, t, r) {
                if (this._avatar) {
                    var n = this._avatarNodeMap[t];
                    if (n)
                        if (r) {
                            e._transform._dummy = n.transform,
                            this._linkAvatarSprites.push(e);
                            var i = n.transform
                              , a = e.transform;
                            if (!a.owner.isStatic && i) {
                                var o = a.worldMatrix
                                  , s = this.owner._transform._parent;
                                if (s)
                                    R.matrix4x4MultiplyMFM(s.worldMatrix, i.getWorldMatrix(), o);
                                else
                                    for (var l = o.elements, u = i.getWorldMatrix(), c = 0; c < 16; c++)
                                        l[c] = u[c];
                                a.worldMatrix = o;
                            }
                        } else
                            e._transform._dummy = null,
                            this._linkAvatarSprites.splice(this._linkAvatarSprites.indexOf(e), 1);
                }
            }
        }, {
            key: "_updateAvatarNodesToSprite",
            value: function() {
                for (var e = 0, t = this._linkAvatarSprites.length; e < t; e++) {
                    var r = this._linkAvatarSprites[e]
                      , n = r.transform._dummy
                      , i = r.transform;
                    if (!i.owner.isStatic && n) {
                        var a = i.worldMatrix
                          , o = this.owner._transform;
                        R.matrix4x4MultiplyMFM(o.worldMatrix, n.getWorldMatrix(), a),
                        i.worldMatrix = a;
                    }
                }
            }
        }, {
            key: "linkSprite3DToAvatarNode",
            value: function(e, t) {
                return this._isLinkSpriteToAnimationNodeData(t, e, !0),
                this._isLinkSpriteToAnimationNode(t, e, !0),
                !0;
            }
        }, {
            key: "unLinkSprite3DToAvatarNode",
            value: function(e) {
                var t = e.transform._dummy;
                if (t) {
                    var r = t._owner.name;
                    return this._isLinkSpriteToAnimationNodeData(e, r, !1),
                    this._isLinkSpriteToAnimationNode(e, r, !1),
                    !0;
                }
                return !1;
            }
        }, {
            key: "_updateAnimationNodeWorldMatix",
            value: function(e, r, n, i, a) {
                t.LayaGL.instance.updateAnimationNodeWorldMatix(e, r, n, a, i);
            }
        }, {
            key: "speed",
            get: function() {
                return this._speed;
            },
            set: function(e) {
                this._speed = e;
            }
        }, {
            key: "avatar",
            get: function() {
                return this._avatar;
            },
            set: function(e) {
                if (this._avatar !== e)
                    if (this._avatar = e,
                    e)
                        this._getAvatarOwnersAndInitDatasAsync(),
                        this.owner._changeHierarchyAnimatorAvatar(this, e);
                    else {
                        var t = this.owner._parent;
                        this.owner._changeHierarchyAnimatorAvatar(this, t ? t._hierarchyAnimator._avatar : null);
                    }
            }
        }], [{
            key: "_update",
            value: function(e) {
                for (var t = e._animatorPool, r = t.elements, n = 0, i = t.length; n < i; n++) {
                    var a = r[n];
                    a && a.enabled && a._update();
                }
            }
        }]),
        Animator;
    }();
    N._tempVector30 = new o(),
    N._tempVector31 = new o(),
    N._tempQuaternion0 = new f(),
    N._tempQuaternion1 = new f(),
    N.CULLINGMODE_ALWAYSANIMATE = 0,
    N.CULLINGMODE_CULLCOMPLETELY = 2;
    var b = function PostProcessRenderContext() {
        _classCallCheck(this, PostProcessRenderContext),
        this.source = null,
        this.destination = null,
        this.camera = null,
        this.compositeShaderData = null,
        this.command = null,
        this.deferredReleaseTextures = [];
    }
      , k = function RenderContext3D() {
        _classCallCheck(this, RenderContext3D),
        this.invertY = !1;
    };
    k._instance = new k();
    var V = function(e) {
        function RenderTexture(e, r) {
            var n, i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : t.RenderTextureFormat.R8G8B8, a = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : t.RenderTextureDepthFormat.DEPTH_16;
            return _classCallCheck(this, RenderTexture),
            (n = _possibleConstructorReturn(this, _getPrototypeOf(RenderTexture).call(this, i, !1)))._inPool = !1,
            n._isCameraTarget = !1,
            n._glTextureType = t.LayaGL.instance.TEXTURE_2D,
            n._width = e,
            n._height = r,
            n._depthStencilFormat = a,
            n._create(e, r),
            n;
        }
        return _inherits(RenderTexture, t.BaseTexture),
        _createClass(RenderTexture, [{
            key: "_texImage2D",
            value: function(e, r, n, i) {
                switch (this._format) {
                case t.RenderTextureFormat.R8G8B8:
                    e.texImage2D(r, 0, e.RGB, n, i, 0, e.RGB, e.UNSIGNED_BYTE, null);
                    break;
                case t.RenderTextureFormat.R8G8B8A8:
                    e.texImage2D(r, 0, e.RGBA, n, i, 0, e.RGBA, e.UNSIGNED_BYTE, null);
                    break;
                case t.RenderTextureFormat.Alpha8:
                    e.texImage2D(r, 0, e.ALPHA, n, i, 0, e.ALPHA, e.UNSIGNED_BYTE, null);
                    break;
                case t.RenderTextureFormat.R16G16B16A16:
                    t.LayaGL.layaGPUInstance._isWebGL2 ? e.texImage2D(this._glTextureType, 0, e.RGBA16F, n, i, 0, e.RGBA, e.HALF_FLOAT, null) : e.texImage2D(this._glTextureType, 0, e.RGBA, n, i, 0, e.RGBA, t.LayaGL.layaGPUInstance._oesTextureHalfFloat.HALF_FLOAT_OES, null);
                }
            }
        }, {
            key: "_create",
            value: function(e, r) {
                var n = t.LayaGL.instance;
                if (this._frameBuffer = n.createFramebuffer(),
                t.WebGLContext.bindTexture(n, this._glTextureType, this._glTexture),
                this._texImage2D(n, this._glTextureType, e, r),
                this._setGPUMemory(e * r * 4),
                n.bindFramebuffer(n.FRAMEBUFFER, this._frameBuffer),
                n.framebufferTexture2D(n.FRAMEBUFFER, n.COLOR_ATTACHMENT0, n.TEXTURE_2D, this._glTexture, 0),
                this._depthStencilFormat !== t.RenderTextureDepthFormat.DEPTHSTENCIL_NONE)
                    switch (this._depthStencilBuffer = n.createRenderbuffer(),
                    n.bindRenderbuffer(n.RENDERBUFFER, this._depthStencilBuffer),
                    this._depthStencilFormat) {
                    case t.RenderTextureDepthFormat.DEPTH_16:
                        n.renderbufferStorage(n.RENDERBUFFER, n.DEPTH_COMPONENT16, e, r),
                        n.framebufferRenderbuffer(n.FRAMEBUFFER, n.DEPTH_ATTACHMENT, n.RENDERBUFFER, this._depthStencilBuffer);
                        break;
                    case t.RenderTextureDepthFormat.STENCIL_8:
                        n.renderbufferStorage(n.RENDERBUFFER, n.STENCIL_INDEX8, e, r),
                        n.framebufferRenderbuffer(n.FRAMEBUFFER, n.STENCIL_ATTACHMENT, n.RENDERBUFFER, this._depthStencilBuffer);
                        break;
                    case t.RenderTextureDepthFormat.DEPTHSTENCIL_16_8:
                        n.renderbufferStorage(n.RENDERBUFFER, n.DEPTH_STENCIL, e, r),
                        n.framebufferRenderbuffer(n.FRAMEBUFFER, n.DEPTH_STENCIL_ATTACHMENT, n.RENDERBUFFER, this._depthStencilBuffer);
                        break;
                    default:
                        throw "RenderTexture: unkonw depth format.";
                    }
                n.bindFramebuffer(n.FRAMEBUFFER, null),
                n.bindRenderbuffer(n.RENDERBUFFER, null),
                this._setWarpMode(n.TEXTURE_WRAP_S, this._wrapModeU),
                this._setWarpMode(n.TEXTURE_WRAP_T, this._wrapModeV),
                this._setFilterMode(this._filterMode),
                this._setAnisotropy(this._anisoLevel),
                this._readyed = !0,
                this._activeResource();
            }
        }, {
            key: "_start",
            value: function() {
                var e = t.LayaGL.instance;
                e.bindFramebuffer(e.FRAMEBUFFER, this._frameBuffer),
                RenderTexture._currentActive = this,
                this._isCameraTarget && (k._instance.invertY = !0),
                this._readyed = !1;
            }
        }, {
            key: "_end",
            value: function() {
                var e = t.LayaGL.instance;
                e.bindFramebuffer(e.FRAMEBUFFER, null),
                RenderTexture._currentActive = null,
                this._isCameraTarget && (k._instance.invertY = !1),
                this._readyed = !0;
            }
        }, {
            key: "getData",
            value: function(e, r, n, i, a) {
                if (t.Render.isConchApp && 2 == window.conchConfig.threadMode)
                    throw "native 2 thread mode use getDataAsync";
                var o = t.LayaGL.instance;
                return o.bindFramebuffer(o.FRAMEBUFFER, this._frameBuffer),
                o.checkFramebufferStatus(o.FRAMEBUFFER) === o.FRAMEBUFFER_COMPLETE ? (o.readPixels(e, r, n, i, o.RGBA, o.UNSIGNED_BYTE, a),
                o.bindFramebuffer(o.FRAMEBUFFER, null),
                a) : (o.bindFramebuffer(o.FRAMEBUFFER, null),
                null);
            }
        }, {
            key: "getDataAsync",
            value: function(e, r, n, i, a) {
                var o = t.LayaGL.instance;
                o.bindFramebuffer(o.FRAMEBUFFER, this._frameBuffer),
                o.readPixelsAsync(e, r, n, i, o.RGBA, o.UNSIGNED_BYTE, function(e) {
                    a(new Uint8Array(e));
                }),
                o.bindFramebuffer(o.FRAMEBUFFER, null);
            }
        }, {
            key: "_disposeResource",
            value: function() {
                if (this._frameBuffer) {
                    var e = t.LayaGL.instance;
                    e.deleteTexture(this._glTexture),
                    e.deleteFramebuffer(this._frameBuffer),
                    e.deleteRenderbuffer(this._depthStencilBuffer),
                    this._glTexture = null,
                    this._frameBuffer = null,
                    this._depthStencilBuffer = null,
                    this._setGPUMemory(0);
                }
            }
        }, {
            key: "depthStencilFormat",
            get: function() {
                return this._depthStencilFormat;
            }
        }, {
            key: "defaulteTexture",
            get: function() {
                return t.Texture2D.grayTexture;
            }
        }], [{
            key: "createFromPool",
            value: function(e, r) {
                for (var n, i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : t.RenderTextureFormat.R8G8B8, a = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : t.RenderTextureDepthFormat.DEPTH_16, o = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : t.FilterMode.Bilinear, s = 0, l = RenderTexture._pool.length; s < l; s++)
                    if ((n = RenderTexture._pool[s])._width == e && n._height == r && n._format == i && n._depthStencilFormat == a && n._filterMode == o) {
                        n._inPool = !1;
                        var u = RenderTexture._pool[l - 1];
                        return RenderTexture._pool[s] = u,
                        RenderTexture._pool.length -= 1,
                        n;
                    }
                return (n = new RenderTexture(e,r,i,a)).filterMode = o,
                n.lock = !0,
                n;
            }
        }, {
            key: "recoverToPool",
            value: function(e) {
                e._inPool || (RenderTexture._pool.push(e),
                e._inPool = !0);
            }
        }, {
            key: "currentActive",
            get: function() {
                return RenderTexture._currentActive;
            }
        }]),
        RenderTexture;
    }();
    V._pool = [];
    var B = function() {
        function DefineDatas() {
            _classCallCheck(this, DefineDatas),
            this._mask = [],
            this._length = 0;
        }
        return _createClass(DefineDatas, [{
            key: "_intersectionDefineDatas",
            value: function(e) {
                for (var t = e._mask, r = this._mask, n = this._length - 1; n >= 0; n--) {
                    var i = r[n] & t[n];
                    0 == i && n == this._length - 1 ? this._length-- : r[n] = i;
                }
            }
        }, {
            key: "add",
            value: function(e) {
                var t = e._index
                  , r = t + 1
                  , n = this._mask
                  , i = this._length;
                if (i < r) {
                    for (n.length < r && (n.length = r); i < t; i++)
                        n[i] = 0;
                    n[t] = e._value,
                    this._length = r;
                } else
                    r > this._length ? (n[t] = e._value,
                    this._length = r) : n[t] |= e._value;
            }
        }, {
            key: "remove",
            value: function(e) {
                var t = e._index
                  , r = this._mask
                  , n = this._length - 1;
                if (!(t > n)) {
                    var i = r[t] & ~e._value;
                    t == n && 0 === i ? this._length-- : r[t] = i;
                }
            }
        }, {
            key: "addDefineDatas",
            value: function(e) {
                var t = e._mask
                  , r = e._length
                  , n = this._mask
                  , i = n.length;
                if (i < r) {
                    n.length = r;
                    for (var a = 0; a < i; a++)
                        n[a] |= t[a];
                    for (; i < r; i++)
                        n[i] = t[i];
                    this._length = r;
                } else {
                    for (a = 0; a < r; a++)
                        n[a] |= t[a];
                    this._length = Math.max(this._length, r);
                }
            }
        }, {
            key: "removeDefineDatas",
            value: function(e) {
                for (var t = e._mask, r = this._mask, n = this._length - 1, i = e._length - 1; i >= 0; i--)
                    if (!(i > n)) {
                        var a = r[i] & ~t[i];
                        i == n && 0 === a ? (n--,
                        this._length--) : r[i] = a;
                    }
            }
        }, {
            key: "has",
            value: function(e) {
                var t = e._index;
                return !(t >= this._length) && 0 != (this._mask[t] & e._value);
            }
        }, {
            key: "clear",
            value: function() {
                this._length = 0;
            }
        }, {
            key: "cloneTo",
            value: function(e) {
                var t = e
                  , r = t._mask
                  , n = this._mask
                  , i = this._length;
                r.length = i;
                for (var a = 0; a < i; a++)
                    r[a] = n[a];
                t._length = i;
            }
        }, {
            key: "clone",
            value: function() {
                var e = new DefineDatas();
                return this.cloneTo(e),
                e;
            }
        }]),
        DefineDatas;
    }()
      , w = function ShaderDefine(e, t) {
        _classCallCheck(this, ShaderDefine),
        this._index = e,
        this._value = t;
    }
      , F = function() {
        function ShaderVariant(e, t, r, n) {
            _classCallCheck(this, ShaderVariant),
            this._subShaderIndex = 0,
            this._passIndex = 0,
            this.setValue(e, t, r, n);
        }
        return _createClass(ShaderVariant, [{
            key: "setValue",
            value: function(e, t, r, n) {
                if (!e)
                    throw "ShaderVariantInfo:Shader can't be null.";
                var i = e.getSubShaderAt(t);
                if (!i)
                    throw "ShaderVariantInfo:Shader don't have subShaderIndex of ".concat(t, ".");
                var a = i._passes[r];
                if (!a)
                    throw "ShaderVariantInfo:Shader don't have passIndex of ".concat(r, ".");
                for (var o = a._validDefine, s = 0, u = n.length; s < u; s++) {
                    var c = n[s];
                    if (!o.has(l.Shader3D.getDefineByName(c)))
                        throw "ShaderVariantInfo:Invalid defineName ".concat(c, " in ").concat(e._name, " subShaderIndex of ").concat(t, " passIndex of ").concat(r, ".");
                }
                this._shader = e,
                this._subShaderIndex = t,
                this._passIndex = r,
                this._defineNames = n;
            }
        }, {
            key: "equal",
            value: function(e) {
                if (this._shader !== e._shader || this._subShaderIndex !== e._subShaderIndex || this._passIndex !== e._passIndex)
                    return !1;
                var t = this._defineNames
                  , r = e._defineNames;
                if (t.length !== r.length)
                    return !1;
                for (var n = 0, i = this._defineNames.length; n < i; n++)
                    if (t[n] !== r[n])
                        return !1;
                return !0;
            }
        }, {
            key: "clone",
            value: function() {
                return new ShaderVariant(this._shader,this._subShaderIndex,this._passIndex,this._defineNames.slice());
            }
        }, {
            key: "shader",
            get: function() {
                return this._shader;
            }
        }, {
            key: "subShaderIndex",
            get: function() {
                return this._subShaderIndex;
            }
        }, {
            key: "passIndex",
            get: function() {
                return this._passIndex;
            }
        }, {
            key: "defineNames",
            get: function() {
                return this._defineNames;
            }
        }]),
        ShaderVariant;
    }()
      , U = function() {
        function ShaderVariantCollection() {
            _classCallCheck(this, ShaderVariantCollection),
            this._allCompiled = !1,
            this._variants = [];
        }
        return _createClass(ShaderVariantCollection, [{
            key: "add",
            value: function(e) {
                for (var t = 0, r = this._variants.length; t < r; t++)
                    if (this._variants[t].equal(e))
                        return !1;
                return this._variants.push(e.clone()),
                this._allCompiled = !1,
                !0;
            }
        }, {
            key: "remove",
            value: function(e) {
                for (var t = 0, r = this._variants.length; t < r; t++)
                    if (this._variants[t].equal(e))
                        return this._variants.splice(t, 1),
                        !0;
                return !1;
            }
        }, {
            key: "contatins",
            value: function(e) {
                for (var t = 0, r = this._variants.length; t < r; t++)
                    if (this._variants[t].equal(e))
                        return !0;
                return !1;
            }
        }, {
            key: "getByIndex",
            value: function(e) {
                return this._variants[e];
            }
        }, {
            key: "clear",
            value: function() {
                this._variants.length = 0;
            }
        }, {
            key: "compile",
            value: function() {
                if (!this._allCompiled) {
                    for (var e = this._variants, t = 0, r = e.length; t < r; t++) {
                        var n = e[t];
                        l.Shader3D.compileShaderByDefineNames(n._shader._name, n._subShaderIndex, n._passIndex, n._defineNames);
                    }
                    this._allCompiled = !0;
                }
            }
        }, {
            key: "allCompiled",
            get: function() {
                return this._allCompiled;
            }
        }, {
            key: "variantCount",
            get: function() {
                return this._variants.length;
            }
        }]),
        ShaderVariantCollection;
    }()
      , G = function() {
        function Shader3D(e, t, r, n) {
            _classCallCheck(this, Shader3D),
            this._attributeMap = null,
            this._uniformMap = null,
            this._enableInstancing = !1,
            this._subShaders = [],
            this._name = e,
            this._attributeMap = t,
            this._uniformMap = r,
            this._enableInstancing = n;
        }
        return _createClass(Shader3D, [{
            key: "addSubShader",
            value: function(e) {
                this._subShaders.push(e),
                e._owner = this;
            }
        }, {
            key: "getSubShaderAt",
            value: function(e) {
                return this._subShaders[e];
            }
        }, {
            key: "name",
            get: function() {
                return this._name;
            }
        }], [{
            key: "_getNamesByDefineData",
            value: function(e, t) {
                var r = Shader3D._maskMap
                  , n = e._mask;
                t.length = 0;
                for (var i = 0, a = e._length; i < a; i++)
                    for (var o = r[i], s = n[i], l = 0; l < 32; l++) {
                        var u = 1 << l;
                        if (s > 0 && u > s)
                            break;
                        s & u && t.push(o[u]);
                    }
            }
        }, {
            key: "getDefineByName",
            value: function(e) {
                var t = Shader3D._defineMap[e];
                if (!t) {
                    var r = Shader3D._maskMap
                      , n = Shader3D._defineCounter
                      , i = Math.floor(n / 32)
                      , a = 1 << n % 32;
                    t = new w(i,a),
                    Shader3D._defineMap[e] = t,
                    i == r.length && (r.length++,
                    r[i] = {}),
                    r[i][a] = e,
                    Shader3D._defineCounter++;
                }
                return t;
            }
        }, {
            key: "propertyNameToID",
            value: function(e) {
                if (null != Shader3D._propertyNameMap[e])
                    return Shader3D._propertyNameMap[e];
                var t = Shader3D._propertyNameCounter++;
                return Shader3D._propertyNameMap[e] = t,
                t;
            }
        }, {
            key: "addInclude",
            value: function(e, r) {
                r = r.replace(t.ShaderCompile._clearCR, ""),
                t.ShaderCompile.addInclude(e, r);
            }
        }, {
            key: "compileShaderByDefineNames",
            value: function(e, t, r, n) {
                var i = Shader3D.find(e);
                if (i) {
                    var a = i.getSubShaderAt(t);
                    if (a) {
                        var o = a._passes[r];
                        if (o) {
                            var l = Shader3D._compileDefineDatas;
                            l.clear();
                            for (var u = 0, c = n.length; u < c; u++)
                                l.add(Shader3D.getDefineByName(n[u]));
                            s._config._multiLighting || l.add(Shader3D.SHADERDEFINE_LEGACYSINGALLIGHTING),
                            o.withCompile(l);
                        } else
                            console.warn("Shader3D: unknown passIndex.");
                    } else
                        console.warn("Shader3D: unknown subShaderIndex.");
                } else
                    console.warn("Shader3D: unknown shader name.");
            }
        }, {
            key: "add",
            value: function(e) {
                var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null
                  , r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null
                  , n = arguments.length > 3 && void 0 !== arguments[3] && arguments[3];
                return Shader3D._preCompileShader[e] = new Shader3D(e,t,r,n);
            }
        }, {
            key: "find",
            value: function(e) {
                return Shader3D._preCompileShader[e];
            }
        }, {
            key: "compileShader",
            value: function(e, t, r) {
                var n = Shader3D.find(e);
                if (n) {
                    var i = n.getSubShaderAt(t);
                    if (i) {
                        var a = i._passes[r];
                        if (a) {
                            var o = Shader3D._compileDefineDatas
                              , l = o._mask;
                            l.length = 0;
                            for (var u = 0, c = arguments.length <= 3 ? 0 : arguments.length - 3; u < c; u++)
                                l.push(u + 3 < 3 || arguments.length <= u + 3 ? void 0 : arguments[u + 3]);
                            o._length = arguments.length <= 3 ? 0 : arguments.length - 3,
                            s._config._multiLighting || o.add(Shader3D.SHADERDEFINE_LEGACYSINGALLIGHTING),
                            a.withCompile(o);
                        } else
                            console.warn("Shader3D: unknown passIndex.");
                    } else
                        console.warn("Shader3D: unknown subShaderIndex.");
                } else
                    console.warn("Shader3D: unknown shader name.");
            }
        }]),
        Shader3D;
    }();
    G._compileDefineDatas = new B(),
    G.RENDER_STATE_CULL = 0,
    G.RENDER_STATE_BLEND = 1,
    G.RENDER_STATE_BLEND_SRC = 2,
    G.RENDER_STATE_BLEND_DST = 3,
    G.RENDER_STATE_BLEND_SRC_RGB = 4,
    G.RENDER_STATE_BLEND_DST_RGB = 5,
    G.RENDER_STATE_BLEND_SRC_ALPHA = 6,
    G.RENDER_STATE_BLEND_DST_ALPHA = 7,
    G.RENDER_STATE_BLEND_CONST_COLOR = 8,
    G.RENDER_STATE_BLEND_EQUATION = 9,
    G.RENDER_STATE_BLEND_EQUATION_RGB = 10,
    G.RENDER_STATE_BLEND_EQUATION_ALPHA = 11,
    G.RENDER_STATE_DEPTH_TEST = 12,
    G.RENDER_STATE_DEPTH_WRITE = 13,
    G.PERIOD_CUSTOM = 0,
    G.PERIOD_MATERIAL = 1,
    G.PERIOD_SPRITE = 2,
    G.PERIOD_CAMERA = 3,
    G.PERIOD_SCENE = 4,
    G._propertyNameCounter = 0,
    G._propertyNameMap = {},
    G._defineCounter = 0,
    G._defineMap = {},
    G._preCompileShader = {},
    G._maskMap = [],
    G.debugMode = !1,
    G.debugShaderVariantCollection = new U();
    var z = function() {
        function ShaderData() {
            var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null;
            _classCallCheck(this, ShaderData),
            this._ownerResource = null,
            this._data = null,
            this._defineDatas = new B(),
            this._runtimeCopyValues = [],
            this._ownerResource = e,
            this._initData();
        }
        return _createClass(ShaderData, [{
            key: "_initData",
            value: function() {
                this._data = new Object();
            }
        }, {
            key: "getData",
            value: function() {
                return this._data;
            }
        }, {
            key: "addDefine",
            value: function(e) {
                this._defineDatas.add(e);
            }
        }, {
            key: "removeDefine",
            value: function(e) {
                this._defineDatas.remove(e);
            }
        }, {
            key: "hasDefine",
            value: function(e) {
                return this._defineDatas.has(e);
            }
        }, {
            key: "clearDefine",
            value: function() {
                this._defineDatas.clear();
            }
        }, {
            key: "getBool",
            value: function(e) {
                return this._data[e];
            }
        }, {
            key: "setBool",
            value: function(e, t) {
                this._data[e] = t;
            }
        }, {
            key: "getInt",
            value: function(e) {
                return this._data[e];
            }
        }, {
            key: "setInt",
            value: function(e, t) {
                this._data[e] = t;
            }
        }, {
            key: "getNumber",
            value: function(e) {
                return this._data[e];
            }
        }, {
            key: "setNumber",
            value: function(e, t) {
                this._data[e] = t;
            }
        }, {
            key: "getVector2",
            value: function(e) {
                return this._data[e];
            }
        }, {
            key: "setVector2",
            value: function(e, t) {
                this._data[e] = t;
            }
        }, {
            key: "getVector3",
            value: function(e) {
                return this._data[e];
            }
        }, {
            key: "setVector3",
            value: function(e, t) {
                this._data[e] = t;
            }
        }, {
            key: "getVector",
            value: function(e) {
                return this._data[e];
            }
        }, {
            key: "setVector",
            value: function(e, t) {
                this._data[e] = t;
            }
        }, {
            key: "getQuaternion",
            value: function(e) {
                return this._data[e];
            }
        }, {
            key: "setQuaternion",
            value: function(e, t) {
                this._data[e] = t;
            }
        }, {
            key: "getMatrix4x4",
            value: function(e) {
                return this._data[e];
            }
        }, {
            key: "setMatrix4x4",
            value: function(e, t) {
                this._data[e] = t;
            }
        }, {
            key: "getBuffer",
            value: function(e) {
                return this._data[e];
            }
        }, {
            key: "setBuffer",
            value: function(e, t) {
                this._data[e] = t;
            }
        }, {
            key: "setTexture",
            value: function(e, t) {
                var r = this._data[e];
                this._data[e] = t,
                this._ownerResource && this._ownerResource.referenceCount > 0 && (r && r._removeReference(),
                t && t._addReference());
            }
        }, {
            key: "getTexture",
            value: function(e) {
                return this._data[e];
            }
        }, {
            key: "setAttribute",
            value: function(e, t) {
                this._data[e] = t;
            }
        }, {
            key: "getAttribute",
            value: function(e) {
                return this._data[e];
            }
        }, {
            key: "getLength",
            value: function() {
                return this._data.length;
            }
        }, {
            key: "setLength",
            value: function(e) {
                this._data.length = e;
            }
        }, {
            key: "cloneTo",
            value: function(e) {
                var r = e
                  , a = r._data;
                for (var s in this._data) {
                    var l = this._data[s];
                    if (null != l)
                        if ("number" == typeof l)
                            a[s] = l;
                        else if ("number" == typeof l)
                            a[s] = l;
                        else if ("boolean" == typeof l)
                            a[s] = l;
                        else if (l instanceof n) {
                            var u = a[s] || (a[s] = new n());
                            l.cloneTo(u),
                            a[s] = u;
                        } else if (l instanceof o) {
                            var c = a[s] || (a[s] = new o());
                            l.cloneTo(c),
                            a[s] = c;
                        } else if (l instanceof i) {
                            var h = a[s] || (a[s] = new i());
                            l.cloneTo(h),
                            a[s] = h;
                        } else if (l instanceof I) {
                            var _ = a[s] || (a[s] = new I());
                            l.cloneTo(_),
                            a[s] = _;
                        } else
                            l instanceof t.BaseTexture && (a[s] = l);
                }
                this._defineDatas.cloneTo(r._defineDatas);
            }
        }, {
            key: "clone",
            value: function() {
                var e = new ShaderData();
                return this.cloneTo(e),
                e;
            }
        }, {
            key: "cloneToForNative",
            value: function(e) {
                var r = e;
                this._int32Data.length - r._int32Data.length > 0 && r.needRenewArrayBufferForNative(this._int32Data.length),
                r._int32Data.set(this._int32Data, 0);
                var a = r._nativeArray
                  , s = this._nativeArray.length;
                a.length = s;
                for (var l = 0; l < s; l++) {
                    var u = this._nativeArray[l];
                    if (u)
                        if ("number" == typeof u)
                            a[l] = u,
                            r.setNumber(l, u);
                        else if ("number" == typeof u)
                            a[l] = u,
                            r.setInt(l, u);
                        else if ("boolean" == typeof u)
                            a[l] = u,
                            r.setBool(l, u);
                        else if (u instanceof n) {
                            var c = a[l] || (a[l] = new n());
                            u.cloneTo(c),
                            a[l] = c,
                            r.setVector2(l, c);
                        } else if (u instanceof o) {
                            var h = a[l] || (a[l] = new o());
                            u.cloneTo(h),
                            a[l] = h,
                            r.setVector3(l, h);
                        } else if (u instanceof i) {
                            var _ = a[l] || (a[l] = new i());
                            u.cloneTo(_),
                            a[l] = _,
                            r.setVector(l, _);
                        } else if (u instanceof I) {
                            var d = a[l] || (a[l] = new I());
                            u.cloneTo(d),
                            a[l] = d,
                            r.setMatrix4x4(l, d);
                        } else
                            u instanceof t.BaseTexture && (a[l] = u,
                            r.setTexture(l, u));
                }
                this._defineDatas.cloneTo(r._defineDatas);
            }
        }, {
            key: "_initDataForNative",
            value: function() {
                this._frameCount = -1,
                this._runtimeCopyValues.length = 0,
                this._nativeArray = [],
                this._data = new ArrayBuffer(32),
                this._int32Data = new Int32Array(this._data),
                this._float32Data = new Float32Array(this._data),
                t.LayaGL.instance.createArrayBufferRef(this._data, t.LayaGL.ARRAY_BUFFER_TYPE_DATA, !0);
            }
        }, {
            key: "needRenewArrayBufferForNative",
            value: function(e) {
                if (e >= this._int32Data.length) {
                    var r = 4 * (e + 1)
                      , n = this._int32Data
                      , i = this._data.conchRef
                      , a = this._data._ptrID;
                    this._data = new ArrayBuffer(r),
                    this._int32Data = new Int32Array(this._data),
                    this._float32Data = new Float32Array(this._data),
                    this._data.conchRef = i,
                    this._data._ptrID = a,
                    n && this._int32Data.set(n, 0);
                    var o = t.LayaGL.instance;
                    o.updateArrayBufferRef ? o.updateArrayBufferRef(this._data._ptrID, i.isSyncToRender(), this._data) : window.conch.updateArrayBufferRef(this._data._ptrID, i.isSyncToRender(), this._data);
                }
            }
        }, {
            key: "getDataForNative",
            value: function() {
                return this._nativeArray;
            }
        }, {
            key: "getIntForNative",
            value: function(e) {
                return this._int32Data[e];
            }
        }, {
            key: "setIntForNative",
            value: function(e, t) {
                this.needRenewArrayBufferForNative(e),
                this._int32Data[e] = t,
                this._nativeArray[e] = t;
            }
        }, {
            key: "getBoolForNative",
            value: function(e) {
                return 1 == this._int32Data[e];
            }
        }, {
            key: "setBoolForNative",
            value: function(e, t) {
                this.needRenewArrayBufferForNative(e),
                this._int32Data[e] = t ? 1 : 0,
                this._nativeArray[e] = t;
            }
        }, {
            key: "getNumberForNative",
            value: function(e) {
                return this._float32Data[e];
            }
        }, {
            key: "setNumberForNative",
            value: function(e, t) {
                this.needRenewArrayBufferForNative(e),
                this._float32Data[e] = t,
                this._nativeArray[e] = t;
            }
        }, {
            key: "getMatrix4x4ForNative",
            value: function(e) {
                return this._nativeArray[e];
            }
        }, {
            key: "setMatrix4x4ForNative",
            value: function(e, t) {
                this.needRenewArrayBufferForNative(e),
                this._nativeArray[e] = t;
                var r = this.setReferenceForNative(t.elements);
                this._int32Data[e] = r;
            }
        }, {
            key: "getVectorForNative",
            value: function(e) {
                return this._nativeArray[e];
            }
        }, {
            key: "setVectorForNative",
            value: function(e, t) {
                this.needRenewArrayBufferForNative(e),
                this._nativeArray[e] = t,
                t.elements || t.forNativeElement();
                var r = this.setReferenceForNative(t.elements);
                this._int32Data[e] = r;
            }
        }, {
            key: "getVector2ForNative",
            value: function(e) {
                return this._nativeArray[e];
            }
        }, {
            key: "setVector2ForNative",
            value: function(e, t) {
                this.needRenewArrayBufferForNative(e),
                this._nativeArray[e] = t,
                t.elements || t.forNativeElement();
                var r = this.setReferenceForNative(t.elements);
                this._int32Data[e] = r;
            }
        }, {
            key: "getVector3ForNative",
            value: function(e) {
                return this._nativeArray[e];
            }
        }, {
            key: "setVector3ForNative",
            value: function(e, t) {
                this.needRenewArrayBufferForNative(e),
                this._nativeArray[e] = t,
                t.elements || t.forNativeElement();
                var r = this.setReferenceForNative(t.elements);
                this._int32Data[e] = r;
            }
        }, {
            key: "getQuaternionForNative",
            value: function(e) {
                return this._nativeArray[e];
            }
        }, {
            key: "setQuaternionForNative",
            value: function(e, t) {
                this.needRenewArrayBufferForNative(e),
                this._nativeArray[e] = t,
                t.elements || t.forNativeElement();
                var r = this.setReferenceForNative(t.elements);
                this._int32Data[e] = r;
            }
        }, {
            key: "getBufferForNative",
            value: function(e) {
                return this._nativeArray[e];
            }
        }, {
            key: "setBufferForNative",
            value: function(e, t) {
                this.needRenewArrayBufferForNative(e),
                this._nativeArray[e] = t;
                var r = this.setReferenceForNative(t);
                this._int32Data[e] = r;
            }
        }, {
            key: "getAttributeForNative",
            value: function(e) {
                return this._nativeArray[e];
            }
        }, {
            key: "setAttributeForNative",
            value: function(e, r) {
                this._nativeArray[e] = r,
                r._ptrID || t.LayaGL.instance.createArrayBufferRef(r, t.LayaGL.ARRAY_BUFFER_TYPE_DATA, !0),
                t.LayaGL.instance.syncBufferToRenderThread(r),
                this._int32Data[e] = r._ptrID;
            }
        }, {
            key: "getTextureForNative",
            value: function(e) {
                return this._nativeArray[e];
            }
        }, {
            key: "setTextureForNative",
            value: function(e, t) {
                if (t) {
                    this.needRenewArrayBufferForNative(e);
                    var r = this._nativeArray[e];
                    this._nativeArray[e] = t;
                    var n = t._getSource() || t.defaulteTexture._getSource();
                    this._int32Data[e] = n.id,
                    this._ownerResource && this._ownerResource.referenceCount > 0 && (r && r._removeReference(),
                    t && t._addReference());
                }
            }
        }, {
            key: "setReferenceForNative",
            value: function(e) {
                this.clearRuntimeCopyArray();
                var r = 0
                  , n = 0;
                return ShaderData._SET_RUNTIME_VALUE_MODE_REFERENCE_ ? (t.LayaGL.instance.createArrayBufferRefs(e, t.LayaGL.ARRAY_BUFFER_TYPE_DATA, !0, t.LayaGL.ARRAY_BUFFER_REF_REFERENCE),
                r = 0,
                n = e.getPtrID(r)) : (t.LayaGL.instance.createArrayBufferRefs(e, t.LayaGL.ARRAY_BUFFER_TYPE_DATA, !0, t.LayaGL.ARRAY_BUFFER_REF_COPY),
                r = e.getRefNum() - 1,
                n = e.getPtrID(r),
                this._runtimeCopyValues.push({
                    obj: e,
                    refID: r,
                    ptrID: n
                })),
                t.LayaGL.instance.syncBufferToRenderThread(e, r),
                n;
            }
        }, {
            key: "clearRuntimeCopyArray",
            value: function() {
                var e = t.Stat.loopCount;
                if (this._frameCount != e) {
                    this._frameCount = e;
                    for (var r = 0, n = this._runtimeCopyValues.length; r < n; r++) {
                        this._runtimeCopyValues[r].obj.clearRefNum();
                    }
                    this._runtimeCopyValues.length = 0;
                }
            }
        }], [{
            key: "setRuntimeValueMode",
            value: function(e) {
                ShaderData._SET_RUNTIME_VALUE_MODE_REFERENCE_ = e;
            }
        }]),
        ShaderData;
    }();
    z._SET_RUNTIME_VALUE_MODE_REFERENCE_ = !0;
    var H = function() {
        function PostProcess() {
            _classCallCheck(this, PostProcess),
            this._compositeShader = G.find("PostProcessComposite"),
            this._compositeShaderData = new z(),
            this._effects = [],
            this._context = null,
            this._context = new b(),
            this._context.compositeShaderData = this._compositeShaderData;
        }
        return _createClass(PostProcess, [{
            key: "_init",
            value: function(e, t) {
                this._context.camera = e,
                this._context.command = t;
            }
        }, {
            key: "_render",
            value: function() {
                var e = z._SET_RUNTIME_VALUE_MODE_REFERENCE_;
                t.ILaya.Render.supportWebGLPlusRendering && z.setRuntimeValueMode(!1);
                var r = this._context.camera
                  , n = r.viewport
                  , i = V.createFromPool(k.clientWidth, k.clientHeight, r._getRenderTextureFormat(), t.RenderTextureDepthFormat.DEPTHSTENCIL_NONE)
                  , a = r._internalRenderTexture;
                this._context.command.clear(),
                this._context.source = i,
                this._context.destination = a,
                this._context.compositeShaderData.clearDefine(),
                this._context.command.blitScreenTriangle(a, i),
                this._context.compositeShaderData.setTexture(PostProcess.SHADERVALUE_AUTOEXPOSURETEX, t.Texture2D.whiteTexture);
                for (var o = 0, s = this._effects.length; o < s; o++)
                    this._effects[o].render(this._context);
                this._compositeShaderData.addDefine(PostProcess.SHADERDEFINE_FINALPASS);
                var l = r._offScreenRenderTexture
                  , u = l || null;
                this._context.destination = u;
                var c = r._getCanvasWidth()
                  , h = r._getCanvasHeight();
                r._screenOffsetScale.setValue(n.x / c, n.y / h, n.width / c, n.height / h),
                this._context.command.blitScreenTriangle(this._context.source, u, r._screenOffsetScale, this._compositeShader, this._compositeShaderData),
                V.recoverToPool(i);
                var _ = this._context.deferredReleaseTextures;
                for (o = 0,
                s = _.length; o < s; o++)
                    V.recoverToPool(_[o]);
                _.length = 0,
                t.ILaya.Render.supportWebGLPlusRendering && z.setRuntimeValueMode(e);
            }
        }, {
            key: "addEffect",
            value: function(e) {
                this._effects.push(e);
            }
        }, {
            key: "removeEffect",
            value: function(e) {
                var t = this._effects.indexOf(e);
                -1 !== t && this._effects.splice(t, 1);
            }
        }], [{
            key: "__init__",
            value: function() {
                PostProcess.SHADERDEFINE_BLOOM_LOW = G.getDefineByName("BLOOM_LOW"),
                PostProcess.SHADERDEFINE_BLOOM = G.getDefineByName("BLOOM"),
                PostProcess.SHADERDEFINE_FINALPASS = G.getDefineByName("FINALPASS");
            }
        }]),
        PostProcess;
    }();
    H.SHADERVALUE_MAINTEX = G.propertyNameToID("u_MainTex"),
    H.SHADERVALUE_BLOOMTEX = G.propertyNameToID("u_BloomTex"),
    H.SHADERVALUE_AUTOEXPOSURETEX = G.propertyNameToID("u_AutoExposureTex"),
    H.SHADERVALUE_BLOOM_DIRTTEX = G.propertyNameToID("u_Bloom_DirtTex"),
    H.SHADERVALUE_BLOOMTEX_TEXELSIZE = G.propertyNameToID("u_BloomTex_TexelSize"),
    H.SHADERVALUE_BLOOM_DIRTTILEOFFSET = G.propertyNameToID("u_Bloom_DirtTileOffset"),
    H.SHADERVALUE_BLOOM_SETTINGS = G.propertyNameToID("u_Bloom_Settings"),
    H.SHADERVALUE_BLOOM_COLOR = G.propertyNameToID("u_Bloom_Color");
    var W = function(e) {
        function AnimationTransform3D(e) {
            var r, n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null, i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null, a = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : null, s = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : null;
            return _classCallCheck(this, AnimationTransform3D),
            (r = _possibleConstructorReturn(this, _getPrototypeOf(AnimationTransform3D).call(this)))._owner = e,
            r._children = [],
            r._localMatrix = new Float32Array(16),
            t.Render.supportWebGLPlusAnimation ? (r._localPosition = new A(0,0,0,n),
            r._localRotation = new L(0,0,0,1,i),
            r._localScale = new A(0,0,0,a),
            r._worldMatrix = s) : (r._localPosition = new o(),
            r._localRotation = new f(),
            r._localScale = new o(),
            r._worldMatrix = new Float32Array(16)),
            r._localQuaternionUpdate = !1,
            r._locaEulerlUpdate = !1,
            r._localUpdate = !1,
            r._worldUpdate = !0,
            r;
        }
        return _inherits(AnimationTransform3D, t.EventDispatcher),
        _createClass(AnimationTransform3D, [{
            key: "_getlocalMatrix",
            value: function() {
                return this._localUpdate && (R._createAffineTransformationArray(this._localPosition, this._localRotation, this._localScale, this._localMatrix),
                this._localUpdate = !1),
                this._localMatrix;
            }
        }, {
            key: "_onWorldTransform",
            value: function() {
                if (!this._worldUpdate) {
                    this._worldUpdate = !0,
                    this.event(t.Event.TRANSFORM_CHANGED);
                    for (var e = 0, r = this._children.length; e < r; e++)
                        this._children[e]._onWorldTransform();
                }
            }
        }, {
            key: "getWorldMatrix",
            value: function() {
                if (!t.Render.supportWebGLPlusAnimation && this._worldUpdate) {
                    if (null != this._parent)
                        R.matrix4x4MultiplyFFF(this._parent.getWorldMatrix(), this._getlocalMatrix(), this._worldMatrix);
                    else {
                        var e = this._worldMatrix;
                        e[1] = e[2] = e[3] = e[4] = e[6] = e[7] = e[8] = e[9] = e[11] = e[12] = e[13] = e[14] = 0,
                        e[0] = e[5] = e[10] = e[15] = 1;
                    }
                    this._worldUpdate = !1;
                }
                return t.Render.supportWebGLPlusAnimation && this._worldUpdate && (this._worldUpdate = !1),
                this._worldMatrix;
            }
        }, {
            key: "setParent",
            value: function(e) {
                if (this._parent !== e) {
                    if (this._parent) {
                        var t = this._parent._children
                          , r = t.indexOf(this);
                        t.splice(r, 1);
                    }
                    e && (e._children.push(this),
                    e && this._onWorldTransform()),
                    this._parent = e;
                }
            }
        }, {
            key: "localPosition",
            get: function() {
                return this._localPosition;
            },
            set: function(e) {
                this._localPosition = e,
                this._localUpdate = !0,
                this._onWorldTransform();
            }
        }, {
            key: "localRotation",
            get: function() {
                if (this._localQuaternionUpdate) {
                    var e = this._localRotationEuler;
                    f.createFromYawPitchRoll(e.y / AnimationTransform3D._angleToRandin, e.x / AnimationTransform3D._angleToRandin, e.z / AnimationTransform3D._angleToRandin, this._localRotation),
                    this._localQuaternionUpdate = !1;
                }
                return this._localRotation;
            },
            set: function(e) {
                this._localRotation = e,
                this._locaEulerlUpdate = !0,
                this._localQuaternionUpdate = !1,
                this._localUpdate = !0,
                this._onWorldTransform();
            }
        }, {
            key: "localScale",
            get: function() {
                return this._localScale;
            },
            set: function(e) {
                this._localScale = e,
                this._localUpdate = !0,
                this._onWorldTransform();
            }
        }, {
            key: "localRotationEuler",
            get: function() {
                if (this._locaEulerlUpdate) {
                    this._localRotation.getYawPitchRoll(AnimationTransform3D._tempVector3);
                    var e = AnimationTransform3D._tempVector3
                      , t = this._localRotationEuler;
                    t.x = e.y * AnimationTransform3D._angleToRandin,
                    t.y = e.x * AnimationTransform3D._angleToRandin,
                    t.z = e.z * AnimationTransform3D._angleToRandin,
                    this._locaEulerlUpdate = !1;
                }
                return this._localRotationEuler;
            },
            set: function(e) {
                this._localRotationEuler = e,
                this._locaEulerlUpdate = !1,
                this._localQuaternionUpdate = !0,
                this._localUpdate = !0,
                this._onWorldTransform();
            }
        }]),
        AnimationTransform3D;
    }();
    W._tempVector3 = new o(),
    W._angleToRandin = 180 / Math.PI;
    var X = function() {
        function AnimationNode() {
            var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null
              , t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null
              , r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null
              , n = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : null;
            _classCallCheck(this, AnimationNode),
            this._children = [],
            this.transform = new W(this,e,t,r,n);
        }
        return _createClass(AnimationNode, [{
            key: "addChild",
            value: function(e) {
                e._parent = this,
                e.transform.setParent(this.transform),
                this._children.push(e);
            }
        }, {
            key: "removeChild",
            value: function(e) {
                var t = this._children.indexOf(e);
                -1 !== t && this._children.splice(t, 1);
            }
        }, {
            key: "getChildByName",
            value: function(e) {
                for (var t = 0, r = this._children.length; t < r; t++) {
                    var n = this._children[t];
                    if (n.name === e)
                        return n;
                }
                return null;
            }
        }, {
            key: "getChildByIndex",
            value: function(e) {
                return this._children[e];
            }
        }, {
            key: "getChildCount",
            value: function() {
                return this._children.length;
            }
        }, {
            key: "cloneTo",
            value: function(e) {
                var t = e;
                t.name = this.name;
                for (var r = 0, n = this._children.length; r < n; r++) {
                    var i = this._children[r]
                      , a = i.clone();
                    t.addChild(a);
                    var o = i.transform
                      , s = a.transform
                      , l = s.localPosition
                      , u = s.localRotation
                      , c = s.localScale;
                    o.localPosition.cloneTo(l),
                    o.localRotation.cloneTo(u),
                    o.localScale.cloneTo(c),
                    s.localPosition = l,
                    s.localRotation = u,
                    s.localScale = c;
                }
            }
        }, {
            key: "clone",
            value: function() {
                var e = new AnimationNode();
                return this.cloneTo(e),
                e;
            }
        }, {
            key: "_cloneNative",
            value: function(e, t, r, n, i, a, o) {
                var s = o._nativeCurCloneCount;
                i[s] = a;
                var l = new AnimationNode(new Float32Array(e.buffer,3 * s * 4,3),new Float32Array(t.buffer,4 * s * 4,4),new Float32Array(r.buffer,3 * s * 4,3),new Float32Array(n.buffer,16 * s * 4,16));
                return l._worldMatrixIndex = s,
                this._cloneToNative(l, e, t, r, n, i, s, o),
                l;
            }
        }, {
            key: "_cloneToNative",
            value: function(e, t, r, n, i, a, o, s) {
                var l = e;
                l.name = this.name;
                for (var u = 0, c = this._children.length; u < c; u++) {
                    var h = this._children[u];
                    s._nativeCurCloneCount++;
                    var _ = h._cloneNative(t, r, n, i, a, o, s);
                    l.addChild(_);
                    var d = h.transform
                      , f = _.transform
                      , m = f.localPosition
                      , p = f.localRotation
                      , v = f.localScale;
                    d.localPosition.cloneTo(m),
                    d.localRotation.cloneTo(p),
                    d.localScale.cloneTo(v),
                    f.localPosition = m,
                    f.localRotation = p,
                    f.localScale = v;
                }
            }
        }]),
        AnimationNode;
    }()
      , Y = function(e) {
        function Avatar() {
            var e;
            return _classCallCheck(this, Avatar),
            (e = _possibleConstructorReturn(this, _getPrototypeOf(Avatar).call(this)))._nativeNodeCount = 0,
            e._nativeCurCloneCount = 0,
            e;
        }
        return _inherits(Avatar, t.Resource),
        _createClass(Avatar, [{
            key: "_initCloneToAnimator",
            value: function(e, t) {
                t._avatarNodeMap[e.name] = e;
                for (var r = 0, n = e.getChildCount(); r < n; r++)
                    this._initCloneToAnimator(e.getChildByIndex(r), t);
            }
        }, {
            key: "_parseNode",
            value: function(e, r) {
                var n = e.props.name;
                r.name = n;
                var i = e.props
                  , a = r.transform
                  , o = a.localPosition
                  , s = a.localRotation
                  , l = a.localScale;
                o.fromArray(i.translate),
                s.fromArray(i.rotation),
                l.fromArray(i.scale),
                a.localPosition = o,
                a.localRotation = s,
                a.localScale = l;
                for (var u = e.child, c = 0, h = u.length; c < h; c++) {
                    var _ = u[c]
                      , d = new X(new Float32Array(3),new Float32Array(4),new Float32Array(3),new Float32Array(16));
                    r.addChild(d),
                    t.Render.supportWebGLPlusAnimation && this._nativeNodeCount++,
                    this._parseNode(_, d);
                }
            }
        }, {
            key: "_cloneDatasToAnimator",
            value: function(e) {
                var t;
                t = this._rootNode.clone();
                var r = this._rootNode.transform
                  , n = t.transform
                  , i = n.localPosition
                  , a = n.localRotation
                  , o = n.localScale;
                r.localPosition.cloneTo(i),
                r.localRotation.cloneTo(a),
                r.localScale.cloneTo(o),
                n.localPosition = i,
                n.localRotation = a,
                n.localScale = o,
                e._avatarNodeMap = {},
                this._initCloneToAnimator(t, e);
            }
        }, {
            key: "cloneTo",
            value: function(e) {
                var t = e
                  , r = this._rootNode.clone();
                t._rootNode = r;
            }
        }, {
            key: "clone",
            value: function() {
                var e = new Avatar();
                return this.cloneTo(e),
                e;
            }
        }, {
            key: "_cloneDatasToAnimatorNative",
            value: function(e) {
                var t = new Float32Array(3 * this._nativeNodeCount)
                  , r = new Float32Array(4 * this._nativeNodeCount)
                  , n = new Float32Array(3 * this._nativeNodeCount)
                  , i = new Float32Array(16 * this._nativeNodeCount)
                  , a = new Int16Array(this._nativeNodeCount);
                e._animationNodeLocalPositions = t,
                e._animationNodeLocalRotations = r,
                e._animationNodeLocalScales = n,
                e._animationNodeWorldMatrixs = i,
                e._animationNodeParentIndices = a,
                this._nativeCurCloneCount = 0;
                var o = this._rootNode._cloneNative(t, r, n, i, a, -1, this)
                  , s = this._rootNode.transform
                  , l = o.transform
                  , u = l.localPosition
                  , c = l.localRotation
                  , h = l.localScale;
                s.localPosition.cloneTo(u),
                s.localRotation.cloneTo(c),
                s.localScale.cloneTo(h),
                l.localPosition = u,
                l.localRotation = c,
                l.localScale = h,
                e._avatarNodeMap = {},
                this._initCloneToAnimator(o, e);
            }
        }], [{
            key: "_parse",
            value: function(e) {
                arguments.length > 1 && void 0 !== arguments[1] && arguments[1],
                arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
                var r = new Avatar();
                if (r._rootNode = new X(new Float32Array(3),new Float32Array(4),new Float32Array(3),new Float32Array(16)),
                t.Render.supportWebGLPlusAnimation && r._nativeNodeCount++,
                e.version) {
                    var n = e.rootNode;
                    n && r._parseNode(n, r._rootNode);
                }
                return r;
            }
        }, {
            key: "load",
            value: function(e, r) {
                t.ILaya.loader.create(e, r, null, Avatar.AVATAR);
            }
        }]),
        Avatar;
    }();
    Y.AVATAR = "AVATAR";
    var Z = function(e) {
        function Material() {
            var e;
            return _classCallCheck(this, Material),
            (e = _possibleConstructorReturn(this, _getPrototypeOf(Material).call(this)))._shaderValues = null,
            e._shaderValues = new z(_assertThisInitialized(e)),
            e.renderQueue = Material.RENDERQUEUE_OPAQUE,
            e._alphaTest = !1,
            e;
        }
        return _inherits(Material, t.Resource),
        _createClass(Material, [{
            key: "_removeTetxureReference",
            value: function() {
                var e = this._shaderValues.getData();
                for (var r in e) {
                    var n = e[r];
                    n && n instanceof t.BaseTexture && n._removeReference();
                }
            }
        }, {
            key: "_disposeResource",
            value: function() {
                this._referenceCount > 0 && this._removeTetxureReference(),
                this._shaderValues = null;
            }
        }, {
            key: "_addReference",
            value: function() {
                var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 1;
                _get(_getPrototypeOf(Material.prototype), "_addReference", this).call(this, e);
                var r = this._shaderValues.getData();
                for (var n in r) {
                    var i = r[n];
                    i && i instanceof t.BaseTexture && i._addReference();
                }
            }
        }, {
            key: "_removeReference",
            value: function() {
                var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 1;
                _get(_getPrototypeOf(Material.prototype), "_removeReference", this).call(this, e),
                this._removeTetxureReference();
            }
        }, {
            key: "setShaderName",
            value: function(e) {
                if (this._shader = G.find(e),
                !this._shader)
                    throw new Error("BaseMaterial: unknown shader name.");
            }
        }, {
            key: "cloneTo",
            value: function(e) {
                var t = e;
                t.name = this.name,
                t.renderQueue = this.renderQueue,
                this._shaderValues.cloneTo(t._shaderValues);
            }
        }, {
            key: "clone",
            value: function() {
                var e = new Material();
                return this.cloneTo(e),
                e;
            }
        }, {
            key: "shaderData",
            get: function() {
                return this._shaderValues;
            }
        }, {
            key: "alphaTestValue",
            get: function() {
                return this._shaderValues.getNumber(Material.ALPHATESTVALUE);
            },
            set: function(e) {
                this._shaderValues.setNumber(Material.ALPHATESTVALUE, e);
            }
        }, {
            key: "alphaTest",
            get: function() {
                return this._alphaTest;
            },
            set: function(e) {
                this._alphaTest = e,
                e ? this._shaderValues.addDefine(Material.SHADERDEFINE_ALPHATEST) : this._shaderValues.removeDefine(Material.SHADERDEFINE_ALPHATEST);
            }
        }, {
            key: "_defineDatas",
            get: function() {
                return this._shaderValues._defineDatas;
            }
        }], [{
            key: "load",
            value: function(e, r) {
                t.Laya.loader.create(e, r, null, Material.MATERIAL);
            }
        }, {
            key: "__initDefine__",
            value: function() {
                Material.SHADERDEFINE_ALPHATEST = G.getDefineByName("ALPHATEST");
            }
        }, {
            key: "_parse",
            value: function(e) {
                arguments.length > 1 && void 0 !== arguments[1] && arguments[1],
                arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
                var r, a = e, s = a.props, l = s.type, u = t.ClassUtils.getRegClass(l);
                if (!u)
                    throw "_getSprite3DHierarchyInnerUrls 错误: " + e.type + " 不是类";
                switch (r = new u(),
                a.version) {
                case "LAYAMATERIAL:01":
                case "LAYAMATERIAL:02":
                    var c, h;
                    for (var _ in s)
                        switch (_) {
                        case "type":
                            break;
                        case "vectors":
                            var d = s[_];
                            for (c = 0,
                            h = d.length; c < h; c++) {
                                var f = d[c]
                                  , m = f.value;
                                switch (m.length) {
                                case 2:
                                    r[f.name] = new n(m[0],m[1]);
                                    break;
                                case 3:
                                    r[f.name] = new o(m[0],m[1],m[2]);
                                    break;
                                case 4:
                                    r[f.name] = new i(m[0],m[1],m[2],m[3]);
                                    break;
                                default:
                                    throw new Error("BaseMaterial:unkonwn color length.");
                                }
                            }
                            break;
                        case "textures":
                            var p = s[_];
                            for (c = 0,
                            h = p.length; c < h; c++) {
                                var v = p[c]
                                  , T = v.path;
                                T && (r[v.name] = t.Loader.getRes(T));
                            }
                            break;
                        case "defines":
                            var E = s[_];
                            for (c = 0,
                            h = E.length; c < h; c++) {
                                var y = G.getDefineByName(E[c]);
                                r._shaderValues.addDefine(y);
                            }
                            break;
                        case "renderStates":
                            var g = s[_][0]
                              , S = r;
                            S.blend = g.blend,
                            S.cull = g.cull,
                            S.depthTest = g.depthTest,
                            S.depthWrite = g.depthWrite,
                            S.blendSrc = g.srcBlend,
                            S.blendDst = g.dstBlend;
                            break;
                        case "cull":
                            r.cull = s[_];
                            break;
                        case "blend":
                            r.blend = s[_];
                            break;
                        case "depthWrite":
                            r.depthWrite = s[_];
                            break;
                        case "srcBlend":
                            r.blendSrc = s[_];
                            break;
                        case "dstBlend":
                            r.blendDst = s[_];
                            break;
                        default:
                            r[_] = s[_];
                        }
                    break;
                default:
                    throw new Error("BaseMaterial:unkonwn version.");
                }
                return r;
            }
        }]),
        Material;
    }();
    Z.MATERIAL = "MATERIAL",
    Z.RENDERQUEUE_OPAQUE = 2e3,
    Z.RENDERQUEUE_ALPHATEST = 2450,
    Z.RENDERQUEUE_TRANSPARENT = 3e3,
    Z.ALPHATESTVALUE = G.propertyNameToID("u_AlphaTestValue"),
    Z.SHADERDEFINE_ALPHATEST = null;
    var j = function() {
        function BaseMaterial() {
            _classCallCheck(this, BaseMaterial);
        }
        return _createClass(BaseMaterial, null, [{
            key: "load",
            value: function(e, r) {
                t.Laya.loader.create(e, r, null, Z.MATERIAL);
            }
        }, {
            key: "__initDefine__",
            value: function() {
                BaseMaterial.SHADERDEFINE_ALPHATEST = Z.SHADERDEFINE_ALPHATEST;
            }
        }]),
        BaseMaterial;
    }();
    j.MATERIAL = "MATERIAL",
    j.RENDERQUEUE_OPAQUE = 2e3,
    j.RENDERQUEUE_ALPHATEST = 2450,
    j.RENDERQUEUE_TRANSPARENT = 3e3,
    j.ALPHATESTVALUE = G.propertyNameToID("u_AlphaTestValue"),
    j.SHADERDEFINE_ALPHATEST = null;
    var Q = function() {
        function RenderState() {
            _classCallCheck(this, RenderState),
            this.cull = RenderState.CULL_BACK,
            this.blend = RenderState.BLEND_DISABLE,
            this.srcBlend = RenderState.BLENDPARAM_ONE,
            this.dstBlend = RenderState.BLENDPARAM_ZERO,
            this.srcBlendRGB = RenderState.BLENDPARAM_ONE,
            this.dstBlendRGB = RenderState.BLENDPARAM_ZERO,
            this.srcBlendAlpha = RenderState.BLENDPARAM_ONE,
            this.dstBlendAlpha = RenderState.BLENDPARAM_ZERO,
            this.blendConstColor = new i(1,1,1,1),
            this.blendEquation = RenderState.BLENDEQUATION_ADD,
            this.blendEquationRGB = RenderState.BLENDEQUATION_ADD,
            this.blendEquationAlpha = RenderState.BLENDEQUATION_ADD,
            this.depthTest = RenderState.DEPTHTEST_LEQUAL,
            this.depthWrite = !0;
        }
        return _createClass(RenderState, [{
            key: "cloneTo",
            value: function(e) {
                var t = e;
                t.cull = this.cull,
                t.blend = this.blend,
                t.srcBlend = this.srcBlend,
                t.dstBlend = this.dstBlend,
                t.srcBlendRGB = this.srcBlendRGB,
                t.dstBlendRGB = this.dstBlendRGB,
                t.srcBlendAlpha = this.srcBlendAlpha,
                t.dstBlendAlpha = this.dstBlendAlpha,
                this.blendConstColor.cloneTo(t.blendConstColor),
                t.blendEquation = this.blendEquation,
                t.blendEquationRGB = this.blendEquationRGB,
                t.blendEquationAlpha = this.blendEquationAlpha,
                t.depthTest = this.depthTest,
                t.depthWrite = this.depthWrite;
            }
        }, {
            key: "clone",
            value: function() {
                var e = new RenderState();
                return this.cloneTo(e),
                e;
            }
        }]),
        RenderState;
    }();
    Q.CULL_NONE = 0,
    Q.CULL_FRONT = 1,
    Q.CULL_BACK = 2,
    Q.BLEND_DISABLE = 0,
    Q.BLEND_ENABLE_ALL = 1,
    Q.BLEND_ENABLE_SEPERATE = 2,
    Q.BLENDPARAM_ZERO = 0,
    Q.BLENDPARAM_ONE = 1,
    Q.BLENDPARAM_SRC_COLOR = 768,
    Q.BLENDPARAM_ONE_MINUS_SRC_COLOR = 769,
    Q.BLENDPARAM_DST_COLOR = 774,
    Q.BLENDPARAM_ONE_MINUS_DST_COLOR = 775,
    Q.BLENDPARAM_SRC_ALPHA = 770,
    Q.BLENDPARAM_ONE_MINUS_SRC_ALPHA = 771,
    Q.BLENDPARAM_DST_ALPHA = 772,
    Q.BLENDPARAM_ONE_MINUS_DST_ALPHA = 773,
    Q.BLENDPARAM_SRC_ALPHA_SATURATE = 776,
    Q.BLENDEQUATION_ADD = 32774,
    Q.BLENDEQUATION_SUBTRACT = 32778,
    Q.BLENDEQUATION_REVERSE_SUBTRACT = 32779,
    Q.DEPTHTEST_OFF = 0,
    Q.DEPTHTEST_NEVER = 512,
    Q.DEPTHTEST_LESS = 513,
    Q.DEPTHTEST_EQUAL = 514,
    Q.DEPTHTEST_LEQUAL = 515,
    Q.DEPTHTEST_GREATER = 516,
    Q.DEPTHTEST_NOTEQUAL = 517,
    Q.DEPTHTEST_GEQUAL = 518,
    Q.DEPTHTEST_ALWAYS = 519;
    var q = function(e) {
        function BlinnPhongMaterial() {
            var e;
            _classCallCheck(this, BlinnPhongMaterial),
            (e = _possibleConstructorReturn(this, _getPrototypeOf(BlinnPhongMaterial).call(this)))._enableVertexColor = !1,
            e.setShaderName("BLINNPHONG"),
            e._albedoIntensity = 1,
            e._albedoColor = new i(1,1,1,1);
            var t = e._shaderValues;
            return t.setVector(BlinnPhongMaterial.ALBEDOCOLOR, new i(1,1,1,1)),
            t.setVector(BlinnPhongMaterial.MATERIALSPECULAR, new i(1,1,1,1)),
            t.setNumber(BlinnPhongMaterial.SHININESS, .078125),
            t.setNumber(Z.ALPHATESTVALUE, .5),
            t.setVector(BlinnPhongMaterial.TILINGOFFSET, new i(1,1,0,0)),
            e._enableLighting = !0,
            e.renderMode = BlinnPhongMaterial.RENDERMODE_OPAQUE,
            e;
        }
        return _inherits(BlinnPhongMaterial, Z),
        _createClass(BlinnPhongMaterial, [{
            key: "clone",
            value: function() {
                var e = new BlinnPhongMaterial();
                return this.cloneTo(e),
                e;
            }
        }, {
            key: "cloneTo",
            value: function(e) {
                _get(_getPrototypeOf(BlinnPhongMaterial.prototype), "cloneTo", this).call(this, e);
                var t = e;
                t._enableLighting = this._enableLighting,
                t._albedoIntensity = this._albedoIntensity,
                t._enableVertexColor = this._enableVertexColor,
                this._albedoColor.cloneTo(t._albedoColor);
            }
        }, {
            key: "_ColorR",
            get: function() {
                return this._albedoColor.x;
            },
            set: function(e) {
                this._albedoColor.x = e,
                this.albedoColor = this._albedoColor;
            }
        }, {
            key: "_ColorG",
            get: function() {
                return this._albedoColor.y;
            },
            set: function(e) {
                this._albedoColor.y = e,
                this.albedoColor = this._albedoColor;
            }
        }, {
            key: "_ColorB",
            get: function() {
                return this._albedoColor.z;
            },
            set: function(e) {
                this._albedoColor.z = e,
                this.albedoColor = this._albedoColor;
            }
        }, {
            key: "_ColorA",
            get: function() {
                return this._albedoColor.w;
            },
            set: function(e) {
                this._albedoColor.w = e,
                this.albedoColor = this._albedoColor;
            }
        }, {
            key: "_SpecColorR",
            get: function() {
                return this._shaderValues.getVector(BlinnPhongMaterial.MATERIALSPECULAR).x;
            },
            set: function(e) {
                this._shaderValues.getVector(BlinnPhongMaterial.MATERIALSPECULAR).x = e;
            }
        }, {
            key: "_SpecColorG",
            get: function() {
                return this._shaderValues.getVector(BlinnPhongMaterial.MATERIALSPECULAR).y;
            },
            set: function(e) {
                this._shaderValues.getVector(BlinnPhongMaterial.MATERIALSPECULAR).y = e;
            }
        }, {
            key: "_SpecColorB",
            get: function() {
                return this._shaderValues.getVector(BlinnPhongMaterial.MATERIALSPECULAR).z;
            },
            set: function(e) {
                this._shaderValues.getVector(BlinnPhongMaterial.MATERIALSPECULAR).z = e;
            }
        }, {
            key: "_SpecColorA",
            get: function() {
                return this._shaderValues.getVector(BlinnPhongMaterial.MATERIALSPECULAR).w;
            },
            set: function(e) {
                this._shaderValues.getVector(BlinnPhongMaterial.MATERIALSPECULAR).w = e;
            }
        }, {
            key: "_AlbedoIntensity",
            get: function() {
                return this._albedoIntensity;
            },
            set: function(e) {
                if (this._albedoIntensity !== e) {
                    var t = this._shaderValues.getVector(BlinnPhongMaterial.ALBEDOCOLOR);
                    i.scale(this._albedoColor, e, t),
                    this._albedoIntensity = e,
                    this._shaderValues.setVector(BlinnPhongMaterial.ALBEDOCOLOR, t);
                }
            }
        }, {
            key: "_Shininess",
            get: function() {
                return this._shaderValues.getNumber(BlinnPhongMaterial.SHININESS);
            },
            set: function(e) {
                e = Math.max(0, Math.min(1, e)),
                this._shaderValues.setNumber(BlinnPhongMaterial.SHININESS, e);
            }
        }, {
            key: "_MainTex_STX",
            get: function() {
                return this._shaderValues.getVector(BlinnPhongMaterial.TILINGOFFSET).x;
            },
            set: function(e) {
                var t = this._shaderValues.getVector(BlinnPhongMaterial.TILINGOFFSET);
                t.x = e,
                this.tilingOffset = t;
            }
        }, {
            key: "_MainTex_STY",
            get: function() {
                return this._shaderValues.getVector(BlinnPhongMaterial.TILINGOFFSET).y;
            },
            set: function(e) {
                var t = this._shaderValues.getVector(BlinnPhongMaterial.TILINGOFFSET);
                t.y = e,
                this.tilingOffset = t;
            }
        }, {
            key: "_MainTex_STZ",
            get: function() {
                return this._shaderValues.getVector(BlinnPhongMaterial.TILINGOFFSET).z;
            },
            set: function(e) {
                var t = this._shaderValues.getVector(BlinnPhongMaterial.TILINGOFFSET);
                t.z = e,
                this.tilingOffset = t;
            }
        }, {
            key: "_MainTex_STW",
            get: function() {
                return this._shaderValues.getVector(BlinnPhongMaterial.TILINGOFFSET).w;
            },
            set: function(e) {
                var t = this._shaderValues.getVector(BlinnPhongMaterial.TILINGOFFSET);
                t.w = e,
                this.tilingOffset = t;
            }
        }, {
            key: "_Cutoff",
            get: function() {
                return this.alphaTestValue;
            },
            set: function(e) {
                this.alphaTestValue = e;
            }
        }, {
            key: "renderMode",
            set: function(e) {
                switch (e) {
                case BlinnPhongMaterial.RENDERMODE_OPAQUE:
                    this.alphaTest = !1,
                    this.renderQueue = Z.RENDERQUEUE_OPAQUE,
                    this.depthWrite = !0,
                    this.cull = Q.CULL_BACK,
                    this.blend = Q.BLEND_DISABLE,
                    this.depthTest = Q.DEPTHTEST_LESS;
                    break;
                case BlinnPhongMaterial.RENDERMODE_CUTOUT:
                    this.renderQueue = Z.RENDERQUEUE_ALPHATEST,
                    this.alphaTest = !0,
                    this.depthWrite = !0,
                    this.cull = Q.CULL_BACK,
                    this.blend = Q.BLEND_DISABLE,
                    this.depthTest = Q.DEPTHTEST_LESS;
                    break;
                case BlinnPhongMaterial.RENDERMODE_TRANSPARENT:
                    this.renderQueue = Z.RENDERQUEUE_TRANSPARENT,
                    this.alphaTest = !1,
                    this.depthWrite = !1,
                    this.cull = Q.CULL_BACK,
                    this.blend = Q.BLEND_ENABLE_ALL,
                    this.blendSrc = Q.BLENDPARAM_SRC_ALPHA,
                    this.blendDst = Q.BLENDPARAM_ONE_MINUS_SRC_ALPHA,
                    this.depthTest = Q.DEPTHTEST_LESS;
                    break;
                default:
                    throw new Error("Material:renderMode value error.");
                }
            }
        }, {
            key: "enableVertexColor",
            get: function() {
                return this._enableVertexColor;
            },
            set: function(e) {
                this._enableVertexColor = e,
                e ? this._shaderValues.addDefine(BlinnPhongMaterial.SHADERDEFINE_ENABLEVERTEXCOLOR) : this._shaderValues.removeDefine(BlinnPhongMaterial.SHADERDEFINE_ENABLEVERTEXCOLOR);
            }
        }, {
            key: "tilingOffsetX",
            get: function() {
                return this._MainTex_STX;
            },
            set: function(e) {
                this._MainTex_STX = e;
            }
        }, {
            key: "tilingOffsetY",
            get: function() {
                return this._MainTex_STY;
            },
            set: function(e) {
                this._MainTex_STY = e;
            }
        }, {
            key: "tilingOffsetZ",
            get: function() {
                return this._MainTex_STZ;
            },
            set: function(e) {
                this._MainTex_STZ = e;
            }
        }, {
            key: "tilingOffsetW",
            get: function() {
                return this._MainTex_STW;
            },
            set: function(e) {
                this._MainTex_STW = e;
            }
        }, {
            key: "tilingOffset",
            get: function() {
                return this._shaderValues.getVector(BlinnPhongMaterial.TILINGOFFSET);
            },
            set: function(e) {
                e && (1 != e.x || 1 != e.y || 0 != e.z || 0 != e.w) ? this._shaderValues.addDefine(BlinnPhongMaterial.SHADERDEFINE_TILINGOFFSET) : this._shaderValues.removeDefine(BlinnPhongMaterial.SHADERDEFINE_TILINGOFFSET),
                this._shaderValues.setVector(BlinnPhongMaterial.TILINGOFFSET, e);
            }
        }, {
            key: "albedoColorR",
            get: function() {
                return this._ColorR;
            },
            set: function(e) {
                this._ColorR = e;
            }
        }, {
            key: "albedoColorG",
            get: function() {
                return this._ColorG;
            },
            set: function(e) {
                this._ColorG = e;
            }
        }, {
            key: "albedoColorB",
            get: function() {
                return this._ColorB;
            },
            set: function(e) {
                this._ColorB = e;
            }
        }, {
            key: "albedoColorA",
            get: function() {
                return this._ColorA;
            },
            set: function(e) {
                this._ColorA = e;
            }
        }, {
            key: "albedoColor",
            get: function() {
                return this._albedoColor;
            },
            set: function(e) {
                var t = this._shaderValues.getVector(BlinnPhongMaterial.ALBEDOCOLOR);
                i.scale(e, this._albedoIntensity, t),
                this._albedoColor = e,
                this._shaderValues.setVector(BlinnPhongMaterial.ALBEDOCOLOR, t);
            }
        }, {
            key: "albedoIntensity",
            get: function() {
                return this._albedoIntensity;
            },
            set: function(e) {
                this._AlbedoIntensity = e;
            }
        }, {
            key: "specularColorR",
            get: function() {
                return this._SpecColorR;
            },
            set: function(e) {
                this._SpecColorR = e;
            }
        }, {
            key: "specularColorG",
            get: function() {
                return this._SpecColorG;
            },
            set: function(e) {
                this._SpecColorG = e;
            }
        }, {
            key: "specularColorB",
            get: function() {
                return this._SpecColorB;
            },
            set: function(e) {
                this._SpecColorB = e;
            }
        }, {
            key: "specularColorA",
            get: function() {
                return this._SpecColorA;
            },
            set: function(e) {
                this._SpecColorA = e;
            }
        }, {
            key: "specularColor",
            get: function() {
                return this._shaderValues.getVector(BlinnPhongMaterial.MATERIALSPECULAR);
            },
            set: function(e) {
                this._shaderValues.setVector(BlinnPhongMaterial.MATERIALSPECULAR, e);
            }
        }, {
            key: "shininess",
            get: function() {
                return this._Shininess;
            },
            set: function(e) {
                this._Shininess = e;
            }
        }, {
            key: "albedoTexture",
            get: function() {
                return this._shaderValues.getTexture(BlinnPhongMaterial.ALBEDOTEXTURE);
            },
            set: function(e) {
                e ? this._shaderValues.addDefine(BlinnPhongMaterial.SHADERDEFINE_DIFFUSEMAP) : this._shaderValues.removeDefine(BlinnPhongMaterial.SHADERDEFINE_DIFFUSEMAP),
                this._shaderValues.setTexture(BlinnPhongMaterial.ALBEDOTEXTURE, e);
            }
        }, {
            key: "normalTexture",
            get: function() {
                return this._shaderValues.getTexture(BlinnPhongMaterial.NORMALTEXTURE);
            },
            set: function(e) {
                e ? this._shaderValues.addDefine(BlinnPhongMaterial.SHADERDEFINE_NORMALMAP) : this._shaderValues.removeDefine(BlinnPhongMaterial.SHADERDEFINE_NORMALMAP),
                this._shaderValues.setTexture(BlinnPhongMaterial.NORMALTEXTURE, e);
            }
        }, {
            key: "specularTexture",
            get: function() {
                return this._shaderValues.getTexture(BlinnPhongMaterial.SPECULARTEXTURE);
            },
            set: function(e) {
                e ? this._shaderValues.addDefine(BlinnPhongMaterial.SHADERDEFINE_SPECULARMAP) : this._shaderValues.removeDefine(BlinnPhongMaterial.SHADERDEFINE_SPECULARMAP),
                this._shaderValues.setTexture(BlinnPhongMaterial.SPECULARTEXTURE, e);
            }
        }, {
            key: "depthWrite",
            get: function() {
                return this._shaderValues.getBool(BlinnPhongMaterial.DEPTH_WRITE);
            },
            set: function(e) {
                this._shaderValues.setBool(BlinnPhongMaterial.DEPTH_WRITE, e);
            }
        }, {
            key: "cull",
            get: function() {
                return this._shaderValues.getInt(BlinnPhongMaterial.CULL);
            },
            set: function(e) {
                this._shaderValues.setInt(BlinnPhongMaterial.CULL, e);
            }
        }, {
            key: "blend",
            get: function() {
                return this._shaderValues.getInt(BlinnPhongMaterial.BLEND);
            },
            set: function(e) {
                this._shaderValues.setInt(BlinnPhongMaterial.BLEND, e);
            }
        }, {
            key: "blendSrc",
            get: function() {
                return this._shaderValues.getInt(BlinnPhongMaterial.BLEND_SRC);
            },
            set: function(e) {
                this._shaderValues.setInt(BlinnPhongMaterial.BLEND_SRC, e);
            }
        }, {
            key: "blendDst",
            get: function() {
                return this._shaderValues.getInt(BlinnPhongMaterial.BLEND_DST);
            },
            set: function(e) {
                this._shaderValues.setInt(BlinnPhongMaterial.BLEND_DST, e);
            }
        }, {
            key: "depthTest",
            get: function() {
                return this._shaderValues.getInt(BlinnPhongMaterial.DEPTH_TEST);
            },
            set: function(e) {
                this._shaderValues.setInt(BlinnPhongMaterial.DEPTH_TEST, e);
            }
        }], [{
            key: "__initDefine__",
            value: function() {
                BlinnPhongMaterial.SHADERDEFINE_DIFFUSEMAP = G.getDefineByName("DIFFUSEMAP"),
                BlinnPhongMaterial.SHADERDEFINE_NORMALMAP = G.getDefineByName("NORMALMAP"),
                BlinnPhongMaterial.SHADERDEFINE_SPECULARMAP = G.getDefineByName("SPECULARMAP"),
                BlinnPhongMaterial.SHADERDEFINE_TILINGOFFSET = G.getDefineByName("TILINGOFFSET"),
                BlinnPhongMaterial.SHADERDEFINE_ENABLEVERTEXCOLOR = G.getDefineByName("ENABLEVERTEXCOLOR");
            }
        }]),
        BlinnPhongMaterial;
    }();
    q.RENDERMODE_OPAQUE = 0,
    q.RENDERMODE_CUTOUT = 1,
    q.RENDERMODE_TRANSPARENT = 2,
    q.ALBEDOTEXTURE = G.propertyNameToID("u_DiffuseTexture"),
    q.NORMALTEXTURE = G.propertyNameToID("u_NormalTexture"),
    q.SPECULARTEXTURE = G.propertyNameToID("u_SpecularTexture"),
    q.ALBEDOCOLOR = G.propertyNameToID("u_DiffuseColor"),
    q.MATERIALSPECULAR = G.propertyNameToID("u_MaterialSpecular"),
    q.SHININESS = G.propertyNameToID("u_Shininess"),
    q.TILINGOFFSET = G.propertyNameToID("u_TilingOffset"),
    q.CULL = G.propertyNameToID("s_Cull"),
    q.BLEND = G.propertyNameToID("s_Blend"),
    q.BLEND_SRC = G.propertyNameToID("s_BlendSrc"),
    q.BLEND_DST = G.propertyNameToID("s_BlendDst"),
    q.DEPTH_TEST = G.propertyNameToID("s_DepthTest"),
    q.DEPTH_WRITE = G.propertyNameToID("s_DepthWrite");
    var K = function(e) {
        function EffectMaterial() {
            var e;
            return _classCallCheck(this, EffectMaterial),
            (e = _possibleConstructorReturn(this, _getPrototypeOf(EffectMaterial).call(this))).setShaderName("Effect"),
            e._color = new i(1,1,1,1),
            e._shaderValues.setVector(EffectMaterial.TINTCOLOR, new i(1,1,1,1)),
            e.renderMode = EffectMaterial.RENDERMODE_ADDTIVE,
            e;
        }
        return _inherits(EffectMaterial, Z),
        _createClass(EffectMaterial, [{
            key: "clone",
            value: function() {
                var e = new EffectMaterial();
                return this.cloneTo(e),
                e;
            }
        }, {
            key: "_TintColorR",
            get: function() {
                return this._color.x;
            },
            set: function(e) {
                this._color.x = e,
                this.color = this._color;
            }
        }, {
            key: "_TintColorG",
            get: function() {
                return this._color.y;
            },
            set: function(e) {
                this._color.y = e,
                this.color = this._color;
            }
        }, {
            key: "_TintColorB",
            get: function() {
                return this._color.z;
            },
            set: function(e) {
                this._color.z = e,
                this.color = this._color;
            }
        }, {
            key: "_TintColorA",
            get: function() {
                return this._color.w;
            },
            set: function(e) {
                this._color.w = e,
                this.color = this._color;
            }
        }, {
            key: "_MainTex_STX",
            get: function() {
                return this._shaderValues.getVector(EffectMaterial.TILINGOFFSET).x;
            },
            set: function(e) {
                var t = this._shaderValues.getVector(EffectMaterial.TILINGOFFSET);
                t.x = e,
                this.tilingOffset = t;
            }
        }, {
            key: "_MainTex_STY",
            get: function() {
                return this._shaderValues.getVector(EffectMaterial.TILINGOFFSET).y;
            },
            set: function(e) {
                var t = this._shaderValues.getVector(EffectMaterial.TILINGOFFSET);
                t.y = e,
                this.tilingOffset = t;
            }
        }, {
            key: "_MainTex_STZ",
            get: function() {
                return this._shaderValues.getVector(EffectMaterial.TILINGOFFSET).z;
            },
            set: function(e) {
                var t = this._shaderValues.getVector(EffectMaterial.TILINGOFFSET);
                t.z = e,
                this.tilingOffset = t;
            }
        }, {
            key: "_MainTex_STW",
            get: function() {
                return this._shaderValues.getVector(EffectMaterial.TILINGOFFSET).w;
            },
            set: function(e) {
                var t = this._shaderValues.getVector(EffectMaterial.TILINGOFFSET);
                t.w = e,
                this.tilingOffset = t;
            }
        }, {
            key: "renderMode",
            set: function(e) {
                switch (e) {
                case EffectMaterial.RENDERMODE_ADDTIVE:
                    this.renderQueue = Z.RENDERQUEUE_TRANSPARENT,
                    this.alphaTest = !1,
                    this.depthWrite = !1,
                    this.cull = Q.CULL_NONE,
                    this.blend = Q.BLEND_ENABLE_ALL,
                    this.blendSrc = Q.BLENDPARAM_SRC_ALPHA,
                    this.blendDst = Q.BLENDPARAM_ONE,
                    this.depthTest = Q.DEPTHTEST_LESS,
                    this._shaderValues.addDefine(EffectMaterial.SHADERDEFINE_ADDTIVEFOG);
                    break;
                case EffectMaterial.RENDERMODE_ALPHABLENDED:
                    this.renderQueue = Z.RENDERQUEUE_TRANSPARENT,
                    this.alphaTest = !1,
                    this.depthWrite = !1,
                    this.cull = Q.CULL_NONE,
                    this.blend = Q.BLEND_ENABLE_ALL,
                    this.blendSrc = Q.BLENDPARAM_SRC_ALPHA,
                    this.blendDst = Q.BLENDPARAM_ONE_MINUS_SRC_ALPHA,
                    this.depthTest = Q.DEPTHTEST_LESS,
                    this._shaderValues.removeDefine(EffectMaterial.SHADERDEFINE_ADDTIVEFOG);
                    break;
                default:
                    throw new Error("MeshEffectMaterial : renderMode value error.");
                }
            }
        }, {
            key: "colorR",
            get: function() {
                return this._TintColorR;
            },
            set: function(e) {
                this._TintColorR = e;
            }
        }, {
            key: "colorG",
            get: function() {
                return this._TintColorG;
            },
            set: function(e) {
                this._TintColorG = e;
            }
        }, {
            key: "colorB",
            get: function() {
                return this._TintColorB;
            },
            set: function(e) {
                this._TintColorB = e;
            }
        }, {
            key: "colorA",
            get: function() {
                return this._TintColorA;
            },
            set: function(e) {
                this._TintColorA = e;
            }
        }, {
            key: "color",
            get: function() {
                return this._shaderValues.getVector(EffectMaterial.TINTCOLOR);
            },
            set: function(e) {
                this._shaderValues.setVector(EffectMaterial.TINTCOLOR, e);
            }
        }, {
            key: "texture",
            get: function() {
                return this._shaderValues.getTexture(EffectMaterial.MAINTEXTURE);
            },
            set: function(e) {
                e ? this._shaderValues.addDefine(EffectMaterial.SHADERDEFINE_MAINTEXTURE) : this._shaderValues.removeDefine(EffectMaterial.SHADERDEFINE_MAINTEXTURE),
                this._shaderValues.setTexture(EffectMaterial.MAINTEXTURE, e);
            }
        }, {
            key: "tilingOffsetX",
            get: function() {
                return this._MainTex_STX;
            },
            set: function(e) {
                this._MainTex_STX = e;
            }
        }, {
            key: "tilingOffsetY",
            get: function() {
                return this._MainTex_STY;
            },
            set: function(e) {
                this._MainTex_STY = e;
            }
        }, {
            key: "tilingOffsetZ",
            get: function() {
                return this._MainTex_STZ;
            },
            set: function(e) {
                this._MainTex_STZ = e;
            }
        }, {
            key: "tilingOffsetW",
            get: function() {
                return this._MainTex_STW;
            },
            set: function(e) {
                this._MainTex_STW = e;
            }
        }, {
            key: "tilingOffset",
            get: function() {
                return this._shaderValues.getVector(EffectMaterial.TILINGOFFSET);
            },
            set: function(e) {
                e && (1 != e.x || 1 != e.y || 0 != e.z || 0 != e.w) ? this._shaderValues.addDefine(EffectMaterial.SHADERDEFINE_TILINGOFFSET) : this._shaderValues.removeDefine(EffectMaterial.SHADERDEFINE_TILINGOFFSET),
                this._shaderValues.setVector(EffectMaterial.TILINGOFFSET, e);
            }
        }, {
            key: "depthWrite",
            get: function() {
                return this._shaderValues.getBool(EffectMaterial.DEPTH_WRITE);
            },
            set: function(e) {
                this._shaderValues.setBool(EffectMaterial.DEPTH_WRITE, e);
            }
        }, {
            key: "cull",
            get: function() {
                return this._shaderValues.getInt(EffectMaterial.CULL);
            },
            set: function(e) {
                this._shaderValues.setInt(EffectMaterial.CULL, e);
            }
        }, {
            key: "blend",
            get: function() {
                return this._shaderValues.getInt(EffectMaterial.BLEND);
            },
            set: function(e) {
                this._shaderValues.setInt(EffectMaterial.BLEND, e);
            }
        }, {
            key: "blendSrc",
            get: function() {
                return this._shaderValues.getInt(EffectMaterial.BLEND_SRC);
            },
            set: function(e) {
                this._shaderValues.setInt(EffectMaterial.BLEND_SRC, e);
            }
        }, {
            key: "blendDst",
            get: function() {
                return this._shaderValues.getInt(EffectMaterial.BLEND_DST);
            },
            set: function(e) {
                this._shaderValues.setInt(EffectMaterial.BLEND_DST, e);
            }
        }, {
            key: "depthTest",
            get: function() {
                return this._shaderValues.getInt(EffectMaterial.DEPTH_TEST);
            },
            set: function(e) {
                this._shaderValues.setInt(EffectMaterial.DEPTH_TEST, e);
            }
        }], [{
            key: "__initDefine__",
            value: function() {
                EffectMaterial.SHADERDEFINE_MAINTEXTURE = G.getDefineByName("MAINTEXTURE"),
                EffectMaterial.SHADERDEFINE_TILINGOFFSET = G.getDefineByName("TILINGOFFSET"),
                EffectMaterial.SHADERDEFINE_ADDTIVEFOG = G.getDefineByName("ADDTIVEFOG");
            }
        }]),
        EffectMaterial;
    }();
    K.RENDERMODE_ADDTIVE = 0,
    K.RENDERMODE_ALPHABLENDED = 1,
    K.MAINTEXTURE = G.propertyNameToID("u_AlbedoTexture"),
    K.TINTCOLOR = G.propertyNameToID("u_AlbedoColor"),
    K.TILINGOFFSET = G.propertyNameToID("u_TilingOffset"),
    K.CULL = G.propertyNameToID("s_Cull"),
    K.BLEND = G.propertyNameToID("s_Blend"),
    K.BLEND_SRC = G.propertyNameToID("s_BlendSrc"),
    K.BLEND_DST = G.propertyNameToID("s_BlendDst"),
    K.DEPTH_TEST = G.propertyNameToID("s_DepthTest"),
    K.DEPTH_WRITE = G.propertyNameToID("s_DepthWrite");
    var J, $ = function(e) {
        function ExtendTerrainMaterial() {
            var e;
            return _classCallCheck(this, ExtendTerrainMaterial),
            (e = _possibleConstructorReturn(this, _getPrototypeOf(ExtendTerrainMaterial).call(this)))._enableLighting = !0,
            e.setShaderName("ExtendTerrain"),
            e.renderMode = ExtendTerrainMaterial.RENDERMODE_OPAQUE,
            e;
        }
        return _inherits(ExtendTerrainMaterial, Z),
        _createClass(ExtendTerrainMaterial, [{
            key: "_setDetailNum",
            value: function(e) {
                switch (e) {
                case 1:
                    this._shaderValues.addDefine(ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM1),
                    this._shaderValues.removeDefine(ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM2),
                    this._shaderValues.removeDefine(ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM3),
                    this._shaderValues.removeDefine(ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM4),
                    this._shaderValues.removeDefine(ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM5);
                    break;
                case 2:
                    this._shaderValues.addDefine(ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM2),
                    this._shaderValues.removeDefine(ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM1),
                    this._shaderValues.removeDefine(ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM3),
                    this._shaderValues.removeDefine(ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM4),
                    this._shaderValues.removeDefine(ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM5);
                    break;
                case 3:
                    this._shaderValues.addDefine(ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM3),
                    this._shaderValues.removeDefine(ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM1),
                    this._shaderValues.removeDefine(ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM2),
                    this._shaderValues.removeDefine(ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM4),
                    this._shaderValues.removeDefine(ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM5);
                    break;
                case 4:
                    this._shaderValues.addDefine(ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM4),
                    this._shaderValues.removeDefine(ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM1),
                    this._shaderValues.removeDefine(ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM2),
                    this._shaderValues.removeDefine(ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM3),
                    this._shaderValues.removeDefine(ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM5);
                    break;
                case 5:
                    this._shaderValues.addDefine(ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM5),
                    this._shaderValues.removeDefine(ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM1),
                    this._shaderValues.removeDefine(ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM2),
                    this._shaderValues.removeDefine(ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM3),
                    this._shaderValues.removeDefine(ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM4);
                }
            }
        }, {
            key: "clone",
            value: function() {
                var e = new ExtendTerrainMaterial();
                return this.cloneTo(e),
                e;
            }
        }, {
            key: "splatAlphaTexture",
            get: function() {
                return this._shaderValues.getTexture(ExtendTerrainMaterial.SPLATALPHATEXTURE);
            },
            set: function(e) {
                this._shaderValues.setTexture(ExtendTerrainMaterial.SPLATALPHATEXTURE, e);
            }
        }, {
            key: "diffuseTexture1",
            get: function() {
                return this._shaderValues.getTexture(ExtendTerrainMaterial.DIFFUSETEXTURE1);
            },
            set: function(e) {
                this._shaderValues.setTexture(ExtendTerrainMaterial.DIFFUSETEXTURE1, e),
                this._setDetailNum(1);
            }
        }, {
            key: "diffuseTexture2",
            get: function() {
                return this._shaderValues.getTexture(ExtendTerrainMaterial.DIFFUSETEXTURE2);
            },
            set: function(e) {
                this._shaderValues.setTexture(ExtendTerrainMaterial.DIFFUSETEXTURE2, e),
                this._setDetailNum(2);
            }
        }, {
            key: "diffuseTexture3",
            get: function() {
                return this._shaderValues.getTexture(ExtendTerrainMaterial.DIFFUSETEXTURE3);
            },
            set: function(e) {
                this._shaderValues.setTexture(ExtendTerrainMaterial.DIFFUSETEXTURE3, e),
                this._setDetailNum(3);
            }
        }, {
            key: "diffuseTexture4",
            get: function() {
                return this._shaderValues.getTexture(ExtendTerrainMaterial.DIFFUSETEXTURE4);
            },
            set: function(e) {
                this._shaderValues.setTexture(ExtendTerrainMaterial.DIFFUSETEXTURE4, e),
                this._setDetailNum(4);
            }
        }, {
            key: "diffuseTexture5",
            get: function() {
                return this._shaderValues.getTexture(ExtendTerrainMaterial.DIFFUSETEXTURE5);
            },
            set: function(e) {
                this._shaderValues.setTexture(ExtendTerrainMaterial.DIFFUSETEXTURE5, e),
                this._setDetailNum(5);
            }
        }, {
            key: "diffuseScaleOffset1",
            set: function(e) {
                this._shaderValues.setVector(ExtendTerrainMaterial.DIFFUSESCALEOFFSET1, e);
            }
        }, {
            key: "diffuseScaleOffset2",
            set: function(e) {
                this._shaderValues.setVector(ExtendTerrainMaterial.DIFFUSESCALEOFFSET2, e);
            }
        }, {
            key: "diffuseScaleOffset3",
            set: function(e) {
                this._shaderValues.setVector(ExtendTerrainMaterial.DIFFUSESCALEOFFSET3, e);
            }
        }, {
            key: "diffuseScaleOffset4",
            set: function(e) {
                this._shaderValues.setVector(ExtendTerrainMaterial.DIFFUSESCALEOFFSET4, e);
            }
        }, {
            key: "diffuseScaleOffset5",
            set: function(e) {
                this._shaderValues.setVector(ExtendTerrainMaterial.DIFFUSESCALEOFFSET5, e);
            }
        }, {
            key: "renderMode",
            set: function(e) {
                switch (e) {
                case ExtendTerrainMaterial.RENDERMODE_OPAQUE:
                    this.renderQueue = Z.RENDERQUEUE_OPAQUE,
                    this.depthWrite = !0,
                    this.cull = Q.CULL_BACK,
                    this.blend = Q.BLEND_DISABLE,
                    this.depthTest = Q.DEPTHTEST_LESS;
                    break;
                case ExtendTerrainMaterial.RENDERMODE_TRANSPARENT:
                    this.renderQueue = Z.RENDERQUEUE_OPAQUE,
                    this.depthWrite = !1,
                    this.cull = Q.CULL_BACK,
                    this.blend = Q.BLEND_ENABLE_ALL,
                    this.blendSrc = Q.BLENDPARAM_SRC_ALPHA,
                    this.blendDst = Q.BLENDPARAM_ONE_MINUS_SRC_ALPHA,
                    this.depthTest = Q.DEPTHTEST_LEQUAL;
                    break;
                default:
                    throw new Error("ExtendTerrainMaterial:renderMode value error.");
                }
            }
        }, {
            key: "depthWrite",
            get: function() {
                return this._shaderValues.getBool(ExtendTerrainMaterial.DEPTH_WRITE);
            },
            set: function(e) {
                this._shaderValues.setBool(ExtendTerrainMaterial.DEPTH_WRITE, e);
            }
        }, {
            key: "cull",
            get: function() {
                return this._shaderValues.getInt(ExtendTerrainMaterial.CULL);
            },
            set: function(e) {
                this._shaderValues.setInt(ExtendTerrainMaterial.CULL, e);
            }
        }, {
            key: "blend",
            get: function() {
                return this._shaderValues.getInt(ExtendTerrainMaterial.BLEND);
            },
            set: function(e) {
                this._shaderValues.setInt(ExtendTerrainMaterial.BLEND, e);
            }
        }, {
            key: "blendSrc",
            get: function() {
                return this._shaderValues.getInt(ExtendTerrainMaterial.BLEND_SRC);
            },
            set: function(e) {
                this._shaderValues.setInt(ExtendTerrainMaterial.BLEND_SRC, e);
            }
        }, {
            key: "blendDst",
            get: function() {
                return this._shaderValues.getInt(ExtendTerrainMaterial.BLEND_DST);
            },
            set: function(e) {
                this._shaderValues.setInt(ExtendTerrainMaterial.BLEND_DST, e);
            }
        }, {
            key: "depthTest",
            get: function() {
                return this._shaderValues.getInt(ExtendTerrainMaterial.DEPTH_TEST);
            },
            set: function(e) {
                this._shaderValues.setInt(ExtendTerrainMaterial.DEPTH_TEST, e);
            }
        }], [{
            key: "__initDefine__",
            value: function() {
                ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM1 = G.getDefineByName("ExtendTerrain_DETAIL_NUM1"),
                ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM2 = G.getDefineByName("ExtendTerrain_DETAIL_NUM2"),
                ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM3 = G.getDefineByName("ExtendTerrain_DETAIL_NUM3"),
                ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM4 = G.getDefineByName("ExtendTerrain_DETAIL_NUM4"),
                ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM5 = G.getDefineByName("ExtendTerrain_DETAIL_NUM5");
            }
        }]),
        ExtendTerrainMaterial;
    }();
    $.RENDERMODE_OPAQUE = 1,
    $.RENDERMODE_TRANSPARENT = 2,
    $.SPLATALPHATEXTURE = G.propertyNameToID("u_SplatAlphaTexture"),
    $.DIFFUSETEXTURE1 = G.propertyNameToID("u_DiffuseTexture1"),
    $.DIFFUSETEXTURE2 = G.propertyNameToID("u_DiffuseTexture2"),
    $.DIFFUSETEXTURE3 = G.propertyNameToID("u_DiffuseTexture3"),
    $.DIFFUSETEXTURE4 = G.propertyNameToID("u_DiffuseTexture4"),
    $.DIFFUSETEXTURE5 = G.propertyNameToID("u_DiffuseTexture5"),
    $.DIFFUSESCALEOFFSET1 = G.propertyNameToID("u_DiffuseScaleOffset1"),
    $.DIFFUSESCALEOFFSET2 = G.propertyNameToID("u_DiffuseScaleOffset2"),
    $.DIFFUSESCALEOFFSET3 = G.propertyNameToID("u_DiffuseScaleOffset3"),
    $.DIFFUSESCALEOFFSET4 = G.propertyNameToID("u_DiffuseScaleOffset4"),
    $.DIFFUSESCALEOFFSET5 = G.propertyNameToID("u_DiffuseScaleOffset5"),
    $.CULL = G.propertyNameToID("s_Cull"),
    $.BLEND = G.propertyNameToID("s_Blend"),
    $.BLEND_SRC = G.propertyNameToID("s_BlendSrc"),
    $.BLEND_DST = G.propertyNameToID("s_BlendDst"),
    $.DEPTH_TEST = G.propertyNameToID("s_DepthTest"),
    $.DEPTH_WRITE = G.propertyNameToID("s_DepthWrite"),
    (J = e.PBRRenderMode || (e.PBRRenderMode = {}))[J.Opaque = 0] = "Opaque",
    J[J.Cutout = 1] = "Cutout",
    J[J.Fade = 2] = "Fade",
    J[J.Transparent = 3] = "Transparent";
    var ee = function(t) {
        function PBRMaterial() {
            var t;
            return _classCallCheck(this, PBRMaterial),
            (t = _possibleConstructorReturn(this, _getPrototypeOf(PBRMaterial).call(this)))._enableEmission = !1,
            t._shaderValues.setVector(PBRMaterial.ALBEDOCOLOR, new i(1,1,1,1)),
            t._shaderValues.setVector(PBRMaterial.EMISSIONCOLOR, new i(1,1,1,1)),
            t._shaderValues.setNumber(PBRMaterial.SMOOTHNESS, .5),
            t._shaderValues.setNumber(PBRMaterial.SMOOTHNESSSCALE, 1),
            t._shaderValues.setNumber(PBRMaterial.OCCLUSIONSTRENGTH, 1),
            t._shaderValues.setNumber(PBRMaterial.NORMALSCALE, 1),
            t._shaderValues.setNumber(PBRMaterial.PARALLAXSCALE, .001),
            t._shaderValues.setNumber(Z.ALPHATESTVALUE, .5),
            t.renderMode = e.PBRRenderMode.Opaque,
            t;
        }
        return _inherits(PBRMaterial, Z),
        _createClass(PBRMaterial, [{
            key: "albedoColor",
            get: function() {
                return this._shaderValues.getVector(PBRMaterial.ALBEDOCOLOR);
            },
            set: function(e) {
                this._shaderValues.setVector(PBRMaterial.ALBEDOCOLOR, e);
            }
        }, {
            key: "albedoTexture",
            get: function() {
                return this._shaderValues.getTexture(PBRMaterial.ALBEDOTEXTURE);
            },
            set: function(e) {
                e ? this._shaderValues.addDefine(PBRMaterial.SHADERDEFINE_ALBEDOTEXTURE) : this._shaderValues.removeDefine(PBRMaterial.SHADERDEFINE_ALBEDOTEXTURE),
                this._shaderValues.setTexture(PBRMaterial.ALBEDOTEXTURE, e);
            }
        }, {
            key: "normalTexture",
            get: function() {
                return this._shaderValues.getTexture(PBRMaterial.NORMALTEXTURE);
            },
            set: function(e) {
                e ? this._shaderValues.addDefine(PBRMaterial.SHADERDEFINE_NORMALTEXTURE) : this._shaderValues.removeDefine(PBRMaterial.SHADERDEFINE_NORMALTEXTURE),
                this._shaderValues.setTexture(PBRMaterial.NORMALTEXTURE, e);
            }
        }, {
            key: "normalTextureScale",
            get: function() {
                return this._shaderValues.getNumber(PBRMaterial.NORMALSCALE);
            },
            set: function(e) {
                this._shaderValues.setNumber(PBRMaterial.NORMALSCALE, e);
            }
        }, {
            key: "parallaxTexture",
            get: function() {
                return this._shaderValues.getTexture(PBRMaterial.PARALLAXTEXTURE);
            },
            set: function(e) {
                e ? this._shaderValues.addDefine(PBRMaterial.SHADERDEFINE_PARALLAXTEXTURE) : this._shaderValues.removeDefine(PBRMaterial.SHADERDEFINE_PARALLAXTEXTURE),
                this._shaderValues.setTexture(PBRMaterial.PARALLAXTEXTURE, e);
            }
        }, {
            key: "parallaxTextureScale",
            get: function() {
                return this._shaderValues.getNumber(PBRMaterial.PARALLAXSCALE);
            },
            set: function(e) {
                this._shaderValues.setNumber(PBRMaterial.PARALLAXSCALE, Math.max(.005, Math.min(.08, e)));
            }
        }, {
            key: "occlusionTexture",
            get: function() {
                return this._shaderValues.getTexture(PBRMaterial.OCCLUSIONTEXTURE);
            },
            set: function(e) {
                e ? this._shaderValues.addDefine(PBRMaterial.SHADERDEFINE_OCCLUSIONTEXTURE) : this._shaderValues.removeDefine(PBRMaterial.SHADERDEFINE_OCCLUSIONTEXTURE),
                this._shaderValues.setTexture(PBRMaterial.OCCLUSIONTEXTURE, e);
            }
        }, {
            key: "occlusionTextureStrength",
            get: function() {
                return this._shaderValues.getNumber(PBRMaterial.OCCLUSIONSTRENGTH);
            },
            set: function(e) {
                this._shaderValues.setNumber(PBRMaterial.OCCLUSIONSTRENGTH, Math.max(0, Math.min(1, e)));
            }
        }, {
            key: "smoothness",
            get: function() {
                return this._shaderValues.getNumber(PBRMaterial.SMOOTHNESS);
            },
            set: function(e) {
                this._shaderValues.setNumber(PBRMaterial.SMOOTHNESS, Math.max(0, Math.min(1, e)));
            }
        }, {
            key: "smoothnessTextureScale",
            get: function() {
                return this._shaderValues.getNumber(PBRMaterial.SMOOTHNESSSCALE);
            },
            set: function(e) {
                this._shaderValues.setNumber(PBRMaterial.SMOOTHNESSSCALE, Math.max(0, Math.min(1, e)));
            }
        }, {
            key: "enableEmission",
            get: function() {
                return this._enableEmission;
            },
            set: function(e) {
                e ? this._shaderValues.addDefine(PBRMaterial.SHADERDEFINE_EMISSION) : this._shaderValues.removeDefine(PBRMaterial.SHADERDEFINE_EMISSION),
                this._enableEmission = e;
            }
        }, {
            key: "emissionColor",
            get: function() {
                return this._shaderValues.getVector(PBRMaterial.EMISSIONCOLOR);
            },
            set: function(e) {
                this._shaderValues.setVector(PBRMaterial.EMISSIONCOLOR, e);
            }
        }, {
            key: "emissionTexture",
            get: function() {
                return this._shaderValues.getTexture(PBRMaterial.EMISSIONTEXTURE);
            },
            set: function(e) {
                e ? this._shaderValues.addDefine(PBRMaterial.SHADERDEFINE_EMISSIONTEXTURE) : this._shaderValues.removeDefine(PBRMaterial.SHADERDEFINE_EMISSIONTEXTURE),
                this._shaderValues.setTexture(PBRMaterial.EMISSIONTEXTURE, e);
            }
        }, {
            key: "tilingOffset",
            get: function() {
                return this._shaderValues.getVector(PBRMaterial.TILINGOFFSET);
            },
            set: function(e) {
                e && (1 != e.x || 1 != e.y || 0 != e.z || 0 != e.w) ? this._shaderValues.addDefine(PBRMaterial.SHADERDEFINE_TILINGOFFSET) : this._shaderValues.removeDefine(PBRMaterial.SHADERDEFINE_TILINGOFFSET),
                this._shaderValues.setVector(PBRMaterial.TILINGOFFSET, e);
            }
        }, {
            key: "depthWrite",
            get: function() {
                return this._shaderValues.getBool(PBRMaterial.DEPTH_WRITE);
            },
            set: function(e) {
                this._shaderValues.setBool(PBRMaterial.DEPTH_WRITE, e);
            }
        }, {
            key: "cull",
            get: function() {
                return this._shaderValues.getInt(PBRMaterial.CULL);
            },
            set: function(e) {
                this._shaderValues.setInt(PBRMaterial.CULL, e);
            }
        }, {
            key: "blend",
            get: function() {
                return this._shaderValues.getInt(PBRMaterial.BLEND);
            },
            set: function(e) {
                this._shaderValues.setInt(PBRMaterial.BLEND, e);
            }
        }, {
            key: "blendSrc",
            get: function() {
                return this._shaderValues.getInt(PBRMaterial.BLEND_SRC);
            },
            set: function(e) {
                this._shaderValues.setInt(PBRMaterial.BLEND_SRC, e);
            }
        }, {
            key: "blendDst",
            get: function() {
                return this._shaderValues.getInt(PBRMaterial.BLEND_DST);
            },
            set: function(e) {
                this._shaderValues.setInt(PBRMaterial.BLEND_DST, e);
            }
        }, {
            key: "depthTest",
            get: function() {
                return this._shaderValues.getInt(PBRMaterial.DEPTH_TEST);
            },
            set: function(e) {
                this._shaderValues.setInt(PBRMaterial.DEPTH_TEST, e);
            }
        }, {
            key: "renderMode",
            set: function(t) {
                switch (t) {
                case e.PBRRenderMode.Opaque:
                    this.alphaTest = !1,
                    this.renderQueue = Z.RENDERQUEUE_OPAQUE,
                    this.depthWrite = !0,
                    this.cull = Q.CULL_BACK,
                    this.blend = Q.BLEND_DISABLE,
                    this.depthTest = Q.DEPTHTEST_LESS,
                    this._shaderValues.removeDefine(PBRMaterial.SHADERDEFINE_TRANSPARENTBLEND);
                    break;
                case e.PBRRenderMode.Cutout:
                    this.renderQueue = Z.RENDERQUEUE_ALPHATEST,
                    this.alphaTest = !0,
                    this.depthWrite = !0,
                    this.cull = Q.CULL_BACK,
                    this.blend = Q.BLEND_DISABLE,
                    this.depthTest = Q.DEPTHTEST_LESS,
                    this._shaderValues.removeDefine(PBRMaterial.SHADERDEFINE_TRANSPARENTBLEND);
                    break;
                case e.PBRRenderMode.Fade:
                    this.renderQueue = Z.RENDERQUEUE_TRANSPARENT,
                    this.alphaTest = !1,
                    this.depthWrite = !1,
                    this.cull = Q.CULL_BACK,
                    this.blend = Q.BLEND_ENABLE_ALL,
                    this.blendSrc = Q.BLENDPARAM_SRC_ALPHA,
                    this.blendDst = Q.BLENDPARAM_ONE_MINUS_SRC_ALPHA,
                    this.depthTest = Q.DEPTHTEST_LESS,
                    this._shaderValues.removeDefine(PBRMaterial.SHADERDEFINE_TRANSPARENTBLEND);
                    break;
                case e.PBRRenderMode.Transparent:
                    this.renderQueue = Z.RENDERQUEUE_TRANSPARENT,
                    this.alphaTest = !1,
                    this.depthWrite = !1,
                    this.cull = Q.CULL_BACK,
                    this.blend = Q.BLEND_ENABLE_ALL,
                    this.blendSrc = Q.BLENDPARAM_ONE,
                    this.blendDst = Q.BLENDPARAM_ONE_MINUS_SRC_ALPHA,
                    this.depthTest = Q.DEPTHTEST_LESS,
                    this._shaderValues.addDefine(PBRMaterial.SHADERDEFINE_TRANSPARENTBLEND);
                    break;
                default:
                    throw new Error("PBRMaterial:unknown renderMode value.");
                }
            }
        }, {
            key: "enableReflection",
            get: function() {
                return !0;
            },
            set: function(e) {}
        }], [{
            key: "__init__",
            value: function() {
                PBRMaterial.SHADERDEFINE_ALBEDOTEXTURE = G.getDefineByName("ALBEDOTEXTURE"),
                PBRMaterial.SHADERDEFINE_NORMALTEXTURE = G.getDefineByName("NORMALTEXTURE"),
                PBRMaterial.SHADERDEFINE_PARALLAXTEXTURE = G.getDefineByName("PARALLAXTEXTURE"),
                PBRMaterial.SHADERDEFINE_OCCLUSIONTEXTURE = G.getDefineByName("OCCLUSIONTEXTURE"),
                PBRMaterial.SHADERDEFINE_EMISSION = G.getDefineByName("EMISSION"),
                PBRMaterial.SHADERDEFINE_EMISSIONTEXTURE = G.getDefineByName("EMISSIONTEXTURE"),
                PBRMaterial.SHADERDEFINE_TILINGOFFSET = G.getDefineByName("TILINGOFFSET"),
                PBRMaterial.SHADERDEFINE_TRANSPARENTBLEND = G.getDefineByName("TRANSPARENTBLEND"),
                PBRMaterial.SHADERDEFINE_LAYA_PBR_BRDF_HIGH = G.getDefineByName("LAYA_PBR_BRDF_HIGH"),
                PBRMaterial.SHADERDEFINE_LAYA_PBR_BRDF_LOW = G.getDefineByName("LAYA_PBR_BRDF_LOW");
            }
        }]),
        PBRMaterial;
    }();
    ee.ALBEDOTEXTURE = G.propertyNameToID("u_AlbedoTexture"),
    ee.ALBEDOCOLOR = G.propertyNameToID("u_AlbedoColor"),
    ee.TILINGOFFSET = G.propertyNameToID("u_TilingOffset"),
    ee.NORMALTEXTURE = G.propertyNameToID("u_NormalTexture"),
    ee.NORMALSCALE = G.propertyNameToID("u_NormalScale"),
    ee.SMOOTHNESS = G.propertyNameToID("u_Smoothness"),
    ee.SMOOTHNESSSCALE = G.propertyNameToID("u_SmoothnessScale"),
    ee.OCCLUSIONTEXTURE = G.propertyNameToID("u_OcclusionTexture"),
    ee.OCCLUSIONSTRENGTH = G.propertyNameToID("u_occlusionStrength"),
    ee.PARALLAXTEXTURE = G.propertyNameToID("u_ParallaxTexture"),
    ee.PARALLAXSCALE = G.propertyNameToID("u_ParallaxScale"),
    ee.EMISSIONTEXTURE = G.propertyNameToID("u_EmissionTexture"),
    ee.EMISSIONCOLOR = G.propertyNameToID("u_EmissionColor"),
    ee.CULL = G.propertyNameToID("s_Cull"),
    ee.BLEND = G.propertyNameToID("s_Blend"),
    ee.BLEND_SRC = G.propertyNameToID("s_BlendSrc"),
    ee.BLEND_DST = G.propertyNameToID("s_BlendDst"),
    ee.DEPTH_TEST = G.propertyNameToID("s_DepthTest"),
    ee.DEPTH_WRITE = G.propertyNameToID("s_DepthWrite"),
    ee.renderQuality = e.PBRRenderQuality.High;
    var te = function ShaderVariable() {
        _classCallCheck(this, ShaderVariable),
        this.textureID = -1;
    }
      , re = function(e) {
        function ShaderInstance(e, t, r, n, i) {
            var a;
            return _classCallCheck(this, ShaderInstance),
            (a = _possibleConstructorReturn(this, _getPrototypeOf(ShaderInstance).call(this)))._stateParamsMap = [],
            a._uploadMark = -1,
            a._uploadRenderType = -1,
            a._vs = e,
            a._ps = t,
            a._attributeMap = r,
            a._uniformMap = n,
            a._shaderPass = i,
            a._create(),
            a.lock = !0,
            a;
        }
        return _inherits(ShaderInstance, t.Resource),
        _createClass(ShaderInstance, [{
            key: "_create",
            value: function() {
                var e = t.LayaGL.instance;
                for (var r in this._program = e.createProgram(),
                this._vshader = this._createShader(e, this._vs, e.VERTEX_SHADER),
                this._pshader = this._createShader(e, this._ps, e.FRAGMENT_SHADER),
                e.attachShader(this._program, this._vshader),
                e.attachShader(this._program, this._pshader),
                this._attributeMap)
                    e.bindAttribLocation(this._program, this._attributeMap[r], r);
                if (e.linkProgram(this._program),
                !t.Render.isConchApp && G.debugMode && !e.getProgramParameter(this._program, e.LINK_STATUS))
                    throw e.getProgramInfoLog(this._program);
                var n = []
                  , i = []
                  , a = []
                  , o = []
                  , s = [];
                this._customUniformParamsMap = [];
                var l, u, c, h = e.getProgramParameter(this._program, e.ACTIVE_UNIFORMS);
                for (t.WebGLContext.useProgram(e, this._program),
                this._curActTexIndex = 0,
                u = 0; u < h; u++) {
                    var _ = e.getActiveUniform(this._program, u)
                      , d = _.name;
                    (l = new te()).location = e.getUniformLocation(this._program, d),
                    d.indexOf("[0]") > 0 ? (l.name = d = d.substr(0, d.length - 3),
                    l.isArray = !0) : (l.name = d,
                    l.isArray = !1),
                    l.type = _.type,
                    this._addShaderUnifiormFun(l);
                    var f = this._uniformMap[d];
                    if (null != f)
                        switch (l.dataOffset = G.propertyNameToID(d),
                        f) {
                        case G.PERIOD_CUSTOM:
                            s.push(l);
                            break;
                        case G.PERIOD_MATERIAL:
                            o.push(l);
                            break;
                        case G.PERIOD_SPRITE:
                            a.push(l);
                            break;
                        case G.PERIOD_CAMERA:
                            i.push(l);
                            break;
                        case G.PERIOD_SCENE:
                            n.push(l);
                            break;
                        default:
                            throw new Error("Shader3D: period is unkonw.");
                        }
                }
                for (this._sceneUniformParamsMap = t.LayaGL.instance.createCommandEncoder(4 * n.length * 5 + 4, 64, !0),
                u = 0,
                c = n.length; u < c; u++)
                    this._sceneUniformParamsMap.addShaderUniform(n[u]);
                for (this._cameraUniformParamsMap = t.LayaGL.instance.createCommandEncoder(4 * i.length * 5 + 4, 64, !0),
                u = 0,
                c = i.length; u < c; u++)
                    this._cameraUniformParamsMap.addShaderUniform(i[u]);
                for (this._spriteUniformParamsMap = t.LayaGL.instance.createCommandEncoder(4 * a.length * 5 + 4, 64, !0),
                u = 0,
                c = a.length; u < c; u++)
                    this._spriteUniformParamsMap.addShaderUniform(a[u]);
                for (this._materialUniformParamsMap = t.LayaGL.instance.createCommandEncoder(4 * o.length * 5 + 4, 64, !0),
                u = 0,
                c = o.length; u < c; u++)
                    this._materialUniformParamsMap.addShaderUniform(o[u]);
                for (this._customUniformParamsMap.length = s.length,
                u = 0,
                c = s.length; u < c; u++) {
                    var m = s[u];
                    this._customUniformParamsMap[m.dataOffset] = m;
                }
                var p = this._shaderPass._stateMap;
                for (var v in p)
                    this._stateParamsMap[p[v]] = G.propertyNameToID(v);
            }
        }, {
            key: "_getRenderState",
            value: function(e, t) {
                var r = this._stateParamsMap[t];
                return null == r ? null : e[r];
            }
        }, {
            key: "_disposeResource",
            value: function() {
                t.LayaGL.instance.deleteShader(this._vshader),
                t.LayaGL.instance.deleteShader(this._pshader),
                t.LayaGL.instance.deleteProgram(this._program),
                this._vshader = this._pshader = this._program = null,
                this._setGPUMemory(0),
                this._curActTexIndex = 0;
            }
        }, {
            key: "_addShaderUnifiormFun",
            value: function(e) {
                var r = t.LayaGL.instance;
                e.caller = this;
                var n = e.isArray;
                switch (e.type) {
                case r.BOOL:
                    e.fun = this._uniform1i,
                    e.uploadedValue = new Array(1);
                    break;
                case r.INT:
                    e.fun = n ? this._uniform1iv : this._uniform1i,
                    e.uploadedValue = new Array(1);
                    break;
                case r.FLOAT:
                    e.fun = n ? this._uniform1fv : this._uniform1f,
                    e.uploadedValue = new Array(1);
                    break;
                case r.FLOAT_VEC2:
                    e.fun = n ? this._uniform_vec2v : this._uniform_vec2,
                    e.uploadedValue = new Array(2);
                    break;
                case r.FLOAT_VEC3:
                    e.fun = n ? this._uniform_vec3v : this._uniform_vec3,
                    e.uploadedValue = new Array(3);
                    break;
                case r.FLOAT_VEC4:
                    e.fun = n ? this._uniform_vec4v : this._uniform_vec4,
                    e.uploadedValue = new Array(4);
                    break;
                case r.FLOAT_MAT2:
                    e.fun = this._uniformMatrix2fv;
                    break;
                case r.FLOAT_MAT3:
                    e.fun = this._uniformMatrix3fv;
                    break;
                case r.FLOAT_MAT4:
                    e.fun = n ? this._uniformMatrix4fv : this._uniformMatrix4f;
                    break;
                case r.SAMPLER_2D:
                    r.uniform1i(e.location, this._curActTexIndex),
                    e.textureID = t.WebGLContext._glTextureIDs[this._curActTexIndex++],
                    e.fun = this._uniform_sampler2D;
                    break;
                case 35679:
                    r.uniform1i(e.location, this._curActTexIndex),
                    e.textureID = t.WebGLContext._glTextureIDs[this._curActTexIndex++],
                    e.fun = this._uniform_sampler3D;
                    break;
                case r.SAMPLER_CUBE:
                    r.uniform1i(e.location, this._curActTexIndex),
                    e.textureID = t.WebGLContext._glTextureIDs[this._curActTexIndex++],
                    e.fun = this._uniform_samplerCube;
                    break;
                default:
                    throw new Error("compile shader err!");
                }
            }
        }, {
            key: "_createShader",
            value: function(e, t, r) {
                var n = e.createShader(r);
                if (e.shaderSource(n, t),
                e.compileShader(n),
                G.debugMode && !e.getShaderParameter(n, e.COMPILE_STATUS))
                    throw e.getShaderInfoLog(n);
                return n;
            }
        }, {
            key: "_uniform1f",
            value: function(e, r) {
                var n = e.uploadedValue;
                return n[0] !== r ? (t.LayaGL.instance.uniform1f(e.location, n[0] = r),
                1) : 0;
            }
        }, {
            key: "_uniform1fv",
            value: function(e, r) {
                if (r.length < 4) {
                    var n = e.uploadedValue;
                    return n[0] !== r[0] || n[1] !== r[1] || n[2] !== r[2] || n[3] !== r[3] ? (t.LayaGL.instance.uniform1fv(e.location, r),
                    n[0] = r[0],
                    n[1] = r[1],
                    n[2] = r[2],
                    n[3] = r[3],
                    1) : 0;
                }
                return t.LayaGL.instance.uniform1fv(e.location, r),
                1;
            }
        }, {
            key: "_uniform_vec2",
            value: function(e, r) {
                var n = e.uploadedValue;
                return n[0] !== r.x || n[1] !== r.y ? (t.LayaGL.instance.uniform2f(e.location, n[0] = r.x, n[1] = r.y),
                1) : 0;
            }
        }, {
            key: "_uniform_vec2v",
            value: function(e, r) {
                if (r.length < 2) {
                    var n = e.uploadedValue;
                    return n[0] !== r[0] || n[1] !== r[1] || n[2] !== r[2] || n[3] !== r[3] ? (t.LayaGL.instance.uniform2fv(e.location, r),
                    n[0] = r[0],
                    n[1] = r[1],
                    n[2] = r[2],
                    n[3] = r[3],
                    1) : 0;
                }
                return t.LayaGL.instance.uniform2fv(e.location, r),
                1;
            }
        }, {
            key: "_uniform_vec3",
            value: function(e, r) {
                var n = e.uploadedValue;
                return n[0] !== r.x || n[1] !== r.y || n[2] !== r.z ? (t.LayaGL.instance.uniform3f(e.location, n[0] = r.x, n[1] = r.y, n[2] = r.z),
                1) : 0;
            }
        }, {
            key: "_uniform_vec3v",
            value: function(e, r) {
                return t.LayaGL.instance.uniform3fv(e.location, r),
                1;
            }
        }, {
            key: "_uniform_vec4",
            value: function(e, r) {
                var n = e.uploadedValue;
                return n[0] !== r.x || n[1] !== r.y || n[2] !== r.z || n[3] !== r.w ? (t.LayaGL.instance.uniform4f(e.location, n[0] = r.x, n[1] = r.y, n[2] = r.z, n[3] = r.w),
                1) : 0;
            }
        }, {
            key: "_uniform_vec4v",
            value: function(e, r) {
                return t.LayaGL.instance.uniform4fv(e.location, r),
                1;
            }
        }, {
            key: "_uniformMatrix2fv",
            value: function(e, r) {
                return t.LayaGL.instance.uniformMatrix2fv(e.location, !1, r),
                1;
            }
        }, {
            key: "_uniformMatrix3fv",
            value: function(e, r) {
                return t.LayaGL.instance.uniformMatrix3fv(e.location, !1, r),
                1;
            }
        }, {
            key: "_uniformMatrix4f",
            value: function(e, r) {
                var n = r.elements;
                return t.LayaGL.instance.uniformMatrix4fv(e.location, !1, n),
                1;
            }
        }, {
            key: "_uniformMatrix4fv",
            value: function(e, r) {
                return t.LayaGL.instance.uniformMatrix4fv(e.location, !1, r),
                1;
            }
        }, {
            key: "_uniform1i",
            value: function(e, r) {
                var n = e.uploadedValue;
                return n[0] !== r ? (t.LayaGL.instance.uniform1i(e.location, n[0] = r),
                1) : 0;
            }
        }, {
            key: "_uniform1iv",
            value: function(e, r) {
                return t.LayaGL.instance.uniform1iv(e.location, r),
                1;
            }
        }, {
            key: "_uniform_ivec2",
            value: function(e, r) {
                var n = e.uploadedValue;
                return n[0] !== r[0] || n[1] !== r[1] ? (t.LayaGL.instance.uniform2i(e.location, n[0] = r[0], n[1] = r[1]),
                1) : 0;
            }
        }, {
            key: "_uniform_ivec2v",
            value: function(e, r) {
                return t.LayaGL.instance.uniform2iv(e.location, r),
                1;
            }
        }, {
            key: "_uniform_vec3i",
            value: function(e, r) {
                var n = e.uploadedValue;
                return n[0] !== r[0] || n[1] !== r[1] || n[2] !== r[2] ? (t.LayaGL.instance.uniform3i(e.location, n[0] = r[0], n[1] = r[1], n[2] = r[2]),
                1) : 0;
            }
        }, {
            key: "_uniform_vec3vi",
            value: function(e, r) {
                return t.LayaGL.instance.uniform3iv(e.location, r),
                1;
            }
        }, {
            key: "_uniform_vec4i",
            value: function(e, r) {
                var n = e.uploadedValue;
                return n[0] !== r[0] || n[1] !== r[1] || n[2] !== r[2] || n[3] !== r[3] ? (t.LayaGL.instance.uniform4i(e.location, n[0] = r[0], n[1] = r[1], n[2] = r[2], n[3] = r[3]),
                1) : 0;
            }
        }, {
            key: "_uniform_vec4vi",
            value: function(e, r) {
                return t.LayaGL.instance.uniform4iv(e.location, r),
                1;
            }
        }, {
            key: "_uniform_sampler2D",
            value: function(e, r) {
                var n = r._getSource() || r.defaulteTexture._getSource()
                  , i = t.LayaGL.instance;
                return t.WebGLContext.activeTexture(i, e.textureID),
                t.WebGLContext.bindTexture(i, i.TEXTURE_2D, n),
                0;
            }
        }, {
            key: "_uniform_sampler3D",
            value: function(e, r) {
                var n = r._getSource() || r.defaulteTexture._getSource()
                  , i = t.LayaGL.instance;
                return t.WebGLContext.activeTexture(i, e.textureID),
                t.WebGLContext.bindTexture(i, WebGL2RenderingContext.TEXTURE_3D, n),
                0;
            }
        }, {
            key: "_uniform_samplerCube",
            value: function(e, r) {
                var n = r._getSource() || r.defaulteTexture._getSource()
                  , i = t.LayaGL.instance;
                return t.WebGLContext.activeTexture(i, e.textureID),
                t.WebGLContext.bindTexture(i, i.TEXTURE_CUBE_MAP, n),
                0;
            }
        }, {
            key: "bind",
            value: function() {
                return t.WebGLContext.useProgram(t.LayaGL.instance, this._program);
            }
        }, {
            key: "uploadUniforms",
            value: function(e, r, n) {
                t.Stat.shaderCall += t.LayaGLRunner.uploadShaderUniforms(t.LayaGL.instance, e, r, n);
            }
        }, {
            key: "uploadRenderStateBlendDepth",
            value: function(e) {
                var r = t.LayaGL.instance
                  , n = this._shaderPass.renderState
                  , i = e.getData()
                  , a = this._getRenderState(i, G.RENDER_STATE_DEPTH_WRITE)
                  , o = this._getRenderState(i, G.RENDER_STATE_DEPTH_TEST)
                  , s = this._getRenderState(i, G.RENDER_STATE_BLEND);
                switch (null == a && (a = n.depthWrite),
                null == o && (o = n.depthTest),
                null == s && (s = n.blend),
                t.WebGLContext.setDepthMask(r, a),
                o === Q.DEPTHTEST_OFF ? t.WebGLContext.setDepthTest(r, !1) : (t.WebGLContext.setDepthTest(r, !0),
                t.WebGLContext.setDepthFunc(r, o)),
                s) {
                case Q.BLEND_DISABLE:
                    t.WebGLContext.setBlend(r, !1);
                    break;
                case Q.BLEND_ENABLE_ALL:
                    var l = this._getRenderState(i, G.RENDER_STATE_BLEND_EQUATION)
                      , u = this._getRenderState(i, G.RENDER_STATE_BLEND_SRC)
                      , c = this._getRenderState(i, G.RENDER_STATE_BLEND_DST);
                    null == l && (l = n.blendEquation),
                    null == u && (u = n.srcBlend),
                    null == c && (c = n.dstBlend),
                    t.WebGLContext.setBlend(r, !0),
                    t.WebGLContext.setBlendEquation(r, l),
                    t.WebGLContext.setBlendFunc(r, u, c);
                    break;
                case Q.BLEND_ENABLE_SEPERATE:
                    var h = this._getRenderState(i, G.RENDER_STATE_BLEND_EQUATION_RGB)
                      , _ = this._getRenderState(i, G.RENDER_STATE_BLEND_EQUATION_ALPHA)
                      , d = this._getRenderState(i, G.RENDER_STATE_BLEND_SRC_RGB)
                      , f = this._getRenderState(i, G.RENDER_STATE_BLEND_DST_RGB)
                      , m = this._getRenderState(i, G.RENDER_STATE_BLEND_SRC_ALPHA)
                      , p = this._getRenderState(i, G.RENDER_STATE_BLEND_DST_ALPHA);
                    null == h && (h = n.blendEquationRGB),
                    null == _ && (_ = n.blendEquationAlpha),
                    null == d && (d = n.srcBlendRGB),
                    null == f && (f = n.dstBlendRGB),
                    null == m && (m = n.srcBlendAlpha),
                    null == p && (p = n.dstBlendAlpha),
                    t.WebGLContext.setBlend(r, !0),
                    t.WebGLContext.setBlendEquationSeparate(r, h, _),
                    t.WebGLContext.setBlendFuncSeperate(r, d, f, m, p);
                }
            }
        }, {
            key: "uploadRenderStateFrontFace",
            value: function(e, r, n) {
                var i, a = t.LayaGL.instance, o = this._shaderPass.renderState, s = e.getData(), l = this._getRenderState(s, G.RENDER_STATE_CULL);
                switch (null == l && (l = o.cull),
                l) {
                case Q.CULL_NONE:
                    t.WebGLContext.setCullFace(a, !1);
                    break;
                case Q.CULL_FRONT:
                    t.WebGLContext.setCullFace(a, !0),
                    i = r ? n ? a.CCW : a.CW : n ? a.CW : a.CCW,
                    t.WebGLContext.setFrontFace(a, i);
                    break;
                case Q.CULL_BACK:
                    t.WebGLContext.setCullFace(a, !0),
                    i = r ? n ? a.CW : a.CCW : n ? a.CCW : a.CW,
                    t.WebGLContext.setFrontFace(a, i);
                }
            }
        }, {
            key: "uploadCustomUniform",
            value: function(e, r) {
                t.Stat.shaderCall += t.LayaGLRunner.uploadCustomUniform(t.LayaGL.instance, this._customUniformParamsMap, e, r);
            }
        }, {
            key: "_uniformMatrix2fvForNative",
            value: function(e, r) {
                return t.LayaGL.instance.uniformMatrix2fvEx(e.location, !1, r),
                1;
            }
        }, {
            key: "_uniformMatrix3fvForNative",
            value: function(e, r) {
                return t.LayaGL.instance.uniformMatrix3fvEx(e.location, !1, r),
                1;
            }
        }, {
            key: "_uniformMatrix4fvForNative",
            value: function(e, r) {
                return t.LayaGL.instance.uniformMatrix4fvEx(e.location, !1, r),
                1;
            }
        }]),
        ShaderInstance;
    }()
      , ne = function(e) {
        function ShaderPass(e, t, r, n) {
            var i;
            for (var a in _classCallCheck(this, ShaderPass),
            (i = _possibleConstructorReturn(this, _getPrototypeOf(ShaderPass).call(this, t, r, null)))._cacheSharders = {},
            i._cacheShaderHierarchy = 1,
            i._renderState = new Q(),
            i._validDefine = new B(),
            i._owner = e,
            i._stateMap = n,
            i.defs)
                i._validDefine.add(G.getDefineByName(a));
            return i;
        }
        return _inherits(ShaderPass, t.ShaderCompile),
        _createClass(ShaderPass, [{
            key: "_compileToTree",
            value: function(e, r, n, i, a) {
                var o, s, l, u, c, h, _, d, f, m, p;
                for (f = n; f < r.length; f++)
                    if (!((l = r[f]).length < 1) && 0 !== (h = l.indexOf("//"))) {
                        if (h >= 0 && (l = l.substr(0, h)),
                        o = d || new t.ShaderNode(i),
                        d = null,
                        o.text = l,
                        (h = l.indexOf("#")) >= 0) {
                            for (u = "#",
                            p = h + 1,
                            m = l.length; p < m; p++) {
                                var v = l.charAt(p);
                                if (" " === v || "\t" === v || "?" === v)
                                    break;
                                u += v;
                            }
                            switch (o.name = u,
                            u) {
                            case "#ifdef":
                            case "#ifndef":
                                if (o.setParent(e),
                                e = o,
                                a)
                                    for (_ = l.substr(p).split(t.ShaderCompile._splitToWordExps3),
                                    p = 0; p < _.length; p++)
                                        (l = _[p]).length && (a[l] = !0);
                                continue;
                            case "#if":
                            case "#elif":
                                if (o.setParent(e),
                                e = o,
                                a)
                                    for (_ = l.substr(p).split(t.ShaderCompile._splitToWordExps3),
                                    p = 0; p < _.length; p++)
                                        (l = _[p]).length && "defined" != l && (a[l] = !0);
                                continue;
                            case "#else":
                                s = (e = e.parent).childs[e.childs.length - 1],
                                o.setParent(e),
                                e = o;
                                continue;
                            case "#endif":
                                s = (e = e.parent).childs[e.childs.length - 1],
                                o.setParent(e);
                                continue;
                            case "#include":
                                _ = t.ShaderCompile.splitToWords(l, null);
                                var T = t.ShaderCompile.includes[_[1]];
                                if (!T)
                                    throw "ShaderCompile error no this include file:" + _[1];
                                if ((h = _[0].indexOf("?")) < 0) {
                                    o.setParent(e),
                                    l = T.getWith("with" == _[2] ? _[3] : null),
                                    this._compileToTree(o, l.split("\n"), 0, i, a),
                                    o.text = "";
                                    continue;
                                }
                                o.setCondition(_[0].substr(h + 1), t.ShaderCompile.IFDEF_YES),
                                o.text = T.getWith("with" == _[2] ? _[3] : null);
                                break;
                            case "#import":
                                c = (_ = t.ShaderCompile.splitToWords(l, null))[1],
                                i.push({
                                    node: o,
                                    file: t.ShaderCompile.includes[c],
                                    ofs: o.text.length
                                });
                                continue;
                            }
                        } else {
                            if ((s = e.childs[e.childs.length - 1]) && !s.name) {
                                i.length > 0 && t.ShaderCompile.splitToWords(l, s),
                                d = o,
                                s.text += "\n" + l;
                                continue;
                            }
                            i.length > 0 && t.ShaderCompile.splitToWords(l, o);
                        }
                        o.setParent(e);
                    }
            }
        }, {
            key: "_resizeCacheShaderMap",
            value: function(e, t, r) {
                var n = this._cacheShaderHierarchy - 1;
                if (t == n) {
                    for (var i in e)
                        for (var a = e[i], o = 0, s = r - n; o < s; o++)
                            o == s - 1 ? e[0] = a : e = e[0 == o ? i : 0] = {};
                    this._cacheShaderHierarchy = r;
                } else
                    for (var i in e)
                        this._resizeCacheShaderMap(e[i], ++t, r);
            }
        }, {
            key: "_addDebugShaderVariantCollection",
            value: function(e) {
                var t = G._debugShaderVariantInfo
                  , r = this._owner
                  , n = r._owner
                  , i = ShaderPass._debugDefineString;
                if (G._getNamesByDefineData(e, i),
                !s._config._multiLighting) {
                    var a = i.indexOf("LEGACYSINGLELIGHTING");
                    -1 !== a && i.splice(a, 1);
                }
                t ? t.setValue(n, n._subShaders.indexOf(r), r._passes.indexOf(this), i) : G._debugShaderVariantInfo = t = new F(n,n._subShaders.indexOf(r),r._passes.indexOf(this),i),
                G.debugShaderVariantCollection.add(t);
            }
        }, {
            key: "withCompile",
            value: function(e) {
                e._intersectionDefineDatas(this._validDefine),
                G.debugMode && this._addDebugShaderVariantCollection(e);
                var r = this._cacheSharders
                  , n = e._length;
                n > this._cacheShaderHierarchy && (this._resizeCacheShaderMap(r, 0, n),
                this._cacheShaderHierarchy = n);
                for (var i = e._mask, a = e._length - 1, o = this._cacheShaderHierarchy - 1, l = 0; l < o; l++) {
                    var u = a < l ? 0 : i[l]
                      , c = r[u];
                    c || (r[u] = c = {}),
                    r = c;
                }
                var h = a < o ? 0 : i[o]
                  , _ = r[h];
                if (_)
                    return _;
                var d = ShaderPass._defineString;
                G._getNamesByDefineData(e, d);
                var f, m, p = s._config, v = p.lightClusterCount, T = {}, E = "";
                t.WebGL._isWebGL2 ? (f = "#version 300 es\n\n\t\t\t\t#define attribute in\n\t\t\t\t#define varying out\n\t\t\t\t#define texture2D texture\n",
                m = "#version 300 es\n\n\t\t\t\t#define varying in\n\t\t\t\tout highp vec4 pc_fragColor;\n\t\t\t\t#define gl_FragColor pc_fragColor\n\t\t\t\t#define gl_FragDepthEXT gl_FragDepth\n\t\t\t\t#define texture2D texture\n\t\t\t\t#define textureCube texture\n\t\t\t\t#define texture2DProj textureProj\n\t\t\t\t#define texture2DLodEXT textureLod\n\t\t\t\t#define texture2DProjLodEXT textureProjLod\n\t\t\t\t#define textureCubeLodEXT textureLod\n\t\t\t\t#define texture2DGradEXT textureGrad\n\t\t\t\t#define texture2DProjGradEXT textureProjGrad\n\t\t\t\t#define textureCubeGradEXT textureGrad\n") : (f = "",
                m = "#ifdef GL_EXT_shader_texture_lod\n\t\t\t\t\t#extension GL_EXT_shader_texture_lod : enable\n\t\t\t\t#endif\n\t\t\t\t#if !defined(GL_EXT_shader_texture_lod)\n\t\t\t\t\t#define texture1DLodEXT texture1D\n\t\t\t\t\t#define texture2DLodEXT texture2D\n\t\t\t\t\t#define texture2DProjLodEXT texture2DProj\n\t\t\t\t\t#define texture3DLodEXT texture3D\n\t\t\t\t\t#define textureCubeLodEXT textureCube\n\t\t\t\t#endif\n"),
                E += "#define MAX_LIGHT_COUNT " + p.maxLightCount + "\n",
                E += "#define MAX_LIGHT_COUNT_PER_CLUSTER " + p._maxAreaLightCountPerClusterAverage + "\n",
                E += "#define CLUSTER_X_COUNT " + v.x + "\n",
                E += "#define CLUSTER_Y_COUNT " + v.y + "\n",
                E += "#define CLUSTER_Z_COUNT " + v.z + "\n",
                E += "#define SHADER_CAPAILITY_LEVEL " + t.SystemUtils._shaderCapailityLevel + "\n";
                l = 0;
                for (var y = d.length; l < y; l++) {
                    var g = d[l];
                    E += "#define " + g + "\n",
                    T[g] = !0;
                }
                var S = this._VS.toscript(T, [])
                  , R = "";
                0 == S[0].indexOf("#version") && (R = S[0] + "\n",
                S.shift());
                var C = this._PS.toscript(T, [])
                  , M = "";
                if (0 == C[0].indexOf("#version") && (M = C[0] + "\n",
                C.shift()),
                _ = new re(R + f + E + S.join("\n"),M + m + E + C.join("\n"),this._owner._attributeMap || this._owner._owner._attributeMap,this._owner._uniformMap || this._owner._owner._uniformMap,this),
                r[h] = _,
                G.debugMode) {
                    var D = ""
                      , x = "";
                    if (!p._multiLighting) {
                        e.remove(G.SHADERDEFINE_LEGACYSINGALLIGHTING);
                        var A = d.indexOf("LEGACYSINGLELIGHTING");
                        -1 !== A && d.splice(A, 1);
                    }
                    for (l = 0,
                    y = e._length; l < y; l++)
                        x += l == y - 1 ? i[l] : i[l] + ",";
                    for (l = 0,
                    y = d.length; l < y; l++)
                        D += l == y - 1 ? d[l] : d[l] + ",";
                    console.log("%cLayaAir: Shader Compile Information---ShaderName:" + this._owner._owner._name + " SubShaderIndex:" + this._owner._owner._subShaders.indexOf(this._owner) + " PassIndex:" + this._owner._passes.indexOf(this) + " DefineMask:[" + x + "] DefineNames:[" + D + "]", "color:green");
                }
                return _;
            }
        }, {
            key: "renderState",
            get: function() {
                return this._renderState;
            }
        }]),
        ShaderPass;
    }();
    ne._defineString = [],
    ne._debugDefineString = [];
    var ie = function() {
        function SubShader(e, t) {
            _classCallCheck(this, SubShader),
            this._flags = {},
            this._passes = [],
            this._attributeMap = e,
            this._uniformMap = t;
        }
        return _createClass(SubShader, [{
            key: "setFlag",
            value: function(e, t) {
                t ? this._flags[e] = t : delete this._flags[e];
            }
        }, {
            key: "getFlag",
            value: function(e) {
                return this._flags[e];
            }
        }, {
            key: "addShaderPass",
            value: function(e, t) {
                var r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null
                  , n = new ne(this,e,t,r);
                return this._passes.push(n),
                n;
            }
        }]),
        SubShader;
    }()
      , ae = function() {
        function VertexElementFormat() {
            _classCallCheck(this, VertexElementFormat);
        }
        return _createClass(VertexElementFormat, null, [{
            key: "__init__",
            value: function() {
                var e = t.LayaGL.instance;
                VertexElementFormat._elementInfos = {
                    single: [1, e.FLOAT, 0],
                    vector2: [2, e.FLOAT, 0],
                    vector3: [3, e.FLOAT, 0],
                    vector4: [4, e.FLOAT, 0],
                    color: [4, e.FLOAT, 0],
                    byte4: [4, e.UNSIGNED_BYTE, 0],
                    short2: [2, e.FLOAT, 0],
                    short4: [4, e.FLOAT, 0],
                    normalizedshort2: [2, e.FLOAT, 0],
                    normalizedshort4: [4, e.FLOAT, 0],
                    halfvector2: [2, e.FLOAT, 0],
                    halfvector4: [4, e.FLOAT, 0]
                };
            }
        }, {
            key: "getElementInfos",
            value: function(e) {
                var t = VertexElementFormat._elementInfos[e];
                if (t)
                    return t;
                throw "VertexElementFormat: this vertexElementFormat is not implement.";
            }
        }]),
        VertexElementFormat;
    }();
    ae.Single = "single",
    ae.Vector2 = "vector2",
    ae.Vector3 = "vector3",
    ae.Vector4 = "vector4",
    ae.Color = "color",
    ae.Byte4 = "byte4",
    ae.Short2 = "short2",
    ae.Short4 = "short4",
    ae.NormalizedShort2 = "normalizedshort2",
    ae.NormalizedShort4 = "normalizedshort4",
    ae.HalfVector2 = "halfvector2",
    ae.HalfVector4 = "halfvector4";
    var oe = function() {
        function VertexDeclaration(e, t) {
            _classCallCheck(this, VertexDeclaration),
            this._id = ++VertexDeclaration._uniqueIDCounter,
            this._vertexElementsDic = {},
            this._vertexStride = e,
            this._vertexElements = t;
            var r = t.length;
            this._shaderValues = new z(null);
            for (var n = 0; n < r; n++) {
                var i = t[n]
                  , a = i._elementUsage;
                this._vertexElementsDic[a] = i;
                var o = new Int32Array(5)
                  , s = ae.getElementInfos(i._elementFormat);
                o[0] = s[0],
                o[1] = s[1],
                o[2] = s[2],
                o[3] = this._vertexStride,
                o[4] = i._offset,
                this._shaderValues.setAttribute(a, o);
            }
        }
        return _createClass(VertexDeclaration, [{
            key: "getVertexElementByIndex",
            value: function(e) {
                return this._vertexElements[e];
            }
        }, {
            key: "getVertexElementByUsage",
            value: function(e) {
                return this._vertexElementsDic[e];
            }
        }, {
            key: "id",
            get: function() {
                return this._id;
            }
        }, {
            key: "vertexStride",
            get: function() {
                return this._vertexStride;
            }
        }, {
            key: "vertexElementCount",
            get: function() {
                return this._vertexElements.length;
            }
        }]),
        VertexDeclaration;
    }();
    oe._uniqueIDCounter = 1;
    var se, le = function() {
        function VertexElement(e, t, r) {
            _classCallCheck(this, VertexElement),
            this._offset = e,
            this._elementFormat = t,
            this._elementUsage = r;
        }
        return _createClass(VertexElement, [{
            key: "offset",
            get: function() {
                return this._offset;
            }
        }, {
            key: "elementFormat",
            get: function() {
                return this._elementFormat;
            }
        }, {
            key: "elementUsage",
            get: function() {
                return this._elementUsage;
            }
        }]),
        VertexElement;
    }(), ue = function() {
        function VertexMesh() {
            _classCallCheck(this, VertexMesh);
        }
        return _createClass(VertexMesh, null, [{
            key: "__init__",
            value: function() {
                VertexMesh.instanceWorldMatrixDeclaration = new oe(64,[new le(0,ae.Vector4,VertexMesh.MESH_WORLDMATRIX_ROW0), new le(16,ae.Vector4,VertexMesh.MESH_WORLDMATRIX_ROW1), new le(32,ae.Vector4,VertexMesh.MESH_WORLDMATRIX_ROW2), new le(48,ae.Vector4,VertexMesh.MESH_WORLDMATRIX_ROW3)]),
                VertexMesh.instanceMVPMatrixDeclaration = new oe(64,[new le(0,ae.Vector4,VertexMesh.MESH_MVPMATRIX_ROW0), new le(16,ae.Vector4,VertexMesh.MESH_MVPMATRIX_ROW1), new le(32,ae.Vector4,VertexMesh.MESH_MVPMATRIX_ROW2), new le(48,ae.Vector4,VertexMesh.MESH_MVPMATRIX_ROW3)]);
            }
        }, {
            key: "getVertexDeclaration",
            value: function(e) {
                var t = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1]
                  , r = VertexMesh._vertexDeclarationMap[e + (t ? "_0" : "_1")];
                if (!r) {
                    for (var n = e.split(","), i = 0, a = [], o = 0, s = n.length; o < s; o++) {
                        var l;
                        switch (n[o]) {
                        case "POSITION":
                            l = new le(i,ae.Vector3,VertexMesh.MESH_POSITION0),
                            i += 12;
                            break;
                        case "NORMAL":
                            l = new le(i,ae.Vector3,VertexMesh.MESH_NORMAL0),
                            i += 12;
                            break;
                        case "COLOR":
                            l = new le(i,ae.Vector4,VertexMesh.MESH_COLOR0),
                            i += 16;
                            break;
                        case "UV":
                            l = new le(i,ae.Vector2,VertexMesh.MESH_TEXTURECOORDINATE0),
                            i += 8;
                            break;
                        case "UV1":
                            l = new le(i,ae.Vector2,VertexMesh.MESH_TEXTURECOORDINATE1),
                            i += 8;
                            break;
                        case "BLENDWEIGHT":
                            l = new le(i,ae.Vector4,VertexMesh.MESH_BLENDWEIGHT0),
                            i += 16;
                            break;
                        case "BLENDINDICES":
                            t ? (l = new le(i,ae.Vector4,VertexMesh.MESH_BLENDINDICES0),
                            i += 16) : (l = new le(i,ae.Byte4,VertexMesh.MESH_BLENDINDICES0),
                            i += 4);
                            break;
                        case "TANGENT":
                            l = new le(i,ae.Vector4,VertexMesh.MESH_TANGENT0),
                            i += 16;
                            break;
                        default:
                            throw "VertexMesh: unknown vertex flag.";
                        }
                        a.push(l);
                    }
                    r = new oe(i,a),
                    VertexMesh._vertexDeclarationMap[e + (t ? "_0" : "_1")] = r;
                }
                return r;
            }
        }]),
        VertexMesh;
    }();
    ue.MESH_POSITION0 = 0,
    ue.MESH_COLOR0 = 1,
    ue.MESH_TEXTURECOORDINATE0 = 2,
    ue.MESH_NORMAL0 = 3,
    ue.MESH_TANGENT0 = 4,
    ue.MESH_BLENDINDICES0 = 5,
    ue.MESH_BLENDWEIGHT0 = 6,
    ue.MESH_TEXTURECOORDINATE1 = 7,
    ue.MESH_WORLDMATRIX_ROW0 = 8,
    ue.MESH_WORLDMATRIX_ROW1 = 9,
    ue.MESH_WORLDMATRIX_ROW2 = 10,
    ue.MESH_WORLDMATRIX_ROW3 = 11,
    ue.MESH_MVPMATRIX_ROW0 = 12,
    ue.MESH_MVPMATRIX_ROW1 = 13,
    ue.MESH_MVPMATRIX_ROW2 = 14,
    ue.MESH_MVPMATRIX_ROW3 = 15,
    ue._vertexDeclarationMap = {},
    (se = e.PBRSpecularSmoothnessSource || (e.PBRSpecularSmoothnessSource = {}))[se.SpecularTextureAlpha = 0] = "SpecularTextureAlpha",
    se[se.AlbedoTextureAlpha = 1] = "AlbedoTextureAlpha";
    var ce = function(e) {
        function PBRSpecularMaterial() {
            var e;
            return _classCallCheck(this, PBRSpecularMaterial),
            (e = _possibleConstructorReturn(this, _getPrototypeOf(PBRSpecularMaterial).call(this))).setShaderName("PBRSpecular"),
            e._shaderValues.setVector(PBRSpecularMaterial.SPECULARCOLOR, new i(.2,.2,.2,1)),
            e;
        }
        return _inherits(PBRSpecularMaterial, ee),
        _createClass(PBRSpecularMaterial, [{
            key: "clone",
            value: function() {
                var e = new PBRSpecularMaterial();
                return this.cloneTo(e),
                e;
            }
        }, {
            key: "specularTexture",
            get: function() {
                return this._shaderValues.getTexture(PBRSpecularMaterial.SPECULARTEXTURE);
            },
            set: function(e) {
                e ? this._shaderValues.addDefine(PBRSpecularMaterial.SHADERDEFINE_SPECULARGLOSSTEXTURE) : this._shaderValues.removeDefine(PBRSpecularMaterial.SHADERDEFINE_SPECULARGLOSSTEXTURE),
                this._shaderValues.setTexture(PBRSpecularMaterial.SPECULARTEXTURE, e);
            }
        }, {
            key: "specularColor",
            get: function() {
                return this._shaderValues.getVector(PBRSpecularMaterial.SPECULARCOLOR);
            },
            set: function(e) {
                this._shaderValues.setVector(PBRSpecularMaterial.SPECULARCOLOR, e);
            }
        }], [{
            key: "__init__",
            value: function() {
                PBRSpecularMaterial.SHADERDEFINE_SPECULARGLOSSTEXTURE = G.getDefineByName("SPECULARGLOSSTEXTURE"),
                PBRSpecularMaterial.SHADERDEFINE_SMOOTHNESSSOURCE_ALBEDOTEXTURE_ALPHA = G.getDefineByName("SMOOTHNESSSOURCE_ALBEDOTEXTURE_ALPHA");
                var e = {
                    a_Position: ue.MESH_POSITION0,
                    a_Normal: ue.MESH_NORMAL0,
                    a_Tangent0: ue.MESH_TANGENT0,
                    a_Texcoord0: ue.MESH_TEXTURECOORDINATE0,
                    a_Texcoord1: ue.MESH_TEXTURECOORDINATE1,
                    a_BoneWeights: ue.MESH_BLENDWEIGHT0,
                    a_BoneIndices: ue.MESH_BLENDINDICES0,
                    a_MvpMatrix: ue.MESH_MVPMATRIX_ROW0,
                    a_WorldMat: ue.MESH_WORLDMATRIX_ROW0
                }
                  , t = {
                    u_Bones: G.PERIOD_CUSTOM,
                    u_MvpMatrix: G.PERIOD_SPRITE,
                    u_WorldMat: G.PERIOD_SPRITE,
                    u_LightmapScaleOffset: G.PERIOD_SPRITE,
                    u_LightMap: G.PERIOD_SPRITE,
                    u_CameraPos: G.PERIOD_CAMERA,
                    u_View: G.PERIOD_CAMERA,
                    u_ProjectionParams: G.PERIOD_CAMERA,
                    u_Viewport: G.PERIOD_CAMERA,
                    u_AlphaTestValue: G.PERIOD_MATERIAL,
                    u_AlbedoColor: G.PERIOD_MATERIAL,
                    u_EmissionColor: G.PERIOD_MATERIAL,
                    u_AlbedoTexture: G.PERIOD_MATERIAL,
                    u_NormalTexture: G.PERIOD_MATERIAL,
                    u_ParallaxTexture: G.PERIOD_MATERIAL,
                    u_OcclusionTexture: G.PERIOD_MATERIAL,
                    u_EmissionTexture: G.PERIOD_MATERIAL,
                    u_Smoothness: G.PERIOD_MATERIAL,
                    u_SmoothnessScale: G.PERIOD_MATERIAL,
                    u_occlusionStrength: G.PERIOD_MATERIAL,
                    u_NormalScale: G.PERIOD_MATERIAL,
                    u_ParallaxScale: G.PERIOD_MATERIAL,
                    u_TilingOffset: G.PERIOD_MATERIAL,
                    u_SpecGlossTexture: G.PERIOD_MATERIAL,
                    u_SpecularColor: G.PERIOD_MATERIAL,
                    u_ReflectTexture: G.PERIOD_SCENE,
                    u_ReflectIntensity: G.PERIOD_SCENE,
                    u_AmbientColor: G.PERIOD_SCENE,
                    u_FogStart: G.PERIOD_SCENE,
                    u_FogRange: G.PERIOD_SCENE,
                    u_FogColor: G.PERIOD_SCENE,
                    u_DirationLightCount: G.PERIOD_SCENE,
                    u_LightBuffer: G.PERIOD_SCENE,
                    u_LightClusterBuffer: G.PERIOD_SCENE,
                    u_shadowMap1: G.PERIOD_SCENE,
                    u_shadowMap2: G.PERIOD_SCENE,
                    u_shadowMap3: G.PERIOD_SCENE,
                    u_shadowPSSMDistance: G.PERIOD_SCENE,
                    u_lightShadowVP: G.PERIOD_SCENE,
                    u_shadowPCFoffset: G.PERIOD_SCENE,
                    u_AmbientSHAr: G.PERIOD_SCENE,
                    u_AmbientSHAg: G.PERIOD_SCENE,
                    u_AmbientSHAb: G.PERIOD_SCENE,
                    u_AmbientSHBr: G.PERIOD_SCENE,
                    u_AmbientSHBg: G.PERIOD_SCENE,
                    u_AmbientSHBb: G.PERIOD_SCENE,
                    u_AmbientSHC: G.PERIOD_SCENE,
                    u_ReflectionProbe: G.PERIOD_SCENE,
                    u_ReflectCubeHDRParams: G.PERIOD_SCENE,
                    "u_DirectionLight.direction": G.PERIOD_SCENE,
                    "u_DirectionLight.color": G.PERIOD_SCENE,
                    "u_PointLight.position": G.PERIOD_SCENE,
                    "u_PointLight.range": G.PERIOD_SCENE,
                    "u_PointLight.color": G.PERIOD_SCENE,
                    "u_SpotLight.position": G.PERIOD_SCENE,
                    "u_SpotLight.direction": G.PERIOD_SCENE,
                    "u_SpotLight.range": G.PERIOD_SCENE,
                    "u_SpotLight.spot": G.PERIOD_SCENE,
                    "u_SpotLight.color": G.PERIOD_SCENE
                }
                  , r = {
                    s_Cull: G.RENDER_STATE_CULL,
                    s_Blend: G.RENDER_STATE_BLEND,
                    s_BlendSrc: G.RENDER_STATE_BLEND_SRC,
                    s_BlendDst: G.RENDER_STATE_BLEND_DST,
                    s_DepthTest: G.RENDER_STATE_DEPTH_TEST,
                    s_DepthWrite: G.RENDER_STATE_DEPTH_WRITE
                }
                  , n = G.add("PBRSpecular")
                  , i = new ie(e,t);
                n.addSubShader(i),
                i.addShaderPass('#include "PBRVSInput.glsl";\r\n#include "Lighting.glsl";\r\n#include "PBRVertex.glsl";\r\n#include "PBRVSShadow.glsl";\r\n\r\nvoid main()\r\n{\r\n\t#ifdef CASTSHADOW\r\n\t\tmain_castShadow();\r\n\t#else\r\n\t\tvertexForward();\r\n\t#endif\r\n\tgl_Position=remapGLPositionZ(gl_Position);\r\n}', '#ifdef GL_FRAGMENT_PRECISION_HIGH\r\n\tprecision highp float;\r\n\tprecision highp int;\r\n#else\r\n\tprecision mediump float;\r\n\tprecision mediump int;\r\n#endif\r\n\r\n#define SETUP_BRDF_INPUT specularSetup\r\n\r\n#include "Lighting.glsl";\r\n#include "PBRFSInput.glsl";\r\n#include "LayaPBRBRDF.glsl";\r\n#include "GlobalIllumination.glsl";\r\n#include "ShadowHelper.glsl"\r\n#include "PBRCore.glsl";\r\n#include "PBRFSShadow.glsl";\r\n\r\nvoid main()\r\n{\r\n\t#ifdef CASTSHADOW\t\t\r\n\t\tmain_castShadow();\r\n\t#else\r\n\t\tfragmentForward();\r\n\t#endif  \r\n}', r);
            }
        }]),
        PBRSpecularMaterial;
    }();
    ce.SPECULARTEXTURE = G.propertyNameToID("u_SpecularTexture"),
    ce.SPECULARCOLOR = G.propertyNameToID("u_SpecularColor");
    var he;
    (he = e.PBRMetallicSmoothnessSource || (e.PBRMetallicSmoothnessSource = {}))[he.MetallicGlossTextureAlpha = 0] = "MetallicGlossTextureAlpha",
    he[he.AlbedoTextureAlpha = 1] = "AlbedoTextureAlpha";
    var _e = function(e) {
        function PBRStandardMaterial() {
            var e;
            return _classCallCheck(this, PBRStandardMaterial),
            (e = _possibleConstructorReturn(this, _getPrototypeOf(PBRStandardMaterial).call(this)))._smoothnessSource = 0,
            e.setShaderName("PBR"),
            e._shaderValues.setNumber(PBRStandardMaterial.METALLIC, 0),
            e;
        }
        return _inherits(PBRStandardMaterial, ee),
        _createClass(PBRStandardMaterial, [{
            key: "clone",
            value: function() {
                var e = new PBRStandardMaterial();
                return this.cloneTo(e),
                e;
            }
        }, {
            key: "metallicGlossTexture",
            get: function() {
                return this._shaderValues.getTexture(PBRStandardMaterial.METALLICGLOSSTEXTURE);
            },
            set: function(e) {
                e ? this._shaderValues.addDefine(PBRStandardMaterial.SHADERDEFINE_METALLICGLOSSTEXTURE) : this._shaderValues.removeDefine(PBRStandardMaterial.SHADERDEFINE_METALLICGLOSSTEXTURE),
                this._shaderValues.setTexture(PBRStandardMaterial.METALLICGLOSSTEXTURE, e);
            }
        }, {
            key: "metallic",
            get: function() {
                return this._shaderValues.getNumber(PBRStandardMaterial.METALLIC);
            },
            set: function(e) {
                this._shaderValues.setNumber(PBRStandardMaterial.METALLIC, Math.max(0, Math.min(1, e)));
            }
        }, {
            key: "smoothnessSource",
            get: function() {
                return this._smoothnessSource;
            },
            set: function(e) {
                e ? this._shaderValues.addDefine(PBRStandardMaterial.SHADERDEFINE_SMOOTHNESSSOURCE_ALBEDOTEXTURE_ALPHA) : this._shaderValues.removeDefine(PBRStandardMaterial.SHADERDEFINE_SMOOTHNESSSOURCE_ALBEDOTEXTURE_ALPHA),
                this._smoothnessSource = e;
            }
        }], [{
            key: "__init__",
            value: function() {
                PBRStandardMaterial.SHADERDEFINE_METALLICGLOSSTEXTURE = G.getDefineByName("METALLICGLOSSTEXTURE"),
                PBRStandardMaterial.SHADERDEFINE_SMOOTHNESSSOURCE_ALBEDOTEXTURE_ALPHA = G.getDefineByName("SMOOTHNESSSOURCE_ALBEDOTEXTURE_ALPHA");
                var e = {
                    a_Position: ue.MESH_POSITION0,
                    a_Normal: ue.MESH_NORMAL0,
                    a_Tangent0: ue.MESH_TANGENT0,
                    a_Texcoord0: ue.MESH_TEXTURECOORDINATE0,
                    a_Texcoord1: ue.MESH_TEXTURECOORDINATE1,
                    a_BoneWeights: ue.MESH_BLENDWEIGHT0,
                    a_BoneIndices: ue.MESH_BLENDINDICES0,
                    a_MvpMatrix: ue.MESH_MVPMATRIX_ROW0,
                    a_WorldMat: ue.MESH_WORLDMATRIX_ROW0
                }
                  , t = {
                    u_Bones: G.PERIOD_CUSTOM,
                    u_MvpMatrix: G.PERIOD_SPRITE,
                    u_WorldMat: G.PERIOD_SPRITE,
                    u_LightmapScaleOffset: G.PERIOD_SPRITE,
                    u_LightMap: G.PERIOD_SPRITE,
                    u_CameraPos: G.PERIOD_CAMERA,
                    u_View: G.PERIOD_CAMERA,
                    u_ProjectionParams: G.PERIOD_CAMERA,
                    u_Viewport: G.PERIOD_CAMERA,
                    u_AlphaTestValue: G.PERIOD_MATERIAL,
                    u_AlbedoColor: G.PERIOD_MATERIAL,
                    u_EmissionColor: G.PERIOD_MATERIAL,
                    u_AlbedoTexture: G.PERIOD_MATERIAL,
                    u_NormalTexture: G.PERIOD_MATERIAL,
                    u_ParallaxTexture: G.PERIOD_MATERIAL,
                    u_OcclusionTexture: G.PERIOD_MATERIAL,
                    u_EmissionTexture: G.PERIOD_MATERIAL,
                    u_Smoothness: G.PERIOD_MATERIAL,
                    u_SmoothnessScale: G.PERIOD_MATERIAL,
                    u_occlusionStrength: G.PERIOD_MATERIAL,
                    u_NormalScale: G.PERIOD_MATERIAL,
                    u_ParallaxScale: G.PERIOD_MATERIAL,
                    u_TilingOffset: G.PERIOD_MATERIAL,
                    u_MetallicGlossTexture: G.PERIOD_MATERIAL,
                    u_Metallic: G.PERIOD_MATERIAL,
                    u_ReflectTexture: G.PERIOD_SCENE,
                    u_ReflectIntensity: G.PERIOD_SCENE,
                    u_AmbientColor: G.PERIOD_SCENE,
                    u_FogStart: G.PERIOD_SCENE,
                    u_FogRange: G.PERIOD_SCENE,
                    u_FogColor: G.PERIOD_SCENE,
                    u_DirationLightCount: G.PERIOD_SCENE,
                    u_LightBuffer: G.PERIOD_SCENE,
                    u_LightClusterBuffer: G.PERIOD_SCENE,
                    u_shadowMap1: G.PERIOD_SCENE,
                    u_shadowMap2: G.PERIOD_SCENE,
                    u_shadowMap3: G.PERIOD_SCENE,
                    u_shadowPSSMDistance: G.PERIOD_SCENE,
                    u_lightShadowVP: G.PERIOD_SCENE,
                    u_shadowPCFoffset: G.PERIOD_SCENE,
                    u_AmbientSHAr: G.PERIOD_SCENE,
                    u_AmbientSHAg: G.PERIOD_SCENE,
                    u_AmbientSHAb: G.PERIOD_SCENE,
                    u_AmbientSHBr: G.PERIOD_SCENE,
                    u_AmbientSHBg: G.PERIOD_SCENE,
                    u_AmbientSHBb: G.PERIOD_SCENE,
                    u_AmbientSHC: G.PERIOD_SCENE,
                    u_ReflectionProbe: G.PERIOD_SCENE,
                    u_ReflectCubeHDRParams: G.PERIOD_SCENE,
                    "u_DirectionLight.direction": G.PERIOD_SCENE,
                    "u_DirectionLight.color": G.PERIOD_SCENE,
                    "u_PointLight.position": G.PERIOD_SCENE,
                    "u_PointLight.range": G.PERIOD_SCENE,
                    "u_PointLight.color": G.PERIOD_SCENE,
                    "u_SpotLight.position": G.PERIOD_SCENE,
                    "u_SpotLight.direction": G.PERIOD_SCENE,
                    "u_SpotLight.range": G.PERIOD_SCENE,
                    "u_SpotLight.spot": G.PERIOD_SCENE,
                    "u_SpotLight.color": G.PERIOD_SCENE
                }
                  , r = {
                    s_Cull: G.RENDER_STATE_CULL,
                    s_Blend: G.RENDER_STATE_BLEND,
                    s_BlendSrc: G.RENDER_STATE_BLEND_SRC,
                    s_BlendDst: G.RENDER_STATE_BLEND_DST,
                    s_DepthTest: G.RENDER_STATE_DEPTH_TEST,
                    s_DepthWrite: G.RENDER_STATE_DEPTH_WRITE
                }
                  , n = G.add("PBR")
                  , i = new ie(e,t);
                n.addSubShader(i),
                i.addShaderPass('#include "PBRVSInput.glsl";\r\n#include "Lighting.glsl";\r\n#include "PBRVertex.glsl";\r\n#include "PBRVSShadow.glsl";\r\n\r\nvoid main()\r\n{\r\n\t#ifdef CASTSHADOW\r\n\t\tmain_castShadow();\r\n\t#else\r\n\t\tvertexForward();\r\n\t#endif\r\n\tgl_Position=remapGLPositionZ(gl_Position);\r\n}', '#ifdef GL_FRAGMENT_PRECISION_HIGH\r\n\tprecision highp float;\r\n\tprecision highp int;\r\n#else\r\n\tprecision mediump float;\r\n\tprecision mediump int;\r\n#endif\r\n\r\n#include "Lighting.glsl";\r\n#include "PBRFSInput.glsl";\r\n#include "LayaPBRBRDF.glsl";\r\n#include "GlobalIllumination.glsl";\r\n#include "ShadowHelper.glsl"\r\n#include "PBRCore.glsl";\r\n#include "PBRFSShadow.glsl";\r\n\r\nvoid main()\r\n{\r\n\t#ifdef CASTSHADOW\t\t\r\n\t\tmain_castShadow();\r\n\t#else\r\n\t\tfragmentForward();\r\n\t#endif  \r\n}', r);
            }
        }]),
        PBRStandardMaterial;
    }();
    _e.METALLICGLOSSTEXTURE = G.propertyNameToID("u_MetallicGlossTexture"),
    _e.METALLIC = G.propertyNameToID("u_Metallic");
    var de = function(e) {
        function SkyBoxMaterial() {
            var e;
            return _classCallCheck(this, SkyBoxMaterial),
            (e = _possibleConstructorReturn(this, _getPrototypeOf(SkyBoxMaterial).call(this))).setShaderName("SkyBox"),
            e.tintColor = new i(.5,.5,.5,.5),
            e.exposure = 1,
            e.rotation = 0,
            e;
        }
        return _inherits(SkyBoxMaterial, Z),
        _createClass(SkyBoxMaterial, [{
            key: "clone",
            value: function() {
                var e = new SkyBoxMaterial();
                return this.cloneTo(e),
                e;
            }
        }, {
            key: "tintColor",
            get: function() {
                return this._shaderValues.getVector(SkyBoxMaterial.TINTCOLOR);
            },
            set: function(e) {
                this._shaderValues.setVector(SkyBoxMaterial.TINTCOLOR, e);
            }
        }, {
            key: "exposure",
            get: function() {
                return this._shaderValues.getNumber(SkyBoxMaterial.EXPOSURE);
            },
            set: function(e) {
                this._shaderValues.setNumber(SkyBoxMaterial.EXPOSURE, e);
            }
        }, {
            key: "rotation",
            get: function() {
                return this._shaderValues.getNumber(SkyBoxMaterial.ROTATION);
            },
            set: function(e) {
                this._shaderValues.setNumber(SkyBoxMaterial.ROTATION, e);
            }
        }, {
            key: "textureCube",
            get: function() {
                return this._shaderValues.getTexture(SkyBoxMaterial.TEXTURECUBE);
            },
            set: function(e) {
                this._shaderValues.setTexture(SkyBoxMaterial.TEXTURECUBE, e);
            }
        }], [{
            key: "__initDefine__",
            value: function() {}
        }]),
        SkyBoxMaterial;
    }();
    de.TINTCOLOR = G.propertyNameToID("u_TintColor"),
    de.EXPOSURE = G.propertyNameToID("u_Exposure"),
    de.ROTATION = G.propertyNameToID("u_Rotation"),
    de.TEXTURECUBE = G.propertyNameToID("u_CubeTexture");
    var fe = function(e) {
        function SkyProceduralMaterial() {
            var e;
            return _classCallCheck(this, SkyProceduralMaterial),
            (e = _possibleConstructorReturn(this, _getPrototypeOf(SkyProceduralMaterial).call(this))).setShaderName("SkyBoxProcedural"),
            e.sunDisk = SkyProceduralMaterial.SUN_HIGH_QUALITY,
            e.sunSize = .04,
            e.sunSizeConvergence = 5,
            e.atmosphereThickness = 1,
            e.skyTint = new i(.5,.5,.5,1),
            e.groundTint = new i(.369,.349,.341,1),
            e.exposure = 1.3,
            e;
        }
        return _inherits(SkyProceduralMaterial, Z),
        _createClass(SkyProceduralMaterial, [{
            key: "clone",
            value: function() {
                var e = new SkyProceduralMaterial();
                return this.cloneTo(e),
                e;
            }
        }, {
            key: "sunDisk",
            get: function() {
                return this._sunDisk;
            },
            set: function(e) {
                switch (e) {
                case SkyProceduralMaterial.SUN_HIGH_QUALITY:
                    this._shaderValues.removeDefine(SkyProceduralMaterial.SHADERDEFINE_SUN_SIMPLE),
                    this._shaderValues.addDefine(SkyProceduralMaterial.SHADERDEFINE_SUN_HIGH_QUALITY);
                    break;
                case SkyProceduralMaterial.SUN_SIMPLE:
                    this._shaderValues.removeDefine(SkyProceduralMaterial.SHADERDEFINE_SUN_HIGH_QUALITY),
                    this._shaderValues.addDefine(SkyProceduralMaterial.SHADERDEFINE_SUN_SIMPLE);
                    break;
                case SkyProceduralMaterial.SUN_NODE:
                    this._shaderValues.removeDefine(SkyProceduralMaterial.SHADERDEFINE_SUN_HIGH_QUALITY),
                    this._shaderValues.removeDefine(SkyProceduralMaterial.SHADERDEFINE_SUN_SIMPLE);
                    break;
                default:
                    throw "SkyBoxProceduralMaterial: unknown sun value.";
                }
                this._sunDisk = e;
            }
        }, {
            key: "sunSize",
            get: function() {
                return this._shaderValues.getNumber(SkyProceduralMaterial.SUNSIZE);
            },
            set: function(e) {
                e = Math.min(Math.max(0, e), 1),
                this._shaderValues.setNumber(SkyProceduralMaterial.SUNSIZE, e);
            }
        }, {
            key: "sunSizeConvergence",
            get: function() {
                return this._shaderValues.getNumber(SkyProceduralMaterial.SUNSIZECONVERGENCE);
            },
            set: function(e) {
                e = Math.min(Math.max(0, e), 20),
                this._shaderValues.setNumber(SkyProceduralMaterial.SUNSIZECONVERGENCE, e);
            }
        }, {
            key: "atmosphereThickness",
            get: function() {
                return this._shaderValues.getNumber(SkyProceduralMaterial.ATMOSPHERETHICKNESS);
            },
            set: function(e) {
                e = Math.min(Math.max(0, e), 5),
                this._shaderValues.setNumber(SkyProceduralMaterial.ATMOSPHERETHICKNESS, e);
            }
        }, {
            key: "skyTint",
            get: function() {
                return this._shaderValues.getVector(SkyProceduralMaterial.SKYTINT);
            },
            set: function(e) {
                this._shaderValues.setVector(SkyProceduralMaterial.SKYTINT, e);
            }
        }, {
            key: "groundTint",
            get: function() {
                return this._shaderValues.getVector(SkyProceduralMaterial.GROUNDTINT);
            },
            set: function(e) {
                this._shaderValues.setVector(SkyProceduralMaterial.GROUNDTINT, e);
            }
        }, {
            key: "exposure",
            get: function() {
                return this._shaderValues.getNumber(SkyProceduralMaterial.EXPOSURE);
            },
            set: function(e) {
                e = Math.min(Math.max(0, e), 8),
                this._shaderValues.setNumber(SkyProceduralMaterial.EXPOSURE, e);
            }
        }], [{
            key: "__initDefine__",
            value: function() {
                SkyProceduralMaterial.SHADERDEFINE_SUN_HIGH_QUALITY = G.getDefineByName("SUN_HIGH_QUALITY"),
                SkyProceduralMaterial.SHADERDEFINE_SUN_SIMPLE = G.getDefineByName("SUN_SIMPLE");
            }
        }]),
        SkyProceduralMaterial;
    }();
    fe.SUN_NODE = 0,
    fe.SUN_SIMPLE = 1,
    fe.SUN_HIGH_QUALITY = 2,
    fe.SUNSIZE = G.propertyNameToID("u_SunSize"),
    fe.SUNSIZECONVERGENCE = G.propertyNameToID("u_SunSizeConvergence"),
    fe.ATMOSPHERETHICKNESS = G.propertyNameToID("u_AtmosphereThickness"),
    fe.SKYTINT = G.propertyNameToID("u_SkyTint"),
    fe.GROUNDTINT = G.propertyNameToID("u_GroundTint"),
    fe.EXPOSURE = G.propertyNameToID("u_Exposure");
    var me = function(e) {
        function UnlitMaterial() {
            var e;
            return _classCallCheck(this, UnlitMaterial),
            (e = _possibleConstructorReturn(this, _getPrototypeOf(UnlitMaterial).call(this)))._albedoColor = new i(1,1,1,1),
            e._albedoIntensity = 1,
            e._enableVertexColor = !1,
            e.setShaderName("Unlit"),
            e._shaderValues.setVector(UnlitMaterial.ALBEDOCOLOR, new i(1,1,1,1)),
            e.renderMode = UnlitMaterial.RENDERMODE_OPAQUE,
            e;
        }
        return _inherits(UnlitMaterial, Z),
        _createClass(UnlitMaterial, [{
            key: "clone",
            value: function() {
                var e = new UnlitMaterial();
                return this.cloneTo(e),
                e;
            }
        }, {
            key: "_ColorR",
            get: function() {
                return this._albedoColor.x;
            },
            set: function(e) {
                this._albedoColor.x = e,
                this.albedoColor = this._albedoColor;
            }
        }, {
            key: "_ColorG",
            get: function() {
                return this._albedoColor.y;
            },
            set: function(e) {
                this._albedoColor.y = e,
                this.albedoColor = this._albedoColor;
            }
        }, {
            key: "_ColorB",
            get: function() {
                return this._albedoColor.z;
            },
            set: function(e) {
                this._albedoColor.z = e,
                this.albedoColor = this._albedoColor;
            }
        }, {
            key: "_ColorA",
            get: function() {
                return this._albedoColor.w;
            },
            set: function(e) {
                this._albedoColor.w = e,
                this.albedoColor = this._albedoColor;
            }
        }, {
            key: "_AlbedoIntensity",
            get: function() {
                return this._albedoIntensity;
            },
            set: function(e) {
                if (this._albedoIntensity !== e) {
                    var t = this._shaderValues.getVector(UnlitMaterial.ALBEDOCOLOR);
                    i.scale(this._albedoColor, e, t),
                    this._albedoIntensity = e,
                    this._shaderValues.setVector(UnlitMaterial.ALBEDOCOLOR, t);
                }
            }
        }, {
            key: "_MainTex_STX",
            get: function() {
                return this._shaderValues.getVector(UnlitMaterial.TILINGOFFSET).x;
            },
            set: function(e) {
                var t = this._shaderValues.getVector(UnlitMaterial.TILINGOFFSET);
                t.x = e,
                this.tilingOffset = t;
            }
        }, {
            key: "_MainTex_STY",
            get: function() {
                return this._shaderValues.getVector(UnlitMaterial.TILINGOFFSET).y;
            },
            set: function(e) {
                var t = this._shaderValues.getVector(UnlitMaterial.TILINGOFFSET);
                t.y = e,
                this.tilingOffset = t;
            }
        }, {
            key: "_MainTex_STZ",
            get: function() {
                return this._shaderValues.getVector(UnlitMaterial.TILINGOFFSET).z;
            },
            set: function(e) {
                var t = this._shaderValues.getVector(UnlitMaterial.TILINGOFFSET);
                t.z = e,
                this.tilingOffset = t;
            }
        }, {
            key: "_MainTex_STW",
            get: function() {
                return this._shaderValues.getVector(UnlitMaterial.TILINGOFFSET).w;
            },
            set: function(e) {
                var t = this._shaderValues.getVector(UnlitMaterial.TILINGOFFSET);
                t.w = e,
                this.tilingOffset = t;
            }
        }, {
            key: "_Cutoff",
            get: function() {
                return this.alphaTestValue;
            },
            set: function(e) {
                this.alphaTestValue = e;
            }
        }, {
            key: "albedoColorR",
            get: function() {
                return this._ColorR;
            },
            set: function(e) {
                this._ColorR = e;
            }
        }, {
            key: "albedoColorG",
            get: function() {
                return this._ColorG;
            },
            set: function(e) {
                this._ColorG = e;
            }
        }, {
            key: "albedoColorB",
            get: function() {
                return this._ColorB;
            },
            set: function(e) {
                this._ColorB = e;
            }
        }, {
            key: "albedoColorA",
            get: function() {
                return this._ColorA;
            },
            set: function(e) {
                this._ColorA = e;
            }
        }, {
            key: "albedoColor",
            get: function() {
                return this._albedoColor;
            },
            set: function(e) {
                var t = this._shaderValues.getVector(UnlitMaterial.ALBEDOCOLOR);
                i.scale(e, this._albedoIntensity, t),
                this._albedoColor = e,
                this._shaderValues.setVector(UnlitMaterial.ALBEDOCOLOR, t);
            }
        }, {
            key: "albedoIntensity",
            get: function() {
                return this._albedoIntensity;
            },
            set: function(e) {
                this._AlbedoIntensity = e;
            }
        }, {
            key: "albedoTexture",
            get: function() {
                return this._shaderValues.getTexture(UnlitMaterial.ALBEDOTEXTURE);
            },
            set: function(e) {
                e ? this._shaderValues.addDefine(UnlitMaterial.SHADERDEFINE_ALBEDOTEXTURE) : this._shaderValues.removeDefine(UnlitMaterial.SHADERDEFINE_ALBEDOTEXTURE),
                this._shaderValues.setTexture(UnlitMaterial.ALBEDOTEXTURE, e);
            }
        }, {
            key: "tilingOffsetX",
            get: function() {
                return this._MainTex_STX;
            },
            set: function(e) {
                this._MainTex_STX = e;
            }
        }, {
            key: "tilingOffsetY",
            get: function() {
                return this._MainTex_STY;
            },
            set: function(e) {
                this._MainTex_STY = e;
            }
        }, {
            key: "tilingOffsetZ",
            get: function() {
                return this._MainTex_STZ;
            },
            set: function(e) {
                this._MainTex_STZ = e;
            }
        }, {
            key: "tilingOffsetW",
            get: function() {
                return this._MainTex_STW;
            },
            set: function(e) {
                this._MainTex_STW = e;
            }
        }, {
            key: "tilingOffset",
            get: function() {
                return this._shaderValues.getVector(UnlitMaterial.TILINGOFFSET);
            },
            set: function(e) {
                e && (1 != e.x || 1 != e.y || 0 != e.z || 0 != e.w) ? this._shaderValues.addDefine(UnlitMaterial.SHADERDEFINE_TILINGOFFSET) : this._shaderValues.removeDefine(UnlitMaterial.SHADERDEFINE_TILINGOFFSET),
                this._shaderValues.setVector(UnlitMaterial.TILINGOFFSET, e);
            }
        }, {
            key: "enableVertexColor",
            get: function() {
                return this._enableVertexColor;
            },
            set: function(e) {
                this._enableVertexColor = e,
                e ? this._shaderValues.addDefine(UnlitMaterial.SHADERDEFINE_ENABLEVERTEXCOLOR) : this._shaderValues.removeDefine(UnlitMaterial.SHADERDEFINE_ENABLEVERTEXCOLOR);
            }
        }, {
            key: "renderMode",
            set: function(e) {
                switch (e) {
                case UnlitMaterial.RENDERMODE_OPAQUE:
                    this.alphaTest = !1,
                    this.renderQueue = Z.RENDERQUEUE_OPAQUE,
                    this.depthWrite = !0,
                    this.cull = Q.CULL_BACK,
                    this.blend = Q.BLEND_DISABLE,
                    this.depthTest = Q.DEPTHTEST_LESS;
                    break;
                case UnlitMaterial.RENDERMODE_CUTOUT:
                    this.renderQueue = Z.RENDERQUEUE_ALPHATEST,
                    this.alphaTest = !0,
                    this.depthWrite = !0,
                    this.cull = Q.CULL_BACK,
                    this.blend = Q.BLEND_DISABLE,
                    this.depthTest = Q.DEPTHTEST_LESS;
                    break;
                case UnlitMaterial.RENDERMODE_TRANSPARENT:
                    this.renderQueue = Z.RENDERQUEUE_TRANSPARENT,
                    this.alphaTest = !1,
                    this.depthWrite = !1,
                    this.cull = Q.CULL_BACK,
                    this.blend = Q.BLEND_ENABLE_ALL,
                    this.blendSrc = Q.BLENDPARAM_SRC_ALPHA,
                    this.blendDst = Q.BLENDPARAM_ONE_MINUS_SRC_ALPHA,
                    this.depthTest = Q.DEPTHTEST_LESS;
                    break;
                default:
                    throw new Error("UnlitMaterial : renderMode value error.");
                }
            }
        }, {
            key: "depthWrite",
            get: function() {
                return this._shaderValues.getBool(UnlitMaterial.DEPTH_WRITE);
            },
            set: function(e) {
                this._shaderValues.setBool(UnlitMaterial.DEPTH_WRITE, e);
            }
        }, {
            key: "cull",
            get: function() {
                return this._shaderValues.getInt(UnlitMaterial.CULL);
            },
            set: function(e) {
                this._shaderValues.setInt(UnlitMaterial.CULL, e);
            }
        }, {
            key: "blend",
            get: function() {
                return this._shaderValues.getInt(UnlitMaterial.BLEND);
            },
            set: function(e) {
                this._shaderValues.setInt(UnlitMaterial.BLEND, e);
            }
        }, {
            key: "blendSrc",
            get: function() {
                return this._shaderValues.getInt(UnlitMaterial.BLEND_SRC);
            },
            set: function(e) {
                this._shaderValues.setInt(UnlitMaterial.BLEND_SRC, e);
            }
        }, {
            key: "blendDst",
            get: function() {
                return this._shaderValues.getInt(UnlitMaterial.BLEND_DST);
            },
            set: function(e) {
                this._shaderValues.setInt(UnlitMaterial.BLEND_DST, e);
            }
        }, {
            key: "depthTest",
            get: function() {
                return this._shaderValues.getInt(UnlitMaterial.DEPTH_TEST);
            },
            set: function(e) {
                this._shaderValues.setInt(UnlitMaterial.DEPTH_TEST, e);
            }
        }], [{
            key: "__initDefine__",
            value: function() {
                UnlitMaterial.SHADERDEFINE_ALBEDOTEXTURE = G.getDefineByName("ALBEDOTEXTURE"),
                UnlitMaterial.SHADERDEFINE_TILINGOFFSET = G.getDefineByName("TILINGOFFSET"),
                UnlitMaterial.SHADERDEFINE_ENABLEVERTEXCOLOR = G.getDefineByName("ENABLEVERTEXCOLOR");
            }
        }]),
        UnlitMaterial;
    }();
    me.RENDERMODE_OPAQUE = 0,
    me.RENDERMODE_CUTOUT = 1,
    me.RENDERMODE_TRANSPARENT = 2,
    me.RENDERMODE_ADDTIVE = 3,
    me.ALBEDOTEXTURE = G.propertyNameToID("u_AlbedoTexture"),
    me.ALBEDOCOLOR = G.propertyNameToID("u_AlbedoColor"),
    me.TILINGOFFSET = G.propertyNameToID("u_TilingOffset"),
    me.CULL = G.propertyNameToID("s_Cull"),
    me.BLEND = G.propertyNameToID("s_Blend"),
    me.BLEND_SRC = G.propertyNameToID("s_BlendSrc"),
    me.BLEND_DST = G.propertyNameToID("s_BlendDst"),
    me.DEPTH_TEST = G.propertyNameToID("s_DepthTest"),
    me.DEPTH_WRITE = G.propertyNameToID("s_DepthWrite");
    var pe = function(e) {
        function WaterPrimaryMaterial() {
            var e;
            return _classCallCheck(this, WaterPrimaryMaterial),
            (e = _possibleConstructorReturn(this, _getPrototypeOf(WaterPrimaryMaterial).call(this))).setShaderName("WaterPrimary"),
            e._shaderValues.setVector(WaterPrimaryMaterial.HORIZONCOLOR, new i(.172,.463,.435,0)),
            e._shaderValues.setNumber(WaterPrimaryMaterial.WAVESCALE, .15),
            e._shaderValues.setVector(WaterPrimaryMaterial.WAVESPEED, new i(19,9,-16,-7)),
            e;
        }
        return _inherits(WaterPrimaryMaterial, Z),
        _createClass(WaterPrimaryMaterial, [{
            key: "clone",
            value: function() {
                var e = new WaterPrimaryMaterial();
                return this.cloneTo(e),
                e;
            }
        }, {
            key: "horizonColor",
            get: function() {
                return this._shaderValues.getVector(WaterPrimaryMaterial.HORIZONCOLOR);
            },
            set: function(e) {
                this._shaderValues.setVector(WaterPrimaryMaterial.HORIZONCOLOR, e);
            }
        }, {
            key: "mainTexture",
            get: function() {
                return this._shaderValues.getTexture(WaterPrimaryMaterial.MAINTEXTURE);
            },
            set: function(e) {
                e ? this._shaderValues.addDefine(WaterPrimaryMaterial.SHADERDEFINE_MAINTEXTURE) : this._shaderValues.removeDefine(WaterPrimaryMaterial.SHADERDEFINE_MAINTEXTURE),
                this._shaderValues.setTexture(WaterPrimaryMaterial.MAINTEXTURE, e);
            }
        }, {
            key: "normalTexture",
            get: function() {
                return this._shaderValues.getTexture(WaterPrimaryMaterial.NORMALTEXTURE);
            },
            set: function(e) {
                e ? this._shaderValues.addDefine(WaterPrimaryMaterial.SHADERDEFINE_NORMALTEXTURE) : this._shaderValues.removeDefine(WaterPrimaryMaterial.SHADERDEFINE_NORMALTEXTURE),
                this._shaderValues.setTexture(WaterPrimaryMaterial.NORMALTEXTURE, e);
            }
        }, {
            key: "waveScale",
            get: function() {
                return this._shaderValues.getNumber(WaterPrimaryMaterial.WAVESCALE);
            },
            set: function(e) {
                this._shaderValues.setNumber(WaterPrimaryMaterial.WAVESCALE, e);
            }
        }, {
            key: "waveSpeed",
            get: function() {
                return this._shaderValues.getVector(WaterPrimaryMaterial.WAVESPEED);
            },
            set: function(e) {
                this._shaderValues.setVector(WaterPrimaryMaterial.WAVESPEED, e);
            }
        }], [{
            key: "__initDefine__",
            value: function() {
                WaterPrimaryMaterial.SHADERDEFINE_MAINTEXTURE = G.getDefineByName("MAINTEXTURE"),
                WaterPrimaryMaterial.SHADERDEFINE_NORMALTEXTURE = G.getDefineByName("NORMALTEXTURE");
            }
        }]),
        WaterPrimaryMaterial;
    }();
    pe.HORIZONCOLOR = G.propertyNameToID("u_HorizonColor"),
    pe.MAINTEXTURE = G.propertyNameToID("u_MainTexture"),
    pe.NORMALTEXTURE = G.propertyNameToID("u_NormalTexture"),
    pe.WAVESCALE = G.propertyNameToID("u_WaveScale"),
    pe.WAVESPEED = G.propertyNameToID("u_WaveSpeed");
    var ve = function() {
        function Color() {
            var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 1
              , t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1
              , r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 1
              , n = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 1;
            _classCallCheck(this, Color),
            this.r = e,
            this.g = t,
            this.b = r,
            this.a = n;
        }
        return _createClass(Color, [{
            key: "toLinear",
            value: function(e) {
                e.r = Color.gammaToLinearSpace(this.r),
                e.g = Color.gammaToLinearSpace(this.g),
                e.b = Color.gammaToLinearSpace(this.b);
            }
        }, {
            key: "toGamma",
            value: function(e) {
                e.r = Color.linearToGammaSpace(this.r),
                e.g = Color.linearToGammaSpace(this.g),
                e.b = Color.linearToGammaSpace(this.b);
            }
        }, {
            key: "cloneTo",
            value: function(e) {
                var t = e;
                t.r = this.r,
                t.g = this.g,
                t.b = this.b,
                t.a = this.a;
            }
        }, {
            key: "clone",
            value: function() {
                var e = new Color();
                return this.cloneTo(e),
                e;
            }
        }, {
            key: "forNativeElement",
            value: function() {}
        }], [{
            key: "gammaToLinearSpace",
            value: function(e) {
                return e <= .04045 ? e / 12.92 : e < 1 ? Math.pow((e + .055) / 1.055, 2.4) : Math.pow(e, 2.4);
            }
        }, {
            key: "linearToGammaSpace",
            value: function(e) {
                return e <= 0 ? 0 : e <= .0031308 ? 12.92 * e : e <= 1 ? 1.055 * Math.pow(e, .41666) - .055 : Math.pow(e, .41666);
            }
        }]),
        Color;
    }();
    ve.RED = new ve(1,0,0,1),
    ve.GREEN = new ve(0,1,0,1),
    ve.BLUE = new ve(0,0,1,1),
    ve.CYAN = new ve(0,1,1,1),
    ve.YELLOW = new ve(1,.92,.016,1),
    ve.MAGENTA = new ve(1,0,1,1),
    ve.GRAY = new ve(.5,.5,.5,1),
    ve.WHITE = new ve(1,1,1,1),
    ve.BLACK = new ve(0,0,0,1);
    var Te = function() {
        function DynamicBatchManager() {
            _classCallCheck(this, DynamicBatchManager),
            this._batchRenderElementPool = [];
        }
        return _createClass(DynamicBatchManager, [{
            key: "_clear",
            value: function() {
                this._batchRenderElementPoolIndex = 0;
            }
        }, {
            key: "_getBatchRenderElementFromPool",
            value: function() {
                throw "StaticBatch:must override this function.";
            }
        }, {
            key: "dispose",
            value: function() {}
        }], [{
            key: "_registerManager",
            value: function(e) {
                DynamicBatchManager._managers.push(e);
            }
        }]),
        DynamicBatchManager;
    }();
    Te._managers = [];
    var Ee = function(e) {
        function Transform3D(e) {
            var t;
            return _classCallCheck(this, Transform3D),
            (t = _possibleConstructorReturn(this, _getPrototypeOf(Transform3D).call(this)))._localPosition = new o(0,0,0),
            t._localRotation = new f(0,0,0,1),
            t._localScale = new o(1,1,1),
            t._localRotationEuler = new o(0,0,0),
            t._localMatrix = new I(),
            t._position = new o(0,0,0),
            t._rotation = new f(0,0,0,1),
            t._scale = new o(1,1,1),
            t._rotationEuler = new o(0,0,0),
            t._worldMatrix = new I(),
            t._children = null,
            t._parent = null,
            t._dummy = null,
            t._transformFlag = 0,
            t._owner = e,
            t._children = [],
            t._setTransformFlag(Transform3D.TRANSFORM_LOCALQUATERNION | Transform3D.TRANSFORM_LOCALEULER | Transform3D.TRANSFORM_LOCALMATRIX, !1),
            t._setTransformFlag(Transform3D.TRANSFORM_WORLDPOSITION | Transform3D.TRANSFORM_WORLDQUATERNION | Transform3D.TRANSFORM_WORLDEULER | Transform3D.TRANSFORM_WORLDSCALE | Transform3D.TRANSFORM_WORLDMATRIX, !0),
            t;
        }
        return _inherits(Transform3D, t.EventDispatcher),
        _createClass(Transform3D, [{
            key: "_getScaleMatrix",
            value: function() {
                var e = Transform3D._tempQuaternion0
                  , t = Transform3D._tempMatrix3x30
                  , r = Transform3D._tempMatrix3x31
                  , n = Transform3D._tempMatrix3x32;
                return d.createFromMatrix4x4(this.worldMatrix, r),
                this.rotation.invert(e),
                d.createRotationQuaternion(e, t),
                d.multiply(t, r, n),
                n;
            }
        }, {
            key: "_setTransformFlag",
            value: function(e, t) {
                t ? this._transformFlag |= e : this._transformFlag &= ~e;
            }
        }, {
            key: "_getTransformFlag",
            value: function(e) {
                return 0 != (this._transformFlag & e);
            }
        }, {
            key: "_setParent",
            value: function(e) {
                if (this._parent !== e) {
                    if (this._parent) {
                        var t = this._parent._children
                          , r = t.indexOf(this);
                        t.splice(r, 1);
                    }
                    e && (e._children.push(this),
                    e && this._onWorldTransform()),
                    this._parent = e;
                }
            }
        }, {
            key: "_onWorldPositionRotationTransform",
            value: function() {
                if (!(this._getTransformFlag(Transform3D.TRANSFORM_WORLDMATRIX) && this._getTransformFlag(Transform3D.TRANSFORM_WORLDPOSITION) && this._getTransformFlag(Transform3D.TRANSFORM_WORLDQUATERNION) && this._getTransformFlag(Transform3D.TRANSFORM_WORLDEULER))) {
                    this._setTransformFlag(Transform3D.TRANSFORM_WORLDMATRIX | Transform3D.TRANSFORM_WORLDPOSITION | Transform3D.TRANSFORM_WORLDQUATERNION | Transform3D.TRANSFORM_WORLDEULER, !0),
                    this.event(t.Event.TRANSFORM_CHANGED, this._transformFlag);
                    for (var e = 0, r = this._children.length; e < r; e++)
                        this._children[e]._onWorldPositionRotationTransform();
                }
            }
        }, {
            key: "_onWorldPositionScaleTransform",
            value: function() {
                if (!this._getTransformFlag(Transform3D.TRANSFORM_WORLDMATRIX) || !this._getTransformFlag(Transform3D.TRANSFORM_WORLDPOSITION) || !this._getTransformFlag(Transform3D.TRANSFORM_WORLDSCALE)) {
                    this._setTransformFlag(Transform3D.TRANSFORM_WORLDMATRIX | Transform3D.TRANSFORM_WORLDPOSITION | Transform3D.TRANSFORM_WORLDSCALE, !0),
                    this.event(t.Event.TRANSFORM_CHANGED, this._transformFlag);
                    for (var e = 0, r = this._children.length; e < r; e++)
                        this._children[e]._onWorldPositionScaleTransform();
                }
            }
        }, {
            key: "_onWorldPositionTransform",
            value: function() {
                if (!this._getTransformFlag(Transform3D.TRANSFORM_WORLDMATRIX) || !this._getTransformFlag(Transform3D.TRANSFORM_WORLDPOSITION)) {
                    this._setTransformFlag(Transform3D.TRANSFORM_WORLDMATRIX | Transform3D.TRANSFORM_WORLDPOSITION, !0),
                    this.event(t.Event.TRANSFORM_CHANGED, this._transformFlag);
                    for (var e = 0, r = this._children.length; e < r; e++)
                        this._children[e]._onWorldPositionTransform();
                }
            }
        }, {
            key: "_onWorldRotationTransform",
            value: function() {
                if (!this._getTransformFlag(Transform3D.TRANSFORM_WORLDMATRIX) || !this._getTransformFlag(Transform3D.TRANSFORM_WORLDQUATERNION) || !this._getTransformFlag(Transform3D.TRANSFORM_WORLDEULER)) {
                    this._setTransformFlag(Transform3D.TRANSFORM_WORLDMATRIX | Transform3D.TRANSFORM_WORLDQUATERNION | Transform3D.TRANSFORM_WORLDEULER, !0),
                    this.event(t.Event.TRANSFORM_CHANGED, this._transformFlag);
                    for (var e = 0, r = this._children.length; e < r; e++)
                        this._children[e]._onWorldPositionRotationTransform();
                }
            }
        }, {
            key: "_onWorldScaleTransform",
            value: function() {
                if (!this._getTransformFlag(Transform3D.TRANSFORM_WORLDMATRIX) || !this._getTransformFlag(Transform3D.TRANSFORM_WORLDSCALE)) {
                    this._setTransformFlag(Transform3D.TRANSFORM_WORLDMATRIX | Transform3D.TRANSFORM_WORLDSCALE, !0),
                    this.event(t.Event.TRANSFORM_CHANGED, this._transformFlag);
                    for (var e = 0, r = this._children.length; e < r; e++)
                        this._children[e]._onWorldPositionScaleTransform();
                }
            }
        }, {
            key: "_onWorldTransform",
            value: function() {
                if (!(this._getTransformFlag(Transform3D.TRANSFORM_WORLDMATRIX) && this._getTransformFlag(Transform3D.TRANSFORM_WORLDPOSITION) && this._getTransformFlag(Transform3D.TRANSFORM_WORLDQUATERNION) && this._getTransformFlag(Transform3D.TRANSFORM_WORLDEULER) && this._getTransformFlag(Transform3D.TRANSFORM_WORLDSCALE))) {
                    this._setTransformFlag(Transform3D.TRANSFORM_WORLDMATRIX | Transform3D.TRANSFORM_WORLDPOSITION | Transform3D.TRANSFORM_WORLDQUATERNION | Transform3D.TRANSFORM_WORLDEULER | Transform3D.TRANSFORM_WORLDSCALE, !0),
                    this.event(t.Event.TRANSFORM_CHANGED, this._transformFlag);
                    for (var e = 0, r = this._children.length; e < r; e++)
                        this._children[e]._onWorldTransform();
                }
            }
        }, {
            key: "translate",
            value: function(e) {
                !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1] ? (I.createFromQuaternion(this.localRotation, Transform3D._tempMatrix0),
                o.transformCoordinate(e, Transform3D._tempMatrix0, Transform3D._tempVector30),
                o.add(this.localPosition, Transform3D._tempVector30, this._localPosition),
                this.localPosition = this._localPosition) : (o.add(this.position, e, this._position),
                this.position = this._position);
            }
        }, {
            key: "rotate",
            value: function(e) {
                var t, r = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1];
                !(arguments.length > 2 && void 0 !== arguments[2]) || arguments[2] ? t = e : (o.scale(e, Math.PI / 180, Transform3D._tempVector30),
                t = Transform3D._tempVector30),
                f.createFromYawPitchRoll(t.y, t.x, t.z, Transform3D._tempQuaternion0),
                r ? (f.multiply(this._localRotation, Transform3D._tempQuaternion0, this._localRotation),
                this.localRotation = this._localRotation) : (f.multiply(Transform3D._tempQuaternion0, this.rotation, this._rotation),
                this.rotation = this._rotation);
            }
        }, {
            key: "getForward",
            value: function(e) {
                var t = this.worldMatrix.elements;
                e.x = -t[8],
                e.y = -t[9],
                e.z = -t[10];
            }
        }, {
            key: "getUp",
            value: function(e) {
                var t = this.worldMatrix.elements;
                e.x = t[4],
                e.y = t[5],
                e.z = t[6];
            }
        }, {
            key: "getRight",
            value: function(e) {
                var t = this.worldMatrix.elements;
                e.x = t[0],
                e.y = t[1],
                e.z = t[2];
            }
        }, {
            key: "lookAt",
            value: function(e, t) {
                var n;
                if (arguments.length > 2 && void 0 !== arguments[2] && arguments[2]) {
                    if (n = this._localPosition,
                    Math.abs(n.x - e.x) < r.zeroTolerance && Math.abs(n.y - e.y) < r.zeroTolerance && Math.abs(n.z - e.z) < r.zeroTolerance)
                        return;
                    f.lookAt(this._localPosition, e, t, this._localRotation),
                    this._localRotation.invert(this._localRotation),
                    this.localRotation = this._localRotation;
                } else {
                    var i = this.position;
                    if (n = i,
                    Math.abs(n.x - e.x) < r.zeroTolerance && Math.abs(n.y - e.y) < r.zeroTolerance && Math.abs(n.z - e.z) < r.zeroTolerance)
                        return;
                    f.lookAt(i, e, t, this._rotation),
                    this._rotation.invert(this._rotation),
                    this.rotation = this._rotation;
                }
            }
        }, {
            key: "getWorldLossyScale",
            value: function() {
                if (this._getTransformFlag(Transform3D.TRANSFORM_WORLDSCALE)) {
                    if (null !== this._parent) {
                        var e = this._getScaleMatrix().elements;
                        this._scale.x = e[0],
                        this._scale.y = e[4],
                        this._scale.z = e[8];
                    } else
                        this._localScale.cloneTo(this._scale);
                    this._setTransformFlag(Transform3D.TRANSFORM_WORLDSCALE, !1);
                }
                return this._scale;
            }
        }, {
            key: "setWorldLossyScale",
            value: function(e) {
                if (null !== this._parent) {
                    var t = Transform3D._tempMatrix3x33
                      , r = Transform3D._tempMatrix3x33
                      , n = r.elements
                      , i = this._parent._getScaleMatrix();
                    i.invert(i),
                    d.createFromScaling(e, t),
                    d.multiply(i, t, r),
                    this._localScale.x = n[0],
                    this._localScale.y = n[4],
                    this._localScale.z = n[8];
                } else
                    e.cloneTo(this._localScale);
                this.localScale = this._localScale,
                this._scale !== e && e.cloneTo(this._scale),
                this._setTransformFlag(Transform3D.TRANSFORM_WORLDSCALE, !1);
            }
        }, {
            key: "_isFrontFaceInvert",
            get: function() {
                var e = this.getWorldLossyScale()
                  , t = e.x < 0;
                return e.y < 0 && (t = !t),
                e.z < 0 && (t = !t),
                t;
            }
        }, {
            key: "owner",
            get: function() {
                return this._owner;
            }
        }, {
            key: "worldNeedUpdate",
            get: function() {
                return this._getTransformFlag(Transform3D.TRANSFORM_WORLDMATRIX);
            }
        }, {
            key: "localPositionX",
            get: function() {
                return this._localPosition.x;
            },
            set: function(e) {
                this._localPosition.x = e,
                this.localPosition = this._localPosition;
            }
        }, {
            key: "localPositionY",
            get: function() {
                return this._localPosition.y;
            },
            set: function(e) {
                this._localPosition.y = e,
                this.localPosition = this._localPosition;
            }
        }, {
            key: "localPositionZ",
            get: function() {
                return this._localPosition.z;
            },
            set: function(e) {
                this._localPosition.z = e,
                this.localPosition = this._localPosition;
            }
        }, {
            key: "localPosition",
            get: function() {
                return this._localPosition;
            },
            set: function(e) {
                this._localPosition !== e && e.cloneTo(this._localPosition),
                this._setTransformFlag(Transform3D.TRANSFORM_LOCALMATRIX, !0),
                this._onWorldPositionTransform();
            }
        }, {
            key: "localRotationX",
            get: function() {
                return this.localRotation.x;
            },
            set: function(e) {
                this._localRotation.x = e,
                this.localRotation = this._localRotation;
            }
        }, {
            key: "localRotationY",
            get: function() {
                return this.localRotation.y;
            },
            set: function(e) {
                this._localRotation.y = e,
                this.localRotation = this._localRotation;
            }
        }, {
            key: "localRotationZ",
            get: function() {
                return this.localRotation.z;
            },
            set: function(e) {
                this._localRotation.z = e,
                this.localRotation = this._localRotation;
            }
        }, {
            key: "localRotationW",
            get: function() {
                return this.localRotation.w;
            },
            set: function(e) {
                this._localRotation.w = e,
                this.localRotation = this._localRotation;
            }
        }, {
            key: "localRotation",
            get: function() {
                if (this._getTransformFlag(Transform3D.TRANSFORM_LOCALQUATERNION)) {
                    var e = this._localRotationEuler;
                    f.createFromYawPitchRoll(e.y / Transform3D._angleToRandin, e.x / Transform3D._angleToRandin, e.z / Transform3D._angleToRandin, this._localRotation),
                    this._setTransformFlag(Transform3D.TRANSFORM_LOCALQUATERNION, !1);
                }
                return this._localRotation;
            },
            set: function(e) {
                this._localRotation !== e && e.cloneTo(this._localRotation),
                this._localRotation.normalize(this._localRotation),
                this._setTransformFlag(Transform3D.TRANSFORM_LOCALEULER | Transform3D.TRANSFORM_LOCALMATRIX, !0),
                this._setTransformFlag(Transform3D.TRANSFORM_LOCALQUATERNION, !1),
                this._onWorldRotationTransform();
            }
        }, {
            key: "localScaleX",
            get: function() {
                return this._localScale.x;
            },
            set: function(e) {
                this._localScale.x = e,
                this.localScale = this._localScale;
            }
        }, {
            key: "localScaleY",
            get: function() {
                return this._localScale.y;
            },
            set: function(e) {
                this._localScale.y = e,
                this.localScale = this._localScale;
            }
        }, {
            key: "localScaleZ",
            get: function() {
                return this._localScale.z;
            },
            set: function(e) {
                this._localScale.z = e,
                this.localScale = this._localScale;
            }
        }, {
            key: "localScale",
            get: function() {
                return this._localScale;
            },
            set: function(e) {
                this._localScale !== e && e.cloneTo(this._localScale),
                this._setTransformFlag(Transform3D.TRANSFORM_LOCALMATRIX, !0),
                this._onWorldScaleTransform();
            }
        }, {
            key: "localRotationEulerX",
            get: function() {
                return this.localRotationEuler.x;
            },
            set: function(e) {
                this._localRotationEuler.x = e,
                this.localRotationEuler = this._localRotationEuler;
            }
        }, {
            key: "localRotationEulerY",
            get: function() {
                return this.localRotationEuler.y;
            },
            set: function(e) {
                this._localRotationEuler.y = e,
                this.localRotationEuler = this._localRotationEuler;
            }
        }, {
            key: "localRotationEulerZ",
            get: function() {
                return this.localRotationEuler.z;
            },
            set: function(e) {
                this._localRotationEuler.z = e,
                this.localRotationEuler = this._localRotationEuler;
            }
        }, {
            key: "localRotationEuler",
            get: function() {
                if (this._getTransformFlag(Transform3D.TRANSFORM_LOCALEULER)) {
                    this._localRotation.getYawPitchRoll(Transform3D._tempVector30);
                    var e = Transform3D._tempVector30
                      , t = this._localRotationEuler;
                    t.x = e.y * Transform3D._angleToRandin,
                    t.y = e.x * Transform3D._angleToRandin,
                    t.z = e.z * Transform3D._angleToRandin,
                    this._setTransformFlag(Transform3D.TRANSFORM_LOCALEULER, !1);
                }
                return this._localRotationEuler;
            },
            set: function(e) {
                this._localRotationEuler !== e && e.cloneTo(this._localRotationEuler),
                this._setTransformFlag(Transform3D.TRANSFORM_LOCALEULER, !1),
                this._setTransformFlag(Transform3D.TRANSFORM_LOCALQUATERNION | Transform3D.TRANSFORM_LOCALMATRIX, !0),
                this._onWorldRotationTransform();
            }
        }, {
            key: "localMatrix",
            get: function() {
                return this._getTransformFlag(Transform3D.TRANSFORM_LOCALMATRIX) && (I.createAffineTransformation(this._localPosition, this.localRotation, this._localScale, this._localMatrix),
                this._setTransformFlag(Transform3D.TRANSFORM_LOCALMATRIX, !1)),
                this._localMatrix;
            },
            set: function(e) {
                this._localMatrix !== e && e.cloneTo(this._localMatrix),
                this._localMatrix.decomposeTransRotScale(this._localPosition, this._localRotation, this._localScale),
                this._setTransformFlag(Transform3D.TRANSFORM_LOCALEULER, !0),
                this._setTransformFlag(Transform3D.TRANSFORM_LOCALMATRIX, !1),
                this._onWorldTransform();
            }
        }, {
            key: "position",
            get: function() {
                if (this._getTransformFlag(Transform3D.TRANSFORM_WORLDPOSITION)) {
                    if (null != this._parent) {
                        var e = this.worldMatrix.elements;
                        this._position.x = e[12],
                        this._position.y = e[13],
                        this._position.z = e[14];
                    } else
                        this._localPosition.cloneTo(this._position);
                    this._setTransformFlag(Transform3D.TRANSFORM_WORLDPOSITION, !1);
                }
                return this._position;
            },
            set: function(e) {
                if (null != this._parent) {
                    var t = Transform3D._tempMatrix0;
                    this._parent.worldMatrix.invert(t),
                    o.transformCoordinate(e, t, this._localPosition);
                } else
                    e.cloneTo(this._localPosition);
                this.localPosition = this._localPosition,
                this._position !== e && e.cloneTo(this._position),
                this._setTransformFlag(Transform3D.TRANSFORM_WORLDPOSITION, !1);
            }
        }, {
            key: "rotation",
            get: function() {
                return this._getTransformFlag(Transform3D.TRANSFORM_WORLDQUATERNION) && (null != this._parent ? f.multiply(this._parent.rotation, this.localRotation, this._rotation) : this.localRotation.cloneTo(this._rotation),
                this._setTransformFlag(Transform3D.TRANSFORM_WORLDQUATERNION, !1)),
                this._rotation;
            },
            set: function(e) {
                null != this._parent ? (this._parent.rotation.invert(Transform3D._tempQuaternion0),
                f.multiply(Transform3D._tempQuaternion0, e, this._localRotation)) : e.cloneTo(this._localRotation),
                this.localRotation = this._localRotation,
                e !== this._rotation && e.cloneTo(this._rotation),
                this._setTransformFlag(Transform3D.TRANSFORM_WORLDQUATERNION, !1);
            }
        }, {
            key: "rotationEuler",
            get: function() {
                if (this._getTransformFlag(Transform3D.TRANSFORM_WORLDEULER)) {
                    this.rotation.getYawPitchRoll(Transform3D._tempVector30);
                    var e = Transform3D._tempVector30
                      , t = this._rotationEuler;
                    t.x = e.y * Transform3D._angleToRandin,
                    t.y = e.x * Transform3D._angleToRandin,
                    t.z = e.z * Transform3D._angleToRandin,
                    this._setTransformFlag(Transform3D.TRANSFORM_WORLDEULER, !1);
                }
                return this._rotationEuler;
            },
            set: function(e) {
                f.createFromYawPitchRoll(e.y / Transform3D._angleToRandin, e.x / Transform3D._angleToRandin, e.z / Transform3D._angleToRandin, this._rotation),
                this.rotation = this._rotation,
                this._rotationEuler !== e && e.cloneTo(this._rotationEuler),
                this._setTransformFlag(Transform3D.TRANSFORM_WORLDEULER, !1);
            }
        }, {
            key: "worldMatrix",
            get: function() {
                return this._getTransformFlag(Transform3D.TRANSFORM_WORLDMATRIX) && (null != this._parent ? I.multiply(this._parent.worldMatrix, this.localMatrix, this._worldMatrix) : this.localMatrix.cloneTo(this._worldMatrix),
                this._setTransformFlag(Transform3D.TRANSFORM_WORLDMATRIX, !1)),
                this._worldMatrix;
            },
            set: function(e) {
                null === this._parent ? e.cloneTo(this._localMatrix) : (this._parent.worldMatrix.invert(this._localMatrix),
                I.multiply(this._localMatrix, e, this._localMatrix)),
                this.localMatrix = this._localMatrix,
                this._worldMatrix !== e && e.cloneTo(this._worldMatrix),
                this._setTransformFlag(Transform3D.TRANSFORM_WORLDMATRIX, !1);
            }
        }, {
            key: "scale",
            get: function() {
                return console.warn("Transfrm3D: discard function,please use getWorldLossyScale instead."),
                this.getWorldLossyScale();
            },
            set: function(e) {
                console.warn("Transfrm3D: discard function,please use setWorldLossyScale instead."),
                this.setWorldLossyScale(e);
            }
        }]),
        Transform3D;
    }();
    Ee._tempVector30 = new o(),
    Ee._tempQuaternion0 = new f(),
    Ee._tempMatrix0 = new I(),
    Ee._tempMatrix3x30 = new d(),
    Ee._tempMatrix3x31 = new d(),
    Ee._tempMatrix3x32 = new d(),
    Ee._tempMatrix3x33 = new d(),
    Ee.TRANSFORM_LOCALQUATERNION = 1,
    Ee.TRANSFORM_LOCALEULER = 2,
    Ee.TRANSFORM_LOCALMATRIX = 4,
    Ee.TRANSFORM_WORLDPOSITION = 8,
    Ee.TRANSFORM_WORLDQUATERNION = 16,
    Ee.TRANSFORM_WORLDSCALE = 32,
    Ee.TRANSFORM_WORLDMATRIX = 64,
    Ee.TRANSFORM_WORLDEULER = 128,
    Ee._angleToRandin = 180 / Math.PI;
    var ye = function(e) {
        function Sprite3D() {
            var e, t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null, r = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
            return _classCallCheck(this, Sprite3D),
            (e = _possibleConstructorReturn(this, _getPrototypeOf(Sprite3D).call(this)))._needProcessCollisions = !1,
            e._needProcessTriggers = !1,
            e._id = ++Sprite3D._uniqueIDCounter,
            e._transform = new Ee(_assertThisInitialized(e)),
            e._isStatic = r,
            e.layer = 0,
            e.name = t || "New Sprite3D",
            e;
        }
        return _inherits(Sprite3D, t.Node),
        _createClass(Sprite3D, [{
            key: "_setCreateURL",
            value: function(e) {
                this._url = t.URL.formatURL(e);
            }
        }, {
            key: "_changeAnimatorsToLinkSprite3D",
            value: function(e, t, r) {
                var n = this.getComponent(N);
                if (n && (n.avatar || e._changeAnimatorToLinkSprite3DNoAvatar(n, t, r)),
                this._parent && this._parent instanceof Sprite3D) {
                    r.unshift(this._parent.name);
                    var i = this._parent;
                    i._hierarchyAnimator && i._changeAnimatorsToLinkSprite3D(e, t, r);
                }
            }
        }, {
            key: "_setHierarchyAnimator",
            value: function(e, t) {
                this._changeHierarchyAnimator(e),
                this._changeAnimatorAvatar(e.avatar);
                for (var r = 0, n = this._children.length; r < n; r++) {
                    var i = this._children[r];
                    i._hierarchyAnimator == t && i._setHierarchyAnimator(e, t);
                }
            }
        }, {
            key: "_clearHierarchyAnimator",
            value: function(e, t) {
                this._changeHierarchyAnimator(t),
                this._changeAnimatorAvatar(t ? t.avatar : null);
                for (var r = 0, n = this._children.length; r < n; r++) {
                    var i = this._children[r];
                    i._hierarchyAnimator == e && i._clearHierarchyAnimator(e, t);
                }
            }
        }, {
            key: "_changeHierarchyAnimatorAvatar",
            value: function(e, t) {
                this._changeAnimatorAvatar(t);
                for (var r = 0, n = this._children.length; r < n; r++) {
                    var i = this._children[r];
                    i._hierarchyAnimator == e && i._changeHierarchyAnimatorAvatar(e, t);
                }
            }
        }, {
            key: "_changeAnimatorToLinkSprite3DNoAvatar",
            value: function(e, t, r) {
                e._handleSpriteOwnersBySprite(t, r, this);
                for (var n = 0, i = this._children.length; n < i; n++) {
                    var a = this._children[n]
                      , o = r.length;
                    r.push(a.name),
                    a._changeAnimatorToLinkSprite3DNoAvatar(e, t, r),
                    r.splice(o, 1);
                }
            }
        }, {
            key: "_changeHierarchyAnimator",
            value: function(e) {
                this._hierarchyAnimator = e;
            }
        }, {
            key: "_changeAnimatorAvatar",
            value: function(e) {}
        }, {
            key: "_onAdded",
            value: function() {
                if (this._parent instanceof Sprite3D) {
                    var e = this._parent;
                    this.transform._setParent(e.transform),
                    e._hierarchyAnimator && (!this._hierarchyAnimator && this._setHierarchyAnimator(e._hierarchyAnimator, null),
                    e._changeAnimatorsToLinkSprite3D(this, !0, [this.name]));
                }
                _get(_getPrototypeOf(Sprite3D.prototype), "_onAdded", this).call(this);
            }
        }, {
            key: "_onRemoved",
            value: function() {
                if (_get(_getPrototypeOf(Sprite3D.prototype), "_onRemoved", this).call(this),
                this._parent instanceof Sprite3D) {
                    var e = this._parent;
                    this.transform._setParent(null),
                    e._hierarchyAnimator && (this._hierarchyAnimator == e._hierarchyAnimator && this._clearHierarchyAnimator(e._hierarchyAnimator, null),
                    e._changeAnimatorsToLinkSprite3D(this, !1, [this.name]));
                }
            }
        }, {
            key: "_parse",
            value: function(e, t) {
                if (void 0 !== e.isStatic && (this._isStatic = e.isStatic),
                void 0 !== e.active && (this.active = e.active),
                null != e.name && (this.name = e.name),
                void 0 !== e.position) {
                    var r = this.transform.localPosition;
                    r.fromArray(e.position),
                    this.transform.localPosition = r;
                }
                if (void 0 !== e.rotationEuler) {
                    var n = this.transform.localRotationEuler;
                    n.fromArray(e.rotationEuler),
                    this.transform.localRotationEuler = n;
                }
                if (void 0 !== e.rotation) {
                    var i = this.transform.localRotation;
                    i.fromArray(e.rotation),
                    this.transform.localRotation = i;
                }
                if (void 0 !== e.scale) {
                    var a = this.transform.localScale;
                    a.fromArray(e.scale),
                    this.transform.localScale = a;
                }
                null != e.layer && (this.layer = e.layer);
            }
        }, {
            key: "_cloneTo",
            value: function(e, t, r) {
                if (this.destroyed)
                    throw new Error("Sprite3D: Can't be cloned if the Sprite3D has destroyed.");
                var n = e
                  , i = this._transform
                  , a = n._transform;
                n.name = this.name,
                n.destroyed = this.destroyed,
                n.active = this.active,
                a.localPosition = i.localPosition,
                a.localRotation = i.localRotation,
                a.localScale = i.localScale,
                n._isStatic = this._isStatic,
                n.layer = this.layer,
                _get(_getPrototypeOf(Sprite3D.prototype), "_cloneTo", this).call(this, n, t, r);
            }
        }, {
            key: "clone",
            value: function() {
                var e = Sprite3D._createSprite3DInstance(this);
                return Sprite3D._parseSprite3DInstance(this, e, this, e),
                e;
            }
        }, {
            key: "destroy",
            value: function() {
                var e = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0];
                this.destroyed || (_get(_getPrototypeOf(Sprite3D.prototype), "destroy", this).call(this, e),
                this._transform = null,
                this._scripts = null,
                this._url && t.Loader.clearRes(this._url));
            }
        }, {
            key: "_create",
            value: function() {
                return new Sprite3D();
            }
        }, {
            key: "id",
            get: function() {
                return this._id;
            }
        }, {
            key: "layer",
            get: function() {
                return this._layer;
            },
            set: function(e) {
                if (this._layer !== e) {
                    if (!(e >= 0 && e <= 30))
                        throw new Error("Layer value must be 0-30.");
                    this._layer = e;
                }
            }
        }, {
            key: "url",
            get: function() {
                return this._url;
            }
        }, {
            key: "isStatic",
            get: function() {
                return this._isStatic;
            }
        }, {
            key: "transform",
            get: function() {
                return this._transform;
            }
        }], [{
            key: "__init__",
            value: function() {}
        }, {
            key: "instantiate",
            value: function(e) {
                var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null
                  , r = !(arguments.length > 2 && void 0 !== arguments[2]) || arguments[2]
                  , n = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : null
                  , i = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : null
                  , a = e.clone();
                t && t.addChild(a);
                var o = a.transform;
                if (r) {
                    var s = o.worldMatrix;
                    e.transform.worldMatrix.cloneTo(s),
                    o.worldMatrix = s;
                } else
                    n && (o.position = n),
                    i && (o.rotation = i);
                return a;
            }
        }, {
            key: "load",
            value: function(e, r) {
                t.Laya.loader.create(e, r, null, Sprite3D.HIERARCHY);
            }
        }, {
            key: "_createSprite3DInstance",
            value: function(e) {
                for (var t = e._create(), r = e._children, n = 0, i = r.length; n < i; n++) {
                    var a = Sprite3D._createSprite3DInstance(r[n]);
                    t.addChild(a);
                }
                return t;
            }
        }, {
            key: "_parseSprite3DInstance",
            value: function(e, t, r, n) {
                for (var i = r._children, a = n._children, o = 0, s = i.length; o < s; o++)
                    Sprite3D._parseSprite3DInstance(e, t, i[o], a[o]);
                r._cloneTo(n, e, t);
            }
        }]),
        Sprite3D;
    }();
    ye.HIERARCHY = "HIERARCHY",
    ye.WORLDMATRIX = G.propertyNameToID("u_WorldMat"),
    ye.MVPMATRIX = G.propertyNameToID("u_MvpMatrix"),
    ye._uniqueIDCounter = 0;
    var ge = function(e) {
        function RenderableSprite3D(e) {
            return _classCallCheck(this, RenderableSprite3D),
            _possibleConstructorReturn(this, _getPrototypeOf(RenderableSprite3D).call(this, e));
        }
        return _inherits(RenderableSprite3D, ye),
        _createClass(RenderableSprite3D, [{
            key: "_onInActive",
            value: function() {
                _get(_getPrototypeOf(RenderableSprite3D.prototype), "_onInActive", this).call(this),
                this._scene._removeRenderObject(this._render);
            }
        }, {
            key: "_onActive",
            value: function() {
                _get(_getPrototypeOf(RenderableSprite3D.prototype), "_onActive", this).call(this),
                this._scene._addRenderObject(this._render);
            }
        }, {
            key: "_onActiveInScene",
            value: function() {
                if (_get(_getPrototypeOf(RenderableSprite3D.prototype), "_onActiveInScene", this).call(this),
                l.Laya3D._editerEnvironment) {
                    var e = this._scene
                      , t = new i();
                    e._allotPickColorByID(this.id, t),
                    e._pickIdToSprite[this.id] = this,
                    this._render._shaderValues.setVector(RenderableSprite3D.PICKCOLOR, t);
                }
            }
        }, {
            key: "_addToInitStaticBatchManager",
            value: function() {}
        }, {
            key: "_setBelongScene",
            value: function(e) {
                _get(_getPrototypeOf(RenderableSprite3D.prototype), "_setBelongScene", this).call(this, e),
                this._render._setBelongScene(e);
            }
        }, {
            key: "_setUnBelongScene",
            value: function() {
                this._render._shaderValues.removeDefine(RenderableSprite3D.SAHDERDEFINE_LIGHTMAP),
                _get(_getPrototypeOf(RenderableSprite3D.prototype), "_setUnBelongScene", this).call(this);
            }
        }, {
            key: "_changeHierarchyAnimator",
            value: function(e) {
                if (this._hierarchyAnimator) {
                    var t = this._hierarchyAnimator._renderableSprites;
                    t.splice(t.indexOf(this), 1);
                }
                e && e._renderableSprites.push(this),
                _get(_getPrototypeOf(RenderableSprite3D.prototype), "_changeHierarchyAnimator", this).call(this, e);
            }
        }, {
            key: "destroy",
            value: function() {
                var e = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0];
                _get(_getPrototypeOf(RenderableSprite3D.prototype), "destroy", this).call(this, e),
                this._render._destroy(),
                this._render = null;
            }
        }, {
            key: "_create",
            value: function() {
                return new RenderableSprite3D(this.name);
            }
        }], [{
            key: "__init__",
            value: function() {
                RenderableSprite3D.SHADERDEFINE_RECEIVE_SHADOW = G.getDefineByName("RECEIVESHADOW"),
                RenderableSprite3D.SAHDERDEFINE_LIGHTMAP = G.getDefineByName("LIGHTMAP");
            }
        }]),
        RenderableSprite3D;
    }();
    ge.LIGHTMAPSCALEOFFSET = G.propertyNameToID("u_LightmapScaleOffset"),
    ge.LIGHTMAP = G.propertyNameToID("u_LightMap"),
    ge.PICKCOLOR = G.propertyNameToID("u_PickColor");
    var Se = function() {
        function StaticBatchManager() {
            _classCallCheck(this, StaticBatchManager),
            this._initBatchSprites = [],
            this._staticBatches = {},
            this._batchRenderElementPoolIndex = 0,
            this._batchRenderElementPool = [];
        }
        return _createClass(StaticBatchManager, [{
            key: "_partition",
            value: function(e, t, r) {
                for (var n = e[Math.floor((r + t) / 2)]; t <= r; ) {
                    for (; this._compare(e[t], n) < 0; )
                        t++;
                    for (; this._compare(e[r], n) > 0; )
                        r--;
                    if (t < r) {
                        var i = e[t];
                        e[t] = e[r],
                        e[r] = i,
                        t++,
                        r--;
                    } else if (t === r) {
                        t++;
                        break;
                    }
                }
                return t;
            }
        }, {
            key: "_quickSort",
            value: function(e, t, r) {
                if (e.length > 1) {
                    var n = this._partition(e, t, r)
                      , i = n - 1;
                    t < i && this._quickSort(e, t, i),
                    n < r && this._quickSort(e, n, r);
                }
            }
        }, {
            key: "_compare",
            value: function(e, t) {
                throw "StaticBatch:must override this function.";
            }
        }, {
            key: "_initStaticBatchs",
            value: function(e) {
                throw "StaticBatch:must override this function.";
            }
        }, {
            key: "_getBatchRenderElementFromPool",
            value: function() {
                throw "StaticBatch:must override this function.";
            }
        }, {
            key: "_addBatchSprite",
            value: function(e) {
                this._initBatchSprites.push(e);
            }
        }, {
            key: "_clear",
            value: function() {
                this._batchRenderElementPoolIndex = 0;
            }
        }, {
            key: "_garbageCollection",
            value: function() {
                throw "StaticBatchManager: must override it.";
            }
        }, {
            key: "dispose",
            value: function() {
                this._staticBatches = null;
            }
        }], [{
            key: "_addToStaticBatchQueue",
            value: function(e, t) {
                e instanceof ge && t.push(e);
                for (var r = 0, n = e.numChildren; r < n; r++)
                    StaticBatchManager._addToStaticBatchQueue(e._children[r], t);
            }
        }, {
            key: "_registerManager",
            value: function(e) {
                StaticBatchManager._managers.push(e);
            }
        }, {
            key: "combine",
            value: function(e) {
                var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null;
                t || (t = [],
                e && StaticBatchManager._addToStaticBatchQueue(e, t));
                var r = t.length;
                if (r > 0) {
                    for (var n = 0; n < r; n++) {
                        var i = t[n];
                        i.destroyed || (i._render._isPartOfStaticBatch ? console.warn("StaticBatchManager: Sprite " + i.name + " has a part of Static Batch,it will be ignore.") : i._addToInitStaticBatchManager());
                    }
                    for (var a = 0, o = StaticBatchManager._managers.length; a < o; a++) {
                        StaticBatchManager._managers[a]._initStaticBatchs(e);
                    }
                }
            }
        }]),
        StaticBatchManager;
    }();
    Se._managers = [];
    var Re = function() {
        function FrustumCulling() {
            _classCallCheck(this, FrustumCulling);
        }
        return _createClass(FrustumCulling, null, [{
            key: "__init__",
            value: function() {
                t.Render.supportWebGLPlusCulling && (FrustumCulling._cullingBufferLength = 0,
                FrustumCulling._cullingBuffer = new Float32Array(4096));
            }
        }, {
            key: "_drawTraversalCullingBound",
            value: function(e, t) {
                e.length;
                for (var r = e.elements, n = 0, i = e.length; n < i; n++) {
                    var a = FrustumCulling._tempColor0;
                    a.r = 0,
                    a.g = 1,
                    a.b = 0,
                    a.a = 1,
                    R._drawBound(t, r[n].bounds._getBoundBox(), a);
                }
            }
        }, {
            key: "_traversalCulling",
            value: function(e, r, n, i, a, s, l) {
                for (var u = i.elements, c = e.boundFrustum, h = e._transform.position, _ = t.Stat.loopCount, d = 0, f = i.length; d < f; d++) {
                    var m = u[d];
                    if ((l ? m._castShadow && m._enable : e._isLayerVisible(m._owner._layer) && m._enable) && (t.Stat.frustumCulling++,
                    !e.useOcclusionCulling || m._needRender(c, n))) {
                        m._renderMark = _,
                        m._distanceForSort = o.distance(m.bounds.getCenter(), h);
                        for (var p = m._renderElements, v = 0, T = p.length; v < T; v++)
                            p[v]._update(r, n, a, s);
                    }
                }
            }
        }, {
            key: "renderObjectCulling",
            value: function(e, t, r, n, i, a) {
                var o, s, l = t._opaqueQueue, u = t._transparentQueue, c = t._renders;
                l.clear(),
                u.clear();
                var h = Se._managers;
                for (o = 0,
                s = h.length; o < s; o++)
                    h[o]._clear();
                var _ = Te._managers;
                for (o = 0,
                s = _.length; o < s; o++)
                    _[o]._clear();
                var d = t._octree;
                if (d && (d.updateMotionObjects(),
                d.shrinkRootIfPossible(),
                d.getCollidingWithFrustum(r, n, i, a)),
                FrustumCulling._traversalCulling(e, t, r, c, n, i, a),
                FrustumCulling.debugFrustumCulling) {
                    var f = t._debugTool;
                    f.clear(),
                    d && (d.drawAllBounds(f),
                    d.drawAllObjects(f)),
                    FrustumCulling._drawTraversalCullingBound(c, f);
                }
                var m = l.elements.length;
                m > 0 && l._quickSort(0, m - 1),
                (m = u.elements.length) > 0 && u._quickSort(0, m - 1);
            }
        }, {
            key: "renderObjectCullingNative",
            value: function(e, r, n, i, a, s) {
                var l, u, c, h, _ = r._opaqueQueue, d = r._transparentQueue;
                _.clear(),
                d.clear();
                var f = Se._managers;
                for (l = 0,
                u = f.length; l < u; l++)
                    f[l]._clear();
                var m = Te._managers;
                for (l = 0,
                u = m.length; l < u; l++)
                    m[l]._clear();
                var p = i.length
                  , v = i.elements;
                for (l = 0; l < p; l++)
                    v[l].bounds,
                    v[l]._updateForNative && v[l]._updateForNative(n);
                e.boundFrustum;
                FrustumCulling.cullingNative(e._boundFrustumBuffer, FrustumCulling._cullingBuffer, r._cullingBufferIndices, p, r._cullingBufferResult);
                var T = t.Stat.loopCount
                  , E = n.camera._transform.position;
                for (l = 0; l < p; l++) {
                    var y = v[l];
                    if (!e.useOcclusionCulling || e._isLayerVisible(y._owner._layer) && y._enable && r._cullingBufferResult[l]) {
                        y._renderMark = T,
                        y._distanceForSort = o.distance(y.bounds.getCenter(), E);
                        var g = y._renderElements;
                        for (c = 0,
                        h = g.length; c < h; c++) {
                            g[c]._update(r, n, a, s);
                        }
                    }
                }
                var S = _.elements.length;
                S > 0 && _._quickSort(0, S - 1),
                (S = d.elements.length) > 0 && d._quickSort(0, S - 1);
            }
        }, {
            key: "cullingNative",
            value: function(e, r, n, i, a) {
                return t.LayaGL.instance.culling(e, r, n, i, a);
            }
        }]),
        FrustumCulling;
    }();
    Re._tempVector3 = new o(),
    Re._tempColor0 = new ve(),
    Re.debugFrustumCulling = !1;
    var Ce = function BatchMark() {
        _classCallCheck(this, BatchMark),
        this.updateMark = -1,
        this.indexInList = -1,
        this.batched = !1;
    }
      , Me = function() {
        function GeometryElement() {
            _classCallCheck(this, GeometryElement),
            this._destroyed = !1;
        }
        return _createClass(GeometryElement, [{
            key: "_getType",
            value: function() {
                throw "GeometryElement:must override it.";
            }
        }, {
            key: "_prepareRender",
            value: function(e) {
                return !0;
            }
        }, {
            key: "_render",
            value: function(e) {
                throw "GeometryElement:must override it.";
            }
        }, {
            key: "destroy",
            value: function() {
                this._destroyed || (this._destroyed = !0);
            }
        }, {
            key: "destroyed",
            get: function() {
                return this._destroyed;
            }
        }]),
        GeometryElement;
    }();
    Me._typeCounter = 0;
    var De = function(e) {
        function VertexBuffer3D(e, r) {
            var n, i = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
            _classCallCheck(this, VertexBuffer3D),
            (n = _possibleConstructorReturn(this, _getPrototypeOf(VertexBuffer3D).call(this)))._vertexDeclaration = null,
            n._float32Reader = null;
            var a = t.LayaGL.instance;
            return n._bufferUsage = r,
            n._bufferType = a.ARRAY_BUFFER,
            n._canRead = i,
            n._byteLength = e,
            n.bind(),
            a.bufferData(n._bufferType, n._byteLength, n._bufferUsage),
            i && (n._buffer = new Uint8Array(e),
            n._float32Reader = new Float32Array(n._buffer.buffer)),
            n;
        }
        return _inherits(VertexBuffer3D, t.Buffer),
        _createClass(VertexBuffer3D, [{
            key: "bind",
            value: function() {
                if (t.Buffer._bindedVertexBuffer !== this._glBuffer) {
                    var e = t.LayaGL.instance;
                    return e.bindBuffer(e.ARRAY_BUFFER, this._glBuffer),
                    t.Buffer._bindedVertexBuffer = this._glBuffer,
                    !0;
                }
                return !1;
            }
        }, {
            key: "setData",
            value: function(e) {
                var r = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0
                  , n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0
                  , i = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : Number.MAX_SAFE_INTEGER;
                if (this.bind(),
                0 !== n || i !== Number.MAX_SAFE_INTEGER) {
                    var a = new Uint8Array(e,n,i);
                    t.LayaGL.instance.bufferSubData(this._bufferType, r, a),
                    this._canRead && this._buffer.set(a, r);
                } else
                    t.LayaGL.instance.bufferSubData(this._bufferType, r, e),
                    this._canRead && this._buffer.set(new Uint8Array(e), r);
            }
        }, {
            key: "getUint8Data",
            value: function() {
                if (this._canRead)
                    return this._buffer;
                throw new Error("Can't read data from VertexBuffer with only write flag!");
            }
        }, {
            key: "getFloat32Data",
            value: function() {
                if (this._canRead)
                    return this._float32Reader;
                throw new Error("Can't read data from VertexBuffer with only write flag!");
            }
        }, {
            key: "markAsUnreadbale",
            value: function() {
                this._canRead = !1,
                this._buffer = null,
                this._float32Reader = null;
            }
        }, {
            key: "destroy",
            value: function() {
                _get(_getPrototypeOf(VertexBuffer3D.prototype), "destroy", this).call(this),
                this._buffer = null,
                this._float32Reader = null,
                this._vertexDeclaration = null;
            }
        }, {
            key: "vertexDeclaration",
            get: function() {
                return this._vertexDeclaration;
            },
            set: function(e) {
                this._vertexDeclaration = e;
            }
        }, {
            key: "canRead",
            get: function() {
                return this._canRead;
            }
        }]),
        VertexBuffer3D;
    }();
    De.DATATYPE_FLOAT32ARRAY = 0,
    De.DATATYPE_UINT8ARRAY = 1;
    var xe = function(e) {
        function SubMeshInstanceBatch() {
            var e;
            _classCallCheck(this, SubMeshInstanceBatch),
            (e = _possibleConstructorReturn(this, _getPrototypeOf(SubMeshInstanceBatch).call(this))).maxInstanceCount = 1024,
            e.instanceWorldMatrixData = new Float32Array(16 * e.maxInstanceCount),
            e.instanceMVPMatrixData = new Float32Array(16 * e.maxInstanceCount);
            var r = t.LayaGL.instance;
            return e.instanceWorldMatrixBuffer = new De(4 * e.instanceWorldMatrixData.length,r.DYNAMIC_DRAW),
            e.instanceMVPMatrixBuffer = new De(4 * e.instanceMVPMatrixData.length,r.DYNAMIC_DRAW),
            e.instanceWorldMatrixBuffer.vertexDeclaration = ue.instanceWorldMatrixDeclaration,
            e.instanceMVPMatrixBuffer.vertexDeclaration = ue.instanceMVPMatrixDeclaration,
            e;
        }
        return _inherits(SubMeshInstanceBatch, Me),
        _createClass(SubMeshInstanceBatch, [{
            key: "_render",
            value: function(e) {
                var r = t.LayaGL.instance
                  , n = e.renderElement
                  , i = n.instanceSubMesh
                  , a = n.instanceBatchElementList.length
                  , o = i._indexCount;
                i._mesh._instanceBufferState.bind(),
                t.LayaGL.layaGPUInstance.drawElementsInstanced(r.TRIANGLES, o, r.UNSIGNED_SHORT, 2 * i._indexStart, a),
                t.Stat.renderBatches++,
                t.Stat.savedRenderBatches += a - 1,
                t.Stat.trianglesFaces += o * a / 3;
            }
        }], [{
            key: "__init__",
            value: function() {
                SubMeshInstanceBatch.instance = new SubMeshInstanceBatch();
            }
        }]),
        SubMeshInstanceBatch;
    }()
      , Ae = function ClusterData() {
        _classCallCheck(this, ClusterData),
        this.updateMark = -1,
        this.pointLightCount = 0,
        this.spotLightCount = 0,
        this.indices = [];
    }
      , Ie = function() {
        function Cluster(e, t, r, i) {
            _classCallCheck(this, Cluster),
            this._updateMark = 0,
            this._depthSliceParam = new n(),
            this._xSlices = e,
            this._ySlices = t,
            this._zSlices = r;
            var a = e * t
              , o = r * (1 + Math.ceil(i / 4));
            this._clusterTexture = R._createFloatTextureBuffer(a, o),
            this._clusterTexture.lock = !0,
            this._clusterPixels = new Float32Array(a * o * 4);
            for (var s = new Array(this._zSlices), l = 0; l < this._zSlices; l++) {
                s[l] = new Array(this._ySlices);
                for (var u = 0; u < this._ySlices; u++) {
                    s[l][u] = new Array(this._xSlices);
                    for (var c = 0; c < this._xSlices; c++)
                        s[l][u][c] = new Ae();
                }
            }
            this._clusterDatas = s;
        }
        return _createClass(Cluster, [{
            key: "_insertSpotLightSphere",
            value: function(e, t, r, n, i) {
                var a = Cluster._tempVector35;
                a.x = i.x - e.x,
                a.y = i.y - e.y,
                a.z = i.z - e.z;
                var s = o.dot(a, a)
                  , l = i.w;
                if (!(s > l * l))
                    return !1;
                var u = o.dot(a, t);
                return !(Math.cos(n) * Math.sqrt(s - u * u) - u * Math.sin(n) > l || u > l + r || u < -l);
            }
        }, {
            key: "_placePointLightToClusters",
            value: function(e, t) {
                for (var r = this._clusterDatas, n = this._updateMark, i = t.zMin, a = t.zMax; i < a; i++)
                    for (var o = t.yMin, s = t.yMax; o < s; o++)
                        for (var l = t.xMin, u = t.xMax; l < u; l++) {
                            var c = r[i][o][l];
                            c.updateMark != n && (c.pointLightCount = 0,
                            c.spotLightCount = 0,
                            c.updateMark = n);
                            var h = c.indices
                              , _ = c.pointLightCount++;
                            _ < h.length ? h[_] = e : h.push(e);
                        }
            }
        }, {
            key: "_placeSpotLightToClusters",
            value: function(e, t) {
                for (var r = this._clusterDatas, n = this._updateMark, i = t.zMin, a = t.zMax; i < a; i++)
                    for (var o = t.yMin, s = t.yMax; o < s; o++)
                        for (var l = t.xMin, u = t.xMax; l < u; l++) {
                            var c = r[i][o][l];
                            c.updateMark != n && (c.pointLightCount = 0,
                            c.spotLightCount = 0,
                            c.updateMark = n);
                            var h = c.indices
                              , _ = c.pointLightCount + c.spotLightCount++;
                            _ < h.length ? h[_] = e : h.push(e);
                        }
            }
        }, {
            key: "_insertConePlane",
            value: function(e, t, r, n, i) {
                var a = Cluster._tempVector36
                  , s = Cluster._tempVector37;
                o.cross(i, t, a),
                o.cross(a, t, s),
                o.normalize(s, s);
                var l = r * Math.tan(n)
                  , u = e.x + r * t.x + l * s.x
                  , c = e.y + r * t.y + l * s.y
                  , h = e.z + r * t.z + l * s.z;
                return u * i.x + c * i.y + h * i.z <= 0 || e.x * i.x + e.y * i.y + e.z * i.z <= 0;
            }
        }, {
            key: "_shrinkSphereLightZPerspective",
            value: function(e, t, r, n, i) {
                var a = r.z
                  , o = a - n
                  , s = a + n;
                if (o > t || s <= e)
                    return !1;
                var l = this._depthSliceParam;
                return i.zMin = Math.floor(Math.log2(Math.max(o, e)) * l.x - l.y),
                i.zMax = Math.min(Math.ceil(Math.log2(s) * l.x - l.y), this._zSlices),
                !0;
            }
        }, {
            key: "_shrinkSpotLightZPerspective",
            value: function(e, t, r, n, i, a, o) {
                var s = n.x
                  , l = n.y
                  , u = n.z
                  , c = Math.tan(a) * i
                  , h = r.x
                  , _ = r.y
                  , d = r.z
                  , f = s - h
                  , m = l - _
                  , p = u - d
                  , v = f * f + m * m + p * p
                  , T = Math.sqrt(1 - p * p / v)
                  , E = Math.max(Math.min(d, u - T * c), r.z - i)
                  , y = Math.min(Math.max(d, u + T * c), r.z + i);
                if (E > t || y <= e)
                    return !1;
                var g = this._depthSliceParam;
                return o.zMin = Math.floor(Math.log2(Math.max(E, e)) * g.x - g.y),
                o.zMax = Math.min(Math.ceil(Math.log2(y) * g.x - g.y), this._zSlices),
                !0;
            }
        }, {
            key: "_shrinkSphereLightByBoundOrth",
            value: function(e, t, r, n, i, a, o) {
                var s = i.z
                  , l = s - a
                  , u = s + a;
                if (l > n || u <= r)
                    return !1;
                var c = i.x
                  , h = c - a
                  , _ = c + a;
                if (h > e || _ <= -e)
                    return !1;
                var d = i.y
                  , f = d - a
                  , m = d + a;
                if (f > t || m <= -t)
                    return !1;
                var p = this._xSlices
                  , v = this._ySlices
                  , T = this._depthSliceParam
                  , E = 2 * e / p
                  , y = 2 * t / v;
                return o.xMin = Math.max(Math.floor((h + e) / E), 0),
                o.xMax = Math.min(Math.ceil((_ + e) / E), p),
                o.yMin = Math.max(Math.floor((t - m) / y), 0),
                o.yMax = Math.min(Math.ceil((t - f) / y), v),
                o.zMin = Math.floor(Math.log2(Math.max(l, r)) * T.x - T.y),
                o.zMax = Math.min(Math.ceil(Math.log2(u) * T.x - T.y), this._zSlices),
                !0;
            }
        }, {
            key: "_shrinkSpotLightByBoundOrth",
            value: function(e, t, r, n, i, a, o, s, l) {
                var u = a.x
                  , c = a.y
                  , h = a.z
                  , _ = Math.tan(s) * o
                  , d = i.x
                  , f = i.y
                  , m = i.z
                  , p = u - d
                  , v = c - f
                  , T = h - m
                  , E = p * p + v * v + T * T
                  , y = Math.sqrt(1 - T * T / E)
                  , g = Math.max(Math.min(m, h - y * _), i.z - o)
                  , S = Math.min(Math.max(m, h + y * _), i.z + o);
                if (g > n || S <= r)
                    return !1;
                var R = Math.sqrt(1 - p * p / E)
                  , C = Math.max(Math.min(d, u - R * _), i.x - o)
                  , M = Math.min(Math.max(d, u + R * _), i.x + o);
                if (C > e || M <= -e)
                    return !1;
                var D = Math.sqrt(1 - v * v / E)
                  , x = Math.max(Math.min(f, c - D * _), i.y - o)
                  , A = Math.min(Math.max(f, c + D * _), i.y + o);
                if (x > t || A <= -t)
                    return !1;
                var I = this._xSlices
                  , L = this._ySlices
                  , P = this._depthSliceParam
                  , O = 2 * e / I
                  , N = 2 * t / L;
                return l.xMin = Math.max(Math.floor((C + e) / O), 0),
                l.xMax = Math.min(Math.ceil((M + e) / O), I),
                l.yMin = Math.max(Math.floor((t - A) / N), 0),
                l.yMax = Math.min(Math.ceil((t - x) / N), L),
                l.zMin = Math.floor(Math.log2(Math.max(g, r)) * P.x - P.y),
                l.zMax = Math.min(Math.ceil(Math.log2(S) * P.x - P.y), this._zSlices),
                !0;
            }
        }, {
            key: "_shrinkXYByRadiusPerspective",
            value: function(e, t, r, n, i) {
                var a, o, s, l, u, c = e.x, h = e.y, _ = e.z, d = this._ySlices + 1;
                for (u = 0; u < d; u++) {
                    if (h * (f = i[u]).y + _ * f.z < t) {
                        o = Math.max(0, u - 1);
                        break;
                    }
                }
                if (u == d)
                    return !1;
                for (l = this._ySlices,
                u = o + 1; u < d; u++) {
                    if (h * (f = i[u]).y + _ * f.z <= -t) {
                        l = Math.max(0, u);
                        break;
                    }
                }
                for (d = this._xSlices + 1,
                u = 0; u < d; u++) {
                    if (c * (f = n[u]).x + _ * f.z < t) {
                        a = Math.max(0, u - 1);
                        break;
                    }
                }
                for (s = this._xSlices,
                u = a + 1; u < d; u++) {
                    var f;
                    if (c * (f = n[u]).x + _ * f.z <= -t) {
                        s = Math.max(0, u);
                        break;
                    }
                }
                return r.xMin = a,
                r.xMax = s,
                r.yMin = o,
                r.yMax = l,
                !0;
            }
        }, {
            key: "_shrinkSpotXYByConePerspective",
            value: function(e, t, r, n, i, a, o) {
                for (var s, l, u, c, h = Cluster._tempVector32, _ = i.yMax + 1, d = i.yMin + 1; d < _; d++)
                    if (this._insertConePlane(e, t, r, n, o[d])) {
                        l = Math.max(0, d - 1);
                        break;
                    }
                c = i.yMax;
                for (d = l + 1; d < _; d++) {
                    var f = o[d];
                    if (h.setValue(0, -f.y, -f.z),
                    !this._insertConePlane(e, t, r, n, h)) {
                        c = Math.max(0, d);
                        break;
                    }
                }
                _ = i.xMax + 1;
                for (d = i.xMin + 1; d < _; d++)
                    if (this._insertConePlane(e, t, r, n, a[d])) {
                        s = Math.max(0, d - 1);
                        break;
                    }
                u = i.xMax;
                for (d = s + 1; d < _; d++) {
                    f = a[d];
                    if (h.setValue(-f.x, 0, -f.z),
                    !this._insertConePlane(e, t, r, n, h)) {
                        u = Math.max(0, d);
                        break;
                    }
                }
                i.xMin = s,
                i.xMax = u,
                i.yMin = l,
                i.yMax = c;
            }
        }, {
            key: "_updatePointLightPerspective",
            value: function(e, t, r, n, i, a, s) {
                var l = Cluster._tempLightBound
                  , u = Cluster._tempVector30;
                o.transformV3ToV3(n._transform.position, r, u),
                u.z *= -1,
                this._shrinkSphereLightZPerspective(e, t, u, n.range, l) && this._shrinkXYByRadiusPerspective(u, n.range, l, a, s) && this._placePointLightToClusters(i, l);
            }
        }, {
            key: "_updateSpotLightPerspective",
            value: function(e, t, r, n, i, a, s) {
                var l = Cluster._tempLightBound
                  , u = Cluster._tempVector30
                  , c = Cluster._tempVector31
                  , h = Cluster._tempVector34
                  , _ = n._transform.position
                  , d = n.range;
                n._transform.worldMatrix.getForward(c),
                o.normalize(c, c),
                o.scale(c, d, h),
                o.add(_, h, h),
                o.transformV3ToV3(_, r, u),
                o.transformV3ToV3(h, r, h),
                u.z *= -1,
                h.z *= -1;
                var f = n.spotAngle / 2 * Math.PI / 180;
                if (this._shrinkSpotLightZPerspective(e, t, u, h, d, f, l) && this._shrinkXYByRadiusPerspective(u, d, l, a, s)) {
                    var m = Cluster._tempVector33;
                    m.x = h.x - u.x,
                    m.y = h.y - u.y,
                    m.z = h.z - u.z,
                    o.normalize(m, m),
                    this._shrinkSpotXYByConePerspective(u, m, d, f, l, a, s),
                    this._placeSpotLightToClusters(i, l);
                }
            }
        }, {
            key: "_updatePointLightOrth",
            value: function(e, t, r, n, i, a, s) {
                var l = Cluster._tempLightBound
                  , u = Cluster._tempVector30;
                o.transformV3ToV3(a._transform.position, i, u),
                u.z *= -1,
                this._shrinkSphereLightByBoundOrth(e, t, r, n, u, a.range, l) && this._placePointLightToClusters(s, l);
            }
        }, {
            key: "_updateSpotLightOrth",
            value: function(e, t, r, n, i, a, s) {
                var l = Cluster._tempLightBound
                  , u = Cluster._tempVector30
                  , c = Cluster._tempVector31
                  , h = Cluster._tempVector34
                  , _ = a._transform.position
                  , d = a.range;
                a._transform.worldMatrix.getForward(c),
                o.normalize(c, c),
                o.scale(c, d, h),
                o.add(_, h, h),
                o.transformV3ToV3(_, i, u),
                o.transformV3ToV3(h, i, h),
                u.z *= -1,
                h.z *= -1;
                var f = a.spotAngle / 2 * Math.PI / 180;
                this._shrinkSpotLightByBoundOrth(e, t, r, n, u, h, d, f, l) && this._placeSpotLightToClusters(s, l);
            }
        }, {
            key: "update",
            value: function(e, t) {
                this._updateMark++;
                var r = e.nearPlane;
                this._depthSliceParam.x = s._config.lightClusterCount.z / Math.log2(e.farPlane / r),
                this._depthSliceParam.y = Math.log2(r) * this._depthSliceParam.x;
                var n = e.nearPlane
                  , i = e.farPlane
                  , a = e.viewMatrix
                  , o = t._directionLights._length
                  , l = t._pointLights
                  , u = l._length
                  , c = l._elements
                  , h = t._spotLights
                  , _ = h._length
                  , d = h._elements;
                if (e.orthographic) {
                    for (var f = e.orthographicVerticalSize / 2, m = f * e.aspectRatio, p = 0; p < u; p++,
                    o++)
                        this._updatePointLightOrth(m, f, n, i, a, c[p], o);
                    for (p = 0; p < _; p++,
                    o++)
                        this._updateSpotLightOrth(m, f, n, i, a, d[p], o);
                } else {
                    e._updateClusterPlaneXY();
                    var v = e._clusterXPlanes
                      , T = e._clusterYPlanes;
                    for (p = 0; p < u; p++,
                    o++)
                        this._updatePointLightPerspective(n, i, a, c[p], o, v, T);
                    for (p = 0; p < _; p++,
                    o++)
                        this._updateSpotLightPerspective(n, i, a, d[p], o, v, T);
                }
                if (u + _ > 0) {
                    for (var E = this._xSlices, y = this._ySlices, g = this._zSlices, S = E * y * 4, R = S * g, C = this._clusterPixels, M = C.length, D = this._clusterDatas, x = this._updateMark, A = !0, I = 0; I < g; I++)
                        for (var L = 0; L < y; L++)
                            for (var P = 0; P < E; P++) {
                                var O = D[I][L][P]
                                  , N = 4 * (P + L * E + I * E * y);
                                if (O.updateMark !== x)
                                    C[N] = 0,
                                    C[N + 1] = 0;
                                else if (A) {
                                    var b = O.indices
                                      , k = O.pointLightCount
                                      , V = O.spotLightCount
                                      , B = k + V;
                                    if (R + B < M) {
                                        C[N] = k,
                                        C[N + 1] = V,
                                        C[N + 2] = Math.floor(R / S),
                                        C[N + 3] = R % S;
                                        for (p = 0; p < B; p++)
                                            C[R++] = b[p];
                                    } else {
                                        B = M - (R + B),
                                        k = Math.min(k, B),
                                        C[N] = k,
                                        C[N + 1] = Math.min(V, B - k),
                                        C[N + 2] = Math.floor(R / S),
                                        C[N + 3] = R % S;
                                        for (p = 0; p < B; p++)
                                            C[R++] = b[p];
                                        A = !1;
                                    }
                                }
                            }
                    var w = this._clusterTexture.width;
                    this._clusterTexture.setSubPixels(0, 0, w, Math.ceil(R / (4 * w)), C);
                }
            }
        }]),
        Cluster;
    }();
    Ie._tempVector30 = new o(),
    Ie._tempVector31 = new o(),
    Ie._tempVector32 = new o(),
    Ie._tempVector33 = new o(),
    Ie._tempVector34 = new o(),
    Ie._tempVector35 = new o(),
    Ie._tempVector36 = new o(),
    Ie._tempVector37 = new o(),
    Ie._tempLightBound = new function LightBound() {
        _classCallCheck(this, LightBound);
    }
    ();
    var Le = function() {
        function Plane(e) {
            var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
            _classCallCheck(this, Plane),
            this.normal = e,
            this.distance = t;
        }
        return _createClass(Plane, [{
            key: "normalize",
            value: function() {
                var e = this.normal.x
                  , t = this.normal.y
                  , r = this.normal.z
                  , n = 1 / Math.sqrt(e * e + t * t + r * r);
                this.normal.x = e * n,
                this.normal.y = t * n,
                this.normal.z = r * n,
                this.distance *= n;
            }
        }], [{
            key: "createPlaneBy3P",
            value: function(e, t, r) {
                var n = t.x - e.x
                  , i = t.y - e.y
                  , a = t.z - e.z
                  , o = r.x - e.x
                  , s = r.y - e.y
                  , l = r.z - e.z
                  , u = i * l - a * s
                  , c = a * o - n * l
                  , h = n * s - i * o
                  , _ = 1 / Math.sqrt(u * u + c * c + h * h)
                  , d = u * _
                  , f = c * _
                  , m = h * _;
                Plane._TEMPVec3.x = d,
                Plane._TEMPVec3.y = f,
                Plane._TEMPVec3.z = m;
                var p = -(d * e.x + f * e.y + m * e.z);
                return new Plane(Plane._TEMPVec3,p);
            }
        }]),
        Plane;
    }();
    Le._TEMPVec3 = new o(),
    Le.PlaneIntersectionType_Back = 0,
    Le.PlaneIntersectionType_Front = 1,
    Le.PlaneIntersectionType_Intersecting = 2;
    var Pe = function Ray(e, t) {
        _classCallCheck(this, Ray),
        this.origin = e,
        this.direction = t;
    }
      , Oe = function ContainmentType() {
        _classCallCheck(this, ContainmentType);
    };
    Oe.Disjoint = 0,
    Oe.Contains = 1,
    Oe.Intersects = 2;
    var Ne = function() {
        function CollisionUtils() {
            _classCallCheck(this, CollisionUtils);
        }
        return _createClass(CollisionUtils, null, [{
            key: "distancePlaneToPoint",
            value: function(e, t) {
                return o.dot(e.normal, t) - e.distance;
            }
        }, {
            key: "distanceBoxToPoint",
            value: function(e, t) {
                var r = e.min
                  , n = r.x
                  , i = r.y
                  , a = r.z
                  , o = e.max
                  , s = o.x
                  , l = o.y
                  , u = o.z
                  , c = t.x
                  , h = t.y
                  , _ = t.z
                  , d = 0;
                return c < n && (d += (n - c) * (n - c)),
                c > s && (d += (s - c) * (s - c)),
                h < i && (d += (i - h) * (i - h)),
                h > l && (d += (l - h) * (l - h)),
                _ < a && (d += (a - _) * (a - _)),
                _ > u && (d += (u - _) * (u - _)),
                Math.sqrt(d);
            }
        }, {
            key: "distanceBoxToBox",
            value: function(e, t) {
                var r, n = e.min, i = n.x, a = n.y, o = n.z, s = e.max, l = s.x, u = s.y, c = s.z, h = t.min, _ = h.x, d = h.y, f = h.z, m = t.max, p = m.x, v = m.y, T = m.z, E = 0;
                return i > p ? E += (r = i - p) * r : _ > l && (E += (r = _ - l) * r),
                a > v ? E += (r = a - v) * r : d > u && (E += (r = d - u) * r),
                o > T ? E += (r = o - T) * r : f > c && (E += (r = f - c) * r),
                Math.sqrt(E);
            }
        }, {
            key: "distanceSphereToPoint",
            value: function(e, t) {
                var r = Math.sqrt(o.distanceSquared(e.center, t));
                return r -= e.radius,
                Math.max(r, 0);
            }
        }, {
            key: "distanceSphereToSphere",
            value: function(e, t) {
                var r = Math.sqrt(o.distanceSquared(e.center, t.center));
                return r -= e.radius + t.radius,
                Math.max(r, 0);
            }
        }, {
            key: "intersectsRayAndTriangleRD",
            value: function(e, t, n, i, a) {
                var o = e.origin
                  , s = o.x
                  , l = o.y
                  , u = o.z
                  , c = e.direction
                  , h = c.x
                  , _ = c.y
                  , d = c.z
                  , f = t.x
                  , m = t.y
                  , p = t.z
                  , v = n.x
                  , T = n.y
                  , E = n.z
                  , y = i.x
                  , g = i.y
                  , S = i.z
                  , R = CollisionUtils._tempV30.x
                  , C = CollisionUtils._tempV30.y
                  , M = CollisionUtils._tempV30.z;
                R = v - f,
                C = T - m,
                M = E - p;
                var D = CollisionUtils._tempV31.x
                  , x = CollisionUtils._tempV31.y
                  , A = CollisionUtils._tempV31.z;
                D = y - f,
                x = g - m,
                A = S - p;
                var I = CollisionUtils._tempV32.x
                  , L = CollisionUtils._tempV32.y
                  , P = CollisionUtils._tempV32.z
                  , O = R * (I = _ * A - d * x) + C * (L = d * D - h * A) + M * (P = h * x - _ * D);
                if (r.isZero(O))
                    return !1;
                var N = 1 / O
                  , b = CollisionUtils._tempV33.x
                  , k = CollisionUtils._tempV33.y
                  , V = CollisionUtils._tempV33.z
                  , B = (b = s - f) * I + (k = l - m) * L + (V = u - p) * P;
                if ((B *= N) < 0 || B > 1)
                    return !1;
                var w = CollisionUtils._tempV34.x
                  , F = CollisionUtils._tempV34.y
                  , U = CollisionUtils._tempV34.z
                  , G = h * (w = k * M - V * C) + _ * (F = V * R - b * M) + d * (U = b * C - k * R);
                if ((G *= N) < 0 || B + G > 1)
                    return !1;
                var z = D * w + x * F + A * U;
                return !((z *= N) < 0);
            }
        }, {
            key: "intersectsRayAndTriangleRP",
            value: function(e, t, r, n, i) {
                return CollisionUtils.intersectsRayAndTriangleRD(e, t, r, n, void 0) ? (o.scale(e.direction, void 0, CollisionUtils._tempV30),
                o.add(e.origin, CollisionUtils._tempV30, i),
                !0) : (i = o._ZERO,
                !1);
            }
        }, {
            key: "intersectsRayAndPoint",
            value: function(e, t) {
                o.subtract(e.origin, t, CollisionUtils._tempV30);
                var n = o.dot(CollisionUtils._tempV30, e.direction)
                  , i = o.dot(CollisionUtils._tempV30, CollisionUtils._tempV30) - r.zeroTolerance;
                return !(i > 0 && n > 0) && !(n * n - i < 0);
            }
        }, {
            key: "intersectsRayAndRay",
            value: function(e, t, n) {
                var i = e.origin
                  , a = i.x
                  , s = i.y
                  , l = i.z
                  , u = e.direction
                  , c = u.x
                  , h = u.y
                  , _ = u.z
                  , d = t.origin
                  , f = d.x
                  , m = d.y
                  , p = d.z
                  , v = t.direction
                  , T = v.x
                  , E = v.y
                  , y = v.z;
                o.cross(u, v, CollisionUtils._tempV30);
                var g = CollisionUtils._tempV30
                  , S = o.scalarLength(CollisionUtils._tempV30);
                if (r.isZero(S) && r.nearEqual(f, a) && r.nearEqual(m, s) && r.nearEqual(p, l))
                    return !0;
                S *= S;
                var R = f - a
                  , C = m - s
                  , M = p - l
                  , D = T
                  , x = E
                  , A = y
                  , I = g.x
                  , L = g.y
                  , P = g.z
                  , O = R * x * P + C * A * I + M * D * L - R * A * L - C * D * P - M * x * I;
                D = c,
                x = h,
                A = _;
                var N = O / S;
                o.scale(u, N, CollisionUtils._tempV30),
                o.scale(v, N, CollisionUtils._tempV31),
                o.add(i, CollisionUtils._tempV30, CollisionUtils._tempV32),
                o.add(d, CollisionUtils._tempV31, CollisionUtils._tempV33);
                var b = CollisionUtils._tempV32
                  , k = CollisionUtils._tempV33;
                return !!(r.nearEqual(k.x, b.x) && r.nearEqual(k.y, b.y) && r.nearEqual(k.z, b.z));
            }
        }, {
            key: "intersectsPlaneAndTriangle",
            value: function(e, t, r, n) {
                var i = CollisionUtils.intersectsPlaneAndPoint(e, t)
                  , a = CollisionUtils.intersectsPlaneAndPoint(e, r)
                  , o = CollisionUtils.intersectsPlaneAndPoint(e, n);
                return i == Le.PlaneIntersectionType_Front && a == Le.PlaneIntersectionType_Front && o == Le.PlaneIntersectionType_Front ? Le.PlaneIntersectionType_Front : i == Le.PlaneIntersectionType_Back && a == Le.PlaneIntersectionType_Back && o == Le.PlaneIntersectionType_Back ? Le.PlaneIntersectionType_Back : Le.PlaneIntersectionType_Intersecting;
            }
        }, {
            key: "intersectsRayAndPlaneRD",
            value: function(e, t) {
                var n = t.normal
                  , i = o.dot(n, e.direction);
                if (Math.abs(i) < r.zeroTolerance)
                    return -1;
                var a = o.dot(n, e.origin)
                  , s = (-t.distance - a) / i;
                if (s < 0) {
                    if (s < -r.zeroTolerance)
                        return -1;
                    s = 0;
                }
                return s;
            }
        }, {
            key: "intersectsRayAndPlaneRP",
            value: function(e, t, r) {
                var n = CollisionUtils.intersectsRayAndPlaneRD(e, t);
                if (-1 == n)
                    return r.setValue(0, 0, 0),
                    !1;
                var i = CollisionUtils._tempV30;
                return o.scale(e.direction, n, i),
                o.add(e.origin, i, r),
                !0;
            }
        }, {
            key: "intersectsRayAndBoxRD",
            value: function(e, t) {
                var n = e.origin
                  , i = n.x
                  , a = n.y
                  , o = n.z
                  , s = e.direction
                  , l = s.x
                  , u = s.y
                  , c = s.z
                  , h = t.min
                  , _ = h.x
                  , d = h.y
                  , f = h.z
                  , m = t.max
                  , p = m.x
                  , v = m.y
                  , T = m.z
                  , E = 0
                  , y = r.MaxValue;
                if (r.isZero(l)) {
                    if (i < _ || i > p)
                        return -1;
                } else {
                    var g = 1 / l
                      , S = (_ - i) * g
                      , R = (p - i) * g;
                    if (S > R) {
                        var C = S;
                        S = R,
                        R = C;
                    }
                    if ((E = Math.max(S, E)) > (y = Math.min(R, y)))
                        return -1;
                }
                if (r.isZero(u)) {
                    if (a < d || a > v)
                        return -1;
                } else {
                    var M = 1 / u
                      , D = (d - a) * M
                      , x = (v - a) * M;
                    if (D > x) {
                        var A = D;
                        D = x,
                        x = A;
                    }
                    if ((E = Math.max(D, E)) > (y = Math.min(x, y)))
                        return -1;
                }
                if (r.isZero(c)) {
                    if (o < f || o > T)
                        return -1;
                } else {
                    var I = 1 / c
                      , L = (f - o) * I
                      , P = (T - o) * I;
                    if (L > P) {
                        var O = L;
                        L = P,
                        P = O;
                    }
                    if ((E = Math.max(L, E)) > (y = Math.min(P, y)))
                        return -1;
                }
                return E;
            }
        }, {
            key: "intersectsRayAndBoxRP",
            value: function(e, t, r) {
                var n = CollisionUtils.intersectsRayAndBoxRD(e, t);
                return -1 === n ? (o._ZERO.cloneTo(r),
                n) : (o.scale(e.direction, n, CollisionUtils._tempV30),
                o.add(e.origin, CollisionUtils._tempV30, CollisionUtils._tempV31),
                CollisionUtils._tempV31.cloneTo(r),
                n);
            }
        }, {
            key: "intersectsRayAndSphereRD",
            value: function(e, t) {
                var r = t.radius;
                o.subtract(e.origin, t.center, CollisionUtils._tempV30);
                var n = o.dot(CollisionUtils._tempV30, e.direction)
                  , i = o.dot(CollisionUtils._tempV30, CollisionUtils._tempV30) - r * r;
                if (i > 0 && n > 0)
                    return -1;
                var a = n * n - i;
                if (a < 0)
                    return -1;
                var s = -n - Math.sqrt(a);
                return s < 0 && (s = 0),
                s;
            }
        }, {
            key: "intersectsRayAndSphereRP",
            value: function(e, t, r) {
                var n = CollisionUtils.intersectsRayAndSphereRD(e, t);
                return -1 === n ? (o._ZERO.cloneTo(r),
                n) : (o.scale(e.direction, n, CollisionUtils._tempV30),
                o.add(e.origin, CollisionUtils._tempV30, CollisionUtils._tempV31),
                CollisionUtils._tempV31.cloneTo(r),
                n);
            }
        }, {
            key: "intersectsSphereAndTriangle",
            value: function(e, t, r, n) {
                var i = e.center
                  , a = e.radius;
                return CollisionUtils.closestPointPointTriangle(i, t, r, n, CollisionUtils._tempV30),
                o.subtract(CollisionUtils._tempV30, i, CollisionUtils._tempV31),
                o.dot(CollisionUtils._tempV31, CollisionUtils._tempV31) <= a * a;
            }
        }, {
            key: "intersectsPlaneAndPoint",
            value: function(e, t) {
                var r = o.dot(e.normal, t) + e.distance;
                return r > 0 ? Le.PlaneIntersectionType_Front : r < 0 ? Le.PlaneIntersectionType_Back : Le.PlaneIntersectionType_Intersecting;
            }
        }, {
            key: "intersectsPlaneAndPlane",
            value: function(e, t) {
                o.cross(e.normal, t.normal, CollisionUtils._tempV30);
                var n = o.dot(CollisionUtils._tempV30, CollisionUtils._tempV30);
                return !r.isZero(n);
            }
        }, {
            key: "intersectsPlaneAndPlaneRL",
            value: function(e, t, n) {
                var i = e.normal
                  , a = t.normal;
                o.cross(i, a, CollisionUtils._tempV34);
                var s = o.dot(CollisionUtils._tempV34, CollisionUtils._tempV34);
                return !r.isZero(s) && (o.scale(a, e.distance, CollisionUtils._tempV30),
                o.scale(i, t.distance, CollisionUtils._tempV31),
                o.subtract(CollisionUtils._tempV30, CollisionUtils._tempV31, CollisionUtils._tempV32),
                o.cross(CollisionUtils._tempV32, CollisionUtils._tempV34, CollisionUtils._tempV33),
                o.normalize(CollisionUtils._tempV34, CollisionUtils._tempV34),
                !0);
            }
        }, {
            key: "intersectsPlaneAndBox",
            value: function(e, t) {
                var r = e.distance
                  , n = e.normal
                  , i = n.x
                  , a = n.y
                  , s = n.z
                  , l = t.min
                  , u = l.x
                  , c = l.y
                  , h = l.z
                  , _ = t.max
                  , d = _.x
                  , f = _.y
                  , m = _.z;
                CollisionUtils._tempV30.x = i > 0 ? u : d,
                CollisionUtils._tempV30.y = a > 0 ? c : f,
                CollisionUtils._tempV30.z = s > 0 ? h : m,
                CollisionUtils._tempV31.x = i > 0 ? d : u,
                CollisionUtils._tempV31.y = a > 0 ? f : c,
                CollisionUtils._tempV31.z = s > 0 ? m : h;
                var p = o.dot(n, CollisionUtils._tempV30);
                return p + r > 0 ? Le.PlaneIntersectionType_Front : (p = o.dot(n, CollisionUtils._tempV31)) + r < 0 ? Le.PlaneIntersectionType_Back : Le.PlaneIntersectionType_Intersecting;
            }
        }, {
            key: "intersectsPlaneAndSphere",
            value: function(e, t) {
                var r = t.radius
                  , n = o.dot(e.normal, t.center) + e.distance;
                return n > r ? Le.PlaneIntersectionType_Front : n < -r ? Le.PlaneIntersectionType_Back : Le.PlaneIntersectionType_Intersecting;
            }
        }, {
            key: "intersectsBoxAndBox",
            value: function(e, t) {
                var r = e.min
                  , n = e.max
                  , i = t.min
                  , a = t.max;
                return !(r.x > a.x || i.x > n.x) && (!(r.y > a.y || i.y > n.y) && !(r.z > a.z || i.z > n.z));
            }
        }, {
            key: "intersectsBoxAndSphere",
            value: function(e, t) {
                var r = t.center
                  , n = t.radius;
                return o.Clamp(r, e.min, e.max, CollisionUtils._tempV30),
                o.distanceSquared(r, CollisionUtils._tempV30) <= n * n;
            }
        }, {
            key: "intersectsSphereAndSphere",
            value: function(e, t) {
                var r = e.radius + t.radius;
                return o.distanceSquared(e.center, t.center) <= r * r;
            }
        }, {
            key: "boxContainsPoint",
            value: function(e, t) {
                var r = e.min
                  , n = e.max;
                return r.x <= t.x && n.x >= t.x && r.y <= t.y && n.y >= t.y && r.z <= t.z && n.z >= t.z ? Oe.Contains : Oe.Disjoint;
            }
        }, {
            key: "boxContainsBox",
            value: function(e, t) {
                var r = e.min
                  , n = r.x
                  , i = r.y
                  , a = r.z
                  , o = e.max
                  , s = o.x
                  , l = o.y
                  , u = o.z
                  , c = t.min
                  , h = c.x
                  , _ = c.y
                  , d = c.z
                  , f = t.max
                  , m = f.x
                  , p = f.y
                  , v = f.z;
                return s < h || n > m ? Oe.Disjoint : l < _ || i > p ? Oe.Disjoint : u < d || a > v ? Oe.Disjoint : n <= h && m <= s && i <= _ && p <= l && a <= d && v <= u ? Oe.Contains : Oe.Intersects;
            }
        }, {
            key: "boxContainsSphere",
            value: function(e, t) {
                var r = e.min
                  , n = r.x
                  , i = r.y
                  , a = r.z
                  , s = e.max
                  , l = s.x
                  , u = s.y
                  , c = s.z
                  , h = t.center
                  , _ = h.x
                  , d = h.y
                  , f = h.z
                  , m = t.radius;
                return o.Clamp(h, r, s, CollisionUtils._tempV30),
                o.distanceSquared(h, CollisionUtils._tempV30) > m * m ? Oe.Disjoint : n + m <= _ && _ <= l - m && l - n > m && i + m <= d && d <= u - m && u - i > m && a + m <= f && f <= c - m && c - a > m ? Oe.Contains : Oe.Intersects;
            }
        }, {
            key: "sphereContainsPoint",
            value: function(e, t) {
                return o.distanceSquared(t, e.center) <= e.radius * e.radius ? Oe.Contains : Oe.Disjoint;
            }
        }, {
            key: "sphereContainsTriangle",
            value: function(e, t, r, n) {
                var i = CollisionUtils.sphereContainsPoint(e, t)
                  , a = CollisionUtils.sphereContainsPoint(e, r)
                  , o = CollisionUtils.sphereContainsPoint(e, n);
                return i == Oe.Contains && a == Oe.Contains && o == Oe.Contains ? Oe.Contains : CollisionUtils.intersectsSphereAndTriangle(e, t, r, n) ? Oe.Intersects : Oe.Disjoint;
            }
        }, {
            key: "sphereContainsBox",
            value: function(e, t) {
                var r = e.center
                  , n = r.x
                  , i = r.y
                  , a = r.z
                  , s = e.radius
                  , l = t.min
                  , u = l.x
                  , c = l.y
                  , h = l.z
                  , _ = t.max
                  , d = _.x
                  , f = _.y
                  , m = _.z
                  , p = CollisionUtils._tempV30;
                p.x,
                p.y,
                p.z;
                if (!CollisionUtils.intersectsBoxAndSphere(t, e))
                    return Oe.Disjoint;
                var v = s * s;
                return n - u,
                i - f,
                a - m,
                o.scalarLengthSquared(CollisionUtils._tempV30) > v ? Oe.Intersects : (n - d,
                i - f,
                a - m,
                o.scalarLengthSquared(CollisionUtils._tempV30) > v ? Oe.Intersects : (n - d,
                i - c,
                a - m,
                o.scalarLengthSquared(CollisionUtils._tempV30) > v ? Oe.Intersects : (n - u,
                i - c,
                a - m,
                o.scalarLengthSquared(CollisionUtils._tempV30) > v ? Oe.Intersects : (n - u,
                i - f,
                a - h,
                o.scalarLengthSquared(CollisionUtils._tempV30) > v ? Oe.Intersects : (n - d,
                i - f,
                a - h,
                o.scalarLengthSquared(CollisionUtils._tempV30) > v ? Oe.Intersects : (n - d,
                i - c,
                a - h,
                o.scalarLengthSquared(CollisionUtils._tempV30) > v ? Oe.Intersects : (n - u,
                i - c,
                a - h,
                o.scalarLengthSquared(CollisionUtils._tempV30) > v ? Oe.Intersects : Oe.Contains)))))));
            }
        }, {
            key: "sphereContainsSphere",
            value: function(e, t) {
                var r = e.radius
                  , n = t.radius
                  , i = o.distance(e.center, t.center);
                return r + n < i ? Oe.Disjoint : r - n < i ? Oe.Intersects : Oe.Contains;
            }
        }, {
            key: "closestPointPointTriangle",
            value: function(e, t, r, n, i) {
                o.subtract(r, t, CollisionUtils._tempV30),
                o.subtract(n, t, CollisionUtils._tempV31),
                o.subtract(e, t, CollisionUtils._tempV32),
                o.subtract(e, r, CollisionUtils._tempV33),
                o.subtract(e, n, CollisionUtils._tempV34);
                var a = o.dot(CollisionUtils._tempV30, CollisionUtils._tempV32)
                  , s = o.dot(CollisionUtils._tempV31, CollisionUtils._tempV32)
                  , l = o.dot(CollisionUtils._tempV30, CollisionUtils._tempV33)
                  , u = o.dot(CollisionUtils._tempV31, CollisionUtils._tempV33)
                  , c = o.dot(CollisionUtils._tempV30, CollisionUtils._tempV34)
                  , h = o.dot(CollisionUtils._tempV31, CollisionUtils._tempV34);
                if (a <= 0 && s <= 0)
                    t.cloneTo(i);
                else if (l >= 0 && u <= l)
                    r.cloneTo(i);
                else {
                    var _ = a * u - l * s;
                    if (_ <= 0 && a >= 0 && l <= 0) {
                        var d = a / (a - l);
                        return o.scale(CollisionUtils._tempV30, d, i),
                        void o.add(t, i, i);
                    }
                    if (h >= 0 && c <= h)
                        n.cloneTo(i);
                    else {
                        var f = c * s - a * h;
                        if (f <= 0 && s >= 0 && h <= 0) {
                            var m = s / (s - h);
                            return o.scale(CollisionUtils._tempV31, m, i),
                            void o.add(t, i, i);
                        }
                        var p = l * h - c * u;
                        if (p <= 0 && u - l >= 0 && c - h >= 0) {
                            var v = (u - l) / (u - l + (c - h));
                            return o.subtract(n, r, i),
                            o.scale(i, v, i),
                            void o.add(r, i, i);
                        }
                        var T = 1 / (p + f + _)
                          , E = f * T
                          , y = _ * T;
                        o.scale(CollisionUtils._tempV30, E, CollisionUtils._tempV35),
                        o.scale(CollisionUtils._tempV31, y, CollisionUtils._tempV36),
                        o.add(CollisionUtils._tempV35, CollisionUtils._tempV36, i),
                        o.add(t, i, i);
                    }
                }
            }
        }, {
            key: "closestPointPlanePoint",
            value: function(e, t, r) {
                var n = e.normal
                  , i = o.dot(n, t) - e.distance;
                o.scale(n, i, CollisionUtils._tempV30),
                o.subtract(t, CollisionUtils._tempV30, r);
            }
        }, {
            key: "closestPointBoxPoint",
            value: function(e, t, r) {
                o.max(t, e.min, CollisionUtils._tempV30),
                o.min(CollisionUtils._tempV30, e.max, r);
            }
        }, {
            key: "closestPointSpherePoint",
            value: function(e, t, r) {
                var n = e.center;
                o.subtract(t, n, r),
                o.normalize(r, r),
                o.scale(r, e.radius, r),
                o.add(r, n, r);
            }
        }, {
            key: "closestPointSphereSphere",
            value: function(e, t, r) {
                var n = e.center;
                o.subtract(t.center, n, r),
                o.normalize(r, r),
                o.scale(r, e.radius, r),
                o.add(r, n, r);
            }
        }]),
        CollisionUtils;
    }();
    Ne._tempV30 = new o(),
    Ne._tempV31 = new o(),
    Ne._tempV32 = new o(),
    Ne._tempV33 = new o(),
    Ne._tempV34 = new o(),
    Ne._tempV35 = new o(),
    Ne._tempV36 = new o();
    var be = function() {
        function BoundFrustum(e) {
            _classCallCheck(this, BoundFrustum),
            this._matrix = e,
            this._near = new Le(new o()),
            this._far = new Le(new o()),
            this._left = new Le(new o()),
            this._right = new Le(new o()),
            this._top = new Le(new o()),
            this._bottom = new Le(new o()),
            BoundFrustum._getPlanesFromMatrix(this._matrix, this._near, this._far, this._left, this._right, this._top, this._bottom);
        }
        return _createClass(BoundFrustum, [{
            key: "equalsBoundFrustum",
            value: function(e) {
                return this._matrix.equalsOtherMatrix(e.matrix);
            }
        }, {
            key: "equalsObj",
            value: function(e) {
                if (e instanceof BoundFrustum) {
                    var t = e;
                    return this.equalsBoundFrustum(t);
                }
                return !1;
            }
        }, {
            key: "getPlane",
            value: function(e) {
                switch (e) {
                case 0:
                    return this._near;
                case 1:
                    return this._far;
                case 2:
                    return this._left;
                case 3:
                    return this._right;
                case 4:
                    return this._top;
                case 5:
                    return this._bottom;
                default:
                    return null;
                }
            }
        }, {
            key: "getCorners",
            value: function(e) {
                BoundFrustum._get3PlaneInterPoint(this._near, this._bottom, this._right).cloneTo(e[0]),
                BoundFrustum._get3PlaneInterPoint(this._near, this._top, this._right).cloneTo(e[1]),
                BoundFrustum._get3PlaneInterPoint(this._near, this._top, this._left).cloneTo(e[2]),
                BoundFrustum._get3PlaneInterPoint(this._near, this._bottom, this._left).cloneTo(e[3]),
                BoundFrustum._get3PlaneInterPoint(this._far, this._bottom, this._right).cloneTo(e[4]),
                BoundFrustum._get3PlaneInterPoint(this._far, this._top, this._right).cloneTo(e[5]),
                BoundFrustum._get3PlaneInterPoint(this._far, this._top, this._left).cloneTo(e[6]),
                BoundFrustum._get3PlaneInterPoint(this._far, this._bottom, this._left).cloneTo(e[7]);
            }
        }, {
            key: "containsPoint",
            value: function(e) {
                for (var t = Le.PlaneIntersectionType_Front, r = Le.PlaneIntersectionType_Front, n = 0; n < 6; n++) {
                    switch (n) {
                    case 0:
                        r = Ne.intersectsPlaneAndPoint(this._near, e);
                        break;
                    case 1:
                        r = Ne.intersectsPlaneAndPoint(this._far, e);
                        break;
                    case 2:
                        r = Ne.intersectsPlaneAndPoint(this._left, e);
                        break;
                    case 3:
                        r = Ne.intersectsPlaneAndPoint(this._right, e);
                        break;
                    case 4:
                        r = Ne.intersectsPlaneAndPoint(this._top, e);
                        break;
                    case 5:
                        r = Ne.intersectsPlaneAndPoint(this._bottom, e);
                    }
                    switch (r) {
                    case Le.PlaneIntersectionType_Back:
                        return Oe.Disjoint;
                    case Le.PlaneIntersectionType_Intersecting:
                        t = Le.PlaneIntersectionType_Intersecting;
                    }
                }
                switch (t) {
                case Le.PlaneIntersectionType_Intersecting:
                    return Oe.Intersects;
                default:
                    return Oe.Contains;
                }
            }
        }, {
            key: "intersects",
            value: function(e) {
                var t = e.min
                  , r = e.max
                  , n = t.x
                  , i = t.y
                  , a = t.z
                  , o = r.x
                  , s = r.y
                  , l = r.z
                  , u = this._near.normal;
                if (this._near.distance + u.x * (u.x < 0 ? n : o) + u.y * (u.y < 0 ? i : s) + u.z * (u.z < 0 ? a : l) < 0)
                    return !1;
                var c = this._left.normal;
                if (this._left.distance + c.x * (c.x < 0 ? n : o) + c.y * (c.y < 0 ? i : s) + c.z * (c.z < 0 ? a : l) < 0)
                    return !1;
                var h = this._right.normal;
                if (this._right.distance + h.x * (h.x < 0 ? n : o) + h.y * (h.y < 0 ? i : s) + h.z * (h.z < 0 ? a : l) < 0)
                    return !1;
                var _ = this._bottom.normal;
                if (this._bottom.distance + _.x * (_.x < 0 ? n : o) + _.y * (_.y < 0 ? i : s) + _.z * (_.z < 0 ? a : l) < 0)
                    return !1;
                var d = this._top.normal;
                if (this._top.distance + d.x * (d.x < 0 ? n : o) + d.y * (d.y < 0 ? i : s) + d.z * (d.z < 0 ? a : l) < 0)
                    return !1;
                var f = this._far.normal;
                return !(this._far.distance + f.x * (f.x < 0 ? n : o) + f.y * (f.y < 0 ? i : s) + f.z * (f.z < 0 ? a : l) < 0);
            }
        }, {
            key: "containsBoundBox",
            value: function(e) {
                for (var t = BoundFrustum._tempV30, r = BoundFrustum._tempV31, n = e.min, i = e.max, a = Oe.Contains, o = 0; o < 6; o++) {
                    var s = this.getPlane(o)
                      , l = s.normal;
                    if (l.x >= 0 ? (t.x = i.x,
                    r.x = n.x) : (t.x = n.x,
                    r.x = i.x),
                    l.y >= 0 ? (t.y = i.y,
                    r.y = n.y) : (t.y = n.y,
                    r.y = i.y),
                    l.z >= 0 ? (t.z = i.z,
                    r.z = n.z) : (t.z = n.z,
                    r.z = i.z),
                    Ne.intersectsPlaneAndPoint(s, t) === Le.PlaneIntersectionType_Back)
                        return Oe.Disjoint;
                    Ne.intersectsPlaneAndPoint(s, r) === Le.PlaneIntersectionType_Back && (a = Oe.Intersects);
                }
                return a;
            }
        }, {
            key: "containsBoundSphere",
            value: function(e) {
                for (var t = Le.PlaneIntersectionType_Front, r = Le.PlaneIntersectionType_Front, n = 0; n < 6; n++) {
                    switch (n) {
                    case 0:
                        r = Ne.intersectsPlaneAndSphere(this._near, e);
                        break;
                    case 1:
                        r = Ne.intersectsPlaneAndSphere(this._far, e);
                        break;
                    case 2:
                        r = Ne.intersectsPlaneAndSphere(this._left, e);
                        break;
                    case 3:
                        r = Ne.intersectsPlaneAndSphere(this._right, e);
                        break;
                    case 4:
                        r = Ne.intersectsPlaneAndSphere(this._top, e);
                        break;
                    case 5:
                        r = Ne.intersectsPlaneAndSphere(this._bottom, e);
                    }
                    switch (r) {
                    case Le.PlaneIntersectionType_Back:
                        return Oe.Disjoint;
                    case Le.PlaneIntersectionType_Intersecting:
                        t = Le.PlaneIntersectionType_Intersecting;
                    }
                }
                switch (t) {
                case Le.PlaneIntersectionType_Intersecting:
                    return Oe.Intersects;
                default:
                    return Oe.Contains;
                }
            }
        }, {
            key: "matrix",
            get: function() {
                return this._matrix;
            },
            set: function(e) {
                this._matrix = e,
                BoundFrustum._getPlanesFromMatrix(this._matrix, this._near, this._far, this._left, this._right, this._top, this._bottom);
            }
        }, {
            key: "near",
            get: function() {
                return this._near;
            }
        }, {
            key: "far",
            get: function() {
                return this._far;
            }
        }, {
            key: "left",
            get: function() {
                return this._left;
            }
        }, {
            key: "right",
            get: function() {
                return this._right;
            }
        }, {
            key: "top",
            get: function() {
                return this._top;
            }
        }, {
            key: "bottom",
            get: function() {
                return this._bottom;
            }
        }], [{
            key: "_getPlanesFromMatrix",
            value: function(e, t, r, n, i, a, o) {
                var s = e.elements
                  , l = s[0]
                  , u = s[1]
                  , c = s[2]
                  , h = s[3]
                  , _ = s[4]
                  , d = s[5]
                  , f = s[6]
                  , m = s[7]
                  , p = s[8]
                  , v = s[9]
                  , T = s[10]
                  , E = s[11]
                  , y = s[12]
                  , g = s[13]
                  , S = s[14]
                  , R = s[15]
                  , C = t.normal;
                C.x = h + c,
                C.y = m + f,
                C.z = E + T,
                t.distance = R + S,
                t.normalize();
                var M = r.normal;
                M.x = h - c,
                M.y = m - f,
                M.z = E - T,
                r.distance = R - S,
                r.normalize();
                var D = n.normal;
                D.x = h + l,
                D.y = m + _,
                D.z = E + p,
                n.distance = R + y,
                n.normalize();
                var x = i.normal;
                x.x = h - l,
                x.y = m - _,
                x.z = E - p,
                i.distance = R - y,
                i.normalize();
                var A = a.normal;
                A.x = h - u,
                A.y = m - d,
                A.z = E - v,
                a.distance = R - g,
                a.normalize();
                var I = o.normal;
                I.x = h + u,
                I.y = m + d,
                I.z = E + v,
                o.distance = R + g,
                o.normalize();
            }
        }, {
            key: "_get3PlaneInterPoint",
            value: function(e, t, r) {
                var n = e.normal
                  , i = t.normal
                  , a = r.normal;
                o.cross(i, a, BoundFrustum._tempV30),
                o.cross(a, n, BoundFrustum._tempV31),
                o.cross(n, i, BoundFrustum._tempV32);
                var s = o.dot(n, BoundFrustum._tempV30)
                  , l = o.dot(i, BoundFrustum._tempV31)
                  , u = o.dot(a, BoundFrustum._tempV32);
                return o.scale(BoundFrustum._tempV30, -e.distance / s, BoundFrustum._tempV33),
                o.scale(BoundFrustum._tempV31, -t.distance / l, BoundFrustum._tempV34),
                o.scale(BoundFrustum._tempV32, -r.distance / u, BoundFrustum._tempV35),
                o.add(BoundFrustum._tempV33, BoundFrustum._tempV34, BoundFrustum._tempV36),
                o.add(BoundFrustum._tempV35, BoundFrustum._tempV36, BoundFrustum._tempV37),
                BoundFrustum._tempV37;
            }
        }]),
        BoundFrustum;
    }();
    be._tempV30 = new o(),
    be._tempV31 = new o(),
    be._tempV32 = new o(),
    be._tempV33 = new o(),
    be._tempV34 = new o(),
    be._tempV35 = new o(),
    be._tempV36 = new o(),
    be._tempV37 = new o();
    var ke = function() {
        function Viewport(e, t, r, n) {
            _classCallCheck(this, Viewport),
            this.minDepth = 0,
            this.maxDepth = 1,
            this.x = e,
            this.y = t,
            this.width = r,
            this.height = n;
        }
        return _createClass(Viewport, [{
            key: "project",
            value: function(e, t, r) {
                o.transformV3ToV4(e, t, r);
                var n = r.x
                  , i = r.y
                  , a = r.z
                  , s = r.w;
                1 !== s && (n /= s,
                i /= s,
                a /= s),
                r.x = .5 * (n + 1) * this.width + this.x,
                r.y = .5 * (1 - i) * this.height + this.y,
                r.z = a * (this.maxDepth - this.minDepth) + this.minDepth;
            }
        }, {
            key: "unprojectFromMat",
            value: function(e, t, r) {
                var n = t.elements;
                r.x = (e.x - this.x) / this.width * 2 - 1,
                r.y = -((e.y - this.y) / this.height * 2 - 1);
                var i = (this.maxDepth - this.minDepth) / 2;
                r.z = (e.z - this.minDepth - i) / i;
                var a = r.x * n[3] + r.y * n[7] + r.z * n[11] + n[15];
                o.transformV3ToV3(r, t, r),
                1 !== a && (r.x = r.x / a,
                r.y = r.y / a,
                r.z = r.z / a);
            }
        }, {
            key: "unprojectFromWVP",
            value: function(e, t, r, n, i) {
                I.multiply(t, r, Viewport._tempMatrix4x4),
                n && I.multiply(Viewport._tempMatrix4x4, n, Viewport._tempMatrix4x4),
                Viewport._tempMatrix4x4.invert(Viewport._tempMatrix4x4),
                this.unprojectFromMat(e, Viewport._tempMatrix4x4, i);
            }
        }, {
            key: "cloneTo",
            value: function(e) {
                e.x = this.x,
                e.y = this.y,
                e.width = this.width,
                e.height = this.height,
                e.minDepth = this.minDepth,
                e.maxDepth = this.maxDepth;
            }
        }]),
        Viewport;
    }();
    ke._tempMatrix4x4 = new I();
    var Ve = function() {
        function Picker() {
            _classCallCheck(this, Picker);
        }
        return _createClass(Picker, null, [{
            key: "calculateCursorRay",
            value: function(e, t, r, n, i, a) {
                var s = e.x
                  , l = e.y
                  , u = Picker._tempVector30
                  , c = u;
                c.x = s,
                c.y = l,
                c.z = t.minDepth;
                var h = Picker._tempVector31
                  , _ = h;
                _.x = s,
                _.y = l,
                _.z = t.maxDepth;
                var d = a.origin
                  , f = Picker._tempVector32;
                t.unprojectFromWVP(u, r, n, i, d),
                t.unprojectFromWVP(h, r, n, i, f);
                var m = a.direction;
                m.x = f.x - d.x,
                m.y = f.y - d.y,
                m.z = f.z - d.z,
                o.normalize(a.direction, a.direction);
            }
        }, {
            key: "rayIntersectsTriangle",
            value: function(e, t, r, n) {
                var i = Picker._tempVector30
                  , a = Picker._tempVector31;
                o.subtract(r, t, i),
                o.subtract(n, t, a);
                var s, l = Picker._tempVector32;
                if (o.cross(e.direction, a, l),
                (s = o.dot(i, l)) > -Number.MIN_VALUE && s < Number.MIN_VALUE)
                    return Number.NaN;
                var u, c = 1 / s, h = Picker._tempVector33;
                if (o.subtract(e.origin, t, h),
                u = o.dot(h, l),
                (u *= c) < 0 || u > 1)
                    return Number.NaN;
                var _, d, f = Picker._tempVector34;
                return o.cross(h, i, f),
                _ = o.dot(e.direction, f),
                (_ *= c) < 0 || u + _ > 1 ? Number.NaN : (d = o.dot(a, f),
                (d *= c) < 0 ? Number.NaN : d);
            }
        }]),
        Picker;
    }();
    Ve._tempVector30 = new o(),
    Ve._tempVector31 = new o(),
    Ve._tempVector32 = new o(),
    Ve._tempVector33 = new o(),
    Ve._tempVector34 = new o();
    var Be, we = function(e) {
        function BufferState() {
            return _classCallCheck(this, BufferState),
            _possibleConstructorReturn(this, _getPrototypeOf(BufferState).call(this));
        }
        return _inherits(BufferState, t.BufferStateBase),
        _createClass(BufferState, [{
            key: "applyVertexBuffer",
            value: function(e) {
                if (t.BufferStateBase._curBindedBufferState !== this)
                    throw "BufferState: must call bind() function first.";
                var r = t.LayaGL.instance
                  , n = e.vertexDeclaration
                  , i = n._shaderValues.getData();
                for (var a in this.vertexDeclaration = n,
                e.bind(),
                i) {
                    var o = parseInt(a)
                      , s = i[a];
                    r.enableVertexAttribArray(o),
                    r.vertexAttribPointer(o, s[0], s[1], !!s[2], s[3], s[4]);
                }
            }
        }, {
            key: "applyVertexBuffers",
            value: function(e) {
                if (t.BufferStateBase._curBindedBufferState !== this)
                    throw "BufferState: must call bind() function first.";
                for (var r = t.LayaGL.instance, n = 0, i = e.length; n < i; n++) {
                    var a = e[n]
                      , o = a.vertexDeclaration._shaderValues.getData();
                    for (var s in a.bind(),
                    o) {
                        var l = parseInt(s)
                          , u = o[s];
                        r.enableVertexAttribArray(l),
                        r.vertexAttribPointer(l, u[0], u[1], !!u[2], u[3], u[4]);
                    }
                }
            }
        }, {
            key: "applyInstanceVertexBuffer",
            value: function(e) {
                if (t.LayaGL.layaGPUInstance.supportInstance()) {
                    if (t.BufferStateBase._curBindedBufferState !== this)
                        throw "BufferState: must call bind() function first.";
                    var r = t.LayaGL.instance
                      , n = e.vertexDeclaration._shaderValues.getData();
                    for (var i in e.bind(),
                    n) {
                        var a = parseInt(i)
                          , o = n[i];
                        r.enableVertexAttribArray(a),
                        r.vertexAttribPointer(a, o[0], o[1], !!o[2], o[3], o[4]),
                        t.LayaGL.layaGPUInstance.vertexAttribDivisor(a, 1);
                    }
                }
            }
        }, {
            key: "applyIndexBuffer",
            value: function(e) {
                if (t.BufferStateBase._curBindedBufferState !== this)
                    throw "BufferState: must call bind() function first.";
                this._bindedIndexBuffer !== e && (e._bindForVAO(),
                this._bindedIndexBuffer = e);
            }
        }]),
        BufferState;
    }();
    (Be = e.IndexFormat || (e.IndexFormat = {}))[Be.UInt8 = 0] = "UInt8",
    Be[Be.UInt16 = 1] = "UInt16",
    Be[Be.UInt32 = 2] = "UInt32";
    var Fe = function(r) {
        function IndexBuffer3D(r, n) {
            var i, a = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 35044, o = arguments.length > 3 && void 0 !== arguments[3] && arguments[3];
            switch (_classCallCheck(this, IndexBuffer3D),
            (i = _possibleConstructorReturn(this, _getPrototypeOf(IndexBuffer3D).call(this)))._indexType = r,
            i._indexCount = n,
            i._bufferUsage = a,
            i._bufferType = t.LayaGL.instance.ELEMENT_ARRAY_BUFFER,
            i._canRead = o,
            r) {
            case e.IndexFormat.UInt32:
                i._indexTypeByteCount = 4;
                break;
            case e.IndexFormat.UInt16:
                i._indexTypeByteCount = 2;
                break;
            case e.IndexFormat.UInt8:
                i._indexTypeByteCount = 1;
                break;
            default:
                throw new Error("unidentification index type.");
            }
            var s = i._indexTypeByteCount * n
              , l = t.BufferStateBase._curBindedBufferState;
            if (i._byteLength = s,
            l ? l._bindedIndexBuffer === _assertThisInitialized(i) ? t.LayaGL.instance.bufferData(i._bufferType, s, i._bufferUsage) : (l.unBind(),
            i.bind(),
            t.LayaGL.instance.bufferData(i._bufferType, s, i._bufferUsage),
            l.bind()) : (i.bind(),
            t.LayaGL.instance.bufferData(i._bufferType, s, i._bufferUsage)),
            o)
                switch (r) {
                case e.IndexFormat.UInt32:
                    i._buffer = new Uint32Array(n);
                    break;
                case e.IndexFormat.UInt16:
                    i._buffer = new Uint16Array(n);
                    break;
                case e.IndexFormat.UInt8:
                    i._buffer = new Uint8Array(n);
                }
            return i;
        }
        return _inherits(IndexBuffer3D, t.Buffer),
        _createClass(IndexBuffer3D, [{
            key: "indexType",
            get: function() {
                return this._indexType;
            }
        }, {
            key: "indexTypeByteCount",
            get: function() {
                return this._indexTypeByteCount;
            }
        }, {
            key: "indexCount",
            get: function() {
                return this._indexCount;
            }
        }, {
            key: "canRead",
            get: function() {
                return this._canRead;
            }
        }]),
        _createClass(IndexBuffer3D, [{
            key: "_bindForVAO",
            value: function() {
                if (!t.BufferStateBase._curBindedBufferState)
                    throw "IndexBuffer3D: must bind current BufferState.";
                var e = t.LayaGL.instance;
                e.bindBuffer(e.ELEMENT_ARRAY_BUFFER, this._glBuffer);
            }
        }, {
            key: "bind",
            value: function() {
                if (t.BufferStateBase._curBindedBufferState)
                    throw "IndexBuffer3D: must unbind current BufferState.";
                if (t.Buffer._bindedIndexBuffer !== this._glBuffer) {
                    var e = t.LayaGL.instance;
                    return e.bindBuffer(e.ELEMENT_ARRAY_BUFFER, this._glBuffer),
                    t.Buffer._bindedIndexBuffer = this._glBuffer,
                    !0;
                }
                return !1;
            }
        }, {
            key: "setData",
            value: function(r) {
                var n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0
                  , i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0
                  , a = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 4294967295
                  , o = this._indexTypeByteCount;
                if (0 !== i || 4294967295 !== a)
                    switch (this._indexType) {
                    case e.IndexFormat.UInt32:
                        r = new Uint32Array(r.buffer,i * o,a);
                        break;
                    case e.IndexFormat.UInt16:
                        r = new Uint16Array(r.buffer,i * o,a);
                        break;
                    case e.IndexFormat.UInt8:
                        r = new Uint8Array(r.buffer,i * o,a);
                    }
                var s = t.BufferStateBase._curBindedBufferState;
                if (s ? s._bindedIndexBuffer === this ? t.LayaGL.instance.bufferSubData(this._bufferType, n * o, r) : (s.unBind(),
                this.bind(),
                t.LayaGL.instance.bufferSubData(this._bufferType, n * o, r),
                s.bind()) : (this.bind(),
                t.LayaGL.instance.bufferSubData(this._bufferType, n * o, r)),
                this._canRead)
                    if (0 !== n || 0 !== i || 4294967295 !== a) {
                        var l = this._buffer.length - n;
                        a > l && (a = l);
                        for (var u = 0; u < a; u++)
                            this._buffer[n + u] = r[u];
                    } else
                        this._buffer = r;
            }
        }, {
            key: "getData",
            value: function() {
                if (this._canRead)
                    return this._buffer;
                throw new Error("Can't read data from VertexBuffer with only write flag!");
            }
        }, {
            key: "destroy",
            value: function() {
                _get(_getPrototypeOf(IndexBuffer3D.prototype), "destroy", this).call(this),
                this._buffer = null;
            }
        }]),
        IndexBuffer3D;
    }()
      , Ue = function() {
        function SkyMesh() {
            _classCallCheck(this, SkyMesh);
        }
        return _createClass(SkyMesh, [{
            key: "_render",
            value: function(e) {}
        }]),
        SkyMesh;
    }()
      , Ge = function(r) {
        function SkyBox() {
            var r;
            _classCallCheck(this, SkyBox),
            r = _possibleConstructorReturn(this, _getPrototypeOf(SkyBox).call(this));
            var n = t.LayaGL.instance
              , i = new Float32Array([-1, 1, -1, 1, 1, -1, 1, 1, 1, -1, 1, 1, -1, -1, -1, 1, -1, -1, 1, -1, 1, -1, -1, 1])
              , a = new Uint8Array([0, 1, 2, 2, 3, 0, 4, 7, 6, 6, 5, 4, 0, 3, 7, 7, 4, 0, 1, 5, 6, 6, 2, 1, 3, 2, 6, 6, 7, 3, 0, 4, 5, 5, 1, 0])
              , o = ue.getVertexDeclaration("POSITION");
            r._vertexBuffer = new De(8 * o.vertexStride,n.STATIC_DRAW,!1),
            r._vertexBuffer.vertexDeclaration = o,
            r._indexBuffer = new Fe(e.IndexFormat.UInt8,36,n.STATIC_DRAW,!1),
            r._vertexBuffer.setData(i.buffer),
            r._indexBuffer.setData(a);
            var s = new we();
            return s.bind(),
            s.applyVertexBuffer(r._vertexBuffer),
            s.applyIndexBuffer(r._indexBuffer),
            s.unBind(),
            r._bufferState = s,
            r;
        }
        return _inherits(SkyBox, Ue),
        _createClass(SkyBox, null, [{
            key: "__init__",
            value: function() {
                SkyBox.instance = new SkyBox();
            }
        }]),
        _createClass(SkyBox, [{
            key: "_render",
            value: function(e) {
                var r = t.LayaGL.instance;
                r.drawElements(r.TRIANGLES, 36, r.UNSIGNED_BYTE, 0),
                t.Stat.trianglesFaces += 12,
                t.Stat.renderBatches++;
            }
        }]),
        SkyBox;
    }()
      , ze = function() {
        function SkyRenderer() {
            _classCallCheck(this, SkyRenderer),
            this._mesh = Ge.instance;
        }
        return _createClass(SkyRenderer, [{
            key: "_isAvailable",
            value: function() {
                return !(!this._material || !this._mesh);
            }
        }, {
            key: "_render",
            value: function(e) {
                if (this._material && this._mesh) {
                    var r = t.LayaGL.instance
                      , n = e.scene
                      , i = e.camera
                      , a = z._SET_RUNTIME_VALUE_MODE_REFERENCE_;
                    t.ILaya.Render.supportWebGLPlusRendering && z.setRuntimeValueMode(!1),
                    t.WebGLContext.setCullFace(r, !1),
                    t.WebGLContext.setDepthFunc(r, r.LEQUAL),
                    t.WebGLContext.setDepthMask(r, !1);
                    var s = SkyRenderer._compileDefine;
                    this._material._shaderValues._defineDatas.cloneTo(s);
                    var l = e.shader = this._material._shader.getSubShaderAt(0)._passes[0].withCompile(s)
                      , u = l.bind()
                      , c = t.Stat.loopCount !== l._uploadMark
                      , h = l._uploadScene !== n || c;
                    (h || u) && (l.uploadUniforms(l._sceneUniformParamsMap, n._shaderValues, h),
                    l._uploadScene = n);
                    i._getRenderTexture();
                    var _ = l._uploadCamera !== i || c;
                    if (_ || u) {
                        var d = SkyRenderer._tempMatrix0
                          , f = SkyRenderer._tempMatrix1;
                        i.viewMatrix.cloneTo(d),
                        i.projectionMatrix.cloneTo(f),
                        d.setTranslationVector(o._ZERO),
                        i.orthographic && I.createPerspective(i.fieldOfView, i.aspectRatio, i.nearPlane, i.farPlane, f);
                        var m = 1 / Math.tan(3.1416 * i.fieldOfView / 180 * .5);
                        f.elements[0] = m / i.aspectRatio,
                        f.elements[5] = m,
                        f.elements[10] = 1e-6 - 1,
                        f.elements[11] = -1,
                        f.elements[14] = -0,
                        i._applyViewProject(e, d, f),
                        l.uploadUniforms(l._cameraUniformParamsMap, i._shaderValues, _),
                        l._uploadCamera = i;
                    }
                    var p = l._uploadMaterial !== this._material || c;
                    (p || u) && (l.uploadUniforms(l._materialUniformParamsMap, this._material._shaderValues, p),
                    l._uploadMaterial = this._material),
                    this._mesh._bufferState.bind(),
                    this._mesh._render(e),
                    t.ILaya.Render.supportWebGLPlusRendering && z.setRuntimeValueMode(a),
                    t.WebGLContext.setDepthFunc(r, r.LESS),
                    t.WebGLContext.setDepthMask(r, !0),
                    i._applyViewProject(e, i.viewMatrix, i.projectionMatrix);
                }
            }
        }, {
            key: "destroy",
            value: function() {
                this._material && (this._material._removeReference(),
                this._material = null);
            }
        }, {
            key: "material",
            get: function() {
                return this._material;
            },
            set: function(e) {
                this._material !== e && (this._material && this._material._removeReference(),
                e && e._addReference(),
                this._material = e);
            }
        }, {
            key: "mesh",
            get: function() {
                return this._mesh;
            },
            set: function(e) {
                this._mesh !== e && (this._mesh = e);
            }
        }]),
        SkyRenderer;
    }();
    ze._tempMatrix0 = new I(),
    ze._tempMatrix1 = new I(),
    ze._compileDefine = new B();
    var He = function(e) {
        function BaseCamera() {
            var e, t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : .3, r = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1e3;
            return _classCallCheck(this, BaseCamera),
            (e = _possibleConstructorReturn(this, _getPrototypeOf(BaseCamera).call(this)))._skyRenderer = new ze(),
            e._forward = new o(),
            e._up = new o(),
            e.clearColor = new i(100 / 255,149 / 255,237 / 255,1),
            e._shaderValues = new z(null),
            e._fieldOfView = 60,
            e._useUserProjectionMatrix = !1,
            e._orthographic = !1,
            e._orthographicVerticalSize = 10,
            e.renderingOrder = 0,
            e._nearPlane = t,
            e._farPlane = r,
            e.cullingMask = 2147483647,
            e.useOcclusionCulling = !0,
            e;
        }
        return _inherits(BaseCamera, ye),
        _createClass(BaseCamera, [{
            key: "_sortCamerasByRenderingOrder",
            value: function() {
                if (this.displayedInStage)
                    for (var e = this.scene._cameraPool, t = e.length - 1, r = 0; r < t; r++)
                        if (e[r].renderingOrder > e[t].renderingOrder) {
                            var n = e[r];
                            e[r] = e[t],
                            e[t] = n;
                        }
            }
        }, {
            key: "_calculateProjectionMatrix",
            value: function() {}
        }, {
            key: "_onScreenSizeChanged",
            value: function() {
                this._calculateProjectionMatrix();
            }
        }, {
            key: "_prepareCameraToRender",
            value: function() {
                var e = this._shaderValues;
                this.transform.getForward(this._forward),
                this.transform.getUp(this._up),
                e.setVector3(BaseCamera.CAMERAPOS, this.transform.position),
                e.setVector3(BaseCamera.CAMERADIRECTION, this._forward),
                e.setVector3(BaseCamera.CAMERAUP, this._up);
            }
        }, {
            key: "render",
            value: function() {
                arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
                arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
            }
        }, {
            key: "addLayer",
            value: function(e) {
                this.cullingMask |= Math.pow(2, e);
            }
        }, {
            key: "removeLayer",
            value: function(e) {
                this.cullingMask &= ~Math.pow(2, e);
            }
        }, {
            key: "addAllLayers",
            value: function() {
                this.cullingMask = 2147483647;
            }
        }, {
            key: "removeAllLayers",
            value: function() {
                this.cullingMask = 0;
            }
        }, {
            key: "resetProjectionMatrix",
            value: function() {
                this._useUserProjectionMatrix = !1,
                this._calculateProjectionMatrix();
            }
        }, {
            key: "_onActive",
            value: function() {
                this._scene._addCamera(this),
                _get(_getPrototypeOf(BaseCamera.prototype), "_onActive", this).call(this);
            }
        }, {
            key: "_onInActive",
            value: function() {
                this._scene._removeCamera(this),
                _get(_getPrototypeOf(BaseCamera.prototype), "_onInActive", this).call(this);
            }
        }, {
            key: "_parse",
            value: function(e, r) {
                _get(_getPrototypeOf(BaseCamera.prototype), "_parse", this).call(this, e, r),
                this.orthographic = e.orthographic,
                void 0 !== e.orthographicVerticalSize && (this.orthographicVerticalSize = e.orthographicVerticalSize),
                void 0 !== e.fieldOfView && (this.fieldOfView = e.fieldOfView),
                this.nearPlane = e.nearPlane,
                this.farPlane = e.farPlane;
                var n = e.clearColor;
                this.clearColor = new i(n[0],n[1],n[2],n[3]);
                var a = e.skyboxMaterial;
                a && (this._skyRenderer.material = t.Loader.getRes(a.path));
            }
        }, {
            key: "destroy",
            value: function() {
                var e = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0];
                this._skyRenderer.destroy(),
                this._skyRenderer = null,
                t.Laya.stage.off(t.Event.RESIZE, this, this._onScreenSizeChanged),
                _get(_getPrototypeOf(BaseCamera.prototype), "destroy", this).call(this, e);
            }
        }, {
            key: "_create",
            value: function() {
                return new BaseCamera();
            }
        }, {
            key: "skyRenderer",
            get: function() {
                return this._skyRenderer;
            }
        }, {
            key: "fieldOfView",
            get: function() {
                return this._fieldOfView;
            },
            set: function(e) {
                this._fieldOfView = e,
                this._calculateProjectionMatrix();
            }
        }, {
            key: "nearPlane",
            get: function() {
                return this._nearPlane;
            },
            set: function(e) {
                this._nearPlane = e,
                this._calculateProjectionMatrix();
            }
        }, {
            key: "farPlane",
            get: function() {
                return this._farPlane;
            },
            set: function(e) {
                this._farPlane = e,
                this._calculateProjectionMatrix();
            }
        }, {
            key: "orthographic",
            get: function() {
                return this._orthographic;
            },
            set: function(e) {
                this._orthographic = e,
                this._calculateProjectionMatrix();
            }
        }, {
            key: "orthographicVerticalSize",
            get: function() {
                return this._orthographicVerticalSize;
            },
            set: function(e) {
                this._orthographicVerticalSize = e,
                this._calculateProjectionMatrix();
            }
        }, {
            key: "renderingOrder",
            get: function() {
                return this._renderingOrder;
            },
            set: function(e) {
                this._renderingOrder = e,
                this._sortCamerasByRenderingOrder();
            }
        }]),
        BaseCamera;
    }();
    He._tempMatrix4x40 = new I(),
    He.CAMERAPOS = G.propertyNameToID("u_CameraPos"),
    He.VIEWMATRIX = G.propertyNameToID("u_View"),
    He.PROJECTMATRIX = G.propertyNameToID("u_Projection"),
    He.VIEWPROJECTMATRIX = G.propertyNameToID("u_ViewProjection"),
    He.CAMERADIRECTION = G.propertyNameToID("u_CameraDirection"),
    He.CAMERAUP = G.propertyNameToID("u_CameraUp"),
    He.VIEWPORT = G.propertyNameToID("u_Viewport"),
    He.PROJECTION_PARAMS = G.propertyNameToID("u_ProjectionParams"),
    He.RENDERINGTYPE_DEFERREDLIGHTING = "DEFERREDLIGHTING",
    He.RENDERINGTYPE_FORWARDRENDERING = "FORWARDRENDERING",
    He._invertYScaleMatrix = new I(1,0,0,0,0,-1,0,0,0,0,1,0,0,0,0,1),
    He._invertYProjectionMatrix = new I(),
    He._invertYProjectionViewMatrix = new I(),
    He.CLEARFLAG_SOLIDCOLOR = 0,
    He.CLEARFLAG_SKY = 1,
    He.CLEARFLAG_DEPTHONLY = 2,
    He.CLEARFLAG_NONE = 3;
    var We = function(e) {
        function ScreenQuad() {
            var e;
            _classCallCheck(this, ScreenQuad),
            (e = _possibleConstructorReturn(this, _getPrototypeOf(ScreenQuad).call(this)))._bufferState = new we(),
            e._bufferStateInvertUV = new we();
            var r = t.LayaGL.instance;
            return e._vertexBuffer = new De(64,r.STATIC_DRAW,!1),
            e._vertexBuffer.vertexDeclaration = ScreenQuad._vertexDeclaration,
            e._vertexBuffer.setData(ScreenQuad._vertices.buffer),
            e._bufferState.bind(),
            e._bufferState.applyVertexBuffer(e._vertexBuffer),
            e._bufferState.unBind(),
            e._vertexBufferInvertUV = new De(64,r.STATIC_DRAW,!1),
            e._vertexBufferInvertUV.vertexDeclaration = ScreenQuad._vertexDeclaration,
            e._vertexBufferInvertUV.setData(ScreenQuad._verticesInvertUV.buffer),
            e._bufferStateInvertUV.bind(),
            e._bufferStateInvertUV.applyVertexBuffer(e._vertexBufferInvertUV),
            e._bufferStateInvertUV.unBind(),
            e._setGPUMemory(e._vertexBuffer._byteLength + e._vertexBufferInvertUV._byteLength),
            e;
        }
        return _inherits(ScreenQuad, t.Resource),
        _createClass(ScreenQuad, [{
            key: "render",
            value: function() {
                var e = t.LayaGL.instance;
                this._bufferState.bind(),
                e.drawArrays(e.TRIANGLE_STRIP, 0, 4),
                t.Stat.renderBatches++;
            }
        }, {
            key: "renderInvertUV",
            value: function() {
                var e = t.LayaGL.instance;
                this._bufferStateInvertUV.bind(),
                e.drawArrays(e.TRIANGLE_STRIP, 0, 4),
                t.Stat.renderBatches++;
            }
        }, {
            key: "destroy",
            value: function() {
                _get(_getPrototypeOf(ScreenQuad.prototype), "destroy", this).call(this),
                this._bufferState.destroy(),
                this._vertexBuffer.destroy(),
                this._bufferStateInvertUV.destroy(),
                this._vertexBufferInvertUV.destroy(),
                this._setGPUMemory(0);
            }
        }], [{
            key: "__init__",
            value: function() {
                ScreenQuad._vertexDeclaration = new oe(16,[new le(0,ae.Vector4,ScreenQuad.SCREENQUAD_POSITION_UV)]),
                ScreenQuad.instance = new ScreenQuad(),
                ScreenQuad.instance.lock = !0;
            }
        }]),
        ScreenQuad;
    }();
    We.SCREENQUAD_POSITION_UV = 0,
    We._vertices = new Float32Array([1, 1, 1, 1, 1, -1, 1, 0, -1, 1, 0, 1, -1, -1, 0, 0]),
    We._verticesInvertUV = new Float32Array([1, 1, 1, 0, 1, -1, 1, 1, -1, 1, 0, 0, -1, -1, 0, 1]);
    var Xe = function(e) {
        function ScreenTriangle() {
            var e;
            _classCallCheck(this, ScreenTriangle),
            (e = _possibleConstructorReturn(this, _getPrototypeOf(ScreenTriangle).call(this)))._bufferState = new we(),
            e._bufferStateInvertUV = new we();
            var r = t.LayaGL.instance;
            return e._vertexBuffer = new De(48,r.STATIC_DRAW,!1),
            e._vertexBuffer.vertexDeclaration = ScreenTriangle._vertexDeclaration,
            e._vertexBuffer.setData(ScreenTriangle._vertices.buffer),
            e._bufferState.bind(),
            e._bufferState.applyVertexBuffer(e._vertexBuffer),
            e._bufferState.unBind(),
            e._vertexBufferInvertUV = new De(48,r.STATIC_DRAW,!1),
            e._vertexBufferInvertUV.vertexDeclaration = ScreenTriangle._vertexDeclaration,
            e._vertexBufferInvertUV.setData(ScreenTriangle._verticesInvertUV.buffer),
            e._bufferStateInvertUV.bind(),
            e._bufferStateInvertUV.applyVertexBuffer(e._vertexBufferInvertUV),
            e._bufferStateInvertUV.unBind(),
            e._setGPUMemory(e._vertexBuffer._byteLength + e._vertexBufferInvertUV._byteLength),
            e;
        }
        return _inherits(ScreenTriangle, t.Resource),
        _createClass(ScreenTriangle, [{
            key: "render",
            value: function() {
                var e = t.LayaGL.instance;
                this._bufferState.bind(),
                e.drawArrays(e.TRIANGLES, 0, 3),
                t.Stat.renderBatches++;
            }
        }, {
            key: "renderInvertUV",
            value: function() {
                var e = t.LayaGL.instance;
                this._bufferStateInvertUV.bind(),
                e.drawArrays(e.TRIANGLES, 0, 3),
                t.Stat.renderBatches++;
            }
        }, {
            key: "destroy",
            value: function() {
                _get(_getPrototypeOf(ScreenTriangle.prototype), "destroy", this).call(this),
                this._bufferState.destroy(),
                this._vertexBuffer.destroy(),
                this._bufferStateInvertUV.destroy(),
                this._vertexBufferInvertUV.destroy(),
                this._setGPUMemory(0);
            }
        }], [{
            key: "__init__",
            value: function() {
                ScreenTriangle._vertexDeclaration = new oe(16,[new le(0,ae.Vector4,ScreenTriangle.SCREENTRIANGLE_POSITION_UV)]),
                ScreenTriangle.instance = new ScreenTriangle(),
                ScreenTriangle.instance.lock = !0;
            }
        }]),
        ScreenTriangle;
    }();
    Xe.SCREENTRIANGLE_POSITION_UV = 0,
    Xe._vertices = new Float32Array([-1, -1, 0, 0, -1, 3, 0, 2, 3, -1, 2, 0]),
    Xe._verticesInvertUV = new Float32Array([-1, -1, 0, 1, -1, 3, 0, -1, 3, -1, 2, 1]);
    var Ye = function() {
        function Command() {
            _classCallCheck(this, Command),
            this._commandBuffer = null;
        }
        return _createClass(Command, [{
            key: "run",
            value: function() {}
        }, {
            key: "recover",
            value: function() {
                this._commandBuffer = null;
            }
        }], [{
            key: "__init__",
            value: function() {
                Command._screenShaderData = new z(),
                Command._screenShader = G.find("BlitScreen");
            }
        }]),
        Command;
    }();
    Ye.SCREENTEXTURE_NAME = "u_MainTex",
    Ye.SCREENTEXTUREOFFSETSCALE_NAME = "u_OffsetScale",
    Ye.MAINTEXTURE_TEXELSIZE_NAME = "u_MainTex_TexelSize",
    Ye.SCREENTEXTURE_ID = G.propertyNameToID(Ye.SCREENTEXTURE_NAME),
    Ye.SCREENTEXTUREOFFSETSCALE_ID = G.propertyNameToID(Ye.SCREENTEXTUREOFFSETSCALE_NAME),
    Ye.MAINTEXTURE_TEXELSIZE_ID = G.propertyNameToID(Ye.MAINTEXTURE_TEXELSIZE_NAME);
    var Ze = function(e) {
        function BlitScreenQuadCMD() {
            var e;
            return _classCallCheck(this, BlitScreenQuadCMD),
            (e = _possibleConstructorReturn(this, _getPrototypeOf(BlitScreenQuadCMD).apply(this, arguments)))._source = null,
            e._dest = null,
            e._offsetScale = null,
            e._shader = null,
            e._shaderData = null,
            e._subShader = 0,
            e._sourceTexelSize = new i(),
            e._screenType = 0,
            e;
        }
        return _inherits(BlitScreenQuadCMD, Ye),
        _createClass(BlitScreenQuadCMD, [{
            key: "run",
            value: function() {
                var e = this._shader || Ye._screenShader
                  , r = this._shaderData || Ye._screenShaderData
                  , n = this._dest;
                t.LayaGL.instance.viewport(0, 0, n ? n.width : k.clientWidth, n ? n.height : k.clientHeight),
                r.setTexture(Ye.SCREENTEXTURE_ID, this._source),
                r.setVector(Ye.SCREENTEXTUREOFFSETSCALE_ID, this._offsetScale || BlitScreenQuadCMD._defaultOffsetScale),
                this._sourceTexelSize.setValue(1 / this._source.width, 1 / this._source.height, this._source.width, this._source.height),
                r.setVector(Ye.MAINTEXTURE_TEXELSIZE_ID, this._sourceTexelSize),
                n && n._start();
                for (var i = e.getSubShaderAt(this._subShader)._passes, a = 0, o = i.length; a < o; a++) {
                    var s = BlitScreenQuadCMD._compileDefine;
                    r._defineDatas.cloneTo(s);
                    var l = i[a].withCompile(s);
                    switch (l.bind(),
                    l.uploadUniforms(l._materialUniformParamsMap, r, !0),
                    l.uploadRenderStateBlendDepth(r),
                    l.uploadRenderStateFrontFace(r, !1, null),
                    this._screenType) {
                    case BlitScreenQuadCMD._SCREENTYPE_QUAD:
                        k._instance.invertY ? We.instance.renderInvertUV() : We.instance.render();
                        break;
                    case BlitScreenQuadCMD._SCREENTYPE_TRIANGLE:
                        k._instance.invertY ? Xe.instance.renderInvertUV() : Xe.instance.render();
                        break;
                    default:
                        throw "BlitScreenQuadCMD:unknown screen Type.";
                    }
                }
                n && n._end();
            }
        }, {
            key: "recover",
            value: function() {
                BlitScreenQuadCMD._pool.push(this),
                this._source = null,
                this._dest = null,
                this._offsetScale = null,
                this._shader = null,
                this._shaderData = null,
                _get(_getPrototypeOf(BlitScreenQuadCMD.prototype), "recover", this).call(this);
            }
        }], [{
            key: "create",
            value: function(e, t) {
                var r, n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null, i = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : null, a = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : null, o = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : 0, s = arguments.length > 6 && void 0 !== arguments[6] ? arguments[6] : BlitScreenQuadCMD._SCREENTYPE_QUAD;
                return (r = BlitScreenQuadCMD._pool.length > 0 ? BlitScreenQuadCMD._pool.pop() : new BlitScreenQuadCMD())._source = e,
                r._dest = t,
                r._offsetScale = n,
                r._shader = i,
                r._shaderData = a,
                r._subShader = o,
                r._screenType = s,
                r;
            }
        }]),
        BlitScreenQuadCMD;
    }();
    Ze._SCREENTYPE_QUAD = 0,
    Ze._SCREENTYPE_TRIANGLE = 1,
    Ze._compileDefine = new B(),
    Ze._pool = [],
    Ze._defaultOffsetScale = new i(0,0,1,1);
    var je = function(e) {
        function SetRenderTargetCMD() {
            var e;
            return _classCallCheck(this, SetRenderTargetCMD),
            (e = _possibleConstructorReturn(this, _getPrototypeOf(SetRenderTargetCMD).apply(this, arguments)))._renderTexture = null,
            e;
        }
        return _inherits(SetRenderTargetCMD, Ye),
        _createClass(SetRenderTargetCMD, [{
            key: "run",
            value: function() {
                this._renderTexture._start();
            }
        }, {
            key: "recover",
            value: function() {
                SetRenderTargetCMD._pool.push(this),
                this._renderTexture = null;
            }
        }], [{
            key: "create",
            value: function(e) {
                var t;
                return (t = SetRenderTargetCMD._pool.length > 0 ? SetRenderTargetCMD._pool.pop() : new SetRenderTargetCMD())._renderTexture = e,
                t;
            }
        }]),
        SetRenderTargetCMD;
    }();
    je._pool = [];
    var Qe = function(e) {
        function SetShaderDataTextureCMD() {
            var e;
            return _classCallCheck(this, SetShaderDataTextureCMD),
            (e = _possibleConstructorReturn(this, _getPrototypeOf(SetShaderDataTextureCMD).apply(this, arguments)))._shaderData = null,
            e._nameID = 0,
            e._texture = null,
            e;
        }
        return _inherits(SetShaderDataTextureCMD, Ye),
        _createClass(SetShaderDataTextureCMD, [{
            key: "run",
            value: function() {
                this._shaderData.setTexture(this._nameID, this._texture);
            }
        }, {
            key: "recover",
            value: function() {
                SetShaderDataTextureCMD._pool.push(this),
                this._shaderData = null,
                this._nameID = 0,
                this._texture = null;
            }
        }], [{
            key: "create",
            value: function(e, t, r) {
                var n;
                return (n = SetShaderDataTextureCMD._pool.length > 0 ? SetShaderDataTextureCMD._pool.pop() : new SetShaderDataTextureCMD())._shaderData = e,
                n._nameID = t,
                n._texture = r,
                n;
            }
        }]),
        SetShaderDataTextureCMD;
    }();
    Qe._pool = [];
    var qe, Ke = function() {
        function CommandBuffer() {
            _classCallCheck(this, CommandBuffer),
            this._camera = null,
            this._commands = [];
        }
        return _createClass(CommandBuffer, [{
            key: "_apply",
            value: function() {
                for (var e = 0, t = this._commands.length; e < t; e++)
                    this._commands[e].run();
            }
        }, {
            key: "setShaderDataTexture",
            value: function(e, t, r) {
                this._commands.push(Qe.create(e, t, r));
            }
        }, {
            key: "blitScreenQuad",
            value: function(e, t) {
                var r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null
                  , n = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : null
                  , i = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : null
                  , a = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : 0;
                this._commands.push(Ze.create(e, t, r, n, i, a, Ze._SCREENTYPE_QUAD));
            }
        }, {
            key: "blitScreenTriangle",
            value: function(e, t) {
                var r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null
                  , n = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : null
                  , i = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : null
                  , a = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : 0;
                this._commands.push(Ze.create(e, t, r, n, i, a, Ze._SCREENTYPE_TRIANGLE));
            }
        }, {
            key: "setRenderTarget",
            value: function(e) {
                this._commands.push(je.create(e));
            }
        }, {
            key: "clear",
            value: function() {
                for (var e = 0, t = this._commands.length; e < t; e++)
                    this._commands[e].recover();
                this._commands.length = 0;
            }
        }]),
        CommandBuffer;
    }(), Je = function Scene3DShaderDeclaration() {
        _classCallCheck(this, Scene3DShaderDeclaration);
    };
    (qe = e.CameraClearFlags || (e.CameraClearFlags = {}))[qe.SolidColor = 0] = "SolidColor",
    qe[qe.Sky = 1] = "Sky",
    qe[qe.DepthOnly = 2] = "DepthOnly",
    qe[qe.Nothing = 3] = "Nothing";
    var $e = function(r) {
        function Camera() {
            var r, a = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0, o = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : .3, s = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 1e3;
            return _classCallCheck(this, Camera),
            (r = _possibleConstructorReturn(this, _getPrototypeOf(Camera).call(this, o, s)))._updateViewMatrix = !0,
            r._postProcess = null,
            r._enableHDR = !1,
            r._viewportParams = new i(),
            r._projectionParams = new i(),
            r._offScreenRenderTexture = null,
            r._internalRenderTexture = null,
            r._postProcessCommandBuffers = [],
            r._clusterPlaneCacheFlag = new n(-1,-1),
            r._screenOffsetScale = new i(),
            r.enableRender = !0,
            r.clearFlag = e.CameraClearFlags.SolidColor,
            r._viewMatrix = new I(),
            r._projectionMatrix = new I(),
            r._projectionViewMatrix = new I(),
            r._viewport = new ke(0,0,0,0),
            r._normalizedViewport = new ke(0,0,1,1),
            r._aspectRatio = a,
            r._boundFrustum = new be(I.DEFAULT),
            t.Render.supportWebGLPlusCulling && (r._boundFrustumBuffer = new Float32Array(24)),
            r._calculateProjectionMatrix(),
            t.Laya.stage.on(t.Event.RESIZE, _assertThisInitialized(r), r._onScreenSizeChanged),
            r.transform.on(t.Event.TRANSFORM_CHANGED, _assertThisInitialized(r), r._onTransformChanged),
            r;
        }
        return _inherits(Camera, He),
        _createClass(Camera, [{
            key: "_calculationViewport",
            value: function(e, t, r) {
                var n = e.x * t
                  , i = e.y * r
                  , a = n + Math.max(e.width * t, 0)
                  , o = i + Math.max(e.height * r, 0)
                  , s = Math.ceil(n)
                  , l = Math.ceil(i)
                  , u = Math.floor(a)
                  , c = Math.floor(o)
                  , h = s - n >= .5 ? Math.floor(n) : s
                  , _ = l - i >= .5 ? Math.floor(i) : l
                  , d = a - u >= .5 ? Math.ceil(a) : u
                  , f = o - c >= .5 ? Math.ceil(o) : c;
                this._viewport.x = h,
                this._viewport.y = _,
                this._viewport.width = d - h,
                this._viewport.height = f - _;
            }
        }, {
            key: "_calculateProjectionMatrix",
            value: function() {
                if (!this._useUserProjectionMatrix)
                    if (this._orthographic) {
                        var e = .5 * this.orthographicVerticalSize
                          , t = e * this.aspectRatio;
                        I.createOrthoOffCenter(-t, t, -e, e, this.nearPlane, this.farPlane, this._projectionMatrix);
                    } else
                        I.createPerspective(3.1416 * this.fieldOfView / 180, this.aspectRatio, this.nearPlane, this.farPlane, this._projectionMatrix);
            }
        }, {
            key: "_isLayerVisible",
            value: function(e) {
                return 0 != (Math.pow(2, e) & this.cullingMask);
            }
        }, {
            key: "_onTransformChanged",
            value: function(e) {
                (e &= Ee.TRANSFORM_WORLDMATRIX) && (this._updateViewMatrix = !0);
            }
        }, {
            key: "_parse",
            value: function(e, t) {
                _get(_getPrototypeOf(Camera.prototype), "_parse", this).call(this, e, t);
                var r = e.clearFlag;
                void 0 !== r && (this.clearFlag = r);
                var n = e.viewport;
                this.normalizedViewport = new ke(n[0],n[1],n[2],n[3]);
                var i = e.enableHDR;
                void 0 !== i && (this.enableHDR = i);
            }
        }, {
            key: "_getCanvasWidth",
            value: function() {
                return this._offScreenRenderTexture ? this._offScreenRenderTexture.width : k.clientWidth;
            }
        }, {
            key: "_getCanvasHeight",
            value: function() {
                return this._offScreenRenderTexture ? this._offScreenRenderTexture.height : k.clientHeight;
            }
        }, {
            key: "_getRenderTexture",
            value: function() {
                return this._internalRenderTexture || this._offScreenRenderTexture;
            }
        }, {
            key: "_needInternalRenderTexture",
            value: function() {
                return !(!this._postProcess && !this._enableHDR);
            }
        }, {
            key: "_applyPostProcessCommandBuffers",
            value: function() {
                for (var e = 0, t = this._postProcessCommandBuffers.length; e < t; e++)
                    this._postProcessCommandBuffers[e]._apply();
            }
        }, {
            key: "_getRenderTextureFormat",
            value: function() {
                return this._enableHDR ? t.RenderTextureFormat.R16G16B16A16 : t.RenderTextureFormat.R8G8B8;
            }
        }, {
            key: "_prepareCameraToRender",
            value: function() {
                _get(_getPrototypeOf(Camera.prototype), "_prepareCameraToRender", this).call(this);
                var e = this.viewport;
                this._viewportParams.setValue(e.x, e.y, e.width, e.height),
                this._projectionParams.setValue(this._nearPlane, this._farPlane, k._instance.invertY ? -1 : 1, 0),
                this._shaderValues.setVector(He.VIEWPORT, this._viewportParams),
                this._shaderValues.setVector(He.PROJECTION_PARAMS, this._projectionParams);
            }
        }, {
            key: "_applyViewProject",
            value: function(e, t, r) {
                var n, i = this._shaderValues;
                e.invertY ? (I.multiply(He._invertYScaleMatrix, r, He._invertYProjectionMatrix),
                I.multiply(He._invertYProjectionMatrix, t, He._invertYProjectionViewMatrix),
                r = He._invertYProjectionMatrix,
                n = He._invertYProjectionViewMatrix) : (I.multiply(r, t, this._projectionViewMatrix),
                n = this._projectionViewMatrix),
                e.viewMatrix = t,
                e.projectionMatrix = r,
                e.projectionViewMatrix = n,
                i.setMatrix4x4(He.VIEWMATRIX, t),
                i.setMatrix4x4(He.PROJECTMATRIX, r),
                i.setMatrix4x4(He.VIEWPROJECTMATRIX, n);
            }
        }, {
            key: "_updateClusterPlaneXY",
            value: function() {
                var e = this.fieldOfView
                  , t = this.aspectRatio;
                if (this._clusterPlaneCacheFlag.x !== e || this._clusterPlaneCacheFlag.y !== t) {
                    var r = s._config.lightClusterCount
                      , n = r.x
                      , i = r.y
                      , a = n + 1
                      , l = i + 1
                      , u = this._clusterXPlanes
                      , c = this._clusterYPlanes;
                    if (!u) {
                        u = this._clusterXPlanes = new Array(a),
                        c = this._clusterYPlanes = new Array(l);
                        for (var h = 0; h < a; h++)
                            u[h] = new o();
                        for (h = 0; h < l; h++)
                            c[h] = new o();
                    }
                    var _ = Math.tan(this.fieldOfView / 2 * Math.PI / 180)
                      , d = this.aspectRatio * _
                      , f = 2 * _ / n
                      , m = 2 * d / i;
                    for (h = 0; h < a; h++) {
                        var p = m * h - d
                          , v = 1 / Math.sqrt(1 + p * p);
                        u[h].setValue(v, 0, -p * v);
                    }
                    for (h = 0; h < l; h++) {
                        p = _ - f * h;
                        var T = -1 / Math.sqrt(1 + p * p);
                        c[h].setValue(0, T, -p * T);
                    }
                    this._clusterPlaneCacheFlag.x = e,
                    this._clusterPlaneCacheFlag.y = t;
                }
            }
        }, {
            key: "render",
            value: function() {
                var r = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null
                  , n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null;
                if (this.activeInHierarchy) {
                    var i = this.viewport
                      , a = this._needInternalRenderTexture()
                      , o = t.LayaGL.instance
                      , l = k._instance
                      , u = l.scene = this._scene;
                    if (this._internalRenderTexture = a ? V.createFromPool(i.width, i.height, this._getRenderTextureFormat(), t.RenderTextureDepthFormat.DEPTH_16, t.FilterMode.Bilinear) : null,
                    u.parallelSplitShadowMaps[0]) {
                        z.setRuntimeValueMode(!1);
                        var c = u.parallelSplitShadowMaps[0];
                        c._calcAllLightCameraInfo(this),
                        u._shaderValues.addDefine(Je.SHADERDEFINE_CAST_SHADOW);
                        for (var h = 0, _ = c.shadowMapCount; h < _; h++) {
                            var d = c.cameras[h];
                            l.camera = d,
                            Re.renderObjectCulling(d, u, l, r, n, !0);
                            var f = c.cameras[h + 1].renderTarget;
                            f._start(),
                            k._instance.invertY = !1,
                            l.camera = d,
                            Camera._updateMark++,
                            l.viewport = d.viewport,
                            d._prepareCameraToRender(),
                            d._applyViewProject(l, d.viewMatrix, d.projectionMatrix),
                            u._clear(o, l),
                            u._opaqueQueue._render(l),
                            f._end();
                        }
                        u._shaderValues.removeDefine(Je.SHADERDEFINE_CAST_SHADOW),
                        z.setRuntimeValueMode(!0);
                    }
                    if (l.camera = this,
                    Camera._updateMark++,
                    u._preRenderScript(),
                    a && !this._offScreenRenderTexture && (this.clearFlag == e.CameraClearFlags.DepthOnly || this.clearFlag == e.CameraClearFlags.Nothing))
                        if (this._enableHDR) {
                            var m = V.createFromPool(i.width, i.height, t.RenderTextureFormat.R8G8B8, t.RenderTextureDepthFormat.DEPTH_16, t.FilterMode.Bilinear);
                            t.WebGLContext.bindTexture(o, o.TEXTURE_2D, m._getSource()),
                            o.copyTexSubImage2D(o.TEXTURE_2D, 0, 0, 0, i.x, k.clientHeight - (i.y + i.height), i.width, i.height),
                            (v = Ze.create(m, this._internalRenderTexture)).run(),
                            v.recover(),
                            V.recoverToPool(m);
                        } else
                            t.WebGLContext.bindTexture(o, o.TEXTURE_2D, this._internalRenderTexture._getSource()),
                            o.copyTexSubImage2D(o.TEXTURE_2D, 0, 0, 0, i.x, k.clientHeight - (i.y + i.height), i.width, i.height);
                    var p = this._getRenderTexture();
                    if (p && p._start(),
                    l.viewport = i,
                    this._prepareCameraToRender(),
                    s._config._multiLighting && Ie.instance.update(this, this._scene),
                    this._applyViewProject(l, this.viewMatrix, this._projectionMatrix),
                    u._preCulling(l, this, r, n),
                    u._clear(o, l),
                    u._renderScene(l),
                    u._postRenderScript(),
                    p && p._end(),
                    a) {
                        if (this._postProcess)
                            this._postProcess._render(),
                            this._applyPostProcessCommandBuffers();
                        else if (this._enableHDR) {
                            var v, T = this._getCanvasWidth(), E = this._getCanvasHeight();
                            this._screenOffsetScale.setValue(i.x / T, i.y / E, i.width / T, i.height / E),
                            (v = Ze.create(this._internalRenderTexture, this._offScreenRenderTexture ? this._offScreenRenderTexture : null, this._screenOffsetScale)).run(),
                            v.recover();
                        }
                        V.recoverToPool(this._internalRenderTexture);
                    }
                }
            }
        }, {
            key: "viewportPointToRay",
            value: function(e, t) {
                Ve.calculateCursorRay(e, this.viewport, this._projectionMatrix, this.viewMatrix, null, t);
            }
        }, {
            key: "normalizedViewportPointToRay",
            value: function(e, t) {
                var r = Camera._tempVector20
                  , n = this.viewport;
                r.x = e.x * n.width,
                r.y = e.y * n.height,
                Ve.calculateCursorRay(r, this.viewport, this._projectionMatrix, this.viewMatrix, null, t);
            }
        }, {
            key: "worldToViewportPoint",
            value: function(e, r) {
                I.multiply(this._projectionMatrix, this._viewMatrix, this._projectionViewMatrix),
                this.viewport.project(e, this._projectionViewMatrix, r),
                r.x = r.x / t.Laya.stage.clientScaleX,
                r.y = r.y / t.Laya.stage.clientScaleY;
            }
        }, {
            key: "worldToNormalizedViewportPoint",
            value: function(e, r) {
                I.multiply(this._projectionMatrix, this._viewMatrix, this._projectionViewMatrix),
                this.normalizedViewport.project(e, this._projectionViewMatrix, r),
                r.x = r.x / t.Laya.stage.clientScaleX,
                r.y = r.y / t.Laya.stage.clientScaleY;
            }
        }, {
            key: "convertScreenCoordToOrthographicCoord",
            value: function(e, r) {
                if (this._orthographic) {
                    var n = k.clientWidth
                      , i = k.clientHeight
                      , a = this.orthographicVerticalSize * this.aspectRatio / n
                      , s = this.orthographicVerticalSize / i;
                    return r.x = (-n / 2 + e.x * t.Laya.stage.clientScaleX) * a,
                    r.y = (i / 2 - e.y * t.Laya.stage.clientScaleY) * s,
                    r.z = (this.nearPlane - this.farPlane) * (e.z + 1) / 2 - this.nearPlane,
                    o.transformCoordinate(r, this.transform.worldMatrix, r),
                    !0;
                }
                return !1;
            }
        }, {
            key: "destroy",
            value: function() {
                var e = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0];
                this._offScreenRenderTexture = null,
                this.transform.off(t.Event.TRANSFORM_CHANGED, this, this._onTransformChanged),
                _get(_getPrototypeOf(Camera.prototype), "destroy", this).call(this, e);
            }
        }, {
            key: "addCommandBuffer",
            value: function(e, t) {
                switch (e) {
                case Camera.CAMERAEVENT_POSTPROCESS:
                    this._postProcessCommandBuffers.push(t),
                    t._camera = this;
                    break;
                default:
                    throw "Camera:unknown event.";
                }
            }
        }, {
            key: "removeCommandBuffer",
            value: function(e, t) {
                switch (e) {
                case Camera.CAMERAEVENT_POSTPROCESS:
                    var r = this._postProcessCommandBuffers.indexOf(t);
                    -1 !== r && this._postProcessCommandBuffers.splice(r, 1);
                    break;
                default:
                    throw "Camera:unknown event.";
                }
            }
        }, {
            key: "removeCommandBuffers",
            value: function(e) {
                switch (e) {
                case Camera.CAMERAEVENT_POSTPROCESS:
                    this._postProcessCommandBuffers.length = 0;
                    break;
                default:
                    throw "Camera:unknown event.";
                }
            }
        }, {
            key: "_create",
            value: function() {
                return new Camera();
            }
        }, {
            key: "aspectRatio",
            get: function() {
                if (0 === this._aspectRatio) {
                    var e = this.viewport;
                    return e.width / e.height;
                }
                return this._aspectRatio;
            },
            set: function(e) {
                if (e < 0)
                    throw new Error("Camera: the aspect ratio has to be a positive real number.");
                this._aspectRatio = e,
                this._calculateProjectionMatrix();
            }
        }, {
            key: "viewport",
            get: function() {
                return this._offScreenRenderTexture ? this._calculationViewport(this._normalizedViewport, this._offScreenRenderTexture.width, this._offScreenRenderTexture.height) : this._calculationViewport(this._normalizedViewport, k.clientWidth, k.clientHeight),
                this._viewport;
            },
            set: function(e) {
                var t, r;
                this._offScreenRenderTexture ? (t = this._offScreenRenderTexture.width,
                r = this._offScreenRenderTexture.height) : (t = k.clientWidth,
                r = k.clientHeight),
                this._normalizedViewport.x = e.x / t,
                this._normalizedViewport.y = e.y / r,
                this._normalizedViewport.width = e.width / t,
                this._normalizedViewport.height = e.height / r,
                this._calculationViewport(this._normalizedViewport, t, r),
                this._calculateProjectionMatrix();
            }
        }, {
            key: "normalizedViewport",
            get: function() {
                return this._normalizedViewport;
            },
            set: function(e) {
                var t, r;
                this._offScreenRenderTexture ? (t = this._offScreenRenderTexture.width,
                r = this._offScreenRenderTexture.height) : (t = k.clientWidth,
                r = k.clientHeight),
                this._normalizedViewport !== e && e.cloneTo(this._normalizedViewport),
                this._calculationViewport(e, t, r),
                this._calculateProjectionMatrix();
            }
        }, {
            key: "viewMatrix",
            get: function() {
                if (this._updateViewMatrix) {
                    var e = this.transform.getWorldLossyScale()
                      , t = e.x
                      , r = e.y
                      , n = e.z
                      , i = this._viewMatrix.elements;
                    this.transform.worldMatrix.cloneTo(this._viewMatrix),
                    i[0] /= t,
                    i[1] /= t,
                    i[2] /= t,
                    i[4] /= r,
                    i[5] /= r,
                    i[6] /= r,
                    i[8] /= n,
                    i[9] /= n,
                    i[10] /= n,
                    this._viewMatrix.invert(this._viewMatrix),
                    this._updateViewMatrix = !1;
                }
                return this._viewMatrix;
            }
        }, {
            key: "projectionMatrix",
            get: function() {
                return this._projectionMatrix;
            },
            set: function(e) {
                this._projectionMatrix = e,
                this._useUserProjectionMatrix = !0;
            }
        }, {
            key: "projectionViewMatrix",
            get: function() {
                return I.multiply(this.projectionMatrix, this.viewMatrix, this._projectionViewMatrix),
                this._projectionViewMatrix;
            }
        }, {
            key: "boundFrustum",
            get: function() {
                if (this._boundFrustum.matrix = this.projectionViewMatrix,
                t.Render.supportWebGLPlusCulling) {
                    var e = this._boundFrustum.near
                      , r = this._boundFrustum.far
                      , n = this._boundFrustum.left
                      , i = this._boundFrustum.right
                      , a = this._boundFrustum.top
                      , o = this._boundFrustum.bottom
                      , s = e.normal
                      , l = r.normal
                      , u = n.normal
                      , c = i.normal
                      , h = a.normal
                      , _ = o.normal
                      , d = this._boundFrustumBuffer;
                    d[0] = s.x,
                    d[1] = s.y,
                    d[2] = s.z,
                    d[3] = e.distance,
                    d[4] = l.x,
                    d[5] = l.y,
                    d[6] = l.z,
                    d[7] = r.distance,
                    d[8] = u.x,
                    d[9] = u.y,
                    d[10] = u.z,
                    d[11] = n.distance,
                    d[12] = c.x,
                    d[13] = c.y,
                    d[14] = c.z,
                    d[15] = i.distance,
                    d[16] = h.x,
                    d[17] = h.y,
                    d[18] = h.z,
                    d[19] = a.distance,
                    d[20] = _.x,
                    d[21] = _.y,
                    d[22] = _.z,
                    d[23] = o.distance;
                }
                return this._boundFrustum;
            }
        }, {
            key: "renderTarget",
            get: function() {
                return this._offScreenRenderTexture;
            },
            set: function(e) {
                var t = this._offScreenRenderTexture;
                t !== e && (t && (t._isCameraTarget = !1),
                e && (e._isCameraTarget = !0),
                this._offScreenRenderTexture = e,
                this._calculateProjectionMatrix());
            }
        }, {
            key: "postProcess",
            get: function() {
                return this._postProcess;
            },
            set: function(e) {
                this._postProcess = e;
                var t = new Ke();
                this.addCommandBuffer(Camera.CAMERAEVENT_POSTPROCESS, t),
                e._init(this, t);
            }
        }, {
            key: "enableHDR",
            get: function() {
                return this._enableHDR;
            },
            set: function(e) {
                !e || t.SystemUtils.supportRenderTextureFormat(t.RenderTextureFormat.R16G16B16A16) ? this._enableHDR = e : console.warn("Camera:can't enable HDR in this device.");
            }
        }]),
        Camera;
    }();
    $e.CAMERAEVENT_POSTPROCESS = 0,
    $e._tempVector20 = new n(),
    $e._updateMark = 0;
    var et = function() {
        function RenderElement() {
            _classCallCheck(this, RenderElement),
            this.renderSubShader = null,
            this.renderType = RenderElement.RENDERTYPE_NORMAL;
        }
        return _createClass(RenderElement, [{
            key: "getInvertFront",
            value: function() {
                return this._transform._isFrontFaceInvert;
            }
        }, {
            key: "setTransform",
            value: function(e) {
                this._transform = e;
            }
        }, {
            key: "setGeometry",
            value: function(e) {
                this._geometry = e;
            }
        }, {
            key: "addToOpaqueRenderQueue",
            value: function(e, t) {
                t.elements.add(this);
            }
        }, {
            key: "addToTransparentRenderQueue",
            value: function(e, t) {
                t.elements.add(this),
                t.lastTransparentBatched = !1,
                t.lastTransparentRenderElement = this;
            }
        }, {
            key: "_update",
            value: function(e, t, r, n) {
                if (this.material) {
                    var i = this.material._shader.getSubShaderAt(0);
                    if (this.renderSubShader = null,
                    r)
                        if (n) {
                            var a = i.getFlag(n);
                            if (!a)
                                return;
                            for (var o = r._subShaders, s = 0, l = o.length; s < l; s++) {
                                var u = o[s];
                                if (a === u.getFlag(n)) {
                                    this.renderSubShader = u;
                                    break;
                                }
                            }
                            if (!this.renderSubShader)
                                return;
                        } else
                            this.renderSubShader = r.getSubShaderAt(0);
                    else
                        this.renderSubShader = i;
                    var c = e._getRenderQueue(this.material.renderQueue);
                    c.isTransparent ? this.addToTransparentRenderQueue(t, c) : this.addToOpaqueRenderQueue(t, c);
                }
            }
        }, {
            key: "_render",
            value: function(e) {
                var t, r, n, i = e.invertY, a = $e._updateMark, o = e.scene, s = e.camera, l = this._transform, u = this._geometry;
                e.renderElement = this;
                var c = a !== this.render._updateMark || this.renderType !== this.render._updateRenderType;
                if (c ? (this.render._renderUpdate(e, l),
                this.render._renderUpdateWithCamera(e, l),
                this.render._updateMark = a,
                this.render._updateRenderType = this.renderType) : this.renderType == RenderElement.RENDERTYPE_INSTANCEBATCH && (this.render._renderUpdate(e, l),
                this.render._renderUpdateWithCamera(e, l)),
                u._prepareRender(e))
                    for (var h = this.renderSubShader._passes, _ = 0, d = h.length; _ < d; _++) {
                        var f = RenderElement._compileDefine;
                        o._shaderValues._defineDatas.cloneTo(f),
                        f.addDefineDatas(this.render._shaderValues._defineDatas),
                        f.addDefineDatas(this.material._shaderValues._defineDatas);
                        var m = e.shader = h[_].withCompile(f)
                          , p = m.bind()
                          , v = a !== m._uploadMark
                          , T = m._uploadScene !== o || v;
                        (T || p) && (m.uploadUniforms(m._sceneUniformParamsMap, o._shaderValues, T),
                        m._uploadScene = o);
                        var E = m._uploadRender !== this.render || m._uploadRenderType !== this.renderType || v;
                        (E || p) && (m.uploadUniforms(m._spriteUniformParamsMap, this.render._shaderValues, E),
                        m._uploadRender = this.render,
                        m._uploadRenderType = this.renderType);
                        var y = m._uploadCamera !== s || v;
                        (y || p) && (m.uploadUniforms(m._cameraUniformParamsMap, s._shaderValues, y),
                        m._uploadCamera = s);
                        var g = m._uploadMaterial !== this.material || v;
                        (g || p) && (m.uploadUniforms(m._materialUniformParamsMap, this.material._shaderValues, g),
                        m._uploadMaterial = this.material);
                        var S = this.material._shaderValues;
                        t !== this.material || r !== m ? (m.uploadRenderStateBlendDepth(S),
                        m.uploadRenderStateFrontFace(S, i, this.getInvertFront()),
                        t = this.material,
                        r = m,
                        n = this.render) : n !== this.render && (m.uploadRenderStateFrontFace(S, i, this.getInvertFront()),
                        n = this.render),
                        u._render(e),
                        m._uploadMark = a;
                    }
                c && this.renderType !== RenderElement.RENDERTYPE_NORMAL && this.render._revertBatchRenderUpdate(e);
            }
        }, {
            key: "destroy",
            value: function() {
                this._transform = null,
                this._geometry = null,
                this.material = null,
                this.render = null;
            }
        }]),
        RenderElement;
    }();
    et.RENDERTYPE_NORMAL = 0,
    et.RENDERTYPE_STATICBATCH = 1,
    et.RENDERTYPE_INSTANCEBATCH = 2,
    et.RENDERTYPE_VERTEXBATCH = 3,
    et._compileDefine = new B();
    var tt = function(e) {
        function SubMeshRenderElement() {
            var e;
            return _classCallCheck(this, SubMeshRenderElement),
            (e = _possibleConstructorReturn(this, _getPrototypeOf(SubMeshRenderElement).call(this)))._dynamicWorldPositionNormalNeedUpdate = !0,
            e;
        }
        return _inherits(SubMeshRenderElement, et),
        _createClass(SubMeshRenderElement, [{
            key: "_onWorldMatrixChanged",
            value: function() {
                this._dynamicWorldPositionNormalNeedUpdate = !0;
            }
        }, {
            key: "_computeWorldPositionsAndNormals",
            value: function(e, t, r, n) {
                if (this._dynamicWorldPositionNormalNeedUpdate) {
                    for (var i = this._geometry, a = i._vertexBuffer, o = a.vertexDeclaration.vertexStride / 4, s = a.getFloat32Data(), l = this._transform.worldMatrix, u = this._transform.rotation, c = i._indices, h = 0; h < n; h++) {
                        var _ = (r ? c[h] : h) * o
                          , d = 3 * h;
                        R.transformVector3ArrayToVector3ArrayCoordinate(s, _ + e, l, this._dynamicWorldPositions, d),
                        -1 !== t && R.transformVector3ArrayByQuat(s, _ + t, u, this._dynamicWorldNormals, d);
                    }
                    this._dynamicWorldPositionNormalNeedUpdate = !1;
                }
            }
        }, {
            key: "setTransform",
            value: function(e) {
                this._transform !== e && (this._transform && this._transform.off(t.Event.TRANSFORM_CHANGED, this, this._onWorldMatrixChanged),
                e && e.on(t.Event.TRANSFORM_CHANGED, this, this._onWorldMatrixChanged),
                this._dynamicWorldPositionNormalNeedUpdate = !0,
                this._transform = e);
            }
        }, {
            key: "setGeometry",
            value: function(e) {
                if (this._geometry !== e) {
                    var t = e
                      , r = t._mesh;
                    if (r) {
                        var n = r._subMeshes.length > 1
                          , i = n ? t._indexCount : r._vertexCount;
                        if (i <= l.SubMeshDynamicBatch.maxAllowVertexCount) {
                            var a = 3 * i;
                            this._dynamicVertexBatch = !0,
                            this._dynamicWorldPositions = new Float32Array(a),
                            this._dynamicWorldNormals = new Float32Array(a),
                            this._dynamicVertexCount = i,
                            this._dynamicMultiSubMesh = n;
                        } else
                            this._dynamicVertexBatch = !1;
                    }
                    this._geometry = e;
                }
            }
        }, {
            key: "addToOpaqueRenderQueue",
            value: function(e, r) {
                var n = this.staticBatch
                  , i = r.elements
                  , a = i.elements;
                if (n) {
                    var o = l.MeshRenderStaticBatchManager.instance
                      , s = o.getBatchOpaquaMark(this.render.lightmapIndex + 1, this.render.receiveShadow, this.material.id, n._batchID);
                    if (o._updateCountMark === s.updateMark) {
                        var u = s.indexInList;
                        if (s.batched)
                            a[u].staticBatchElementList.add(this);
                        else {
                            var c = a[u]
                              , h = c.render
                              , _ = o._getBatchRenderElementFromPool();
                            _.renderType = et.RENDERTYPE_STATICBATCH,
                            _.setGeometry(n),
                            _.material = c.material;
                            var d = n.batchOwner
                              , f = d ? d._transform : null;
                            _.setTransform(f),
                            _.render = h,
                            _.renderSubShader = c.renderSubShader;
                            var m = _.staticBatchElementList;
                            m.length = 0,
                            m.add(c),
                            m.add(this),
                            a[u] = _,
                            s.batched = !0;
                        }
                    } else
                        s.updateMark = o._updateCountMark,
                        s.indexInList = i.length,
                        s.batched = !1,
                        i.add(this);
                } else if (this.renderSubShader._owner._enableInstancing && t.LayaGL.layaGPUInstance.supportInstance() && this.render.lightmapIndex < 0) {
                    var p = this._geometry
                      , v = l.MeshRenderDynamicBatchManager.instance
                      , T = v.getInstanceBatchOpaquaMark(this.render.receiveShadow, this.material.id, p._id, this._transform._isFrontFaceInvert);
                    if (v._updateCountMark === T.updateMark) {
                        var E = T.indexInList;
                        if (T.batched) {
                            var y = a[E].instanceBatchElementList;
                            y.length === xe.instance.maxInstanceCount ? (T.updateMark = v._updateCountMark,
                            T.indexInList = i.length,
                            T.batched = !1,
                            i.add(this)) : y.add(this);
                        } else {
                            var g = a[E]
                              , S = g.render
                              , R = v._getBatchRenderElementFromPool();
                            R.renderType = et.RENDERTYPE_INSTANCEBATCH,
                            R.setGeometry(xe.instance),
                            R.material = g.material,
                            R.setTransform(null),
                            R.render = S,
                            R.instanceSubMesh = p,
                            R.renderSubShader = g.renderSubShader;
                            var C = R.instanceBatchElementList;
                            C.length = 0,
                            C.add(g),
                            C.add(this),
                            a[E] = R,
                            T.batched = !0;
                        }
                    } else
                        T.updateMark = v._updateCountMark,
                        T.indexInList = i.length,
                        T.batched = !1,
                        i.add(this);
                } else if (this._dynamicVertexBatch) {
                    var M = this._geometry._vertexBuffer.vertexDeclaration
                      , D = l.MeshRenderDynamicBatchManager.instance
                      , x = D.getVertexBatchOpaquaMark(this.render.lightmapIndex + 1, this.render.receiveShadow, this.material.id, M.id);
                    if (D._updateCountMark === x.updateMark) {
                        var A = x.indexInList;
                        if (x.batched)
                            a[A].vertexBatchElementList.add(this);
                        else {
                            var I = a[A]
                              , L = I.render
                              , P = D._getBatchRenderElementFromPool();
                            P.renderType = et.RENDERTYPE_VERTEXBATCH,
                            P.setGeometry(l.SubMeshDynamicBatch.instance),
                            P.material = I.material,
                            P.setTransform(null),
                            P.render = L,
                            P.vertexBatchVertexDeclaration = M,
                            P.renderSubShader = I.renderSubShader;
                            var O = P.vertexBatchElementList;
                            O.length = 0,
                            O.add(I),
                            O.add(this),
                            a[A] = P,
                            x.batched = !0;
                        }
                    } else
                        x.updateMark = D._updateCountMark,
                        x.indexInList = i.length,
                        x.batched = !1,
                        i.add(this);
                } else
                    i.add(this);
            }
        }, {
            key: "addToTransparentRenderQueue",
            value: function(e, r) {
                var n = this.staticBatch
                  , i = r.elements
                  , a = i.elements;
                if (n) {
                    var o = l.MeshRenderStaticBatchManager.instance
                      , s = r.lastTransparentRenderElement;
                    if (s) {
                        var u = s.render;
                        if (s._geometry._getType() !== this._geometry._getType() || s.staticBatch !== n || s.material !== this.material || u.receiveShadow !== this.render.receiveShadow || u.lightmapIndex !== this.render.lightmapIndex)
                            i.add(this),
                            r.lastTransparentBatched = !1;
                        else {
                            if (r.lastTransparentBatched)
                                a[i.length - 1].staticBatchElementList.add(this);
                            else {
                                var c = o._getBatchRenderElementFromPool();
                                c.renderType = et.RENDERTYPE_STATICBATCH,
                                c.setGeometry(n),
                                c.material = s.material;
                                var h = n.batchOwner
                                  , _ = h ? h._transform : null;
                                c.setTransform(_),
                                c.render = this.render,
                                c.renderSubShader = s.renderSubShader;
                                var d = c.staticBatchElementList;
                                d.length = 0,
                                d.add(s),
                                d.add(this),
                                a[i.length - 1] = c;
                            }
                            r.lastTransparentBatched = !0;
                        }
                    } else
                        i.add(this),
                        r.lastTransparentBatched = !1;
                } else if (this.renderSubShader._owner._enableInstancing && t.LayaGL.layaGPUInstance.supportInstance() && this.render.lightmapIndex < 0) {
                    var f = this._geometry
                      , m = l.MeshRenderDynamicBatchManager.instance
                      , p = r.lastTransparentRenderElement;
                    if (p) {
                        var v = p.render;
                        if (p._geometry._getType() !== this._geometry._getType() || p._geometry !== f || p.material !== this.material || v.receiveShadow !== this.render.receiveShadow)
                            i.add(this),
                            r.lastTransparentBatched = !1;
                        else if (r.lastTransparentBatched) {
                            var T = a[i.length - 1].instanceBatchElementList;
                            T.length === xe.instance.maxInstanceCount ? (i.add(this),
                            r.lastTransparentBatched = !1) : (T.add(this),
                            r.lastTransparentBatched = !0);
                        } else {
                            var E = m._getBatchRenderElementFromPool();
                            E.renderType = et.RENDERTYPE_INSTANCEBATCH,
                            E.setGeometry(xe.instance),
                            E.material = p.material,
                            E.setTransform(null),
                            E.render = this.render,
                            E.instanceSubMesh = f,
                            E.renderSubShader = p.renderSubShader;
                            var y = E.instanceBatchElementList;
                            y.length = 0,
                            y.add(p),
                            y.add(this),
                            a[i.length - 1] = E,
                            r.lastTransparentBatched = !0;
                        }
                    } else
                        i.add(this),
                        r.lastTransparentBatched = !1;
                } else if (this._dynamicVertexBatch) {
                    var g = this._geometry._vertexBuffer.vertexDeclaration
                      , S = l.MeshRenderDynamicBatchManager.instance
                      , R = r.lastTransparentRenderElement;
                    if (R) {
                        var C = R.render;
                        if (R._geometry._getType() !== this._geometry._getType() || R._geometry._vertexBuffer._vertexDeclaration !== g || R.material !== this.material || C.receiveShadow !== this.render.receiveShadow || C.lightmapIndex !== this.render.lightmapIndex)
                            i.add(this),
                            r.lastTransparentBatched = !1;
                        else {
                            if (r.lastTransparentBatched)
                                a[i.length - 1].vertexBatchElementList.add(this);
                            else {
                                var M = S._getBatchRenderElementFromPool();
                                M.renderType = et.RENDERTYPE_VERTEXBATCH,
                                M.setGeometry(l.SubMeshDynamicBatch.instance),
                                M.material = R.material,
                                M.setTransform(null),
                                M.render = this.render,
                                M.vertexBatchVertexDeclaration = g,
                                M.renderSubShader = R.renderSubShader;
                                var D = M.vertexBatchElementList;
                                D.length = 0,
                                D.add(R),
                                D.add(this),
                                a[i.length - 1] = M;
                            }
                            r.lastTransparentBatched = !0;
                        }
                    } else
                        i.add(this),
                        r.lastTransparentBatched = !1;
                } else
                    i.add(this);
                r.lastTransparentRenderElement = this;
            }
        }, {
            key: "getInvertFront",
            value: function() {
                switch (this.renderType) {
                case et.RENDERTYPE_NORMAL:
                    return this._transform._isFrontFaceInvert;
                case et.RENDERTYPE_STATICBATCH:
                case et.RENDERTYPE_VERTEXBATCH:
                    return !1;
                case et.RENDERTYPE_INSTANCEBATCH:
                    return this.instanceBatchElementList.elements[0]._transform._isFrontFaceInvert;
                default:
                    throw "SubMeshRenderElement: unknown renderType";
                }
            }
        }, {
            key: "destroy",
            value: function() {
                _get(_getPrototypeOf(SubMeshRenderElement.prototype), "destroy", this).call(this),
                this._dynamicWorldPositions = null,
                this._dynamicWorldNormals = null,
                this.staticBatch = null,
                this.staticBatchElementList = null,
                this.vertexBatchElementList = null,
                this.vertexBatchVertexDeclaration = null;
            }
        }]),
        SubMeshRenderElement;
    }()
      , rt = function(r) {
        function SubMeshStaticBatch(e, t) {
            var r;
            return _classCallCheck(this, SubMeshStaticBatch),
            (r = _possibleConstructorReturn(this, _getPrototypeOf(SubMeshStaticBatch).call(this)))._bufferState = new we(),
            r._batchID = SubMeshStaticBatch._batchIDCounter++,
            r._batchElements = [],
            r._currentBatchVertexCount = 0,
            r._currentBatchIndexCount = 0,
            r._vertexDeclaration = t,
            r.batchOwner = e,
            r;
        }
        return _inherits(SubMeshStaticBatch, Me),
        _createClass(SubMeshStaticBatch, [{
            key: "_getStaticBatchBakedVertexs",
            value: function(e, t, r, n, i, a) {
                var o, s = a._vertexBuffer, l = s.vertexDeclaration, u = l.getVertexElementByUsage(ue.MESH_POSITION0)._offset / 4, c = l.getVertexElementByUsage(ue.MESH_NORMAL0), h = c ? c._offset / 4 : -1, _ = l.getVertexElementByUsage(ue.MESH_COLOR0), d = _ ? _._offset / 4 : -1, f = l.getVertexElementByUsage(ue.MESH_TEXTURECOORDINATE0), m = f ? f._offset / 4 : -1, p = l.getVertexElementByUsage(ue.MESH_TEXTURECOORDINATE1), v = p ? p._offset / 4 : -1, T = l.getVertexElementByUsage(ue.MESH_TANGENT0), E = T ? T._offset / 4 : -1, y = l.vertexStride / 4, g = s.getFloat32Data();
                r ? (r.worldMatrix.invert(SubMeshStaticBatch._tempMatrix4x40),
                o = SubMeshStaticBatch._tempMatrix4x41,
                I.multiply(SubMeshStaticBatch._tempMatrix4x40, n.worldMatrix, o)) : o = n.worldMatrix;
                var S = SubMeshStaticBatch._tempMatrix4x42;
                o.invert(S),
                S.transpose();
                var C = SubMeshStaticBatch._tempQuaternion0;
                o.decomposeTransRotScale(SubMeshStaticBatch._tempVector30, C, SubMeshStaticBatch._tempVector31);
                for (var M = i.lightmapScaleOffset, D = a.vertexCount, x = 0; x < D; x++) {
                    var A, L, P = x * y, O = 18 * (x + t);
                    R.transformVector3ArrayToVector3ArrayCoordinate(g, P + u, o, e, O + 0),
                    -1 !== h && R.transformVector3ArrayToVector3ArrayNormal(g, P + h, S, e, O + 3);
                    var N = O + 6;
                    if (-1 !== d) {
                        var b = P + d;
                        for (A = 0,
                        L = 4; A < L; A++)
                            e[N + A] = g[b + A];
                    } else
                        for (A = 0,
                        L = 4; A < L; A++)
                            e[N + A] = 1;
                    if (-1 !== m) {
                        var k = P + m;
                        e[O + 10] = g[k],
                        e[O + 11] = g[k + 1];
                    }
                    if (M && (-1 !== v ? R.transformLightingMapTexcoordArray(g, P + v, M, e, O + 12) : R.transformLightingMapTexcoordArray(g, P + m, M, e, O + 12)),
                    -1 !== E) {
                        var V = P + E;
                        e[O + 14] = g[V],
                        e[O + 15] = g[V + 1],
                        e[O + 16] = g[V + 2],
                        e[O + 17] = g[V + 3];
                    }
                }
                return D;
            }
        }, {
            key: "addTest",
            value: function(e) {
                var t = e.meshFilter.sharedMesh.vertexCount;
                return !(this._currentBatchVertexCount + t > SubMeshStaticBatch.maxBatchVertexCount);
            }
        }, {
            key: "add",
            value: function(e) {
                var t = e.meshFilter.sharedMesh
                  , r = t.vertexCount;
                this._batchElements.push(e);
                var n = e._render;
                n._isPartOfStaticBatch = !0,
                n._staticBatch = this;
                for (var i = n._renderElements, a = 0, o = i.length; a < o; a++)
                    i[a].staticBatch = this;
                this._currentBatchIndexCount += t._indexBuffer.indexCount,
                this._currentBatchVertexCount += r;
            }
        }, {
            key: "remove",
            value: function(e) {
                var t = e.meshFilter.sharedMesh
                  , r = this._batchElements.indexOf(e);
                if (-1 !== r) {
                    this._batchElements.splice(r, 1);
                    for (var n = e._render._renderElements, i = 0, a = n.length; i < a; i++)
                        n[i].staticBatch = null;
                    this._currentBatchIndexCount = this._currentBatchIndexCount - t._indexBuffer.indexCount,
                    this._currentBatchVertexCount = this._currentBatchVertexCount - t.vertexCount,
                    e._render._isPartOfStaticBatch = !1;
                }
            }
        }, {
            key: "finishInit",
            value: function() {
                this._vertexBuffer && (this._vertexBuffer.destroy(),
                this._indexBuffer.destroy(),
                t.Resource._addGPUMemory(-(this._vertexBuffer._byteLength + this._indexBuffer._byteLength)));
                var r = t.LayaGL.instance
                  , n = 0
                  , i = 0
                  , a = this.batchOwner
                  , o = this._vertexDeclaration.vertexStride / 4
                  , s = new Float32Array(o * this._currentBatchVertexCount)
                  , l = new Uint16Array(this._currentBatchIndexCount);
                this._vertexBuffer = new De(this._vertexDeclaration.vertexStride * this._currentBatchVertexCount,r.STATIC_DRAW),
                this._vertexBuffer.vertexDeclaration = this._vertexDeclaration,
                this._indexBuffer = new Fe(e.IndexFormat.UInt16,this._currentBatchIndexCount,r.STATIC_DRAW);
                for (var u = 0, c = this._batchElements.length; u < c; u++) {
                    for (var h, _ = this._batchElements[u], d = _.meshFilter.sharedMesh, f = this._getStaticBatchBakedVertexs(s, n, a ? a._transform : null, _._transform, _._render, d), m = d._indexBuffer.getData(), p = n, v = i + m.length, T = _._render._renderElements, E = 0, y = d.subMeshCount; E < y; E++) {
                        var g = d._subMeshes[E]
                          , S = i + g._indexStart
                          , R = T[E];
                        R.staticBatchIndexStart = S,
                        R.staticBatchIndexEnd = S + g._indexCount;
                    }
                    if (l.set(m, i),
                    a ? _._transform._isFrontFaceInvert !== a.transform._isFrontFaceInvert : _._transform._isFrontFaceInvert)
                        for (h = i; h < v; h += 3) {
                            l[h] = p + l[h];
                            var C = l[h + 1]
                              , M = l[h + 2];
                            l[h + 1] = p + M,
                            l[h + 2] = p + C;
                        }
                    else
                        for (h = i; h < v; h += 3)
                            l[h] = p + l[h],
                            l[h + 1] = p + l[h + 1],
                            l[h + 2] = p + l[h + 2];
                    i += m.length,
                    n += f;
                }
                this._vertexBuffer.setData(s.buffer),
                this._indexBuffer.setData(l);
                var D = this._vertexBuffer._byteLength + this._indexBuffer._byteLength;
                t.Resource._addGPUMemory(D),
                this._bufferState.bind(),
                this._bufferState.applyVertexBuffer(this._vertexBuffer),
                this._bufferState.applyIndexBuffer(this._indexBuffer),
                this._bufferState.unBind();
            }
        }, {
            key: "_render",
            value: function(e) {
                this._bufferState.bind();
                for (var r = t.LayaGL.instance, n = e.renderElement.staticBatchElementList, i = n.elements, a = 0, o = 0, s = n.length, l = 1; l < s; l++) {
                    if (i[l - 1].staticBatchIndexEnd !== i[l].staticBatchIndexStart) {
                        var u = i[a].staticBatchIndexStart
                          , c = i[o].staticBatchIndexEnd - u;
                        r.drawElements(r.TRIANGLES, c, r.UNSIGNED_SHORT, 2 * u),
                        a = ++o,
                        t.Stat.trianglesFaces += c / 3;
                    } else
                        o++;
                }
                u = i[a].staticBatchIndexStart,
                c = i[o].staticBatchIndexEnd - u,
                r.drawElements(r.TRIANGLES, c, r.UNSIGNED_SHORT, 2 * u),
                t.Stat.renderBatches++,
                t.Stat.savedRenderBatches += s - 1,
                t.Stat.trianglesFaces += c / 3;
            }
        }, {
            key: "dispose",
            value: function() {
                var e = this._vertexBuffer._byteLength + this._indexBuffer._byteLength;
                t.Resource._addGPUMemory(-e),
                this._batchElements = null,
                this.batchOwner = null,
                this._vertexDeclaration = null,
                this._bufferState.destroy(),
                this._vertexBuffer.destroy(),
                this._indexBuffer.destroy(),
                this._vertexBuffer = null,
                this._indexBuffer = null,
                this._bufferState = null;
            }
        }]),
        SubMeshStaticBatch;
    }();
    rt._tempVector30 = new o(),
    rt._tempVector31 = new o(),
    rt._tempQuaternion0 = new f(),
    rt._tempMatrix4x40 = new I(),
    rt._tempMatrix4x41 = new I(),
    rt._tempMatrix4x42 = new I(),
    rt.maxBatchVertexCount = 65535,
    rt._batchIDCounter = 0;
    var nt = function() {
        function SingletonList() {
            _classCallCheck(this, SingletonList),
            this.elements = [],
            this.length = 0;
        }
        return _createClass(SingletonList, [{
            key: "_add",
            value: function(e) {
                this.length === this.elements.length ? this.elements.push(e) : this.elements[this.length] = e;
            }
        }, {
            key: "add",
            value: function(e) {
                this.length === this.elements.length ? this.elements.push(e) : this.elements[this.length] = e,
                this.length++;
            }
        }]),
        SingletonList;
    }()
      , it = function(e) {
        function MeshRenderStaticBatchManager() {
            var e;
            return _classCallCheck(this, MeshRenderStaticBatchManager),
            (e = _possibleConstructorReturn(this, _getPrototypeOf(MeshRenderStaticBatchManager).call(this)))._opaqueBatchMarks = [],
            e._updateCountMark = 0,
            e;
        }
        return _inherits(MeshRenderStaticBatchManager, Se),
        _createClass(MeshRenderStaticBatchManager, [{
            key: "_compare",
            value: function(e, t) {
                var r = e._render
                  , n = t._render
                  , i = e.meshFilter.sharedMesh
                  , a = t.meshFilter.sharedMesh
                  , o = r.lightmapIndex - n.lightmapIndex;
                if (0 === o) {
                    var s = (r.receiveShadow ? 1 : 0) - (n.receiveShadow ? 1 : 0);
                    if (0 === s) {
                        var l = r.sharedMaterial && n.sharedMaterial ? r.sharedMaterial.id - n.sharedMaterial.id : 0;
                        if (0 === l) {
                            var u = i._vertexBuffer.vertexDeclaration.id - a._vertexBuffer.vertexDeclaration.id;
                            return 0 === u ? a._indexBuffer.indexCount - i._indexBuffer.indexCount : u;
                        }
                        return l;
                    }
                    return s;
                }
                return o;
            }
        }, {
            key: "_getBatchRenderElementFromPool",
            value: function() {
                var e = this._batchRenderElementPool[this._batchRenderElementPoolIndex++];
                return e || (e = new tt(),
                this._batchRenderElementPool[this._batchRenderElementPoolIndex - 1] = e,
                e.staticBatchElementList = new nt()),
                e;
            }
        }, {
            key: "_getStaticBatch",
            value: function(e, t, r) {
                var n = e[r];
                return n || (n = e[r] = new rt(t,MeshRenderStaticBatchManager._verDec),
                this._staticBatches[n._batchID] = n),
                n;
            }
        }, {
            key: "_initStaticBatchs",
            value: function(e) {
                var t = this._initBatchSprites;
                this._quickSort(t, 0, t.length - 1);
                for (var r, n = [], i = !1, a = 0, o = 0, s = t.length; o < s; o++) {
                    var l = t[o];
                    if (i)
                        r.addTest(l) ? r.add(l) : (i = !1,
                        a++);
                    else
                        o !== s - 1 && ((r = this._getStaticBatch(n, e, a)).add(l),
                        i = !0);
                }
                for (o = 0,
                s = n.length; o < s; o++) {
                    var u = n[o];
                    u && u.finishInit();
                }
                this._initBatchSprites.length = 0;
            }
        }, {
            key: "_removeRenderSprite",
            value: function(e) {
                var t = e._render
                  , r = t._staticBatch
                  , n = r._batchElements
                  , i = n.indexOf(e);
                if (-1 !== i) {
                    n.splice(i, 1),
                    t._staticBatch = null;
                    for (var a = t._renderElements, o = 0, s = a.length; o < s; o++)
                        a[o].staticBatch = null;
                }
                0 === n.length && (delete this._staticBatches[r._batchID],
                r.dispose());
            }
        }, {
            key: "_clear",
            value: function() {
                _get(_getPrototypeOf(MeshRenderStaticBatchManager.prototype), "_clear", this).call(this),
                this._updateCountMark++;
            }
        }, {
            key: "_garbageCollection",
            value: function() {
                for (var e in this._staticBatches) {
                    var t = this._staticBatches[e];
                    0 === t._batchElements.length && (t.dispose(),
                    delete this._staticBatches[e]);
                }
            }
        }, {
            key: "getBatchOpaquaMark",
            value: function(e, t, r, n) {
                var i = t ? 1 : 0
                  , a = this._opaqueBatchMarks[e] || (this._opaqueBatchMarks[e] = [])
                  , o = a[i] || (a[i] = [])
                  , s = o[r] || (o[r] = []);
                return s[n] || (s[n] = new Ce());
            }
        }], [{
            key: "__init__",
            value: function() {
                MeshRenderStaticBatchManager._verDec = ue.getVertexDeclaration("POSITION,NORMAL,COLOR,UV,UV1,TANGENT");
            }
        }]),
        MeshRenderStaticBatchManager;
    }();
    it.instance = new it();
    var at = function MeshSprite3DShaderDeclaration() {
        _classCallCheck(this, MeshSprite3DShaderDeclaration);
    }
      , ot = function() {
        function BoundBox(e, t) {
            _classCallCheck(this, BoundBox),
            this.min = e,
            this.max = t;
        }
        return _createClass(BoundBox, [{
            key: "_rotateExtents",
            value: function(e, t, r) {
                var n = e.x
                  , i = e.y
                  , a = e.z
                  , o = t.elements;
                r.x = Math.abs(o[0] * n) + Math.abs(o[4] * i) + Math.abs(o[8] * a),
                r.y = Math.abs(o[1] * n) + Math.abs(o[5] * i) + Math.abs(o[9] * a),
                r.z = Math.abs(o[2] * n) + Math.abs(o[6] * i) + Math.abs(o[10] * a);
            }
        }, {
            key: "getCorners",
            value: function(e) {
                e.length = 8;
                var t = this.min.x
                  , r = this.min.y
                  , n = this.min.z
                  , i = this.max.x
                  , a = this.max.y
                  , s = this.max.z;
                e[0] = new o(t,a,s),
                e[1] = new o(i,a,s),
                e[2] = new o(i,r,s),
                e[3] = new o(t,r,s),
                e[4] = new o(t,a,n),
                e[5] = new o(i,a,n),
                e[6] = new o(i,r,n),
                e[7] = new o(t,r,n);
            }
        }, {
            key: "getCenter",
            value: function(e) {
                o.add(this.min, this.max, e),
                o.scale(e, .5, e);
            }
        }, {
            key: "getExtent",
            value: function(e) {
                o.subtract(this.max, this.min, e),
                o.scale(e, .5, e);
            }
        }, {
            key: "setCenterAndExtent",
            value: function(e, t) {
                o.subtract(e, t, this.min),
                o.add(e, t, this.max);
            }
        }, {
            key: "tranform",
            value: function(e, t) {
                var r = BoundBox._tempVector30
                  , n = BoundBox._tempVector31;
                this.getCenter(r),
                this.getExtent(n),
                o.transformCoordinate(r, e, r),
                this._rotateExtents(n, e, n),
                t.setCenterAndExtent(r, n);
            }
        }, {
            key: "toDefault",
            value: function() {
                this.min.toDefault(),
                this.max.toDefault();
            }
        }, {
            key: "cloneTo",
            value: function(e) {
                var t = e;
                this.min.cloneTo(t.min),
                this.max.cloneTo(t.max);
            }
        }, {
            key: "clone",
            value: function() {
                var e = new BoundBox(new o(),new o());
                return this.cloneTo(e),
                e;
            }
        }], [{
            key: "createfromPoints",
            value: function(e, t) {
                if (null == e)
                    throw new Error("points");
                var r = t.min
                  , n = t.max;
                r.x = Number.MAX_VALUE,
                r.y = Number.MAX_VALUE,
                r.z = Number.MAX_VALUE,
                n.x = -Number.MAX_VALUE,
                n.y = -Number.MAX_VALUE,
                n.z = -Number.MAX_VALUE;
                for (var i = 0, a = e.length; i < a; ++i)
                    o.min(r, e[i], r),
                    o.max(n, e[i], n);
            }
        }, {
            key: "merge",
            value: function(e, t, r) {
                o.min(e.min, t.min, r.min),
                o.max(e.max, t.max, r.max);
            }
        }]),
        BoundBox;
    }();
    ot._tempVector30 = new o(),
    ot._tempVector31 = new o();
    var st = function() {
        function Bounds(e, t) {
            _classCallCheck(this, Bounds),
            this._updateFlag = 0,
            this._center = new o(),
            this._extent = new o(),
            this._boundBox = new ot(new o(),new o()),
            e.cloneTo(this._boundBox.min),
            t.cloneTo(this._boundBox.max),
            this._setUpdateFlag(Bounds._UPDATE_CENTER | Bounds._UPDATE_EXTENT, !0);
        }
        return _createClass(Bounds, [{
            key: "setMin",
            value: function(e) {
                var t = this._boundBox.min;
                e !== t && e.cloneTo(t),
                this._setUpdateFlag(Bounds._UPDATE_CENTER | Bounds._UPDATE_EXTENT, !0),
                this._setUpdateFlag(Bounds._UPDATE_MIN, !1);
            }
        }, {
            key: "getMin",
            value: function() {
                var e = this._boundBox.min;
                return this._getUpdateFlag(Bounds._UPDATE_MIN) && (this._getMin(this.getCenter(), this.getExtent(), e),
                this._setUpdateFlag(Bounds._UPDATE_MIN, !1)),
                e;
            }
        }, {
            key: "setMax",
            value: function(e) {
                var t = this._boundBox.max;
                e !== t && e.cloneTo(t),
                this._setUpdateFlag(Bounds._UPDATE_CENTER | Bounds._UPDATE_EXTENT, !0),
                this._setUpdateFlag(Bounds._UPDATE_MAX, !1);
            }
        }, {
            key: "getMax",
            value: function() {
                var e = this._boundBox.max;
                return this._getUpdateFlag(Bounds._UPDATE_MAX) && (this._getMax(this.getCenter(), this.getExtent(), e),
                this._setUpdateFlag(Bounds._UPDATE_MAX, !1)),
                e;
            }
        }, {
            key: "setCenter",
            value: function(e) {
                e !== this._center && e.cloneTo(this._center),
                this._setUpdateFlag(Bounds._UPDATE_MIN | Bounds._UPDATE_MAX, !0),
                this._setUpdateFlag(Bounds._UPDATE_CENTER, !1);
            }
        }, {
            key: "getCenter",
            value: function() {
                return this._getUpdateFlag(Bounds._UPDATE_CENTER) && (this._getCenter(this.getMin(), this.getMax(), this._center),
                this._setUpdateFlag(Bounds._UPDATE_CENTER, !1)),
                this._center;
            }
        }, {
            key: "setExtent",
            value: function(e) {
                e !== this._extent && e.cloneTo(this._extent),
                this._setUpdateFlag(Bounds._UPDATE_MIN | Bounds._UPDATE_MAX, !0),
                this._setUpdateFlag(Bounds._UPDATE_EXTENT, !1);
            }
        }, {
            key: "getExtent",
            value: function() {
                return this._getUpdateFlag(Bounds._UPDATE_EXTENT) && (this._getExtent(this.getMin(), this.getMax(), this._extent),
                this._setUpdateFlag(Bounds._UPDATE_EXTENT, !1)),
                this._extent;
            }
        }, {
            key: "_getUpdateFlag",
            value: function(e) {
                return 0 != (this._updateFlag & e);
            }
        }, {
            key: "_setUpdateFlag",
            value: function(e, t) {
                t ? this._updateFlag |= e : this._updateFlag &= ~e;
            }
        }, {
            key: "_getCenter",
            value: function(e, t, r) {
                o.add(e, t, r),
                o.scale(r, .5, r);
            }
        }, {
            key: "_getExtent",
            value: function(e, t, r) {
                o.subtract(t, e, r),
                o.scale(r, .5, r);
            }
        }, {
            key: "_getMin",
            value: function(e, t, r) {
                o.subtract(e, t, r);
            }
        }, {
            key: "_getMax",
            value: function(e, t, r) {
                o.add(e, t, r);
            }
        }, {
            key: "_rotateExtents",
            value: function(e, t, r) {
                var n = e.x
                  , i = e.y
                  , a = e.z
                  , o = t.elements;
                r.x = Math.abs(o[0] * n) + Math.abs(o[4] * i) + Math.abs(o[8] * a),
                r.y = Math.abs(o[1] * n) + Math.abs(o[5] * i) + Math.abs(o[9] * a),
                r.z = Math.abs(o[2] * n) + Math.abs(o[6] * i) + Math.abs(o[10] * a);
            }
        }, {
            key: "_tranform",
            value: function(e, t) {
                var r = t._center
                  , n = t._extent;
                o.transformCoordinate(this.getCenter(), e, r),
                this._rotateExtents(this.getExtent(), e, n),
                t._boundBox.setCenterAndExtent(r, n),
                t._updateFlag = 0;
            }
        }, {
            key: "_getBoundBox",
            value: function() {
                if (this._updateFlag & Bounds._UPDATE_MIN) {
                    var e = this._boundBox.min;
                    this._getMin(this.getCenter(), this.getExtent(), e),
                    this._setUpdateFlag(Bounds._UPDATE_MIN, !1);
                }
                if (this._updateFlag & Bounds._UPDATE_MAX) {
                    var t = this._boundBox.max;
                    this._getMax(this.getCenter(), this.getExtent(), t),
                    this._setUpdateFlag(Bounds._UPDATE_MAX, !1);
                }
                return this._boundBox;
            }
        }, {
            key: "cloneTo",
            value: function(e) {
                var t = e;
                this.getMin().cloneTo(t._boundBox.min),
                this.getMax().cloneTo(t._boundBox.max),
                this.getCenter().cloneTo(t._center),
                this.getExtent().cloneTo(t._extent),
                t._updateFlag = 0;
            }
        }, {
            key: "clone",
            value: function() {
                var e = new Bounds(new o(),new o());
                return this.cloneTo(e),
                e;
            }
        }]),
        Bounds;
    }();
    st._UPDATE_MIN = 1,
    st._UPDATE_MAX = 2,
    st._UPDATE_CENTER = 4,
    st._UPDATE_EXTENT = 8;
    var lt = function(e) {
        function BaseRender(e) {
            var r;
            if (_classCallCheck(this, BaseRender),
            (r = _possibleConstructorReturn(this, _getPrototypeOf(BaseRender).call(this)))._lightmapScaleOffset = new i(1,1,0,0),
            r._indexInList = -1,
            r._indexInCastShadowList = -1,
            r._boundsChange = !0,
            r._castShadow = !1,
            r._supportOctree = !0,
            r._sharedMaterials = [],
            r._renderMark = -1,
            r._indexInOctreeMotionList = -1,
            r._updateMark = -1,
            r._updateRenderType = -1,
            r._isPartOfStaticBatch = !1,
            r._staticBatch = null,
            r._id = ++BaseRender._uniqueIDCounter,
            r._indexInCastShadowList = -1,
            r._bounds = new st(o._ZERO,o._ZERO),
            t.Render.supportWebGLPlusCulling) {
                var n = Re._cullingBufferLength;
                r._cullingBufferIndex = n;
                var a = Re._cullingBuffer
                  , s = n + 7;
                if (s >= a.length) {
                    var l = a;
                    (a = Re._cullingBuffer = new Float32Array(a.length + 4096)).set(l, 0);
                }
                a[n] = 2,
                Re._cullingBufferLength = s;
            }
            return r._renderElements = [],
            r._owner = e,
            r._enable = !0,
            r._materialsInstance = [],
            r._shaderValues = new z(null),
            r.lightmapIndex = -1,
            r.receiveShadow = !1,
            r.sortingFudge = 0,
            e && r._owner.transform.on(t.Event.TRANSFORM_CHANGED, _assertThisInitialized(r), r._onWorldMatNeedChange),
            r;
        }
        return _inherits(BaseRender, t.EventDispatcher),
        _createClass(BaseRender, [{
            key: "_getOctreeNode",
            value: function() {
                return this._octreeNode;
            }
        }, {
            key: "_setOctreeNode",
            value: function(e) {
                this._octreeNode = e;
            }
        }, {
            key: "_getIndexInMotionList",
            value: function() {
                return this._indexInOctreeMotionList;
            }
        }, {
            key: "_setIndexInMotionList",
            value: function(e) {
                this._indexInOctreeMotionList = e;
            }
        }, {
            key: "_changeMaterialReference",
            value: function(e, t) {
                e && e._removeReference(),
                t._addReference();
            }
        }, {
            key: "_getInstanceMaterial",
            value: function(e, t) {
                var r = e.clone();
                return r.name = r.name + "(Instance)",
                this._materialsInstance[t] = !0,
                this._changeMaterialReference(this._sharedMaterials[t], r),
                this._sharedMaterials[t] = r,
                r;
            }
        }, {
            key: "_applyLightMapParams",
            value: function() {
                if (this._scene && this._lightmapIndex >= 0) {
                    var e = this._scene.getlightmaps();
                    this._lightmapIndex < e.length ? (this._shaderValues.addDefine(ge.SAHDERDEFINE_LIGHTMAP),
                    this._shaderValues.setTexture(ge.LIGHTMAP, e[this._lightmapIndex])) : this._shaderValues.removeDefine(ge.SAHDERDEFINE_LIGHTMAP);
                } else
                    this._shaderValues.removeDefine(ge.SAHDERDEFINE_LIGHTMAP);
            }
        }, {
            key: "_onWorldMatNeedChange",
            value: function(e) {
                this._boundsChange = !0,
                this._octreeNode && (e &= Ee.TRANSFORM_WORLDPOSITION | Ee.TRANSFORM_WORLDQUATERNION | Ee.TRANSFORM_WORLDSCALE) && -1 === this._indexInOctreeMotionList && this._octreeNode._octree.addMotionObject(this);
            }
        }, {
            key: "_calculateBoundingBox",
            value: function() {
                throw "BaseRender: must override it.";
            }
        }, {
            key: "_getIndexInList",
            value: function() {
                return this._indexInList;
            }
        }, {
            key: "_setIndexInList",
            value: function(e) {
                this._indexInList = e;
            }
        }, {
            key: "_setBelongScene",
            value: function(e) {
                this._scene !== e && (this._scene = e,
                this._applyLightMapParams());
            }
        }, {
            key: "_needRender",
            value: function(e, t) {
                return !0;
            }
        }, {
            key: "_renderUpdate",
            value: function(e, t) {}
        }, {
            key: "_renderUpdateWithCamera",
            value: function(e, t) {}
        }, {
            key: "_revertBatchRenderUpdate",
            value: function(e) {}
        }, {
            key: "_destroy",
            value: function() {
                -1 !== this._indexInOctreeMotionList && this._octreeNode._octree.removeMotionObject(this),
                this.offAll();
                var e = 0
                  , t = 0;
                for (e = 0,
                t = this._renderElements.length; e < t; e++)
                    this._renderElements[e].destroy();
                for (e = 0,
                t = this._sharedMaterials.length; e < t; e++)
                    this._sharedMaterials[e].destroyed || this._sharedMaterials[e]._removeReference();
                this._renderElements = null,
                this._owner = null,
                this._sharedMaterials = null,
                this._bounds = null,
                this._lightmapScaleOffset = null;
            }
        }, {
            key: "markAsUnStatic",
            value: function() {
                this._isPartOfStaticBatch && (it.instance._removeRenderSprite(this._owner),
                this._isPartOfStaticBatch = !1);
            }
        }, {
            key: "id",
            get: function() {
                return this._id;
            }
        }, {
            key: "lightmapIndex",
            get: function() {
                return this._lightmapIndex;
            },
            set: function(e) {
                this._lightmapIndex !== e && (this._lightmapIndex = e,
                this._applyLightMapParams());
            }
        }, {
            key: "lightmapScaleOffset",
            get: function() {
                return this._lightmapScaleOffset;
            },
            set: function(e) {
                if (!e)
                    throw "BaseRender: lightmapScaleOffset can't be null.";
                this._lightmapScaleOffset = e,
                this._shaderValues.setVector(ge.LIGHTMAPSCALEOFFSET, e);
            }
        }, {
            key: "enable",
            get: function() {
                return this._enable;
            },
            set: function(e) {
                this._enable = !!e;
            }
        }, {
            key: "material",
            get: function() {
                var e = this._sharedMaterials[0];
                if (e && !this._materialsInstance[0]) {
                    var t = this._getInstanceMaterial(e, 0)
                      , r = this._renderElements[0];
                    r && (r.material = t);
                }
                return this._sharedMaterials[0];
            },
            set: function(e) {
                this.sharedMaterial = e;
            }
        }, {
            key: "materials",
            get: function() {
                for (var e = 0, t = this._sharedMaterials.length; e < t; e++)
                    if (!this._materialsInstance[e]) {
                        var r = this._getInstanceMaterial(this._sharedMaterials[e], e)
                          , n = this._renderElements[e];
                        n && (n.material = r);
                    }
                return this._sharedMaterials.slice();
            },
            set: function(e) {
                this.sharedMaterials = e;
            }
        }, {
            key: "sharedMaterial",
            get: function() {
                return this._sharedMaterials[0];
            },
            set: function(e) {
                var t = this._sharedMaterials[0];
                if (t !== e) {
                    this._sharedMaterials[0] = e,
                    this._materialsInstance[0] = !1,
                    this._changeMaterialReference(t, e);
                    var r = this._renderElements[0];
                    r && (r.material = e);
                }
            }
        }, {
            key: "sharedMaterials",
            get: function() {
                return this._sharedMaterials.slice();
            },
            set: function(e) {
                for (var t = this._materialsInstance, r = this._sharedMaterials, n = 0, i = r.length; n < i; n++) {
                    var a = r[n];
                    a && a._removeReference();
                }
                if (!e)
                    throw new Error("BaseRender: shadredMaterials value can't be null.");
                var o = e.length;
                for (t.length = o,
                r.length = o,
                n = 0; n < o; n++) {
                    a = r[n];
                    var s = e[n];
                    if (a !== s) {
                        t[n] = !1;
                        var l = this._renderElements[n];
                        l && (l.material = s);
                    }
                    s && s._addReference(),
                    r[n] = s;
                }
            }
        }, {
            key: "bounds",
            get: function() {
                return this._boundsChange && (this._calculateBoundingBox(),
                this._boundsChange = !1),
                this._bounds;
            }
        }, {
            key: "receiveShadow",
            set: function(e) {
                this._receiveShadow !== e && (this._receiveShadow = e,
                e ? this._shaderValues.addDefine(ge.SHADERDEFINE_RECEIVE_SHADOW) : this._shaderValues.removeDefine(ge.SHADERDEFINE_RECEIVE_SHADOW));
            },
            get: function() {
                return this._receiveShadow;
            }
        }, {
            key: "castShadow",
            get: function() {
                return this._castShadow;
            },
            set: function(e) {
                this._castShadow = e;
            }
        }, {
            key: "isPartOfStaticBatch",
            get: function() {
                return this._isPartOfStaticBatch;
            }
        }, {
            key: "isRender",
            get: function() {
                return -1 == this._renderMark || this._renderMark == t.Stat.loopCount - 1;
            }
        }]),
        BaseRender;
    }();
    lt._tempBoundBoxCorners = [new o(), new o(), new o(), new o(), new o(), new o(), new o(), new o()],
    lt._uniqueIDCounter = 0,
    lt._defaultLightmapScaleOffset = new i(1,1,0,0);
    var ut = function(e) {
        function MeshRenderer(e) {
            var t;
            return _classCallCheck(this, MeshRenderer),
            (t = _possibleConstructorReturn(this, _getPrototypeOf(MeshRenderer).call(this, e)))._revertStaticBatchDefineUV1 = !1,
            t._projectionViewWorldMatrix = new I(),
            t;
        }
        return _inherits(MeshRenderer, lt),
        _createClass(MeshRenderer, [{
            key: "_createRenderElement",
            value: function() {
                return new tt();
            }
        }, {
            key: "_onMeshChange",
            value: function(e) {
                if (e) {
                    var t = e.subMeshCount;
                    this._renderElements.length = t;
                    for (var r = 0; r < t; r++) {
                        var n = this._renderElements[r];
                        if (!n) {
                            var i = this.sharedMaterials[r];
                            (n = this._renderElements[r] = this._createRenderElement()).setTransform(this._owner._transform),
                            n.render = this,
                            n.material = i || q.defaultMaterial;
                        }
                        n.setGeometry(e.getSubMesh(r));
                    }
                } else
                    this._renderElements.length = 0;
                this._boundsChange = !0;
            }
        }, {
            key: "_calculateBoundingBox",
            value: function() {
                var e = this._owner.meshFilter.sharedMesh;
                if (e) {
                    var r = this._owner.transform.worldMatrix;
                    e.bounds._tranform(r, this._bounds);
                }
                if (t.Render.supportWebGLPlusCulling) {
                    var n = this._bounds.getMin()
                      , i = this._bounds.getMax()
                      , a = Re._cullingBuffer;
                    a[this._cullingBufferIndex + 1] = n.x,
                    a[this._cullingBufferIndex + 2] = n.y,
                    a[this._cullingBufferIndex + 3] = n.z,
                    a[this._cullingBufferIndex + 4] = i.x,
                    a[this._cullingBufferIndex + 5] = i.y,
                    a[this._cullingBufferIndex + 6] = i.z;
                }
            }
        }, {
            key: "_needRender",
            value: function(e, t) {
                return !e || e.intersects(this.bounds._getBoundBox());
            }
        }, {
            key: "_renderUpdate",
            value: function(e, t) {
                var r = e.renderElement;
                switch (r.renderType) {
                case et.RENDERTYPE_NORMAL:
                    this._shaderValues.setMatrix4x4(ye.WORLDMATRIX, t.worldMatrix);
                    break;
                case et.RENDERTYPE_STATICBATCH:
                    t ? this._shaderValues.setMatrix4x4(ye.WORLDMATRIX, t.worldMatrix) : this._shaderValues.setMatrix4x4(ye.WORLDMATRIX, I.DEFAULT),
                    this._shaderValues.hasDefine(at.SHADERDEFINE_UV1) ? this._revertStaticBatchDefineUV1 = !1 : (this._shaderValues.addDefine(at.SHADERDEFINE_UV1),
                    this._revertStaticBatchDefineUV1 = !0),
                    this._shaderValues.setVector(ge.LIGHTMAPSCALEOFFSET, lt._defaultLightmapScaleOffset);
                    break;
                case et.RENDERTYPE_VERTEXBATCH:
                    this._shaderValues.setMatrix4x4(ye.WORLDMATRIX, I.DEFAULT);
                    break;
                case et.RENDERTYPE_INSTANCEBATCH:
                    for (var n = xe.instance.instanceWorldMatrixData, i = r.instanceBatchElementList, a = i.elements, o = i.length, s = 0; s < o; s++)
                        n.set(a[s]._transform.worldMatrix.elements, 16 * s);
                    xe.instance.instanceWorldMatrixBuffer.setData(n.buffer, 0, 0, 16 * o * 4),
                    this._shaderValues.addDefine(at.SHADERDEFINE_GPU_INSTANCE);
                }
            }
        }, {
            key: "_renderUpdateWithCamera",
            value: function(e, t) {
                var r = e.projectionViewMatrix
                  , n = e.renderElement;
                switch (n.renderType) {
                case et.RENDERTYPE_NORMAL:
                case et.RENDERTYPE_STATICBATCH:
                case et.RENDERTYPE_VERTEXBATCH:
                    t ? (I.multiply(r, t.worldMatrix, this._projectionViewWorldMatrix),
                    this._shaderValues.setMatrix4x4(ye.MVPMATRIX, this._projectionViewWorldMatrix)) : this._shaderValues.setMatrix4x4(ye.MVPMATRIX, r);
                    break;
                case et.RENDERTYPE_INSTANCEBATCH:
                    for (var i = xe.instance.instanceMVPMatrixData, a = n.instanceBatchElementList, o = a.elements, s = a.length, l = 0; l < s; l++) {
                        var u = o[l]._transform.worldMatrix;
                        R.mulMatrixByArray(r.elements, 0, u.elements, 0, i, 16 * l);
                    }
                    xe.instance.instanceMVPMatrixBuffer.setData(i.buffer, 0, 0, 16 * s * 4);
                }
            }
        }, {
            key: "_revertBatchRenderUpdate",
            value: function(e) {
                switch (e.renderElement.renderType) {
                case et.RENDERTYPE_STATICBATCH:
                    this._revertStaticBatchDefineUV1 && this._shaderValues.removeDefine(at.SHADERDEFINE_UV1),
                    this._shaderValues.setVector(ge.LIGHTMAPSCALEOFFSET, this.lightmapScaleOffset);
                    break;
                case et.RENDERTYPE_INSTANCEBATCH:
                    this._shaderValues.removeDefine(at.SHADERDEFINE_GPU_INSTANCE);
                }
            }
        }, {
            key: "_destroy",
            value: function() {
                this._isPartOfStaticBatch && it.instance._removeRenderSprite(this._owner),
                _get(_getPrototypeOf(MeshRenderer.prototype), "_destroy", this).call(this);
            }
        }]),
        MeshRenderer;
    }()
      , ct = function() {
        function MeshFilter(e) {
            _classCallCheck(this, MeshFilter),
            this._owner = e;
        }
        return _createClass(MeshFilter, [{
            key: "_getMeshDefine",
            value: function(e, t) {
                t.length = 0;
                for (var r = 0, n = e._subMeshes.length; r < n; r++)
                    for (var i = e.getSubMesh(r)._vertexBuffer._vertexDeclaration._vertexElements, a = 0, o = i.length; a < o; a++) {
                        switch (i[a]._elementUsage) {
                        case ue.MESH_COLOR0:
                            t.push(at.SHADERDEFINE_COLOR);
                            break;
                        case ue.MESH_TEXTURECOORDINATE0:
                            t.push(at.SHADERDEFINE_UV0);
                            break;
                        case ue.MESH_TEXTURECOORDINATE1:
                            t.push(at.SHADERDEFINE_UV1);
                        }
                    }
            }
        }, {
            key: "destroy",
            value: function() {
                this._owner = null,
                this._sharedMesh && (this._sharedMesh._removeReference(),
                this._sharedMesh = null);
            }
        }, {
            key: "sharedMesh",
            get: function() {
                return this._sharedMesh;
            },
            set: function(e) {
                if (this._sharedMesh !== e) {
                    var t = this._owner._render._shaderValues
                      , r = this._sharedMesh;
                    if (r) {
                        r._removeReference(),
                        this._getMeshDefine(r, MeshFilter._meshVerticeDefine);
                        for (var n = 0, i = MeshFilter._meshVerticeDefine.length; n < i; n++)
                            t.removeDefine(MeshFilter._meshVerticeDefine[n]);
                    }
                    if (e) {
                        e._addReference(),
                        this._getMeshDefine(e, MeshFilter._meshVerticeDefine);
                        for (n = 0,
                        i = MeshFilter._meshVerticeDefine.length; n < i; n++)
                            t.addDefine(MeshFilter._meshVerticeDefine[n]);
                    }
                    this._owner._render._onMeshChange(e),
                    this._sharedMesh = e;
                }
            }
        }]),
        MeshFilter;
    }();
    ct._meshVerticeDefine = [];
    var ht = function(r) {
        function SubMeshDynamicBatch() {
            var r;
            _classCallCheck(this, SubMeshDynamicBatch),
            (r = _possibleConstructorReturn(this, _getPrototypeOf(SubMeshDynamicBatch).call(this)))._bufferState = new we();
            var n = t.LayaGL.instance
              , i = ue.getVertexDeclaration("POSITION,NORMAL,COLOR,UV,UV1,TANGENT").vertexStride * SubMeshDynamicBatch.maxIndicesCount;
            r._vertices = new Float32Array(i / 4),
            r._vertexBuffer = new De(i,n.DYNAMIC_DRAW),
            r._indices = new Int16Array(SubMeshDynamicBatch.maxIndicesCount),
            r._indexBuffer = new Fe(e.IndexFormat.UInt16,r._indices.length,n.DYNAMIC_DRAW);
            var a = r._vertexBuffer._byteLength + r._indexBuffer._byteLength;
            return t.Resource._addMemory(a, a),
            r;
        }
        return _inherits(SubMeshDynamicBatch, Me),
        _createClass(SubMeshDynamicBatch, [{
            key: "_getBatchVertices",
            value: function(e, t, r, n, i, a) {
                var o = e.vertexStride / 4
                  , s = a._vertexBuffer.getFloat32Data()
                  , l = (i.render.lightmapScaleOffset,
                i._dynamicMultiSubMesh)
                  , u = i._dynamicVertexCount;
                i._computeWorldPositionsAndNormals(this._positionOffset, this._normalOffset, l, u);
                for (var c = i._dynamicWorldPositions, h = i._dynamicWorldNormals, _ = a._indices, d = 0; d < u; d++) {
                    var f = (l ? _[d] : d) * o
                      , m = (d + r) * o
                      , p = 3 * d
                      , v = m + this._positionOffset;
                    t[v] = c[p],
                    t[v + 1] = c[p + 1],
                    t[v + 2] = c[p + 2],
                    -1 !== this._normalOffset && (t[v = m + this._normalOffset] = h[p],
                    t[v + 1] = h[p + 1],
                    t[v + 2] = h[p + 2]),
                    -1 !== this._colorOffset && (v = m + this._colorOffset,
                    p = f + this._colorOffset,
                    t[v] = s[p],
                    t[v + 1] = s[p + 1],
                    t[v + 2] = s[p + 2],
                    t[v + 3] = s[p + 3]),
                    -1 !== this._uv0Offset && (v = m + this._uv0Offset,
                    p = f + this._uv0Offset,
                    t[v] = s[p],
                    t[v + 1] = s[p + 1]),
                    -1 !== this._sTangentOffset && (v = m + this._sTangentOffset,
                    p = f + this._sTangentOffset,
                    t[v] = s[p],
                    t[v + 1] = s[p + 1],
                    t[v + 2] = s[p + 2],
                    t[v + 3] = s[p + 3],
                    v = m + this._sTangentOffset,
                    p = f + this._sTangentOffset,
                    t[v] = s[p],
                    t[v + 1] = s[p + 1],
                    t[v + 2] = s[p + 2],
                    t[v + 3] = s[p + 3]);
                }
            }
        }, {
            key: "_getBatchIndices",
            value: function(e, t, r, n, i, a) {
                var o, s, l, u = i._indices, c = n._isFrontFaceInvert;
                if (a)
                    if (c)
                        for (o = 0,
                        s = u.length; o < s; o += 3) {
                            var h = r + o;
                            e[l = t + o] = h,
                            e[l + 1] = h + 2,
                            e[l + 2] = h + 1;
                        }
                    else
                        for (o = 0,
                        s = u.length; o < s; o += 3)
                            h = r + o,
                            e[l = t + o] = h,
                            e[l + 1] = h + 1,
                            e[l + 2] = h + 2;
                else if (c)
                    for (o = 0,
                    s = u.length; o < s; o += 3)
                        e[l = t + o] = r + u[o],
                        e[l + 1] = r + u[o + 2],
                        e[l + 2] = r + u[o + 1];
                else
                    for (o = 0,
                    s = u.length; o < s; o += 3)
                        e[l = t + o] = r + u[o],
                        e[l + 1] = r + u[o + 1],
                        e[l + 2] = r + u[o + 2];
            }
        }, {
            key: "_flush",
            value: function(e, r) {
                var n = t.LayaGL.instance;
                this._vertexBuffer.setData(this._vertices.buffer, 0, 0, e * this._bufferState.vertexDeclaration.vertexStride),
                this._indexBuffer.setData(this._indices, 0, 0, r),
                n.drawElements(n.TRIANGLES, r, n.UNSIGNED_SHORT, 0);
            }
        }, {
            key: "_prepareRender",
            value: function(e) {
                var t = e.renderElement.vertexBatchVertexDeclaration;
                this._bufferState = l.MeshRenderDynamicBatchManager.instance._getBufferState(t),
                this._positionOffset = t.getVertexElementByUsage(ue.MESH_POSITION0)._offset / 4;
                var r = t.getVertexElementByUsage(ue.MESH_NORMAL0);
                this._normalOffset = r ? r._offset / 4 : -1;
                var n = t.getVertexElementByUsage(ue.MESH_COLOR0);
                this._colorOffset = n ? n._offset / 4 : -1;
                var i = t.getVertexElementByUsage(ue.MESH_TEXTURECOORDINATE0);
                this._uv0Offset = i ? i._offset / 4 : -1;
                var a = t.getVertexElementByUsage(ue.MESH_TEXTURECOORDINATE1);
                this._uv1Offset = a ? a._offset / 4 : -1;
                var o = t.getVertexElementByUsage(ue.MESH_TANGENT0);
                return this._sTangentOffset = o ? o._offset / 4 : -1,
                !0;
            }
        }, {
            key: "_render",
            value: function(e) {
                this._bufferState.bind();
                for (var r = e.renderElement, n = r.vertexBatchVertexDeclaration, i = r.vertexBatchElementList, a = 0, o = 0, s = (n.vertexStride,
                0), l = i.length, u = i.elements, c = 0; c < l; c++) {
                    var h = u[c]
                      , _ = h._geometry
                      , d = _._indexCount;
                    o + d > SubMeshDynamicBatch.maxIndicesCount && (this._flush(a, o),
                    s++,
                    t.Stat.trianglesFaces += o / 3,
                    a = o = 0);
                    var f = h._transform;
                    this._getBatchVertices(n, this._vertices, a, f, h, _),
                    this._getBatchIndices(this._indices, o, a, f, _, h._dynamicMultiSubMesh),
                    a += h._dynamicVertexCount,
                    o += d;
                }
                this._flush(a, o),
                s++,
                t.Stat.renderBatches += s,
                t.Stat.savedRenderBatches += l - s,
                t.Stat.trianglesFaces += o / 3;
            }
        }], [{
            key: "__init__",
            value: function() {
                SubMeshDynamicBatch.instance = new SubMeshDynamicBatch();
            }
        }]),
        SubMeshDynamicBatch;
    }();
    ht.maxAllowVertexCount = 10,
    ht.maxAllowAttribueCount = 900,
    ht.maxIndicesCount = 32e3;
    var _t = function(e) {
        function MeshRenderDynamicBatchManager() {
            var e;
            return _classCallCheck(this, MeshRenderDynamicBatchManager),
            (e = _possibleConstructorReturn(this, _getPrototypeOf(MeshRenderDynamicBatchManager).call(this)))._instanceBatchOpaqueMarks = [],
            e._vertexBatchOpaqueMarks = [],
            e._cacheBufferStates = [],
            e._updateCountMark = 0,
            e;
        }
        return _inherits(MeshRenderDynamicBatchManager, Te),
        _createClass(MeshRenderDynamicBatchManager, [{
            key: "getInstanceBatchOpaquaMark",
            value: function(e, t, r, n) {
                var i = this._instanceBatchOpaqueMarks[e ? 0 : 1] || (this._instanceBatchOpaqueMarks[e ? 0 : 1] = [])
                  , a = i[t] || (i[t] = [])
                  , o = a[r] || (a[r] = []);
                return o[n ? 1 : 0] || (o[n ? 1 : 0] = new Ce());
            }
        }, {
            key: "getVertexBatchOpaquaMark",
            value: function(e, t, r, n) {
                var i = this._vertexBatchOpaqueMarks[e] || (this._vertexBatchOpaqueMarks[e] = [])
                  , a = i[t ? 0 : 1] || (i[t ? 0 : 1] = [])
                  , o = a[r] || (a[r] = []);
                return o[n] || (o[n] = new Ce());
            }
        }, {
            key: "_getBufferState",
            value: function(e) {
                var t = this._cacheBufferStates[e.id];
                if (!t) {
                    var r = ht.instance;
                    (t = new we()).bind();
                    var n = r._vertexBuffer;
                    n.vertexDeclaration = e,
                    t.applyVertexBuffer(n),
                    t.applyIndexBuffer(r._indexBuffer),
                    t.unBind(),
                    this._cacheBufferStates[e.id] = t;
                }
                return t;
            }
        }, {
            key: "_getBatchRenderElementFromPool",
            value: function() {
                var e = this._batchRenderElementPool[this._batchRenderElementPoolIndex++];
                return e || (e = new tt(),
                this._batchRenderElementPool[this._batchRenderElementPoolIndex - 1] = e,
                e.vertexBatchElementList = new nt(),
                e.instanceBatchElementList = new nt()),
                e;
            }
        }, {
            key: "_clear",
            value: function() {
                _get(_getPrototypeOf(MeshRenderDynamicBatchManager.prototype), "_clear", this).call(this),
                this._updateCountMark++;
            }
        }]),
        MeshRenderDynamicBatchManager;
    }();
    _t.instance = new _t();
    var dt = function(e) {
        function MeshSprite3D() {
            var e, t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null, r = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null;
            return _classCallCheck(this, MeshSprite3D),
            (e = _possibleConstructorReturn(this, _getPrototypeOf(MeshSprite3D).call(this, r)))._meshFilter = new ct(_assertThisInitialized(e)),
            e._render = new ut(_assertThisInitialized(e)),
            t && (e._meshFilter.sharedMesh = t),
            e;
        }
        return _inherits(MeshSprite3D, ge),
        _createClass(MeshSprite3D, [{
            key: "meshFilter",
            get: function() {
                return this._meshFilter;
            }
        }, {
            key: "meshRenderer",
            get: function() {
                return this._render;
            }
        }], [{
            key: "__init__",
            value: function() {
                at.SHADERDEFINE_UV0 = G.getDefineByName("UV"),
                at.SHADERDEFINE_COLOR = G.getDefineByName("COLOR"),
                at.SHADERDEFINE_UV1 = G.getDefineByName("UV1"),
                at.SHADERDEFINE_GPU_INSTANCE = G.getDefineByName("GPU_INSTANCE"),
                Se._registerManager(it.instance),
                Te._registerManager(_t.instance);
            }
        }]),
        _createClass(MeshSprite3D, [{
            key: "_parse",
            value: function(e, r) {
                _get(_getPrototypeOf(MeshSprite3D.prototype), "_parse", this).call(this, e, r);
                var n = this.meshRenderer
                  , a = e.lightmapIndex;
                null != a && (n.lightmapIndex = a);
                var o = e.lightmapScaleOffset;
                o && (n.lightmapScaleOffset = new i(o[0],o[1],o[2],o[3])),
                null != e.meshPath && (this.meshFilter.sharedMesh = t.Loader.getRes(e.meshPath)),
                null != e.enableRender && (this.meshRenderer.enable = e.enableRender);
                var s = e.materials;
                if (s) {
                    var l = n.sharedMaterials
                      , u = s.length;
                    l.length = u;
                    for (var c = 0; c < u; c++)
                        l[c] = t.Loader.getRes(s[c].path);
                    n.sharedMaterials = l;
                }
            }
        }, {
            key: "_addToInitStaticBatchManager",
            value: function() {
                this.meshFilter.sharedMesh && it.instance._addBatchSprite(this);
            }
        }, {
            key: "_cloneTo",
            value: function(e, t, r) {
                var n = e;
                n._meshFilter.sharedMesh = this._meshFilter.sharedMesh;
                var i = this._render
                  , a = n._render;
                a.enable = i.enable,
                a.sharedMaterials = i.sharedMaterials,
                a.castShadow = i.castShadow;
                var o = i.lightmapScaleOffset;
                o && (a.lightmapScaleOffset = o.clone()),
                a.lightmapIndex = i.lightmapIndex,
                a.receiveShadow = i.receiveShadow,
                a.sortingFudge = i.sortingFudge,
                _get(_getPrototypeOf(MeshSprite3D.prototype), "_cloneTo", this).call(this, e, t, r);
            }
        }, {
            key: "destroy",
            value: function() {
                var e = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0];
                this.destroyed || (_get(_getPrototypeOf(MeshSprite3D.prototype), "destroy", this).call(this, e),
                this._meshFilter.destroy());
            }
        }, {
            key: "_create",
            value: function() {
                return new MeshSprite3D();
            }
        }]),
        MeshSprite3D;
    }()
      , ft = function GradientMode() {
        _classCallCheck(this, GradientMode);
    };
    ft.Blend = 0,
    ft.Fixed = 1;
    var mt = function() {
        function Gradient(e, t) {
            _classCallCheck(this, Gradient),
            this._mode = 0,
            this._maxColorRGBKeysCount = 0,
            this._maxColorAlphaKeysCount = 0,
            this._colorRGBKeysCount = 0,
            this._colorAlphaKeysCount = 0,
            this._alphaElements = null,
            this._rgbElements = null,
            this._maxColorRGBKeysCount = e,
            this._maxColorAlphaKeysCount = t,
            this._rgbElements = new Float32Array(4 * e),
            this._alphaElements = new Float32Array(2 * t);
        }
        return _createClass(Gradient, [{
            key: "addColorRGB",
            value: function(e, t) {
                if (this._colorRGBKeysCount < this._maxColorRGBKeysCount) {
                    var r = 4 * this._colorRGBKeysCount;
                    this._rgbElements[r] = e,
                    this._rgbElements[r + 1] = t.r,
                    this._rgbElements[r + 2] = t.g,
                    this._rgbElements[r + 3] = t.b,
                    this._colorRGBKeysCount++;
                } else
                    console.warn("Gradient:warning:data count must lessEqual than " + this._maxColorRGBKeysCount);
            }
        }, {
            key: "addColorAlpha",
            value: function(e, t) {
                if (this._colorAlphaKeysCount < this._maxColorAlphaKeysCount) {
                    var r = 2 * this._colorAlphaKeysCount;
                    this._alphaElements[r] = e,
                    this._alphaElements[r + 1] = t,
                    this._colorAlphaKeysCount++;
                } else
                    console.warn("Gradient:warning:data count must lessEqual than " + this._maxColorAlphaKeysCount);
            }
        }, {
            key: "updateColorRGB",
            value: function(e, t, r) {
                if (e < this._colorRGBKeysCount) {
                    var n = 4 * e;
                    this._rgbElements[n] = t,
                    this._rgbElements[n + 1] = r.r,
                    this._rgbElements[n + 2] = r.g,
                    this._rgbElements[n + 3] = r.b;
                } else
                    console.warn("Gradient:warning:index must lessEqual than colorRGBKeysCount:" + this._colorRGBKeysCount);
            }
        }, {
            key: "updateColorAlpha",
            value: function(e, t, r) {
                if (e < this._colorAlphaKeysCount) {
                    var n = 2 * e;
                    this._alphaElements[n] = t,
                    this._alphaElements[n + 1] = r;
                } else
                    console.warn("Gradient:warning:index must lessEqual than colorAlphaKeysCount:" + this._colorAlphaKeysCount);
            }
        }, {
            key: "evaluateColorRGB",
            value: function(e, t) {
                var r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0
                  , n = arguments.length > 3 && void 0 !== arguments[3] && arguments[3];
                e = Math.min(Math.max(e, 0), 1);
                var i = this._rgbElements
                  , a = r;
                if (n)
                    for (var o = a; o >= 0; o--) {
                        var s = 4 * o;
                        if (e === (d = i[s]))
                            return t.r = i[s + 1],
                            t.g = i[s + 2],
                            t.b = i[s + 3],
                            a;
                        switch (this._mode) {
                        case ft.Blend:
                            if (e > d) {
                                if (e > (_ = i[s + 4]))
                                    throw "Gradient:wrong startSearchIndex.";
                                var l = _ - d
                                  , u = _ - e
                                  , c = e - d;
                                return t.r = (u * i[s + 1] + c * i[s + 5]) / l,
                                t.g = (u * i[s + 2] + c * i[s + 6]) / l,
                                t.b = (u * i[s + 3] + c * i[s + 7]) / l,
                                a;
                            }
                            a--;
                            continue;
                        case ft.Fixed:
                            if (e > d) {
                                if (e > i[s + 4])
                                    throw "Gradient:wrong startSearchIndex.";
                                return t.r = i[s + 5],
                                t.g = i[s + 6],
                                t.b = i[s + 7],
                                a;
                            }
                            a--;
                            continue;
                        default:
                            throw "Gradient:unknown mode.";
                        }
                    }
                else {
                    o = 0;
                    for (var h = this._rgbElements.length; o < h; o++) {
                        var _;
                        if (e === (_ = i[s = 4 * o]))
                            return t.r = i[s + 1],
                            t.g = i[s + 2],
                            t.b = i[s + 3],
                            a;
                        switch (this._mode) {
                        case ft.Blend:
                            if (e < _) {
                                var d;
                                if (e < (d = i[s - 4]))
                                    throw "Gradient:wrong startSearchIndex.";
                                l = _ - d,
                                u = _ - e,
                                c = e - d;
                                return t.r = (u * i[s - 3] + c * i[s + 1]) / l,
                                t.g = (u * i[s - 2] + c * i[s + 2]) / l,
                                t.b = (u * i[s - 1] + c * i[s + 3]) / l,
                                a;
                            }
                            a++;
                            continue;
                        case ft.Fixed:
                            if (e < _) {
                                if (e < i[s - 4])
                                    throw "Gradient:wrong startSearchIndex.";
                                return t.r = i[s + 1],
                                t.g = i[s + 2],
                                t.b = i[s + 3],
                                a;
                            }
                            a++;
                            continue;
                        default:
                            throw "Gradient:unknown mode.";
                        }
                    }
                }
                return a;
            }
        }, {
            key: "evaluateColorAlpha",
            value: function(e, t) {
                var r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0
                  , n = arguments.length > 3 && void 0 !== arguments[3] && arguments[3];
                e = Math.min(Math.max(e, 0), 1);
                var i = this._alphaElements
                  , a = r;
                if (n)
                    for (var o = a; o >= 0; o--) {
                        if (e === (d = i[h = 2 * o]))
                            return t.a = i[h + 1],
                            a;
                        switch (this._mode) {
                        case ft.Blend:
                            if (e > d) {
                                if (e > (_ = i[h + 2]))
                                    throw "Gradient:wrong startSearchIndex.";
                                var s = _ - d
                                  , l = _ - e
                                  , u = e - d;
                                return t.a = (l * i[h + 1] + u * i[h + 3]) / s,
                                a;
                            }
                            a--;
                            continue;
                        case ft.Fixed:
                            if (e > d) {
                                if (e > i[h + 2])
                                    throw "Gradient:wrong startSearchIndex.";
                                return t.a = i[h + 3],
                                a;
                            }
                            a--;
                            continue;
                        default:
                            throw "Gradient:unknown mode.";
                        }
                    }
                else {
                    o = a;
                    for (var c = this._alphaElements.length; o < c; o++) {
                        var h, _;
                        if (e === (_ = i[h = 2 * o]))
                            return t.a = i[h + 1],
                            a;
                        switch (this._mode) {
                        case ft.Blend:
                            if (e < _) {
                                var d;
                                if (e < (d = i[h - 2]))
                                    throw "Gradient:wrong startSearchIndex.";
                                s = _ - d,
                                l = _ - e,
                                u = e - d;
                                return t.a = (l * i[h - 1] + u * i[h + 1]) / s,
                                a;
                            }
                            a++;
                            continue;
                        case ft.Fixed:
                            if (e < _) {
                                if (e < i[h - 2])
                                    throw "Gradient:wrong startSearchIndex.";
                                return t.a = i[h + 1],
                                a;
                            }
                            a++;
                            continue;
                        default:
                            throw "Gradient:unknown mode.";
                        }
                    }
                }
                return a;
            }
        }, {
            key: "cloneTo",
            value: function(e) {
                var t, r, n = e;
                n._colorAlphaKeysCount = this._colorAlphaKeysCount;
                var i = n._alphaElements;
                for (t = 0,
                r = this._alphaElements.length; t < r; t++)
                    i[t] = this._alphaElements[t];
                n._colorRGBKeysCount = this._colorRGBKeysCount;
                var a = n._rgbElements;
                for (t = 0,
                r = this._rgbElements.length; t < r; t++)
                    a[t] = this._rgbElements[t];
            }
        }, {
            key: "clone",
            value: function() {
                var e = new Gradient(this._maxColorRGBKeysCount,this._maxColorAlphaKeysCount);
                return this.cloneTo(e),
                e;
            }
        }, {
            key: "mode",
            get: function() {
                return this._mode;
            },
            set: function(e) {
                this._mode = e;
            }
        }, {
            key: "colorRGBKeysCount",
            get: function() {
                return this._colorRGBKeysCount;
            }
        }, {
            key: "colorAlphaKeysCount",
            get: function() {
                return this._colorAlphaKeysCount;
            }
        }, {
            key: "maxColorRGBKeysCount",
            get: function() {
                return this._maxColorRGBKeysCount;
            }
        }, {
            key: "maxColorAlphaKeysCount",
            get: function() {
                return this._maxColorAlphaKeysCount;
            }
        }]),
        Gradient;
    }()
      , pt = function() {
        function Burst(e, t, r) {
            _classCallCheck(this, Burst),
            this._time = e,
            this._minCount = t,
            this._maxCount = r;
        }
        return _createClass(Burst, [{
            key: "time",
            get: function() {
                return this._time;
            }
        }, {
            key: "minCount",
            get: function() {
                return this._minCount;
            }
        }, {
            key: "maxCount",
            get: function() {
                return this._maxCount;
            }
        }]),
        _createClass(Burst, [{
            key: "cloneTo",
            value: function(e) {
                var t = e;
                t._time = this._time,
                t._minCount = this._minCount,
                t._maxCount = this._maxCount;
            }
        }, {
            key: "clone",
            value: function() {
                var e = new Burst(this._time,this._minCount,this._maxCount);
                return this.cloneTo(e),
                e;
            }
        }]),
        Burst;
    }()
      , vt = function() {
        function GradientColor() {
            _classCallCheck(this, GradientColor),
            this._type = 0,
            this._constant = null,
            this._constantMin = null,
            this._constantMax = null,
            this._gradient = null,
            this._gradientMin = null,
            this._gradientMax = null;
        }
        return _createClass(GradientColor, [{
            key: "cloneTo",
            value: function(e) {
                var t = e;
                t._type = this._type,
                this._constant.cloneTo(t._constant),
                this._constantMin.cloneTo(t._constantMin),
                this._constantMax.cloneTo(t._constantMax),
                this._gradient.cloneTo(t._gradient),
                this._gradientMin.cloneTo(t._gradientMin),
                this._gradientMax.cloneTo(t._gradientMax);
            }
        }, {
            key: "clone",
            value: function() {
                var e = new GradientColor();
                return this.cloneTo(e),
                e;
            }
        }, {
            key: "type",
            get: function() {
                return this._type;
            }
        }, {
            key: "constant",
            get: function() {
                return this._constant;
            }
        }, {
            key: "constantMin",
            get: function() {
                return this._constantMin;
            }
        }, {
            key: "constantMax",
            get: function() {
                return this._constantMax;
            }
        }, {
            key: "gradient",
            get: function() {
                return this._gradient;
            }
        }, {
            key: "gradientMin",
            get: function() {
                return this._gradientMin;
            }
        }, {
            key: "gradientMax",
            get: function() {
                return this._gradientMax;
            }
        }], [{
            key: "createByConstant",
            value: function(e) {
                var t = new GradientColor();
                return t._type = 0,
                t._constant = e,
                t;
            }
        }, {
            key: "createByGradient",
            value: function(e) {
                var t = new GradientColor();
                return t._type = 1,
                t._gradient = e,
                t;
            }
        }, {
            key: "createByRandomTwoConstant",
            value: function(e, t) {
                var r = new GradientColor();
                return r._type = 2,
                r._constantMin = e,
                r._constantMax = t,
                r;
            }
        }, {
            key: "createByRandomTwoGradient",
            value: function(e, t) {
                var r = new GradientColor();
                return r._type = 3,
                r._gradientMin = e,
                r._gradientMax = t,
                r;
            }
        }]),
        GradientColor;
    }()
      , Tt = function() {
        function ColorOverLifetime(e) {
            _classCallCheck(this, ColorOverLifetime),
            this._color = e;
        }
        return _createClass(ColorOverLifetime, [{
            key: "color",
            get: function() {
                return this._color;
            }
        }]),
        _createClass(ColorOverLifetime, [{
            key: "cloneTo",
            value: function(e) {
                var t = e;
                this._color.cloneTo(t._color),
                t.enable = this.enable;
            }
        }, {
            key: "clone",
            value: function() {
                var e;
                switch (this._color.type) {
                case 0:
                    e = vt.createByConstant(this._color.constant.clone());
                    break;
                case 1:
                    e = vt.createByGradient(this._color.gradient.clone());
                    break;
                case 2:
                    e = vt.createByRandomTwoConstant(this._color.constantMin.clone(), this._color.constantMax.clone());
                    break;
                case 3:
                    e = vt.createByRandomTwoGradient(this._color.gradientMin.clone(), this._color.gradientMax.clone());
                }
                var t = new ColorOverLifetime(e);
                return t.enable = this.enable,
                t;
            }
        }]),
        ColorOverLifetime;
    }()
      , Et = function() {
        function FrameOverTime() {
            _classCallCheck(this, FrameOverTime),
            this._type = 0,
            this._constant = 0,
            this._overTime = null,
            this._constantMin = 0,
            this._constantMax = 0,
            this._overTimeMin = null,
            this._overTimeMax = null;
        }
        return _createClass(FrameOverTime, [{
            key: "cloneTo",
            value: function(e) {
                var t = e;
                t._type = this._type,
                t._constant = this._constant,
                this._overTime && this._overTime.cloneTo(t._overTime),
                t._constantMin = this._constantMin,
                t._constantMax = this._constantMax,
                this._overTimeMin && this._overTimeMin.cloneTo(t._overTimeMin),
                this._overTimeMax && this._overTimeMax.cloneTo(t._overTimeMax);
            }
        }, {
            key: "clone",
            value: function() {
                var e = new FrameOverTime();
                return this.cloneTo(e),
                e;
            }
        }, {
            key: "type",
            get: function() {
                return this._type;
            }
        }, {
            key: "constant",
            get: function() {
                return this._constant;
            }
        }, {
            key: "frameOverTimeData",
            get: function() {
                return this._overTime;
            }
        }, {
            key: "constantMin",
            get: function() {
                return this._constantMin;
            }
        }, {
            key: "constantMax",
            get: function() {
                return this._constantMax;
            }
        }, {
            key: "frameOverTimeDataMin",
            get: function() {
                return this._overTimeMin;
            }
        }, {
            key: "frameOverTimeDataMax",
            get: function() {
                return this._overTimeMax;
            }
        }], [{
            key: "createByConstant",
            value: function() {
                var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0
                  , t = new FrameOverTime();
                return t._type = 0,
                t._constant = e,
                t;
            }
        }, {
            key: "createByOverTime",
            value: function(e) {
                var t = new FrameOverTime();
                return t._type = 1,
                t._overTime = e,
                t;
            }
        }, {
            key: "createByRandomTwoConstant",
            value: function() {
                var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0
                  , t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0
                  , r = new FrameOverTime();
                return r._type = 2,
                r._constantMin = e,
                r._constantMax = t,
                r;
            }
        }, {
            key: "createByRandomTwoOverTime",
            value: function(e, t) {
                var r = new FrameOverTime();
                return r._type = 3,
                r._overTimeMin = e,
                r._overTimeMax = t,
                r;
            }
        }]),
        FrameOverTime;
    }()
      , yt = function() {
        function GradientAngularVelocity() {
            _classCallCheck(this, GradientAngularVelocity),
            this._type = 0,
            this._separateAxes = !1,
            this._constant = 0,
            this._constantSeparate = null,
            this._gradient = null,
            this._gradientX = null,
            this._gradientY = null,
            this._gradientZ = null,
            this._gradientW = null,
            this._constantMin = 0,
            this._constantMax = 0,
            this._constantMinSeparate = null,
            this._constantMaxSeparate = null,
            this._gradientMin = null,
            this._gradientMax = null,
            this._gradientXMin = null,
            this._gradientXMax = null,
            this._gradientYMin = null,
            this._gradientYMax = null,
            this._gradientZMin = null,
            this._gradientZMax = null,
            this._gradientWMin = null,
            this._gradientWMax = null;
        }
        return _createClass(GradientAngularVelocity, [{
            key: "cloneTo",
            value: function(e) {
                var t = e;
                t._type = this._type,
                t._separateAxes = this._separateAxes,
                t._constant = this._constant,
                this._constantSeparate.cloneTo(t._constantSeparate),
                this._gradient.cloneTo(t._gradient),
                this._gradientX.cloneTo(t._gradientX),
                this._gradientY.cloneTo(t._gradientY),
                this._gradientZ.cloneTo(t._gradientZ),
                t._constantMin = this._constantMin,
                t._constantMax = this._constantMax,
                this._constantMinSeparate.cloneTo(t._constantMinSeparate),
                this._constantMaxSeparate.cloneTo(t._constantMaxSeparate),
                this._gradientMin.cloneTo(t._gradientMin),
                this._gradientMax.cloneTo(t._gradientMax),
                this._gradientXMin.cloneTo(t._gradientXMin),
                this._gradientXMax.cloneTo(t._gradientXMax),
                this._gradientYMin.cloneTo(t._gradientYMin),
                this._gradientYMax.cloneTo(t._gradientYMax),
                this._gradientZMin.cloneTo(t._gradientZMin),
                this._gradientZMax.cloneTo(t._gradientZMax);
            }
        }, {
            key: "clone",
            value: function() {
                var e = new GradientAngularVelocity();
                return this.cloneTo(e),
                e;
            }
        }, {
            key: "type",
            get: function() {
                return this._type;
            }
        }, {
            key: "separateAxes",
            get: function() {
                return this._separateAxes;
            }
        }, {
            key: "constant",
            get: function() {
                return this._constant;
            }
        }, {
            key: "constantSeparate",
            get: function() {
                return this._constantSeparate;
            }
        }, {
            key: "gradient",
            get: function() {
                return this._gradient;
            }
        }, {
            key: "gradientX",
            get: function() {
                return this._gradientX;
            }
        }, {
            key: "gradientY",
            get: function() {
                return this._gradientY;
            }
        }, {
            key: "gradientZ",
            get: function() {
                return this._gradientZ;
            }
        }, {
            key: "gradientW",
            get: function() {
                return this._gradientW;
            }
        }, {
            key: "constantMin",
            get: function() {
                return this._constantMin;
            }
        }, {
            key: "constantMax",
            get: function() {
                return this._constantMax;
            }
        }, {
            key: "constantMinSeparate",
            get: function() {
                return this._constantMinSeparate;
            }
        }, {
            key: "constantMaxSeparate",
            get: function() {
                return this._constantMaxSeparate;
            }
        }, {
            key: "gradientMin",
            get: function() {
                return this._gradientMin;
            }
        }, {
            key: "gradientMax",
            get: function() {
                return this._gradientMax;
            }
        }, {
            key: "gradientXMin",
            get: function() {
                return this._gradientXMin;
            }
        }, {
            key: "gradientXMax",
            get: function() {
                return this._gradientXMax;
            }
        }, {
            key: "gradientYMin",
            get: function() {
                return this._gradientYMin;
            }
        }, {
            key: "gradientYMax",
            get: function() {
                return this._gradientYMax;
            }
        }, {
            key: "gradientZMin",
            get: function() {
                return this._gradientZMin;
            }
        }, {
            key: "gradientZMax",
            get: function() {
                return this._gradientZMax;
            }
        }, {
            key: "gradientWMin",
            get: function() {
                return this._gradientWMin;
            }
        }, {
            key: "gradientWMax",
            get: function() {
                return this._gradientWMax;
            }
        }], [{
            key: "createByConstant",
            value: function(e) {
                var t = new GradientAngularVelocity();
                return t._type = 0,
                t._separateAxes = !1,
                t._constant = e,
                t;
            }
        }, {
            key: "createByConstantSeparate",
            value: function(e) {
                var t = new GradientAngularVelocity();
                return t._type = 0,
                t._separateAxes = !0,
                t._constantSeparate = e,
                t;
            }
        }, {
            key: "createByGradient",
            value: function(e) {
                var t = new GradientAngularVelocity();
                return t._type = 1,
                t._separateAxes = !1,
                t._gradient = e,
                t;
            }
        }, {
            key: "createByGradientSeparate",
            value: function(e, t, r) {
                var n = new GradientAngularVelocity();
                return n._type = 1,
                n._separateAxes = !0,
                n._gradientX = e,
                n._gradientY = t,
                n._gradientZ = r,
                n;
            }
        }, {
            key: "createByRandomTwoConstant",
            value: function(e, t) {
                var r = new GradientAngularVelocity();
                return r._type = 2,
                r._separateAxes = !1,
                r._constantMin = e,
                r._constantMax = t,
                r;
            }
        }, {
            key: "createByRandomTwoConstantSeparate",
            value: function(e, t) {
                var r = new GradientAngularVelocity();
                return r._type = 2,
                r._separateAxes = !0,
                r._constantMinSeparate = e,
                r._constantMaxSeparate = t,
                r;
            }
        }, {
            key: "createByRandomTwoGradient",
            value: function(e, t) {
                var r = new GradientAngularVelocity();
                return r._type = 3,
                r._separateAxes = !1,
                r._gradientMin = e,
                r._gradientMax = t,
                r;
            }
        }, {
            key: "createByRandomTwoGradientSeparate",
            value: function(e, t, r, n, i, a, o, s) {
                var l = new GradientAngularVelocity();
                return l._type = 3,
                l._separateAxes = !0,
                l._gradientXMin = e,
                l._gradientXMax = t,
                l._gradientYMin = r,
                l._gradientYMax = n,
                l._gradientZMin = i,
                l._gradientZMax = a,
                l._gradientWMin = o,
                l._gradientWMax = s,
                l;
            }
        }]),
        GradientAngularVelocity;
    }()
      , gt = function() {
        function GradientDataInt() {
            _classCallCheck(this, GradientDataInt),
            this._currentLength = 0,
            this._elements = new Float32Array(8);
        }
        return _createClass(GradientDataInt, [{
            key: "add",
            value: function(e, t) {
                this._currentLength < 8 ? (6 === this._currentLength && 1 !== e && (e = 1,
                console.log("Warning:the forth key is  be force set to 1.")),
                this._elements[this._currentLength++] = e,
                this._elements[this._currentLength++] = t) : console.log("Warning:data count must lessEqual than 4");
            }
        }, {
            key: "cloneTo",
            value: function(e) {
                var t = e;
                t._currentLength = this._currentLength;
                for (var r = t._elements, n = 0, i = this._elements.length; n < i; n++)
                    r[n] = this._elements[n];
            }
        }, {
            key: "clone",
            value: function() {
                var e = new GradientDataInt();
                return this.cloneTo(e),
                e;
            }
        }, {
            key: "gradientCount",
            get: function() {
                return this._currentLength / 2;
            }
        }]),
        GradientDataInt;
    }()
      , St = function() {
        function GradientDataNumber() {
            _classCallCheck(this, GradientDataNumber),
            this._currentLength = 0,
            this._elements = new Float32Array(8);
        }
        return _createClass(GradientDataNumber, [{
            key: "add",
            value: function(e, t) {
                this._currentLength < 8 ? (6 === this._currentLength && 1 !== e && (e = 1,
                console.log("GradientDataNumber warning:the forth key is  be force set to 1.")),
                this._elements[this._currentLength++] = e,
                this._elements[this._currentLength++] = t) : console.log("GradientDataNumber warning:data count must lessEqual than 4");
            }
        }, {
            key: "getKeyByIndex",
            value: function(e) {
                return this._elements[2 * e];
            }
        }, {
            key: "getValueByIndex",
            value: function(e) {
                return this._elements[2 * e + 1];
            }
        }, {
            key: "getAverageValue",
            value: function() {
                for (var e = 0, t = this._currentLength - 2; e < t; e += 2) {
                    this._elements[e + 1];
                    this._elements[e + 3],
                    this._elements[e + 2] - this._elements[e];
                }
                return 0;
            }
        }, {
            key: "cloneTo",
            value: function(e) {
                var t = e;
                t._currentLength = this._currentLength;
                for (var r = t._elements, n = 0, i = this._elements.length; n < i; n++)
                    r[n] = this._elements[n];
            }
        }, {
            key: "clone",
            value: function() {
                var e = new GradientDataNumber();
                return this.cloneTo(e),
                e;
            }
        }, {
            key: "gradientCount",
            get: function() {
                return this._currentLength / 2;
            }
        }]),
        GradientDataNumber;
    }()
      , Rt = function() {
        function GradientSize() {
            _classCallCheck(this, GradientSize),
            this._type = 0,
            this._separateAxes = !1,
            this._gradient = null,
            this._gradientX = null,
            this._gradientY = null,
            this._gradientZ = null,
            this._constantMin = 0,
            this._constantMax = 0,
            this._constantMinSeparate = null,
            this._constantMaxSeparate = null,
            this._gradientMin = null,
            this._gradientMax = null,
            this._gradientXMin = null,
            this._gradientXMax = null,
            this._gradientYMin = null,
            this._gradientYMax = null,
            this._gradientZMin = null,
            this._gradientZMax = null;
        }
        return _createClass(GradientSize, [{
            key: "getMaxSizeInGradient",
            value: function() {
                var e, t, r = -Number.MAX_VALUE;
                switch (this._type) {
                case 0:
                    if (this._separateAxes) {
                        for (e = 0,
                        t = this._gradientX.gradientCount; e < t; e++)
                            r = Math.max(r, this._gradientX.getValueByIndex(e));
                        for (e = 0,
                        t = this._gradientY.gradientCount; e < t; e++)
                            r = Math.max(r, this._gradientY.getValueByIndex(e));
                    } else
                        for (e = 0,
                        t = this._gradient.gradientCount; e < t; e++)
                            r = Math.max(r, this._gradient.getValueByIndex(e));
                    break;
                case 1:
                    this._separateAxes ? (r = Math.max(this._constantMinSeparate.x, this._constantMaxSeparate.x),
                    r = Math.max(r, this._constantMinSeparate.y),
                    r = Math.max(r, this._constantMaxSeparate.y)) : r = Math.max(this._constantMin, this._constantMax);
                    break;
                case 2:
                    if (this._separateAxes) {
                        for (e = 0,
                        t = this._gradientXMin.gradientCount; e < t; e++)
                            r = Math.max(r, this._gradientXMin.getValueByIndex(e));
                        for (e = 0,
                        t = this._gradientXMax.gradientCount; e < t; e++)
                            r = Math.max(r, this._gradientXMax.getValueByIndex(e));
                        for (e = 0,
                        t = this._gradientYMin.gradientCount; e < t; e++)
                            r = Math.max(r, this._gradientYMin.getValueByIndex(e));
                        for (e = 0,
                        t = this._gradientZMax.gradientCount; e < t; e++)
                            r = Math.max(r, this._gradientZMax.getValueByIndex(e));
                    } else {
                        for (e = 0,
                        t = this._gradientMin.gradientCount; e < t; e++)
                            r = Math.max(r, this._gradientMin.getValueByIndex(e));
                        for (e = 0,
                        t = this._gradientMax.gradientCount; e < t; e++)
                            r = Math.max(r, this._gradientMax.getValueByIndex(e));
                    }
                }
                return r;
            }
        }, {
            key: "cloneTo",
            value: function(e) {
                var t = e;
                t._type = this._type,
                t._separateAxes = this._separateAxes,
                this._gradient.cloneTo(t._gradient),
                this._gradientX.cloneTo(t._gradientX),
                this._gradientY.cloneTo(t._gradientY),
                this._gradientZ.cloneTo(t._gradientZ),
                t._constantMin = this._constantMin,
                t._constantMax = this._constantMax,
                this._constantMinSeparate.cloneTo(t._constantMinSeparate),
                this._constantMaxSeparate.cloneTo(t._constantMaxSeparate),
                this._gradientMin.cloneTo(t._gradientMin),
                this._gradientMax.cloneTo(t._gradientMax),
                this._gradientXMin.cloneTo(t._gradientXMin),
                this._gradientXMax.cloneTo(t._gradientXMax),
                this._gradientYMin.cloneTo(t._gradientYMin),
                this._gradientYMax.cloneTo(t._gradientYMax),
                this._gradientZMin.cloneTo(t._gradientZMin),
                this._gradientZMax.cloneTo(t._gradientZMax);
            }
        }, {
            key: "clone",
            value: function() {
                var e = new GradientSize();
                return this.cloneTo(e),
                e;
            }
        }, {
            key: "type",
            get: function() {
                return this._type;
            }
        }, {
            key: "separateAxes",
            get: function() {
                return this._separateAxes;
            }
        }, {
            key: "gradient",
            get: function() {
                return this._gradient;
            }
        }, {
            key: "gradientX",
            get: function() {
                return this._gradientX;
            }
        }, {
            key: "gradientY",
            get: function() {
                return this._gradientY;
            }
        }, {
            key: "gradientZ",
            get: function() {
                return this._gradientZ;
            }
        }, {
            key: "constantMin",
            get: function() {
                return this._constantMin;
            }
        }, {
            key: "constantMax",
            get: function() {
                return this._constantMax;
            }
        }, {
            key: "constantMinSeparate",
            get: function() {
                return this._constantMinSeparate;
            }
        }, {
            key: "constantMaxSeparate",
            get: function() {
                return this._constantMaxSeparate;
            }
        }, {
            key: "gradientMin",
            get: function() {
                return this._gradientMin;
            }
        }, {
            key: "gradientMax",
            get: function() {
                return this._gradientMax;
            }
        }, {
            key: "gradientXMin",
            get: function() {
                return this._gradientXMin;
            }
        }, {
            key: "gradientXMax",
            get: function() {
                return this._gradientXMax;
            }
        }, {
            key: "gradientYMin",
            get: function() {
                return this._gradientYMin;
            }
        }, {
            key: "gradientYMax",
            get: function() {
                return this._gradientYMax;
            }
        }, {
            key: "gradientZMin",
            get: function() {
                return this._gradientZMin;
            }
        }, {
            key: "gradientZMax",
            get: function() {
                return this._gradientZMax;
            }
        }], [{
            key: "createByGradient",
            value: function(e) {
                var t = new GradientSize();
                return t._type = 0,
                t._separateAxes = !1,
                t._gradient = e,
                t;
            }
        }, {
            key: "createByGradientSeparate",
            value: function(e, t, r) {
                var n = new GradientSize();
                return n._type = 0,
                n._separateAxes = !0,
                n._gradientX = e,
                n._gradientY = t,
                n._gradientZ = r,
                n;
            }
        }, {
            key: "createByRandomTwoConstant",
            value: function(e, t) {
                var r = new GradientSize();
                return r._type = 1,
                r._separateAxes = !1,
                r._constantMin = e,
                r._constantMax = t,
                r;
            }
        }, {
            key: "createByRandomTwoConstantSeparate",
            value: function(e, t) {
                var r = new GradientSize();
                return r._type = 1,
                r._separateAxes = !0,
                r._constantMinSeparate = e,
                r._constantMaxSeparate = t,
                r;
            }
        }, {
            key: "createByRandomTwoGradient",
            value: function(e, t) {
                var r = new GradientSize();
                return r._type = 2,
                r._separateAxes = !1,
                r._gradientMin = e,
                r._gradientMax = t,
                r;
            }
        }, {
            key: "createByRandomTwoGradientSeparate",
            value: function(e, t, r, n, i, a) {
                var o = new GradientSize();
                return o._type = 2,
                o._separateAxes = !0,
                o._gradientXMin = e,
                o._gradientXMax = t,
                o._gradientYMin = r,
                o._gradientYMax = n,
                o._gradientZMin = i,
                o._gradientZMax = a,
                o;
            }
        }]),
        GradientSize;
    }()
      , Ct = function() {
        function GradientVelocity() {
            _classCallCheck(this, GradientVelocity),
            this._type = 0,
            this._constant = null,
            this._gradientX = null,
            this._gradientY = null,
            this._gradientZ = null,
            this._constantMin = null,
            this._constantMax = null,
            this._gradientXMin = null,
            this._gradientXMax = null,
            this._gradientYMin = null,
            this._gradientYMax = null,
            this._gradientZMin = null,
            this._gradientZMax = null;
        }
        return _createClass(GradientVelocity, [{
            key: "cloneTo",
            value: function(e) {
                var t = e;
                t._type = this._type,
                this._constant.cloneTo(t._constant),
                this._gradientX.cloneTo(t._gradientX),
                this._gradientY.cloneTo(t._gradientY),
                this._gradientZ.cloneTo(t._gradientZ),
                this._constantMin.cloneTo(t._constantMin),
                this._constantMax.cloneTo(t._constantMax),
                this._gradientXMin.cloneTo(t._gradientXMin),
                this._gradientXMax.cloneTo(t._gradientXMax),
                this._gradientYMin.cloneTo(t._gradientYMin),
                this._gradientYMax.cloneTo(t._gradientYMax),
                this._gradientZMin.cloneTo(t._gradientZMin),
                this._gradientZMax.cloneTo(t._gradientZMax);
            }
        }, {
            key: "clone",
            value: function() {
                var e = new GradientVelocity();
                return this.cloneTo(e),
                e;
            }
        }, {
            key: "type",
            get: function() {
                return this._type;
            }
        }, {
            key: "constant",
            get: function() {
                return this._constant;
            }
        }, {
            key: "gradientX",
            get: function() {
                return this._gradientX;
            }
        }, {
            key: "gradientY",
            get: function() {
                return this._gradientY;
            }
        }, {
            key: "gradientZ",
            get: function() {
                return this._gradientZ;
            }
        }, {
            key: "constantMin",
            get: function() {
                return this._constantMin;
            }
        }, {
            key: "constantMax",
            get: function() {
                return this._constantMax;
            }
        }, {
            key: "gradientXMin",
            get: function() {
                return this._gradientXMin;
            }
        }, {
            key: "gradientXMax",
            get: function() {
                return this._gradientXMax;
            }
        }, {
            key: "gradientYMin",
            get: function() {
                return this._gradientYMin;
            }
        }, {
            key: "gradientYMax",
            get: function() {
                return this._gradientYMax;
            }
        }, {
            key: "gradientZMin",
            get: function() {
                return this._gradientZMin;
            }
        }, {
            key: "gradientZMax",
            get: function() {
                return this._gradientZMax;
            }
        }], [{
            key: "createByConstant",
            value: function(e) {
                var t = new GradientVelocity();
                return t._type = 0,
                t._constant = e,
                t;
            }
        }, {
            key: "createByGradient",
            value: function(e, t, r) {
                var n = new GradientVelocity();
                return n._type = 1,
                n._gradientX = e,
                n._gradientY = t,
                n._gradientZ = r,
                n;
            }
        }, {
            key: "createByRandomTwoConstant",
            value: function(e, t) {
                var r = new GradientVelocity();
                return r._type = 2,
                r._constantMin = e,
                r._constantMax = t,
                r;
            }
        }, {
            key: "createByRandomTwoGradient",
            value: function(e, t, r, n, i, a) {
                var o = new GradientVelocity();
                return o._type = 3,
                o._gradientXMin = e,
                o._gradientXMax = t,
                o._gradientYMin = r,
                o._gradientYMax = n,
                o._gradientZMin = i,
                o._gradientZMax = a,
                o;
            }
        }]),
        GradientVelocity;
    }()
      , Mt = function() {
        function RotationOverLifetime(e) {
            _classCallCheck(this, RotationOverLifetime),
            this._angularVelocity = e;
        }
        return _createClass(RotationOverLifetime, [{
            key: "angularVelocity",
            get: function() {
                return this._angularVelocity;
            }
        }]),
        _createClass(RotationOverLifetime, [{
            key: "cloneTo",
            value: function(e) {
                var t = e;
                this._angularVelocity.cloneTo(t._angularVelocity),
                t.enable = this.enable;
            }
        }, {
            key: "clone",
            value: function() {
                var e;
                switch (this._angularVelocity.type) {
                case 0:
                    e = this._angularVelocity.separateAxes ? yt.createByConstantSeparate(this._angularVelocity.constantSeparate.clone()) : yt.createByConstant(this._angularVelocity.constant);
                    break;
                case 1:
                    e = this._angularVelocity.separateAxes ? yt.createByGradientSeparate(this._angularVelocity.gradientX.clone(), this._angularVelocity.gradientY.clone(), this._angularVelocity.gradientZ.clone()) : yt.createByGradient(this._angularVelocity.gradient.clone());
                    break;
                case 2:
                    e = this._angularVelocity.separateAxes ? yt.createByRandomTwoConstantSeparate(this._angularVelocity.constantMinSeparate.clone(), this._angularVelocity.constantMaxSeparate.clone()) : yt.createByRandomTwoConstant(this._angularVelocity.constantMin, this._angularVelocity.constantMax);
                    break;
                case 3:
                    e = this._angularVelocity.separateAxes ? yt.createByRandomTwoGradientSeparate(this._angularVelocity.gradientXMin.clone(), this._angularVelocity.gradientYMin.clone(), this._angularVelocity.gradientZMin.clone(), this._angularVelocity.gradientWMin.clone(), this._angularVelocity.gradientXMax.clone(), this._angularVelocity.gradientYMax.clone(), this._angularVelocity.gradientZMax.clone(), this._angularVelocity.gradientWMax.clone()) : yt.createByRandomTwoGradient(this._angularVelocity.gradientMin.clone(), this._angularVelocity.gradientMax.clone());
                }
                var t = new RotationOverLifetime(e);
                return t.enable = this.enable,
                t;
            }
        }]),
        RotationOverLifetime;
    }()
      , Dt = function() {
        function BaseShape() {
            _classCallCheck(this, BaseShape),
            this.enable = !0,
            this.randomDirection = 0;
        }
        return _createClass(BaseShape, [{
            key: "_getShapeBoundBox",
            value: function(e) {
                throw new Error("BaseShape: must override it.");
            }
        }, {
            key: "_getSpeedBoundBox",
            value: function(e) {
                throw new Error("BaseShape: must override it.");
            }
        }, {
            key: "generatePositionAndDirection",
            value: function(e, t) {
                arguments.length > 2 && void 0 !== arguments[2] && arguments[2],
                arguments.length > 3 && void 0 !== arguments[3] && arguments[3];
                throw new Error("BaseShape: must override it.");
            }
        }, {
            key: "_calculateProceduralBounds",
            value: function(e, t, r) {
                this._getShapeBoundBox(e);
                var n = e.min
                  , i = e.max;
                o.multiply(n, t, n),
                o.multiply(i, t, i);
                var a = new ot(new o(),new o());
                this.randomDirection ? (a.min = new o(-1,-1,-1),
                a.max = new o(1,1,1)) : this._getSpeedBoundBox(a);
                var s = new ot(new o(),new o())
                  , l = s.min
                  , u = s.max;
                o.scale(a.min, r.y, l),
                o.scale(a.max, r.y, u),
                o.add(e.min, l, l),
                o.add(e.max, u, u),
                o.min(e.min, l, e.min),
                o.max(e.max, l, e.max);
                var c = new ot(new o(),new o())
                  , h = c.min
                  , _ = c.max;
                o.scale(a.min, r.x, h),
                o.scale(a.max, r.x, _),
                o.min(c.min, _, l),
                o.max(c.min, _, u),
                o.min(e.min, l, e.min),
                o.max(e.max, l, e.max);
            }
        }, {
            key: "cloneTo",
            value: function(e) {
                e.enable = this.enable;
            }
        }, {
            key: "clone",
            value: function() {
                var e = new BaseShape();
                return this.cloneTo(e),
                e;
            }
        }]),
        BaseShape;
    }()
      , xt = function() {
        function ShapeUtils() {
            _classCallCheck(this, ShapeUtils);
        }
        return _createClass(ShapeUtils, null, [{
            key: "_randomPointUnitArcCircle",
            value: function(e, t) {
                var r, n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null;
                r = n ? n.getFloat() * e : Math.random() * e,
                t.x = Math.cos(r),
                t.y = Math.sin(r);
            }
        }, {
            key: "_randomPointInsideUnitArcCircle",
            value: function(e, t) {
                var r, n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null;
                ShapeUtils._randomPointUnitArcCircle(e, t, n),
                r = n ? Math.pow(n.getFloat(), .5) : Math.pow(Math.random(), .5),
                t.x = t.x * r,
                t.y = t.y * r;
            }
        }, {
            key: "_randomPointUnitCircle",
            value: function(e) {
                var t, r = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null;
                t = r ? r.getFloat() * Math.PI * 2 : Math.random() * Math.PI * 2,
                e.x = Math.cos(t),
                e.y = Math.sin(t);
            }
        }, {
            key: "_randomPointInsideUnitCircle",
            value: function(e) {
                var t, r = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null;
                ShapeUtils._randomPointUnitCircle(e),
                t = r ? Math.pow(r.getFloat(), .5) : Math.pow(Math.random(), .5),
                e.x = e.x * t,
                e.y = e.y * t;
            }
        }, {
            key: "_randomPointUnitSphere",
            value: function(e) {
                var t, r, n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null;
                n ? (t = e.z = 2 * n.getFloat() - 1,
                r = n.getFloat() * Math.PI * 2) : (t = e.z = 2 * Math.random() - 1,
                r = Math.random() * Math.PI * 2);
                var i = Math.sqrt(1 - t * t);
                e.x = i * Math.cos(r),
                e.y = i * Math.sin(r);
            }
        }, {
            key: "_randomPointInsideUnitSphere",
            value: function(e) {
                var t, r = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null;
                ShapeUtils._randomPointUnitSphere(e),
                t = r ? Math.pow(r.getFloat(), 1 / 3) : Math.pow(Math.random(), 1 / 3),
                e.x = e.x * t,
                e.y = e.y * t,
                e.z = e.z * t;
            }
        }, {
            key: "_randomPointInsideHalfUnitBox",
            value: function(e) {
                var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null;
                t ? (e.x = t.getFloat() - .5,
                e.y = t.getFloat() - .5,
                e.z = t.getFloat() - .5) : (e.x = Math.random() - .5,
                e.y = Math.random() - .5,
                e.z = Math.random() - .5);
            }
        }]),
        ShapeUtils;
    }()
      , At = function(e) {
        function BoxShape() {
            var e;
            return _classCallCheck(this, BoxShape),
            (e = _possibleConstructorReturn(this, _getPrototypeOf(BoxShape).call(this))).x = 1,
            e.y = 1,
            e.z = 1,
            e;
        }
        return _inherits(BoxShape, Dt),
        _createClass(BoxShape, [{
            key: "_getShapeBoundBox",
            value: function(e) {
                var t = e.min;
                t.x = .5 * -this.x,
                t.y = .5 * -this.y,
                t.z = .5 * -this.z;
                var r = e.max;
                r.x = .5 * this.x,
                r.y = .5 * this.y,
                r.z = .5 * this.z;
            }
        }, {
            key: "_getSpeedBoundBox",
            value: function(e) {
                var t = e.min;
                t.x = 0,
                t.y = 0,
                t.z = 0;
                var r = e.max;
                r.x = 0,
                r.y = 1,
                r.z = 0;
            }
        }, {
            key: "generatePositionAndDirection",
            value: function(e, t) {
                var r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null
                  , n = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : null;
                r ? (r.seed = n[16],
                xt._randomPointInsideHalfUnitBox(e, r),
                n[16] = r.seed) : xt._randomPointInsideHalfUnitBox(e),
                e.x = this.x * e.x,
                e.y = this.y * e.y,
                e.z = this.z * e.z,
                this.randomDirection ? r ? (r.seed = n[17],
                xt._randomPointUnitSphere(t, r),
                n[17] = r.seed) : xt._randomPointUnitSphere(t) : (t.x = 0,
                t.y = 0,
                t.z = 1);
            }
        }, {
            key: "cloneTo",
            value: function(e) {
                _get(_getPrototypeOf(BoxShape.prototype), "cloneTo", this).call(this, e);
                var t = e;
                t.x = this.x,
                t.y = this.y,
                t.z = this.z,
                t.randomDirection = this.randomDirection;
            }
        }, {
            key: "clone",
            value: function() {
                var e = new BoxShape();
                return this.cloneTo(e),
                e;
            }
        }]),
        BoxShape;
    }()
      , It = function(e) {
        function CircleShape() {
            var e;
            return _classCallCheck(this, CircleShape),
            (e = _possibleConstructorReturn(this, _getPrototypeOf(CircleShape).call(this))).radius = 1,
            e.arc = 2 * Math.PI,
            e.emitFromEdge = !1,
            e;
        }
        return _inherits(CircleShape, Dt),
        _createClass(CircleShape, [{
            key: "_getShapeBoundBox",
            value: function(e) {
                var t = e.min;
                t.x = t.z = -this.radius,
                t.y = 0;
                var r = e.max;
                r.x = r.z = this.radius,
                r.y = 0;
            }
        }, {
            key: "_getSpeedBoundBox",
            value: function(e) {
                var t = e.min;
                t.x = t.y = -1,
                t.z = 0;
                var r = e.max;
                r.x = r.y = 1,
                r.z = 0;
            }
        }, {
            key: "generatePositionAndDirection",
            value: function(e, t) {
                var r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null
                  , n = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : null
                  , i = CircleShape._tempPositionPoint;
                r ? (r.seed = n[16],
                this.emitFromEdge ? xt._randomPointUnitArcCircle(this.arc, CircleShape._tempPositionPoint, r) : xt._randomPointInsideUnitArcCircle(this.arc, CircleShape._tempPositionPoint, r),
                n[16] = r.seed) : this.emitFromEdge ? xt._randomPointUnitArcCircle(this.arc, CircleShape._tempPositionPoint) : xt._randomPointInsideUnitArcCircle(this.arc, CircleShape._tempPositionPoint),
                e.x = -i.x,
                e.y = i.y,
                e.z = 0,
                o.scale(e, this.radius, e),
                this.randomDirection ? r ? (r.seed = n[17],
                xt._randomPointUnitSphere(t, r),
                n[17] = r.seed) : xt._randomPointUnitSphere(t) : e.cloneTo(t);
            }
        }, {
            key: "cloneTo",
            value: function(e) {
                _get(_getPrototypeOf(CircleShape.prototype), "cloneTo", this).call(this, e);
                var t = e;
                t.radius = this.radius,
                t.arc = this.arc,
                t.emitFromEdge = this.emitFromEdge,
                t.randomDirection = this.randomDirection;
            }
        }, {
            key: "clone",
            value: function() {
                var e = new CircleShape();
                return this.cloneTo(e),
                e;
            }
        }]),
        CircleShape;
    }();
    It._tempPositionPoint = new n();
    var Lt = function(e) {
        function ConeShape() {
            var e;
            return _classCallCheck(this, ConeShape),
            (e = _possibleConstructorReturn(this, _getPrototypeOf(ConeShape).call(this))).angle = 25 / 180 * Math.PI,
            e.radius = 1,
            e.length = 5,
            e.emitType = 0,
            e;
        }
        return _inherits(ConeShape, Dt),
        _createClass(ConeShape, [{
            key: "_getShapeBoundBox",
            value: function(e) {
                var t = this.radius + this.length * Math.sin(this.angle)
                  , r = this.length * Math.cos(this.angle)
                  , n = e.min;
                n.x = n.y = -t,
                n.z = 0;
                var i = e.max;
                i.x = i.y = t,
                i.z = r;
            }
        }, {
            key: "_getSpeedBoundBox",
            value: function(e) {
                var t = Math.sin(this.angle)
                  , r = e.min;
                r.x = r.y = -t,
                r.z = 0;
                var n = e.max;
                n.x = n.y = t,
                n.z = 1;
            }
        }, {
            key: "generatePositionAndDirection",
            value: function(e, t) {
                var r, n, i, a = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null, s = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : null, l = ConeShape._tempPositionPoint, u = Math.cos(this.angle), c = Math.sin(this.angle);
                switch (this.emitType) {
                case 0:
                    a ? (a.seed = s[16],
                    xt._randomPointInsideUnitCircle(ConeShape._tempPositionPoint, a),
                    s[16] = a.seed) : xt._randomPointInsideUnitCircle(ConeShape._tempPositionPoint),
                    r = l.x,
                    n = l.y,
                    e.x = r * this.radius,
                    e.y = n * this.radius,
                    e.z = 0,
                    this.randomDirection ? (a ? (a.seed = s[17],
                    xt._randomPointInsideUnitCircle(ConeShape._tempDirectionPoint, a),
                    s[17] = a.seed) : xt._randomPointInsideUnitCircle(ConeShape._tempDirectionPoint),
                    i = ConeShape._tempDirectionPoint,
                    t.x = i.x * c,
                    t.y = i.y * c) : (t.x = r * c,
                    t.y = n * c),
                    t.z = u;
                    break;
                case 1:
                    a ? (a.seed = s[16],
                    xt._randomPointUnitCircle(ConeShape._tempPositionPoint, a),
                    s[16] = a.seed) : xt._randomPointUnitCircle(ConeShape._tempPositionPoint),
                    r = l.x,
                    n = l.y,
                    e.x = r * this.radius,
                    e.y = n * this.radius,
                    e.z = 0,
                    this.randomDirection ? (a ? (a.seed = s[17],
                    xt._randomPointInsideUnitCircle(ConeShape._tempDirectionPoint, a),
                    s[17] = a.seed) : xt._randomPointInsideUnitCircle(ConeShape._tempDirectionPoint),
                    i = ConeShape._tempDirectionPoint,
                    t.x = i.x * c,
                    t.y = i.y * c) : (t.x = r * c,
                    t.y = n * c),
                    t.z = u;
                    break;
                case 2:
                    a ? (a.seed = s[16],
                    xt._randomPointInsideUnitCircle(ConeShape._tempPositionPoint, a)) : xt._randomPointInsideUnitCircle(ConeShape._tempPositionPoint),
                    r = l.x,
                    n = l.y,
                    e.x = r * this.radius,
                    e.y = n * this.radius,
                    e.z = 0,
                    t.x = r * c,
                    t.y = n * c,
                    t.z = u,
                    o.normalize(t, t),
                    a ? (o.scale(t, this.length * a.getFloat(), t),
                    s[16] = a.seed) : o.scale(t, this.length * Math.random(), t),
                    o.add(e, t, e),
                    this.randomDirection && (a ? (a.seed = s[17],
                    xt._randomPointUnitSphere(t, a),
                    s[17] = a.seed) : xt._randomPointUnitSphere(t));
                    break;
                case 3:
                    a ? (a.seed = s[16],
                    xt._randomPointUnitCircle(ConeShape._tempPositionPoint, a)) : xt._randomPointUnitCircle(ConeShape._tempPositionPoint),
                    r = l.x,
                    n = l.y,
                    e.x = r * this.radius,
                    e.y = n * this.radius,
                    e.z = 0,
                    t.x = r * c,
                    t.y = n * c,
                    t.z = u,
                    o.normalize(t, t),
                    a ? (o.scale(t, this.length * a.getFloat(), t),
                    s[16] = a.seed) : o.scale(t, this.length * Math.random(), t),
                    o.add(e, t, e),
                    this.randomDirection && (a ? (a.seed = s[17],
                    xt._randomPointUnitSphere(t, a),
                    s[17] = a.seed) : xt._randomPointUnitSphere(t));
                    break;
                default:
                    throw new Error("ConeShape:emitType is invalid.");
                }
            }
        }, {
            key: "cloneTo",
            value: function(e) {
                _get(_getPrototypeOf(ConeShape.prototype), "cloneTo", this).call(this, e);
                var t = e;
                t.angle = this.angle,
                t.radius = this.radius,
                t.length = this.length,
                t.emitType = this.emitType,
                t.randomDirection = this.randomDirection;
            }
        }, {
            key: "clone",
            value: function() {
                var e = new ConeShape();
                return this.cloneTo(e),
                e;
            }
        }]),
        ConeShape;
    }();
    Lt._tempPositionPoint = new n(),
    Lt._tempDirectionPoint = new n();
    var Pt = function(e) {
        function HemisphereShape() {
            var e;
            return _classCallCheck(this, HemisphereShape),
            (e = _possibleConstructorReturn(this, _getPrototypeOf(HemisphereShape).call(this))).radius = 1,
            e.emitFromShell = !1,
            e;
        }
        return _inherits(HemisphereShape, Dt),
        _createClass(HemisphereShape, [{
            key: "_getShapeBoundBox",
            value: function(e) {
                var t = e.min;
                t.x = t.y = t.z = -this.radius;
                var r = e.max;
                r.x = r.y = this.radius,
                r.z = 0;
            }
        }, {
            key: "_getSpeedBoundBox",
            value: function(e) {
                var t = e.min;
                t.x = t.y = -1,
                t.z = 0;
                var r = e.max;
                r.x = r.y = r.z = 1;
            }
        }, {
            key: "generatePositionAndDirection",
            value: function(e, t) {
                var r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null
                  , n = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : null;
                r ? (r.seed = n[16],
                this.emitFromShell ? xt._randomPointUnitSphere(e, r) : xt._randomPointInsideUnitSphere(e, r),
                n[16] = r.seed) : this.emitFromShell ? xt._randomPointUnitSphere(e) : xt._randomPointInsideUnitSphere(e),
                o.scale(e, this.radius, e);
                var i = e.z;
                i < 0 && (e.z = -1 * i),
                this.randomDirection ? r ? (r.seed = n[17],
                xt._randomPointUnitSphere(t, r),
                n[17] = r.seed) : xt._randomPointUnitSphere(t) : e.cloneTo(t);
            }
        }, {
            key: "cloneTo",
            value: function(e) {
                _get(_getPrototypeOf(HemisphereShape.prototype), "cloneTo", this).call(this, e);
                var t = e;
                t.radius = this.radius,
                t.emitFromShell = this.emitFromShell,
                t.randomDirection = this.randomDirection;
            }
        }, {
            key: "clone",
            value: function() {
                var e = new HemisphereShape();
                return this.cloneTo(e),
                e;
            }
        }]),
        HemisphereShape;
    }()
      , Ot = function(e) {
        function SphereShape() {
            var e;
            return _classCallCheck(this, SphereShape),
            (e = _possibleConstructorReturn(this, _getPrototypeOf(SphereShape).call(this))).radius = 1,
            e.emitFromShell = !1,
            e;
        }
        return _inherits(SphereShape, Dt),
        _createClass(SphereShape, [{
            key: "_getShapeBoundBox",
            value: function(e) {
                var t = e.min;
                t.x = t.y = t.z = -this.radius;
                var r = e.max;
                r.x = r.y = r.z = this.radius;
            }
        }, {
            key: "_getSpeedBoundBox",
            value: function(e) {
                var t = e.min;
                t.x = t.y = t.z = -1;
                var r = e.max;
                r.x = r.y = r.z = 1;
            }
        }, {
            key: "generatePositionAndDirection",
            value: function(e, t) {
                var r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null
                  , n = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : null;
                r ? (r.seed = n[16],
                this.emitFromShell ? xt._randomPointUnitSphere(e, r) : xt._randomPointInsideUnitSphere(e, r),
                n[16] = r.seed) : this.emitFromShell ? xt._randomPointUnitSphere(e) : xt._randomPointInsideUnitSphere(e),
                o.scale(e, this.radius, e),
                this.randomDirection ? r ? (r.seed = n[17],
                xt._randomPointUnitSphere(t, r),
                n[17] = r.seed) : xt._randomPointUnitSphere(t) : e.cloneTo(t);
            }
        }, {
            key: "cloneTo",
            value: function(e) {
                _get(_getPrototypeOf(SphereShape.prototype), "cloneTo", this).call(this, e);
                var t = e;
                t.radius = this.radius,
                t.emitFromShell = this.emitFromShell,
                t.randomDirection = this.randomDirection;
            }
        }, {
            key: "clone",
            value: function() {
                var e = new SphereShape();
                return this.cloneTo(e),
                e;
            }
        }]),
        SphereShape;
    }()
      , Nt = function() {
        function SizeOverLifetime(e) {
            _classCallCheck(this, SizeOverLifetime),
            this._size = e;
        }
        return _createClass(SizeOverLifetime, [{
            key: "size",
            get: function() {
                return this._size;
            }
        }]),
        _createClass(SizeOverLifetime, [{
            key: "cloneTo",
            value: function(e) {
                var t = e;
                this._size.cloneTo(t._size),
                t.enable = this.enable;
            }
        }, {
            key: "clone",
            value: function() {
                var e;
                switch (this._size.type) {
                case 0:
                    e = this._size.separateAxes ? Rt.createByGradientSeparate(this._size.gradientX.clone(), this._size.gradientY.clone(), this._size.gradientZ.clone()) : Rt.createByGradient(this._size.gradient.clone());
                    break;
                case 1:
                    e = this._size.separateAxes ? Rt.createByRandomTwoConstantSeparate(this._size.constantMinSeparate.clone(), this._size.constantMaxSeparate.clone()) : Rt.createByRandomTwoConstant(this._size.constantMin, this._size.constantMax);
                    break;
                case 2:
                    e = this._size.separateAxes ? Rt.createByRandomTwoGradientSeparate(this._size.gradientXMin.clone(), this._size.gradientYMin.clone(), this._size.gradientZMin.clone(), this._size.gradientXMax.clone(), this._size.gradientYMax.clone(), this._size.gradientZMax.clone()) : Rt.createByRandomTwoGradient(this._size.gradientMin.clone(), this._size.gradientMax.clone());
                }
                var t = new SizeOverLifetime(e);
                return t.enable = this.enable,
                t;
            }
        }]),
        SizeOverLifetime;
    }()
      , bt = function() {
        function StartFrame() {
            _classCallCheck(this, StartFrame),
            this._type = 0,
            this._constant = 0,
            this._constantMin = 0,
            this._constantMax = 0;
        }
        return _createClass(StartFrame, [{
            key: "cloneTo",
            value: function(e) {
                var t = e;
                t._type = this._type,
                t._constant = this._constant,
                t._constantMin = this._constantMin,
                t._constantMax = this._constantMax;
            }
        }, {
            key: "clone",
            value: function() {
                var e = new StartFrame();
                return this.cloneTo(e),
                e;
            }
        }, {
            key: "type",
            get: function() {
                return this._type;
            }
        }, {
            key: "constant",
            get: function() {
                return this._constant;
            }
        }, {
            key: "constantMin",
            get: function() {
                return this._constantMin;
            }
        }, {
            key: "constantMax",
            get: function() {
                return this._constantMax;
            }
        }], [{
            key: "createByConstant",
            value: function() {
                var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0
                  , t = new StartFrame();
                return t._type = 0,
                t._constant = e,
                t;
            }
        }, {
            key: "createByRandomTwoConstant",
            value: function() {
                var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0
                  , t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0
                  , r = new StartFrame();
                return r._type = 1,
                r._constantMin = e,
                r._constantMax = t,
                r;
            }
        }]),
        StartFrame;
    }()
      , kt = function() {
        function TextureSheetAnimation(e, t) {
            _classCallCheck(this, TextureSheetAnimation),
            this.type = 0,
            this.randomRow = !1,
            this.rowIndex = 0,
            this.cycles = 0,
            this.enableUVChannels = 0,
            this.enable = !1,
            this.tiles = new n(1,1),
            this.type = 0,
            this.randomRow = !0,
            this.rowIndex = 0,
            this.cycles = 1,
            this.enableUVChannels = 1,
            this._frame = e,
            this._startFrame = t;
        }
        return _createClass(TextureSheetAnimation, [{
            key: "cloneTo",
            value: function(e) {
                var t = e;
                this.tiles.cloneTo(t.tiles),
                t.type = this.type,
                t.randomRow = this.randomRow,
                t.rowIndex = this.rowIndex,
                t.cycles = this.cycles,
                t.enableUVChannels = this.enableUVChannels,
                t.enable = this.enable,
                this._frame.cloneTo(t._frame),
                this._startFrame.cloneTo(t._startFrame);
            }
        }, {
            key: "clone",
            value: function() {
                var e, t;
                switch (this._frame.type) {
                case 0:
                    e = Et.createByConstant(this._frame.constant);
                    break;
                case 1:
                    e = Et.createByOverTime(this._frame.frameOverTimeData.clone());
                    break;
                case 2:
                    e = Et.createByRandomTwoConstant(this._frame.constantMin, this._frame.constantMax);
                    break;
                case 3:
                    e = Et.createByRandomTwoOverTime(this._frame.frameOverTimeDataMin.clone(), this._frame.frameOverTimeDataMax.clone());
                }
                switch (this._startFrame.type) {
                case 0:
                    t = bt.createByConstant(this._startFrame.constant);
                    break;
                case 1:
                    t = bt.createByRandomTwoConstant(this._startFrame.constantMin, this._startFrame.constantMax);
                }
                var r = new TextureSheetAnimation(e,t);
                return this.cloneTo(r),
                r;
            }
        }, {
            key: "frame",
            get: function() {
                return this._frame;
            }
        }, {
            key: "startFrame",
            get: function() {
                return this._startFrame;
            }
        }]),
        TextureSheetAnimation;
    }()
      , Vt = function() {
        function VelocityOverLifetime(e) {
            _classCallCheck(this, VelocityOverLifetime),
            this.enable = !1,
            this.space = 0,
            this._velocity = e;
        }
        return _createClass(VelocityOverLifetime, [{
            key: "cloneTo",
            value: function(e) {
                var t = e;
                this._velocity.cloneTo(t._velocity),
                t.enable = this.enable,
                t.space = this.space;
            }
        }, {
            key: "clone",
            value: function() {
                var e;
                switch (this._velocity.type) {
                case 0:
                    e = Ct.createByConstant(this._velocity.constant.clone());
                    break;
                case 1:
                    e = Ct.createByGradient(this._velocity.gradientX.clone(), this._velocity.gradientY.clone(), this._velocity.gradientZ.clone());
                    break;
                case 2:
                    e = Ct.createByRandomTwoConstant(this._velocity.constantMin.clone(), this._velocity.constantMax.clone());
                    break;
                case 3:
                    e = Ct.createByRandomTwoGradient(this._velocity.gradientXMin.clone(), this._velocity.gradientYMin.clone(), this._velocity.gradientZMin.clone(), this._velocity.gradientXMax.clone(), this._velocity.gradientYMax.clone(), this._velocity.gradientZMax.clone());
                }
                var t = new VelocityOverLifetime(e);
                return t.enable = this.enable,
                t.space = this.space,
                t;
            }
        }, {
            key: "velocity",
            get: function() {
                return this._velocity;
            }
        }]),
        VelocityOverLifetime;
    }()
      , Bt = function ShuriKenParticle3DShaderDeclaration() {
        _classCallCheck(this, ShuriKenParticle3DShaderDeclaration);
    };
    Bt.WORLDPOSITION = G.propertyNameToID("u_WorldPosition"),
    Bt.WORLDROTATION = G.propertyNameToID("u_WorldRotation"),
    Bt.POSITIONSCALE = G.propertyNameToID("u_PositionScale"),
    Bt.SIZESCALE = G.propertyNameToID("u_SizeScale"),
    Bt.SCALINGMODE = G.propertyNameToID("u_ScalingMode"),
    Bt.GRAVITY = G.propertyNameToID("u_Gravity"),
    Bt.THREEDSTARTROTATION = G.propertyNameToID("u_ThreeDStartRotation"),
    Bt.STRETCHEDBILLBOARDLENGTHSCALE = G.propertyNameToID("u_StretchedBillboardLengthScale"),
    Bt.STRETCHEDBILLBOARDSPEEDSCALE = G.propertyNameToID("u_StretchedBillboardSpeedScale"),
    Bt.SIMULATIONSPACE = G.propertyNameToID("u_SimulationSpace"),
    Bt.CURRENTTIME = G.propertyNameToID("u_CurrentTime"),
    Bt.VOLVELOCITYCONST = G.propertyNameToID("u_VOLVelocityConst"),
    Bt.VOLVELOCITYGRADIENTX = G.propertyNameToID("u_VOLVelocityGradientX"),
    Bt.VOLVELOCITYGRADIENTY = G.propertyNameToID("u_VOLVelocityGradientY"),
    Bt.VOLVELOCITYGRADIENTZ = G.propertyNameToID("u_VOLVelocityGradientZ"),
    Bt.VOLVELOCITYCONSTMAX = G.propertyNameToID("u_VOLVelocityConstMax"),
    Bt.VOLVELOCITYGRADIENTXMAX = G.propertyNameToID("u_VOLVelocityGradientMaxX"),
    Bt.VOLVELOCITYGRADIENTYMAX = G.propertyNameToID("u_VOLVelocityGradientMaxY"),
    Bt.VOLVELOCITYGRADIENTZMAX = G.propertyNameToID("u_VOLVelocityGradientMaxZ"),
    Bt.VOLSPACETYPE = G.propertyNameToID("u_VOLSpaceType"),
    Bt.COLOROVERLIFEGRADIENTALPHAS = G.propertyNameToID("u_ColorOverLifeGradientAlphas"),
    Bt.COLOROVERLIFEGRADIENTCOLORS = G.propertyNameToID("u_ColorOverLifeGradientColors"),
    Bt.MAXCOLOROVERLIFEGRADIENTALPHAS = G.propertyNameToID("u_MaxColorOverLifeGradientAlphas"),
    Bt.MAXCOLOROVERLIFEGRADIENTCOLORS = G.propertyNameToID("u_MaxColorOverLifeGradientColors"),
    Bt.SOLSIZEGRADIENT = G.propertyNameToID("u_SOLSizeGradient"),
    Bt.SOLSIZEGRADIENTX = G.propertyNameToID("u_SOLSizeGradientX"),
    Bt.SOLSIZEGRADIENTY = G.propertyNameToID("u_SOLSizeGradientY"),
    Bt.SOLSizeGradientZ = G.propertyNameToID("u_SOLSizeGradientZ"),
    Bt.SOLSizeGradientMax = G.propertyNameToID("u_SOLSizeGradientMax"),
    Bt.SOLSIZEGRADIENTXMAX = G.propertyNameToID("u_SOLSizeGradientMaxX"),
    Bt.SOLSIZEGRADIENTYMAX = G.propertyNameToID("u_SOLSizeGradientMaxY"),
    Bt.SOLSizeGradientZMAX = G.propertyNameToID("u_SOLSizeGradientMaxZ"),
    Bt.ROLANGULARVELOCITYCONST = G.propertyNameToID("u_ROLAngularVelocityConst"),
    Bt.ROLANGULARVELOCITYCONSTSEPRARATE = G.propertyNameToID("u_ROLAngularVelocityConstSeprarate"),
    Bt.ROLANGULARVELOCITYGRADIENT = G.propertyNameToID("u_ROLAngularVelocityGradient"),
    Bt.ROLANGULARVELOCITYGRADIENTX = G.propertyNameToID("u_ROLAngularVelocityGradientX"),
    Bt.ROLANGULARVELOCITYGRADIENTY = G.propertyNameToID("u_ROLAngularVelocityGradientY"),
    Bt.ROLANGULARVELOCITYGRADIENTZ = G.propertyNameToID("u_ROLAngularVelocityGradientZ"),
    Bt.ROLANGULARVELOCITYCONSTMAX = G.propertyNameToID("u_ROLAngularVelocityConstMax"),
    Bt.ROLANGULARVELOCITYCONSTMAXSEPRARATE = G.propertyNameToID("u_ROLAngularVelocityConstMaxSeprarate"),
    Bt.ROLANGULARVELOCITYGRADIENTMAX = G.propertyNameToID("u_ROLAngularVelocityGradientMax"),
    Bt.ROLANGULARVELOCITYGRADIENTXMAX = G.propertyNameToID("u_ROLAngularVelocityGradientMaxX"),
    Bt.ROLANGULARVELOCITYGRADIENTYMAX = G.propertyNameToID("u_ROLAngularVelocityGradientMaxY"),
    Bt.ROLANGULARVELOCITYGRADIENTZMAX = G.propertyNameToID("u_ROLAngularVelocityGradientMaxZ"),
    Bt.ROLANGULARVELOCITYGRADIENTWMAX = G.propertyNameToID("u_ROLAngularVelocityGradientMaxW"),
    Bt.TEXTURESHEETANIMATIONCYCLES = G.propertyNameToID("u_TSACycles"),
    Bt.TEXTURESHEETANIMATIONSUBUVLENGTH = G.propertyNameToID("u_TSASubUVLength"),
    Bt.TEXTURESHEETANIMATIONGRADIENTUVS = G.propertyNameToID("u_TSAGradientUVs"),
    Bt.TEXTURESHEETANIMATIONGRADIENTMAXUVS = G.propertyNameToID("u_TSAMaxGradientUVs");
    var wt = function(e) {
        function ShurikenParticleMaterial() {
            var e;
            return _classCallCheck(this, ShurikenParticleMaterial),
            (e = _possibleConstructorReturn(this, _getPrototypeOf(ShurikenParticleMaterial).call(this))).setShaderName("PARTICLESHURIKEN"),
            e._color = new i(1,1,1,1),
            e.renderMode = ShurikenParticleMaterial.RENDERMODE_ALPHABLENDED,
            e;
        }
        return _inherits(ShurikenParticleMaterial, Z),
        _createClass(ShurikenParticleMaterial, [{
            key: "clone",
            value: function() {
                var e = new ShurikenParticleMaterial();
                return this.cloneTo(e),
                e;
            }
        }, {
            key: "_TintColorR",
            get: function() {
                return this._color.x;
            },
            set: function(e) {
                this._color.x = e,
                this.color = this._color;
            }
        }, {
            key: "_TintColorG",
            get: function() {
                return this._color.y;
            },
            set: function(e) {
                this._color.y = e,
                this.color = this._color;
            }
        }, {
            key: "_TintColorB",
            get: function() {
                return this._color.z;
            },
            set: function(e) {
                this._color.z = e,
                this.color = this._color;
            }
        }, {
            key: "_TintColorA",
            get: function() {
                return this._color.w;
            },
            set: function(e) {
                this._color.w = e,
                this.color = this._color;
            }
        }, {
            key: "_MainTex_STX",
            get: function() {
                return this._shaderValues.getVector(ShurikenParticleMaterial.TILINGOFFSET).x;
            },
            set: function(e) {
                var t = this._shaderValues.getVector(ShurikenParticleMaterial.TILINGOFFSET);
                t.x = e,
                this.tilingOffset = t;
            }
        }, {
            key: "_MainTex_STY",
            get: function() {
                return this._shaderValues.getVector(ShurikenParticleMaterial.TILINGOFFSET).y;
            },
            set: function(e) {
                var t = this._shaderValues.getVector(ShurikenParticleMaterial.TILINGOFFSET);
                t.y = e,
                this.tilingOffset = t;
            }
        }, {
            key: "_MainTex_STZ",
            get: function() {
                return this._shaderValues.getVector(ShurikenParticleMaterial.TILINGOFFSET).z;
            },
            set: function(e) {
                var t = this._shaderValues.getVector(ShurikenParticleMaterial.TILINGOFFSET);
                t.z = e,
                this.tilingOffset = t;
            }
        }, {
            key: "_MainTex_STW",
            get: function() {
                return this._shaderValues.getVector(ShurikenParticleMaterial.TILINGOFFSET).w;
            },
            set: function(e) {
                var t = this._shaderValues.getVector(ShurikenParticleMaterial.TILINGOFFSET);
                t.w = e,
                this.tilingOffset = t;
            }
        }, {
            key: "renderMode",
            set: function(e) {
                switch (e) {
                case ShurikenParticleMaterial.RENDERMODE_ADDTIVE:
                    this.renderQueue = Z.RENDERQUEUE_TRANSPARENT,
                    this.depthWrite = !1,
                    this.cull = Q.CULL_NONE,
                    this.blend = Q.BLEND_ENABLE_ALL,
                    this.blendSrc = Q.BLENDPARAM_SRC_ALPHA,
                    this.blendDst = Q.BLENDPARAM_ONE,
                    this.alphaTest = !1,
                    this._shaderValues.addDefine(ShurikenParticleMaterial.SHADERDEFINE_ADDTIVEFOG);
                    break;
                case ShurikenParticleMaterial.RENDERMODE_ALPHABLENDED:
                    this.renderQueue = Z.RENDERQUEUE_TRANSPARENT,
                    this.depthWrite = !1,
                    this.cull = Q.CULL_NONE,
                    this.blend = Q.BLEND_ENABLE_ALL,
                    this.blendSrc = Q.BLENDPARAM_SRC_ALPHA,
                    this.blendDst = Q.BLENDPARAM_ONE_MINUS_SRC_ALPHA,
                    this.alphaTest = !1,
                    this._shaderValues.removeDefine(ShurikenParticleMaterial.SHADERDEFINE_ADDTIVEFOG);
                    break;
                default:
                    throw new Error("ShurikenParticleMaterial : renderMode value error.");
                }
            }
        }, {
            key: "colorR",
            get: function() {
                return this._TintColorR;
            },
            set: function(e) {
                this._TintColorR = e;
            }
        }, {
            key: "colorG",
            get: function() {
                return this._TintColorG;
            },
            set: function(e) {
                this._TintColorG = e;
            }
        }, {
            key: "colorB",
            get: function() {
                return this._TintColorB;
            },
            set: function(e) {
                this._TintColorB = e;
            }
        }, {
            key: "colorA",
            get: function() {
                return this._TintColorA;
            },
            set: function(e) {
                this._TintColorA = e;
            }
        }, {
            key: "color",
            get: function() {
                return this._shaderValues.getVector(ShurikenParticleMaterial.TINTCOLOR);
            },
            set: function(e) {
                e ? this._shaderValues.addDefine(ShurikenParticleMaterial.SHADERDEFINE_TINTCOLOR) : this._shaderValues.removeDefine(ShurikenParticleMaterial.SHADERDEFINE_TINTCOLOR),
                this._shaderValues.setVector(ShurikenParticleMaterial.TINTCOLOR, e);
            }
        }, {
            key: "tilingOffsetX",
            get: function() {
                return this._MainTex_STX;
            },
            set: function(e) {
                this._MainTex_STX = e;
            }
        }, {
            key: "tilingOffsetY",
            get: function() {
                return this._MainTex_STY;
            },
            set: function(e) {
                this._MainTex_STY = e;
            }
        }, {
            key: "tilingOffsetZ",
            get: function() {
                return this._MainTex_STZ;
            },
            set: function(e) {
                this._MainTex_STZ = e;
            }
        }, {
            key: "tilingOffsetW",
            get: function() {
                return this._MainTex_STW;
            },
            set: function(e) {
                this._MainTex_STW = e;
            }
        }, {
            key: "tilingOffset",
            get: function() {
                return this._shaderValues.getVector(ShurikenParticleMaterial.TILINGOFFSET);
            },
            set: function(e) {
                e && (1 != e.x || 1 != e.y || 0 != e.z || 0 != e.w) ? this._shaderValues.addDefine(ShurikenParticleMaterial.SHADERDEFINE_TILINGOFFSET) : this._shaderValues.removeDefine(ShurikenParticleMaterial.SHADERDEFINE_TILINGOFFSET),
                this._shaderValues.setVector(ShurikenParticleMaterial.TILINGOFFSET, e);
            }
        }, {
            key: "texture",
            get: function() {
                return this._shaderValues.getTexture(ShurikenParticleMaterial.DIFFUSETEXTURE);
            },
            set: function(e) {
                e ? this._shaderValues.addDefine(ShurikenParticleMaterial.SHADERDEFINE_DIFFUSEMAP) : this._shaderValues.removeDefine(ShurikenParticleMaterial.SHADERDEFINE_DIFFUSEMAP),
                this._shaderValues.setTexture(ShurikenParticleMaterial.DIFFUSETEXTURE, e);
            }
        }, {
            key: "depthWrite",
            get: function() {
                return this._shaderValues.getBool(ShurikenParticleMaterial.DEPTH_WRITE);
            },
            set: function(e) {
                this._shaderValues.setBool(ShurikenParticleMaterial.DEPTH_WRITE, e);
            }
        }, {
            key: "cull",
            get: function() {
                return this._shaderValues.getInt(ShurikenParticleMaterial.CULL);
            },
            set: function(e) {
                this._shaderValues.setInt(ShurikenParticleMaterial.CULL, e);
            }
        }, {
            key: "blend",
            get: function() {
                return this._shaderValues.getInt(ShurikenParticleMaterial.BLEND);
            },
            set: function(e) {
                this._shaderValues.setInt(ShurikenParticleMaterial.BLEND, e);
            }
        }, {
            key: "blendSrc",
            get: function() {
                return this._shaderValues.getInt(ShurikenParticleMaterial.BLEND_SRC);
            },
            set: function(e) {
                this._shaderValues.setInt(ShurikenParticleMaterial.BLEND_SRC, e);
            }
        }, {
            key: "blendDst",
            get: function() {
                return this._shaderValues.getInt(ShurikenParticleMaterial.BLEND_DST);
            },
            set: function(e) {
                this._shaderValues.setInt(ShurikenParticleMaterial.BLEND_DST, e);
            }
        }, {
            key: "depthTest",
            get: function() {
                return this._shaderValues.getInt(ShurikenParticleMaterial.DEPTH_TEST);
            },
            set: function(e) {
                this._shaderValues.setInt(ShurikenParticleMaterial.DEPTH_TEST, e);
            }
        }], [{
            key: "__initDefine__",
            value: function() {
                ShurikenParticleMaterial.SHADERDEFINE_DIFFUSEMAP = G.getDefineByName("DIFFUSEMAP"),
                ShurikenParticleMaterial.SHADERDEFINE_TINTCOLOR = G.getDefineByName("TINTCOLOR"),
                ShurikenParticleMaterial.SHADERDEFINE_ADDTIVEFOG = G.getDefineByName("ADDTIVEFOG"),
                ShurikenParticleMaterial.SHADERDEFINE_TILINGOFFSET = G.getDefineByName("TILINGOFFSET");
            }
        }]),
        ShurikenParticleMaterial;
    }();
    wt.RENDERMODE_ALPHABLENDED = 0,
    wt.RENDERMODE_ADDTIVE = 1,
    wt.DIFFUSETEXTURE = G.propertyNameToID("u_texture"),
    wt.TINTCOLOR = G.propertyNameToID("u_Tintcolor"),
    wt.TILINGOFFSET = G.propertyNameToID("u_TilingOffset"),
    wt.CULL = G.propertyNameToID("s_Cull"),
    wt.BLEND = G.propertyNameToID("s_Blend"),
    wt.BLEND_SRC = G.propertyNameToID("s_BlendSrc"),
    wt.BLEND_DST = G.propertyNameToID("s_BlendDst"),
    wt.DEPTH_TEST = G.propertyNameToID("s_DepthTest"),
    wt.DEPTH_WRITE = G.propertyNameToID("s_DepthWrite");
    var Ft = function() {
        function Physics3DUtils() {
            _classCallCheck(this, Physics3DUtils);
        }
        return _createClass(Physics3DUtils, null, [{
            key: "setColliderCollision",
            value: function(e, t, r) {}
        }, {
            key: "getIColliderCollision",
            value: function(e, t) {
                return !1;
            }
        }]),
        Physics3DUtils;
    }();
    Ft.COLLISIONFILTERGROUP_DEFAULTFILTER = 1,
    Ft.COLLISIONFILTERGROUP_STATICFILTER = 2,
    Ft.COLLISIONFILTERGROUP_KINEMATICFILTER = 4,
    Ft.COLLISIONFILTERGROUP_DEBRISFILTER = 8,
    Ft.COLLISIONFILTERGROUP_SENSORTRIGGER = 16,
    Ft.COLLISIONFILTERGROUP_CHARACTERFILTER = 32,
    Ft.COLLISIONFILTERGROUP_CUSTOMFILTER1 = 64,
    Ft.COLLISIONFILTERGROUP_CUSTOMFILTER2 = 128,
    Ft.COLLISIONFILTERGROUP_CUSTOMFILTER3 = 256,
    Ft.COLLISIONFILTERGROUP_CUSTOMFILTER4 = 512,
    Ft.COLLISIONFILTERGROUP_CUSTOMFILTER5 = 1024,
    Ft.COLLISIONFILTERGROUP_CUSTOMFILTER6 = 2048,
    Ft.COLLISIONFILTERGROUP_CUSTOMFILTER7 = 4096,
    Ft.COLLISIONFILTERGROUP_CUSTOMFILTER8 = 8192,
    Ft.COLLISIONFILTERGROUP_CUSTOMFILTER9 = 16384,
    Ft.COLLISIONFILTERGROUP_CUSTOMFILTER10 = 32768,
    Ft.COLLISIONFILTERGROUP_ALLFILTER = -1,
    Ft.gravity = new o(0,-9.81,0);
    var Ut = function(e) {
        function ShurikenParticleRenderer(e) {
            var t;
            return _classCallCheck(this, ShurikenParticleRenderer),
            (t = _possibleConstructorReturn(this, _getPrototypeOf(ShurikenParticleRenderer).call(this, e)))._finalGravity = new o(),
            t._tempRotationMatrix = new I(),
            t._mesh = null,
            t.stretchedBillboardCameraSpeedScale = 0,
            t.stretchedBillboardSpeedScale = 0,
            t.stretchedBillboardLengthScale = 2,
            t._defaultBoundBox = new ot(new o(),new o()),
            t.renderMode = 0,
            t._supportOctree = !1,
            t;
        }
        return _inherits(ShurikenParticleRenderer, lt),
        _createClass(ShurikenParticleRenderer, [{
            key: "_calculateBoundingBox",
            value: function() {
                if ((e = this._bounds.getMin()).x = -Number.MAX_VALUE,
                e.y = -Number.MAX_VALUE,
                e.z = -Number.MAX_VALUE,
                this._bounds.setMin(e),
                (r = this._bounds.getMax()).x = Number.MAX_VALUE,
                r.y = Number.MAX_VALUE,
                r.z = Number.MAX_VALUE,
                this._bounds.setMax(r),
                t.Render.supportWebGLPlusCulling) {
                    var e = this._bounds.getMin()
                      , r = this._bounds.getMax()
                      , n = Re._cullingBuffer;
                    n[this._cullingBufferIndex + 1] = e.x,
                    n[this._cullingBufferIndex + 2] = e.y,
                    n[this._cullingBufferIndex + 3] = e.z,
                    n[this._cullingBufferIndex + 4] = r.x,
                    n[this._cullingBufferIndex + 5] = r.y,
                    n[this._cullingBufferIndex + 6] = r.z;
                }
            }
        }, {
            key: "_needRender",
            value: function(e, t) {
                return !e || !!e.intersects(this.bounds._getBoundBox()) && !!this._owner.particleSystem.isAlive;
            }
        }, {
            key: "_renderUpdate",
            value: function(e, t) {
                var r = this._owner.particleSystem
                  , n = this._shaderValues
                  , i = this._owner.transform;
                switch (r.simulationSpace) {
                case 0:
                    break;
                case 1:
                    n.setVector3(Bt.WORLDPOSITION, i.position),
                    n.setQuaternion(Bt.WORLDROTATION, i.rotation);
                    break;
                default:
                    throw new Error("ShurikenParticleMaterial: SimulationSpace value is invalid.");
                }
                switch (r.scaleMode) {
                case 0:
                    var a = i.getWorldLossyScale();
                    n.setVector3(Bt.POSITIONSCALE, a),
                    n.setVector3(Bt.SIZESCALE, a);
                    break;
                case 1:
                    var s = i.localScale;
                    n.setVector3(Bt.POSITIONSCALE, s),
                    n.setVector3(Bt.SIZESCALE, s);
                    break;
                case 2:
                    n.setVector3(Bt.POSITIONSCALE, i.getWorldLossyScale()),
                    n.setVector3(Bt.SIZESCALE, o._ONE);
                }
                o.scale(Ft.gravity, r.gravityModifier, this._finalGravity),
                n.setVector3(Bt.GRAVITY, this._finalGravity),
                n.setInt(Bt.SIMULATIONSPACE, r.simulationSpace),
                n.setBool(Bt.THREEDSTARTROTATION, r.threeDStartRotation),
                n.setInt(Bt.SCALINGMODE, r.scaleMode),
                n.setNumber(Bt.STRETCHEDBILLBOARDLENGTHSCALE, this.stretchedBillboardLengthScale),
                n.setNumber(Bt.STRETCHEDBILLBOARDSPEEDSCALE, this.stretchedBillboardSpeedScale),
                n.setNumber(Bt.CURRENTTIME, r._currentTime);
            }
        }, {
            key: "_destroy",
            value: function() {
                _get(_getPrototypeOf(ShurikenParticleRenderer.prototype), "_destroy", this).call(this),
                this._mesh && (this._mesh._removeReference(),
                this._mesh = null);
            }
        }, {
            key: "renderMode",
            get: function() {
                return this._renderMode;
            },
            set: function(e) {
                if (this._renderMode !== e) {
                    var t = this._shaderValues;
                    switch (this._renderMode) {
                    case 0:
                        t.removeDefine(Bt.SHADERDEFINE_RENDERMODE_BILLBOARD);
                        break;
                    case 1:
                        t.removeDefine(Bt.SHADERDEFINE_RENDERMODE_STRETCHEDBILLBOARD);
                        break;
                    case 2:
                        t.removeDefine(Bt.SHADERDEFINE_RENDERMODE_HORIZONTALBILLBOARD);
                        break;
                    case 3:
                        t.removeDefine(Bt.SHADERDEFINE_RENDERMODE_VERTICALBILLBOARD);
                        break;
                    case 4:
                        t.removeDefine(Bt.SHADERDEFINE_RENDERMODE_MESH);
                    }
                    switch (this._renderMode = e,
                    e) {
                    case 0:
                        t.addDefine(Bt.SHADERDEFINE_RENDERMODE_BILLBOARD);
                        break;
                    case 1:
                        t.addDefine(Bt.SHADERDEFINE_RENDERMODE_STRETCHEDBILLBOARD);
                        break;
                    case 2:
                        t.addDefine(Bt.SHADERDEFINE_RENDERMODE_HORIZONTALBILLBOARD);
                        break;
                    case 3:
                        t.addDefine(Bt.SHADERDEFINE_RENDERMODE_VERTICALBILLBOARD);
                        break;
                    case 4:
                        t.addDefine(Bt.SHADERDEFINE_RENDERMODE_MESH);
                        break;
                    default:
                        throw new Error("ShurikenParticleRender: unknown renderMode Value.");
                    }
                    var r = this._owner.particleSystem;
                    r && r._initBufferDatas();
                }
            }
        }, {
            key: "mesh",
            get: function() {
                return this._mesh;
            },
            set: function(e) {
                this._mesh !== e && (this._mesh && this._mesh._removeReference(),
                this._mesh = e,
                e && e._addReference(),
                this._owner.particleSystem._initBufferDatas());
            }
        }, {
            key: "bounds",
            get: function() {
                return this._boundsChange && (this._calculateBoundingBox(),
                this._boundsChange = !1),
                this._bounds;
            }
        }]),
        ShurikenParticleRenderer;
    }()
      , Gt = function VertexShuriKenParticle() {
        _classCallCheck(this, VertexShuriKenParticle);
    };
    Gt.PARTICLE_CORNERTEXTURECOORDINATE0 = 0,
    Gt.PARTICLE_POSITION0 = 1,
    Gt.PARTICLE_COLOR0 = 2,
    Gt.PARTICLE_TEXTURECOORDINATE0 = 3,
    Gt.PARTICLE_SHAPEPOSITIONSTARTLIFETIME = 4,
    Gt.PARTICLE_DIRECTIONTIME = 5,
    Gt.PARTICLE_STARTCOLOR0 = 6,
    Gt.PARTICLE_ENDCOLOR0 = 7,
    Gt.PARTICLE_STARTSIZE = 8,
    Gt.PARTICLE_STARTROTATION = 9,
    Gt.PARTICLE_STARTSPEED = 10,
    Gt.PARTICLE_RANDOM0 = 11,
    Gt.PARTICLE_RANDOM1 = 12,
    Gt.PARTICLE_SIMULATIONWORLDPOSTION = 13,
    Gt.PARTICLE_SIMULATIONWORLDROTATION = 14;
    var zt = function(e) {
        function VertexShurikenParticleBillboard(e, t, r, n, i, a, o, s, l, u, c, h, _, d) {
            var f;
            return _classCallCheck(this, VertexShurikenParticleBillboard),
            (f = _possibleConstructorReturn(this, _getPrototypeOf(VertexShurikenParticleBillboard).call(this)))._cornerTextureCoordinate = e,
            f._positionStartLifeTime = t,
            f._velocity = r,
            f._startColor = n,
            f._startSize = i,
            f._startRotation0 = a,
            f._startRotation1 = o,
            f._startRotation2 = s,
            f._startLifeTime = l,
            f._time = u,
            f._startSpeed = c,
            f._randoms0 = f.random0,
            f._randoms1 = f.random1,
            f._simulationWorldPostion = d,
            f;
        }
        return _inherits(VertexShurikenParticleBillboard, Gt),
        _createClass(VertexShurikenParticleBillboard, [{
            key: "cornerTextureCoordinate",
            get: function() {
                return this._cornerTextureCoordinate;
            }
        }, {
            key: "positionStartLifeTime",
            get: function() {
                return this._positionStartLifeTime;
            }
        }, {
            key: "velocity",
            get: function() {
                return this._velocity;
            }
        }, {
            key: "startColor",
            get: function() {
                return this._startColor;
            }
        }, {
            key: "startSize",
            get: function() {
                return this._startSize;
            }
        }, {
            key: "startRotation0",
            get: function() {
                return this._startRotation0;
            }
        }, {
            key: "startRotation1",
            get: function() {
                return this._startRotation1;
            }
        }, {
            key: "startRotation2",
            get: function() {
                return this._startRotation2;
            }
        }, {
            key: "startLifeTime",
            get: function() {
                return this._startLifeTime;
            }
        }, {
            key: "time",
            get: function() {
                return this._time;
            }
        }, {
            key: "startSpeed",
            get: function() {
                return this._startSpeed;
            }
        }, {
            key: "random0",
            get: function() {
                return this._randoms0;
            }
        }, {
            key: "random1",
            get: function() {
                return this._randoms1;
            }
        }, {
            key: "simulationWorldPostion",
            get: function() {
                return this._simulationWorldPostion;
            }
        }], [{
            key: "__init__",
            value: function() {
                VertexShurikenParticleBillboard._vertexDeclaration = new oe(152,[new le(0,ae.Vector4,Gt.PARTICLE_CORNERTEXTURECOORDINATE0), new le(16,ae.Vector4,Gt.PARTICLE_SHAPEPOSITIONSTARTLIFETIME), new le(32,ae.Vector4,Gt.PARTICLE_DIRECTIONTIME), new le(48,ae.Vector4,Gt.PARTICLE_STARTCOLOR0), new le(64,ae.Vector3,Gt.PARTICLE_STARTSIZE), new le(76,ae.Vector3,Gt.PARTICLE_STARTROTATION), new le(88,ae.Single,Gt.PARTICLE_STARTSPEED), new le(92,ae.Vector4,Gt.PARTICLE_RANDOM0), new le(108,ae.Vector4,Gt.PARTICLE_RANDOM1), new le(124,ae.Vector3,Gt.PARTICLE_SIMULATIONWORLDPOSTION), new le(136,ae.Vector4,Gt.PARTICLE_SIMULATIONWORLDROTATION)]);
            }
        }, {
            key: "vertexDeclaration",
            get: function() {
                return VertexShurikenParticleBillboard._vertexDeclaration;
            }
        }]),
        VertexShurikenParticleBillboard;
    }()
      , Ht = function(e) {
        function VertexShurikenParticleMesh(e, t, r, n, i, a, o, s, l, u, c, h, _, d) {
            var f;
            return _classCallCheck(this, VertexShurikenParticleMesh),
            (f = _possibleConstructorReturn(this, _getPrototypeOf(VertexShurikenParticleMesh).call(this)))._cornerTextureCoordinate = e,
            f._positionStartLifeTime = t,
            f._velocity = r,
            f._startColor = n,
            f._startSize = i,
            f._startRotation0 = a,
            f._startRotation1 = o,
            f._startRotation2 = s,
            f._startLifeTime = l,
            f._time = u,
            f._startSpeed = c,
            f._randoms0 = f.random0,
            f._randoms1 = f.random1,
            f._simulationWorldPostion = d,
            f;
        }
        return _inherits(VertexShurikenParticleMesh, Gt),
        _createClass(VertexShurikenParticleMesh, [{
            key: "cornerTextureCoordinate",
            get: function() {
                return this._cornerTextureCoordinate;
            }
        }, {
            key: "position",
            get: function() {
                return this._positionStartLifeTime;
            }
        }, {
            key: "velocity",
            get: function() {
                return this._velocity;
            }
        }, {
            key: "startColor",
            get: function() {
                return this._startColor;
            }
        }, {
            key: "startSize",
            get: function() {
                return this._startSize;
            }
        }, {
            key: "startRotation0",
            get: function() {
                return this._startRotation0;
            }
        }, {
            key: "startRotation1",
            get: function() {
                return this._startRotation1;
            }
        }, {
            key: "startRotation2",
            get: function() {
                return this._startRotation2;
            }
        }, {
            key: "startLifeTime",
            get: function() {
                return this._startLifeTime;
            }
        }, {
            key: "time",
            get: function() {
                return this._time;
            }
        }, {
            key: "startSpeed",
            get: function() {
                return this._startSpeed;
            }
        }, {
            key: "random0",
            get: function() {
                return this._randoms0;
            }
        }, {
            key: "random1",
            get: function() {
                return this._randoms1;
            }
        }, {
            key: "simulationWorldPostion",
            get: function() {
                return this._simulationWorldPostion;
            }
        }], [{
            key: "__init__",
            value: function() {
                VertexShurikenParticleMesh._vertexDeclaration = new oe(172,[new le(0,ae.Vector3,Gt.PARTICLE_POSITION0), new le(12,ae.Vector4,Gt.PARTICLE_COLOR0), new le(28,ae.Vector2,Gt.PARTICLE_TEXTURECOORDINATE0), new le(36,ae.Vector4,Gt.PARTICLE_SHAPEPOSITIONSTARTLIFETIME), new le(52,ae.Vector4,Gt.PARTICLE_DIRECTIONTIME), new le(68,ae.Vector4,Gt.PARTICLE_STARTCOLOR0), new le(84,ae.Vector3,Gt.PARTICLE_STARTSIZE), new le(96,ae.Vector3,Gt.PARTICLE_STARTROTATION), new le(108,ae.Single,Gt.PARTICLE_STARTSPEED), new le(112,ae.Vector4,Gt.PARTICLE_RANDOM0), new le(128,ae.Vector4,Gt.PARTICLE_RANDOM1), new le(144,ae.Vector3,Gt.PARTICLE_SIMULATIONWORLDPOSTION), new le(156,ae.Vector4,Gt.PARTICLE_SIMULATIONWORLDROTATION)]);
            }
        }, {
            key: "vertexDeclaration",
            get: function() {
                return VertexShurikenParticleMesh._vertexDeclaration;
            }
        }]),
        VertexShurikenParticleMesh;
    }()
      , Wt = function() {
        function BoundSphere(e, t) {
            _classCallCheck(this, BoundSphere),
            this.center = e,
            this.radius = t;
        }
        return _createClass(BoundSphere, [{
            key: "toDefault",
            value: function() {
                this.center.toDefault(),
                this.radius = 0;
            }
        }, {
            key: "intersectsRayDistance",
            value: function(e) {
                return Ne.intersectsRayAndSphereRD(e, this);
            }
        }, {
            key: "intersectsRayPoint",
            value: function(e, t) {
                return Ne.intersectsRayAndSphereRP(e, this, t);
            }
        }, {
            key: "cloneTo",
            value: function(e) {
                var t = e;
                this.center.cloneTo(t.center),
                t.radius = this.radius;
            }
        }, {
            key: "clone",
            value: function() {
                var e = new BoundSphere(new o(),0);
                return this.cloneTo(e),
                e;
            }
        }], [{
            key: "createFromSubPoints",
            value: function(e, t, r, n) {
                if (null == e)
                    throw new Error("points");
                if (t < 0 || t >= e.length)
                    throw new Error("start" + t + "Must be in the range [0, " + (e.length - 1) + "]");
                if (r < 0 || t + r > e.length)
                    throw new Error("count" + r + "Must be in the range <= " + e.length + "}");
                var i = t + r
                  , a = BoundSphere._tempVector3;
                a.x = 0,
                a.y = 0,
                a.z = 0;
                for (var s = t; s < i; ++s)
                    o.add(e[s], a, a);
                var l = n.center;
                o.scale(a, 1 / r, l);
                var u = 0;
                for (s = t; s < i; ++s) {
                    var c = o.distanceSquared(l, e[s]);
                    c > u && (u = c);
                }
                n.radius = Math.sqrt(u);
            }
        }, {
            key: "createfromPoints",
            value: function(e, t) {
                if (null == e)
                    throw new Error("points");
                BoundSphere.createFromSubPoints(e, 0, e.length, t);
            }
        }]),
        BoundSphere;
    }();
    Wt._tempVector3 = new o();
    var Xt = function() {
        function Rand(e) {
            _classCallCheck(this, Rand),
            this._temp = new Uint32Array(1),
            this.seeds = new Uint32Array(4),
            this.seeds[0] = e,
            this.seeds[1] = 1812433253 * this.seeds[0] + 1,
            this.seeds[2] = 1812433253 * this.seeds[1] + 1,
            this.seeds[3] = 1812433253 * this.seeds[2] + 1;
        }
        return _createClass(Rand, [{
            key: "getUint",
            value: function() {
                return this._temp[0] = this.seeds[0] ^ this.seeds[0] << 11,
                this.seeds[0] = this.seeds[1],
                this.seeds[1] = this.seeds[2],
                this.seeds[2] = this.seeds[3],
                this.seeds[3] = this.seeds[3] ^ this.seeds[3] >>> 19 ^ this._temp[0] ^ this._temp[0] >>> 8,
                this.seeds[3];
            }
        }, {
            key: "getFloat",
            value: function() {
                return this.getUint(),
                (8388607 & this.seeds[3]) * (1 / 8388607);
            }
        }, {
            key: "getSignedFloat",
            value: function() {
                return 2 * this.getFloat() - 1;
            }
        }, {
            key: "seed",
            get: function() {
                return this.seeds[0];
            },
            set: function(e) {
                this.seeds[0] = e,
                this.seeds[1] = 1812433253 * this.seeds[0] + 1,
                this.seeds[2] = 1812433253 * this.seeds[1] + 1,
                this.seeds[3] = 1812433253 * this.seeds[2] + 1;
            }
        }], [{
            key: "getFloatFromInt",
            value: function(e) {
                return 1 / 8388607 * (8388607 & e);
            }
        }, {
            key: "getByteFromInt",
            value: function(e) {
                return (8388607 & e) >>> 15;
            }
        }]),
        Rand;
    }()
      , Yt = function() {
        function Emission() {
            _classCallCheck(this, Emission),
            this._emissionRate = 10,
            this._destroyed = !1,
            this._bursts = [];
        }
        return _createClass(Emission, [{
            key: "destroy",
            value: function() {
                this._bursts = null,
                this._destroyed = !0;
            }
        }, {
            key: "getBurstsCount",
            value: function() {
                return this._bursts.length;
            }
        }, {
            key: "getBurstByIndex",
            value: function(e) {
                return this._bursts[e];
            }
        }, {
            key: "addBurst",
            value: function(e) {
                var t = this._bursts.length;
                if (t > 0)
                    for (var r = 0; r < t; r++)
                        this._bursts[r].time > e.time && this._bursts.splice(r, 0, e);
                this._bursts.push(e);
            }
        }, {
            key: "removeBurst",
            value: function(e) {
                var t = this._bursts.indexOf(e);
                -1 !== t && this._bursts.splice(t, 1);
            }
        }, {
            key: "removeBurstByIndex",
            value: function(e) {
                this._bursts.splice(e, 1);
            }
        }, {
            key: "clearBurst",
            value: function() {
                this._bursts.length = 0;
            }
        }, {
            key: "cloneTo",
            value: function(e) {
                var t = e
                  , r = t._bursts;
                r.length = this._bursts.length;
                for (var n = 0, i = this._bursts.length; n < i; n++) {
                    var a = r[n];
                    a ? this._bursts[n].cloneTo(a) : r[n] = this._bursts[n].clone();
                }
                t._emissionRate = this._emissionRate,
                t.enable = this.enable;
            }
        }, {
            key: "clone",
            value: function() {
                var e = new Emission();
                return this.cloneTo(e),
                e;
            }
        }, {
            key: "emissionRate",
            set: function(e) {
                if (e < 0)
                    throw new Error("ParticleBaseShape:emissionRate value must large or equal than 0.");
                this._emissionRate = e;
            },
            get: function() {
                return this._emissionRate;
            }
        }, {
            key: "destroyed",
            get: function() {
                return this._destroyed;
            }
        }]),
        Emission;
    }()
      , Zt = function() {
        function ShurikenParticleData() {
            _classCallCheck(this, ShurikenParticleData);
        }
        return _createClass(ShurikenParticleData, null, [{
            key: "_getStartLifetimeFromGradient",
            value: function(e, r) {
                for (var n = 1, i = e.gradientCount; n < i; n++) {
                    var a = e.getKeyByIndex(n);
                    if (a >= r) {
                        var o = e.getKeyByIndex(n - 1)
                          , s = (r - o) / (a - o);
                        return t.MathUtil.lerp(e.getValueByIndex(n - 1), e.getValueByIndex(n), s);
                    }
                }
                throw new Error("ShurikenParticleData: can't get value foam startLifeTimeGradient.");
            }
        }, {
            key: "_randomInvertRoationArray",
            value: function(e, t, r, n, i) {
                var a;
                n ? (n.seed = i[6],
                a = n.getFloat(),
                i[6] = n.seed) : a = Math.random(),
                a < r ? (t.x = -e.x,
                t.y = -e.y,
                t.z = -e.z) : (t.x = e.x,
                t.y = e.y,
                t.z = e.z);
            }
        }, {
            key: "_randomInvertRoation",
            value: function(e, t, r, n) {
                var i;
                return r ? (r.seed = n[6],
                i = r.getFloat(),
                n[6] = r.seed) : i = Math.random(),
                i < t && (e = -e),
                e;
            }
        }, {
            key: "create",
            value: function(e, r, n) {
                var a = e.autoRandomSeed
                  , o = e._rand
                  , s = e._randomSeeds;
                switch (e.startColorType) {
                case 0:
                    var l = e.startColorConstant;
                    ShurikenParticleData.startColor.x = l.x,
                    ShurikenParticleData.startColor.y = l.y,
                    ShurikenParticleData.startColor.z = l.z,
                    ShurikenParticleData.startColor.w = l.w;
                    break;
                case 2:
                    a ? i.lerp(e.startColorConstantMin, e.startColorConstantMax, Math.random(), ShurikenParticleData.startColor) : (o.seed = s[3],
                    i.lerp(e.startColorConstantMin, e.startColorConstantMax, o.getFloat(), ShurikenParticleData.startColor),
                    s[3] = o.seed);
                }
                var u = e.colorOverLifetime;
                if (u && u.enable) {
                    var c = u.color;
                    switch (c.type) {
                    case 0:
                        ShurikenParticleData.startColor.x = ShurikenParticleData.startColor.x * c.constant.x,
                        ShurikenParticleData.startColor.y = ShurikenParticleData.startColor.y * c.constant.y,
                        ShurikenParticleData.startColor.z = ShurikenParticleData.startColor.z * c.constant.z,
                        ShurikenParticleData.startColor.w = ShurikenParticleData.startColor.w * c.constant.w;
                        break;
                    case 2:
                        var h;
                        a ? h = Math.random() : (o.seed = s[10],
                        h = o.getFloat(),
                        s[10] = o.seed);
                        var _ = c.constantMin
                          , d = c.constantMax;
                        ShurikenParticleData.startColor.x = ShurikenParticleData.startColor.x * t.MathUtil.lerp(_.x, d.x, h),
                        ShurikenParticleData.startColor.y = ShurikenParticleData.startColor.y * t.MathUtil.lerp(_.y, d.y, h),
                        ShurikenParticleData.startColor.z = ShurikenParticleData.startColor.z * t.MathUtil.lerp(_.z, d.z, h),
                        ShurikenParticleData.startColor.w = ShurikenParticleData.startColor.w * t.MathUtil.lerp(_.w, d.w, h);
                    }
                }
                var f = ShurikenParticleData.startSize;
                switch (e.startSizeType) {
                case 0:
                    if (e.threeDStartSize) {
                        var m = e.startSizeConstantSeparate;
                        f[0] = m.x,
                        f[1] = m.y,
                        f[2] = m.z;
                    } else
                        f[0] = f[1] = f[2] = e.startSizeConstant;
                    break;
                case 2:
                    if (e.threeDStartSize) {
                        var p = e.startSizeConstantMinSeparate
                          , v = e.startSizeConstantMaxSeparate;
                        a ? (f[0] = t.MathUtil.lerp(p.x, v.x, Math.random()),
                        f[1] = t.MathUtil.lerp(p.y, v.y, Math.random()),
                        f[2] = t.MathUtil.lerp(p.z, v.z, Math.random())) : (o.seed = s[4],
                        f[0] = t.MathUtil.lerp(p.x, v.x, o.getFloat()),
                        f[1] = t.MathUtil.lerp(p.y, v.y, o.getFloat()),
                        f[2] = t.MathUtil.lerp(p.z, v.z, o.getFloat()),
                        s[4] = o.seed);
                    } else
                        a ? f[0] = f[1] = f[2] = t.MathUtil.lerp(e.startSizeConstantMin, e.startSizeConstantMax, Math.random()) : (o.seed = s[4],
                        f[0] = f[1] = f[2] = t.MathUtil.lerp(e.startSizeConstantMin, e.startSizeConstantMax, o.getFloat()),
                        s[4] = o.seed);
                }
                var T = e.sizeOverLifetime;
                if (T && T.enable && 1 === T.size.type) {
                    var E, y = T.size;
                    if (y.separateAxes)
                        a ? (f[0] = f[0] * t.MathUtil.lerp(y.constantMinSeparate.x, y.constantMaxSeparate.x, Math.random()),
                        f[1] = f[1] * t.MathUtil.lerp(y.constantMinSeparate.y, y.constantMaxSeparate.y, Math.random()),
                        f[2] = f[2] * t.MathUtil.lerp(y.constantMinSeparate.z, y.constantMaxSeparate.z, Math.random())) : (o.seed = s[11],
                        f[0] = f[0] * t.MathUtil.lerp(y.constantMinSeparate.x, y.constantMaxSeparate.x, o.getFloat()),
                        f[1] = f[1] * t.MathUtil.lerp(y.constantMinSeparate.y, y.constantMaxSeparate.y, o.getFloat()),
                        f[2] = f[2] * t.MathUtil.lerp(y.constantMinSeparate.z, y.constantMaxSeparate.z, o.getFloat()),
                        s[11] = o.seed);
                    else
                        a ? E = t.MathUtil.lerp(y.constantMin, y.constantMax, Math.random()) : (o.seed = s[11],
                        E = t.MathUtil.lerp(y.constantMin, y.constantMax, o.getFloat()),
                        s[11] = o.seed),
                        f[0] = f[0] * E,
                        f[1] = f[1] * E,
                        f[2] = f[2] * E;
                }
                var g = r.renderMode;
                if (1 !== g)
                    switch (e.startRotationType) {
                    case 0:
                        if (e.threeDStartRotation) {
                            var S = e.startRotationConstantSeparate
                              , R = ShurikenParticleData._tempVector30;
                            ShurikenParticleData._randomInvertRoationArray(S, R, e.randomizeRotationDirection, a ? null : o, s),
                            ShurikenParticleData.startRotation[0] = R.x,
                            ShurikenParticleData.startRotation[1] = R.y,
                            ShurikenParticleData.startRotation[2] = 4 !== g ? -R.z : R.z;
                        } else
                            ShurikenParticleData.startRotation[0] = ShurikenParticleData._randomInvertRoation(e.startRotationConstant, e.randomizeRotationDirection, a ? null : o, s),
                            ShurikenParticleData.startRotation[1] = 0,
                            ShurikenParticleData.startRotation[2] = 0;
                        break;
                    case 2:
                        if (e.threeDStartRotation) {
                            var C = e.startRotationConstantMinSeparate
                              , M = e.startRotationConstantMaxSeparate
                              , D = ShurikenParticleData._tempVector30;
                            a ? (D.x = t.MathUtil.lerp(C.x, M.x, Math.random()),
                            D.y = t.MathUtil.lerp(C.y, M.y, Math.random()),
                            D.z = t.MathUtil.lerp(C.z, M.z, Math.random())) : (o.seed = s[5],
                            D.x = t.MathUtil.lerp(C.x, M.x, o.getFloat()),
                            D.y = t.MathUtil.lerp(C.y, M.y, o.getFloat()),
                            D.z = t.MathUtil.lerp(C.z, M.z, o.getFloat()),
                            s[5] = o.seed),
                            ShurikenParticleData._randomInvertRoationArray(D, D, e.randomizeRotationDirection, a ? null : o, s),
                            ShurikenParticleData.startRotation[0] = D.x,
                            ShurikenParticleData.startRotation[1] = D.y,
                            ShurikenParticleData.startRotation[2] = 4 !== g ? -D.z : D.z;
                        } else
                            a ? ShurikenParticleData.startRotation[0] = ShurikenParticleData._randomInvertRoation(t.MathUtil.lerp(e.startRotationConstantMin, e.startRotationConstantMax, Math.random()), e.randomizeRotationDirection, a ? null : o, s) : (o.seed = s[5],
                            ShurikenParticleData.startRotation[0] = ShurikenParticleData._randomInvertRoation(t.MathUtil.lerp(e.startRotationConstantMin, e.startRotationConstantMax, o.getFloat()), e.randomizeRotationDirection, a ? null : o, s),
                            s[5] = o.seed);
                    }
                switch (e.startLifetimeType) {
                case 0:
                    ShurikenParticleData.startLifeTime = e.startLifetimeConstant;
                    break;
                case 1:
                    ShurikenParticleData.startLifeTime = ShurikenParticleData._getStartLifetimeFromGradient(e.startLifeTimeGradient, e.emissionTime);
                    break;
                case 2:
                    a ? ShurikenParticleData.startLifeTime = t.MathUtil.lerp(e.startLifetimeConstantMin, e.startLifetimeConstantMax, Math.random()) : (o.seed = s[7],
                    ShurikenParticleData.startLifeTime = t.MathUtil.lerp(e.startLifetimeConstantMin, e.startLifetimeConstantMax, o.getFloat()),
                    s[7] = o.seed);
                    break;
                case 3:
                    var x = e.emissionTime;
                    a ? ShurikenParticleData.startLifeTime = t.MathUtil.lerp(ShurikenParticleData._getStartLifetimeFromGradient(e.startLifeTimeGradientMin, x), ShurikenParticleData._getStartLifetimeFromGradient(e.startLifeTimeGradientMax, x), Math.random()) : (o.seed = s[7],
                    ShurikenParticleData.startLifeTime = t.MathUtil.lerp(ShurikenParticleData._getStartLifetimeFromGradient(e.startLifeTimeGradientMin, x), ShurikenParticleData._getStartLifetimeFromGradient(e.startLifeTimeGradientMax, x), o.getFloat()),
                    s[7] = o.seed);
                }
                var A = e.textureSheetAnimation;
                if (A && A.enable) {
                    var I, L = A.tiles, P = L.x, O = L.y, N = 1 / P, b = 1 / O, k = A.startFrame;
                    switch (k.type) {
                    case 0:
                        I = k.constant;
                        break;
                    case 1:
                        a ? I = t.MathUtil.lerp(k.constantMin, k.constantMax, Math.random()) : (o.seed = s[14],
                        I = t.MathUtil.lerp(k.constantMin, k.constantMax, o.getFloat()),
                        s[14] = o.seed);
                    }
                    var V = A.frame
                      , B = A.cycles;
                    switch (V.type) {
                    case 0:
                        I += V.constant * B;
                        break;
                    case 2:
                        a ? I += t.MathUtil.lerp(V.constantMin, V.constantMax, Math.random()) * B : (o.seed = s[15],
                        I += t.MathUtil.lerp(V.constantMin, V.constantMax, o.getFloat()) * B,
                        s[15] = o.seed);
                    }
                    var w = 0;
                    switch (A.type) {
                    case 0:
                        w = Math.floor(I / P);
                        break;
                    case 1:
                        A.randomRow ? a ? w = Math.floor(Math.random() * O) : (o.seed = s[13],
                        w = Math.floor(o.getFloat() * O),
                        s[13] = o.seed) : w = A.rowIndex;
                    }
                    var F = Math.floor(I % P);
                    ShurikenParticleData.startUVInfo = ShurikenParticleData.startUVInfo,
                    ShurikenParticleData.startUVInfo[0] = N,
                    ShurikenParticleData.startUVInfo[1] = b,
                    ShurikenParticleData.startUVInfo[2] = F * N,
                    ShurikenParticleData.startUVInfo[3] = w * b;
                } else
                    ShurikenParticleData.startUVInfo = ShurikenParticleData.startUVInfo,
                    ShurikenParticleData.startUVInfo[0] = 1,
                    ShurikenParticleData.startUVInfo[1] = 1,
                    ShurikenParticleData.startUVInfo[2] = 0,
                    ShurikenParticleData.startUVInfo[3] = 0;
            }
        }]),
        ShurikenParticleData;
    }();
    Zt._tempVector30 = new o(),
    Zt.startColor = new i(),
    Zt.startSize = new Float32Array(3),
    Zt.startRotation = new Float32Array(3),
    Zt.startUVInfo = new Float32Array(4);
    var jt = function(r) {
        function ShurikenParticleSystem(e) {
            var t;
            return _classCallCheck(this, ShurikenParticleSystem),
            (t = _possibleConstructorReturn(this, _getPrototypeOf(ShurikenParticleSystem).call(this)))._boundingSphere = null,
            t._boundingBox = null,
            t._boundingBoxCorners = null,
            t._owner = null,
            t._ownerRender = null,
            t._vertices = null,
            t._floatCountPerVertex = 0,
            t._startLifeTimeIndex = 0,
            t._timeIndex = 0,
            t._simulateUpdate = !1,
            t._firstActiveElement = 0,
            t._firstNewElement = 0,
            t._firstFreeElement = 0,
            t._firstRetiredElement = 0,
            t._drawCounter = 0,
            t._bufferMaxParticles = 0,
            t._emission = null,
            t._shape = null,
            t._isEmitting = !1,
            t._isPlaying = !1,
            t._isPaused = !1,
            t._playStartDelay = 0,
            t._frameRateTime = 0,
            t._emissionTime = 0,
            t._totalDelayTime = 0,
            t._burstsIndex = 0,
            t._velocityOverLifetime = null,
            t._colorOverLifetime = null,
            t._sizeOverLifetime = null,
            t._rotationOverLifetime = null,
            t._textureSheetAnimation = null,
            t._startLifetimeType = 0,
            t._startLifetimeConstant = 0,
            t._startLifeTimeGradient = null,
            t._startLifetimeConstantMin = 0,
            t._startLifetimeConstantMax = 0,
            t._startLifeTimeGradientMin = null,
            t._startLifeTimeGradientMax = null,
            t._maxStartLifetime = 0,
            t._uvLength = new n(),
            t._vertexStride = 0,
            t._indexStride = 0,
            t._vertexBuffer = null,
            t._indexBuffer = null,
            t._bufferState = new we(),
            t._currentTime = 0,
            t._startUpdateLoopCount = 0,
            t._rand = null,
            t._randomSeeds = null,
            t.duration = 0,
            t.looping = !1,
            t.prewarm = !1,
            t.startDelayType = 0,
            t.startDelay = 0,
            t.startDelayMin = 0,
            t.startDelayMax = 0,
            t.startSpeedType = 0,
            t.startSpeedConstant = 0,
            t.startSpeedConstantMin = 0,
            t.startSpeedConstantMax = 0,
            t.threeDStartSize = !1,
            t.startSizeType = 0,
            t.startSizeConstant = 0,
            t.startSizeConstantSeparate = null,
            t.startSizeConstantMin = 0,
            t.startSizeConstantMax = 0,
            t.startSizeConstantMinSeparate = null,
            t.startSizeConstantMaxSeparate = null,
            t.threeDStartRotation = !1,
            t.startRotationType = 0,
            t.startRotationConstant = 0,
            t.startRotationConstantSeparate = null,
            t.startRotationConstantMin = 0,
            t.startRotationConstantMax = 0,
            t.startRotationConstantMinSeparate = null,
            t.startRotationConstantMaxSeparate = null,
            t.randomizeRotationDirection = 0,
            t.startColorType = 0,
            t.startColorConstant = new i(1,1,1,1),
            t.startColorConstantMin = new i(0,0,0,0),
            t.startColorConstantMax = new i(1,1,1,1),
            t.gravityModifier = 0,
            t.simulationSpace = 0,
            t.simulationSpeed = 1,
            t.scaleMode = 0,
            t.playOnAwake = !1,
            t.randomSeed = null,
            t.autoRandomSeed = !1,
            t.isPerformanceMode = !1,
            t._firstActiveElement = 0,
            t._firstNewElement = 0,
            t._firstFreeElement = 0,
            t._firstRetiredElement = 0,
            t._owner = e,
            t._ownerRender = e.particleRenderer,
            t._boundingBoxCorners = [],
            t._boundingSphere = new Wt(new o(),Number.MAX_VALUE),
            t._boundingBox = new ot(new o(-Number.MAX_VALUE,-Number.MAX_VALUE,-Number.MAX_VALUE),new o(Number.MAX_VALUE,Number.MAX_VALUE,Number.MAX_VALUE)),
            t._currentTime = 0,
            t._isEmitting = !1,
            t._isPlaying = !1,
            t._isPaused = !1,
            t._burstsIndex = 0,
            t._frameRateTime = 0,
            t._emissionTime = 0,
            t._totalDelayTime = 0,
            t._simulateUpdate = !1,
            t._bufferMaxParticles = 1,
            t.duration = 5,
            t.looping = !0,
            t.prewarm = !1,
            t.startDelayType = 0,
            t.startDelay = 0,
            t.startDelayMin = 0,
            t.startDelayMax = 0,
            t._startLifetimeType = 0,
            t._startLifetimeConstant = 5,
            t._startLifeTimeGradient = new St(),
            t._startLifetimeConstantMin = 0,
            t._startLifetimeConstantMax = 5,
            t._startLifeTimeGradientMin = new St(),
            t._startLifeTimeGradientMax = new St(),
            t._maxStartLifetime = 5,
            t.startSpeedType = 0,
            t.startSpeedConstant = 5,
            t.startSpeedConstantMin = 0,
            t.startSpeedConstantMax = 5,
            t.threeDStartSize = !1,
            t.startSizeType = 0,
            t.startSizeConstant = 1,
            t.startSizeConstantSeparate = new o(1,1,1),
            t.startSizeConstantMin = 0,
            t.startSizeConstantMax = 1,
            t.startSizeConstantMinSeparate = new o(0,0,0),
            t.startSizeConstantMaxSeparate = new o(1,1,1),
            t.threeDStartRotation = !1,
            t.startRotationType = 0,
            t.startRotationConstant = 0,
            t.startRotationConstantSeparate = new o(0,0,0),
            t.startRotationConstantMin = 0,
            t.startRotationConstantMax = 0,
            t.startRotationConstantMinSeparate = new o(0,0,0),
            t.startRotationConstantMaxSeparate = new o(0,0,0),
            t.gravityModifier = 0,
            t.simulationSpace = 1,
            t.scaleMode = 0,
            t.playOnAwake = !0,
            t._rand = new Xt(0),
            t.autoRandomSeed = !0,
            t.randomSeed = new Uint32Array(1),
            t._randomSeeds = new Uint32Array(ShurikenParticleSystem._RANDOMOFFSET.length),
            t.isPerformanceMode = !0,
            t._emission = new Yt(),
            t._emission.enable = !0,
            t;
        }
        return _inherits(ShurikenParticleSystem, Me),
        _createClass(ShurikenParticleSystem, [{
            key: "_getVertexBuffer",
            value: function() {
                return 0 === (arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0) ? this._vertexBuffer : null;
            }
        }, {
            key: "_getIndexBuffer",
            value: function() {
                return this._indexBuffer;
            }
        }, {
            key: "_generateBoundingSphere",
            value: function() {
                var e = this._boundingSphere.center;
                e.x = 0,
                e.y = 0,
                e.z = 0,
                this._boundingSphere.radius = Number.MAX_VALUE;
            }
        }, {
            key: "_generateBoundingBox",
            value: function() {
                var e, t, r, n, i, a, s, l, u, c = this._owner.particleRenderer, h = this._boundingBox.min, _ = this._boundingBox.max;
                switch (this.startLifetimeType) {
                case 0:
                    r = this.startLifetimeConstant;
                    break;
                case 1:
                    r = -Number.MAX_VALUE;
                    var d = d;
                    for (e = 0,
                    t = d.gradientCount; e < t; e++)
                        r = Math.max(r, d.getValueByIndex(e));
                    break;
                case 2:
                    r = Math.max(this.startLifetimeConstantMin, this.startLifetimeConstantMax);
                    break;
                case 3:
                    r = -Number.MAX_VALUE;
                    var f = f;
                    for (e = 0,
                    t = f.gradientCount; e < t; e++)
                        r = Math.max(r, f.getValueByIndex(e));
                    var m = m;
                    for (e = 0,
                    t = m.gradientCount; e < t; e++)
                        r = Math.max(r, m.getValueByIndex(e));
                }
                switch (this.startSpeedType) {
                case 0:
                    n = i = this.startSpeedConstant;
                    break;
                case 1:
                    break;
                case 2:
                    n = this.startLifetimeConstantMin,
                    i = this.startLifetimeConstantMax;
                }
                this._shape && this._shape.enable || (a = s = o._ZERO,
                l = o._ZERO,
                u = o._UnitZ);
                var p, v, T = new o(l.x * n,l.y * n,l.z * n), E = new o(u.x * i,u.y * i,u.z * i);
                if (this._velocityOverLifetime && this._velocityOverLifetime.enable) {
                    var y = this._velocityOverLifetime.velocity;
                    switch (y.type) {
                    case 0:
                        y.constant;
                        break;
                    case 1:
                        new o(y.gradientX.getAverageValue(),y.gradientY.getAverageValue(),y.gradientZ.getAverageValue());
                        break;
                    case 2:
                        y.constantMin,
                        y.constantMax;
                        break;
                    case 3:
                        new o(y.gradientXMin.getAverageValue(),y.gradientYMin.getAverageValue(),y.gradientZMin.getAverageValue()),
                        new o(y.gradientXMax.getAverageValue(),y.gradientYMax.getAverageValue(),y.gradientZMax.getAverageValue());
                    }
                }
                var g, S, R, C, M = this._owner.transform, D = M.position, x = ShurikenParticleSystem._tempVector39, A = c.renderMode;
                switch (this.scaleMode) {
                case 0:
                    var I = M.getWorldLossyScale();
                    p = I,
                    x.x = I.x,
                    x.y = I.z,
                    x.z = I.y,
                    1 === A && (v = I);
                    break;
                case 1:
                    var L = M.localScale;
                    p = L,
                    x.x = L.x,
                    x.y = L.z,
                    x.z = L.y,
                    1 === A && (v = L);
                    break;
                case 2:
                    p = M.getWorldLossyScale(),
                    x.x = x.y = x.z = 1,
                    1 === A && (v = o._ONE);
                }
                switch (this._velocityOverLifetime && this._velocityOverLifetime.enable || (g = new o(T.x * r,T.y * r,T.z * r),
                S = new o(E.x * r,E.y * r,E.z * r),
                2 != this.scaleMode ? (o.add(a, g, h),
                o.multiply(p, h, h),
                o.add(s, S, _),
                o.multiply(p, _, _)) : (o.multiply(p, a, h),
                o.add(h, g, h),
                o.multiply(p, s, _),
                o.add(_, S, _))),
                this.simulationSpace) {
                case 0:
                    break;
                case 1:
                    o.add(h, D, h),
                    o.add(_, D, _);
                }
                switch (this.startSizeType) {
                case 0:
                    if (this.threeDStartSize) {
                        var P = P;
                        R = Math.max(P.x, P.y),
                        1 === A && (C = P.y);
                    } else
                        R = this.startSizeConstant,
                        1 === A && (C = this.startSizeConstant);
                    break;
                case 1:
                    break;
                case 2:
                    if (this.threeDStartSize) {
                        var O = O;
                        R = Math.max(O.x, O.y),
                        1 === A && (C = O.y);
                    } else
                        R = this.startSizeConstantMax,
                        1 === A && (C = this.startSizeConstantMax);
                }
                if (this._sizeOverLifetime && this._sizeOverLifetime.enable) {
                    this._sizeOverLifetime.size;
                    R *= this._sizeOverLifetime.size.getMaxSizeInGradient();
                }
                var N, b, k = ShurikenParticleSystem._tempVector30;
                switch (A) {
                case 0:
                    N = R * ShurikenParticleSystem.halfKSqrtOf2,
                    o.scale(x, R, k),
                    o.subtract(h, k, h),
                    o.add(_, k, _);
                    break;
                case 1:
                    var V = ShurikenParticleSystem._tempVector31
                      , B = ShurikenParticleSystem._tempVector32
                      , w = ShurikenParticleSystem._tempVector33
                      , F = ShurikenParticleSystem._tempVector34;
                    this._velocityOverLifetime && this._velocityOverLifetime.enable || (o.multiply(v, E, B),
                    o.multiply(v, T, w));
                    var U = C * c.stretchedBillboardLengthScale
                      , G = o.scalarLength(B) * c.stretchedBillboardSpeedScale + U
                      , z = o.scalarLength(w) * c.stretchedBillboardSpeedScale + U
                      , H = ShurikenParticleSystem._tempVector35
                      , W = ShurikenParticleSystem._tempVector36;
                    o.normalize(B, H),
                    o.scale(H, G, F),
                    o.subtract(S, F, F),
                    o.normalize(w, W),
                    o.scale(W, z, V),
                    o.add(g, V, V),
                    N = R * ShurikenParticleSystem.halfKSqrtOf2,
                    o.scale(x, N, k);
                    var X = ShurikenParticleSystem._tempVector37
                      , Y = ShurikenParticleSystem._tempVector38;
                    o.scale(H, .5, X),
                    o.scale(W, .5, Y),
                    o.multiply(X, x, X),
                    o.multiply(Y, x, Y),
                    o.add(h, Y, h),
                    o.min(h, F, h),
                    o.subtract(h, k, h),
                    o.subtract(_, X, _),
                    o.max(_, V, _),
                    o.add(_, k, _);
                    break;
                case 2:
                    b = .5 * (R *= Math.cos(.7853981633974483)),
                    k.x = x.x * b,
                    k.y = x.z * b,
                    o.subtract(h, k, h),
                    o.add(_, k, _);
                    break;
                case 3:
                    b = .5 * (R *= Math.cos(.7853981633974483)),
                    o.scale(x, b, k),
                    o.subtract(h, k, h),
                    o.add(_, k, _);
                }
                this._boundingBox.getCorners(this._boundingBoxCorners);
            }
        }, {
            key: "_updateEmission",
            value: function() {
                if (this.isAlive)
                    if (this._simulateUpdate)
                        this._simulateUpdate = !1;
                    else {
                        var e = this._startUpdateLoopCount === t.Stat.loopCount || this._isPaused ? 0 : this._owner._scene.timer._delta / 1e3;
                        e = Math.min(ShurikenParticleSystem._maxElapsedTime, e * this.simulationSpeed),
                        this._updateParticles(e);
                    }
            }
        }, {
            key: "_updateParticles",
            value: function(e) {
                (4 !== this._ownerRender.renderMode || this._ownerRender.mesh) && (this._currentTime += e,
                this._retireActiveParticles(),
                this._freeRetiredParticles(),
                this._totalDelayTime += e,
                this._totalDelayTime < this._playStartDelay || this._emission.enable && this._isEmitting && !this._isPaused && this._advanceTime(e, this._currentTime));
            }
        }, {
            key: "_updateParticlesSimulationRestart",
            value: function(e) {
                this._firstActiveElement = 0,
                this._firstNewElement = 0,
                this._firstFreeElement = 0,
                this._firstRetiredElement = 0,
                this._burstsIndex = 0,
                this._frameRateTime = e,
                this._emissionTime = 0,
                this._totalDelayTime = 0,
                this._currentTime = e;
                var t = e;
                t < this._playStartDelay ? this._totalDelayTime = t : this._emission.enable && this._advanceTime(e, e);
            }
        }, {
            key: "_retireActiveParticles",
            value: function() {
                for (; this._firstActiveElement != this._firstNewElement; ) {
                    var e = this._firstActiveElement * this._floatCountPerVertex * this._vertexStride
                      , t = e + this._timeIndex;
                    if (this._currentTime - this._vertices[t] + 1e-4 < this._vertices[e + this._startLifeTimeIndex])
                        break;
                    this._vertices[t] = this._drawCounter,
                    this._firstActiveElement++,
                    this._firstActiveElement >= this._bufferMaxParticles && (this._firstActiveElement = 0);
                }
            }
        }, {
            key: "_freeRetiredParticles",
            value: function() {
                for (; this._firstRetiredElement != this._firstActiveElement; ) {
                    var e = this._drawCounter - this._vertices[this._firstRetiredElement * this._floatCountPerVertex * this._vertexStride + this._timeIndex];
                    if (this.isPerformanceMode && e < 3)
                        break;
                    this._firstRetiredElement++,
                    this._firstRetiredElement >= this._bufferMaxParticles && (this._firstRetiredElement = 0);
                }
            }
        }, {
            key: "_burst",
            value: function(e, r) {
                for (var n = 0, i = this._emission._bursts, a = i.length; this._burstsIndex < a; this._burstsIndex++) {
                    var o, s = i[this._burstsIndex], l = s.time;
                    if (!(e <= l && l < r))
                        break;
                    this.autoRandomSeed ? o = t.MathUtil.lerp(s.minCount, s.maxCount, Math.random()) : (this._rand.seed = this._randomSeeds[0],
                    o = t.MathUtil.lerp(s.minCount, s.maxCount, this._rand.getFloat()),
                    this._randomSeeds[0] = this._rand.seed),
                    n += o;
                }
                return n;
            }
        }, {
            key: "_advanceTime",
            value: function(e, t) {
                var r, n = this._emissionTime;
                this._emissionTime += e;
                var i = 0;
                if (this._emissionTime > this.duration) {
                    if (!this.looping) {
                        for (i = Math.min(this.maxParticles - this.aliveParticleCount, i),
                        r = 0; r < i; r++)
                            this.emit(t);
                        return this._isPlaying = !1,
                        void this.stop();
                    }
                    i += this._burst(n, this._emissionTime),
                    this._emissionTime -= this.duration,
                    this._burstsIndex = 0,
                    i += this._burst(0, this._emissionTime);
                } else
                    i += this._burst(n, this._emissionTime);
                for (i = Math.min(this.maxParticles - this.aliveParticleCount, i),
                r = 0; r < i; r++)
                    this.emit(t);
                var a = this.emission.emissionRate;
                if (a > 0) {
                    var o = 1 / a;
                    for (this._frameRateTime += o,
                    this._frameRateTime = this._currentTime - (this._currentTime - this._frameRateTime) % this._maxStartLifetime; this._frameRateTime <= t && this.emit(this._frameRateTime); )
                        this._frameRateTime += o;
                    this._frameRateTime = Math.floor(t / o) * o;
                }
            }
        }, {
            key: "_initBufferDatas",
            value: function() {
                if (this._vertexBuffer) {
                    this._vertexBuffer.destroy(),
                    this._indexBuffer.destroy();
                    var r = this._vertexBuffer._byteLength + 2 * this._indexBuffer.indexCount;
                    t.Resource._addMemory(-r, -r);
                }
                var n = t.LayaGL.instance
                  , i = this._ownerRender
                  , a = i.renderMode;
                if (-1 !== a && this.maxParticles > 0) {
                    var o, s, l, u, c, h, _, d = 0, f = (r = 0,
                    i.mesh);
                    if (4 === a) {
                        if (f) {
                            _ = Ht.vertexDeclaration,
                            this._floatCountPerVertex = _.vertexStride / 4,
                            this._startLifeTimeIndex = 12,
                            this._timeIndex = 16,
                            this._vertexStride = f._vertexCount;
                            var m = this._bufferMaxParticles * this._vertexStride
                              , p = m % 65535;
                            if (Math.floor(m / 65535) + 1 > 1)
                                throw new Error("ShurikenParticleSystem:the maxParticleCount multiply mesh vertexCount is large than 65535.");
                            d = _.vertexStride * p,
                            this._vertexBuffer = new De(d,n.DYNAMIC_DRAW),
                            this._vertexBuffer.vertexDeclaration = _,
                            this._vertices = new Float32Array(this._floatCountPerVertex * p),
                            this._indexStride = f._indexBuffer.indexCount;
                            var v = f._indexBuffer.getData()
                              , T = this._bufferMaxParticles * this._indexStride;
                            for (this._indexBuffer = new Fe(e.IndexFormat.UInt16,T,n.STATIC_DRAW),
                            o = new Uint16Array(T),
                            r = d + 2 * T,
                            c = 0,
                            s = 0; s < this._bufferMaxParticles; s++) {
                                var E = s * this._vertexStride;
                                for (l = 0,
                                u = v.length; l < u; l++)
                                    o[c++] = E + v[l];
                            }
                            this._indexBuffer.setData(o),
                            this._bufferState.bind(),
                            this._bufferState.applyVertexBuffer(this._vertexBuffer),
                            this._bufferState.applyIndexBuffer(this._indexBuffer),
                            this._bufferState.unBind();
                        }
                    } else {
                        for (_ = zt.vertexDeclaration,
                        this._floatCountPerVertex = _.vertexStride / 4,
                        this._startLifeTimeIndex = 7,
                        this._timeIndex = 11,
                        this._vertexStride = 4,
                        d = _.vertexStride * this._bufferMaxParticles * this._vertexStride,
                        this._vertexBuffer = new De(d,n.DYNAMIC_DRAW),
                        this._vertexBuffer.vertexDeclaration = _,
                        this._vertices = new Float32Array(this._floatCountPerVertex * this._bufferMaxParticles * this._vertexStride),
                        s = 0; s < this._bufferMaxParticles; s++)
                            h = s * this._floatCountPerVertex * this._vertexStride,
                            this._vertices[h] = -.5,
                            this._vertices[h + 1] = -.5,
                            this._vertices[h + 2] = 0,
                            this._vertices[h + 3] = 1,
                            h += this._floatCountPerVertex,
                            this._vertices[h] = .5,
                            this._vertices[h + 1] = -.5,
                            this._vertices[h + 2] = 1,
                            this._vertices[h + 3] = 1,
                            h += this._floatCountPerVertex,
                            this._vertices[h] = .5,
                            this._vertices[h + 1] = .5,
                            this._vertices[h + 2] = 1,
                            this._vertices[h + 3] = 0,
                            h += this._floatCountPerVertex,
                            this._vertices[h] = -.5,
                            this._vertices[h + 1] = .5,
                            this._vertices[h + 2] = 0,
                            this._vertices[h + 3] = 0;
                        for (this._indexStride = 6,
                        this._indexBuffer = new Fe(e.IndexFormat.UInt16,6 * this._bufferMaxParticles,n.STATIC_DRAW),
                        o = new Uint16Array(6 * this._bufferMaxParticles),
                        s = 0; s < this._bufferMaxParticles; s++) {
                            c = 6 * s;
                            var y = s * this._vertexStride
                              , g = y + 2;
                            o[c++] = y,
                            o[c++] = g,
                            o[c++] = y + 1,
                            o[c++] = y,
                            o[c++] = y + 3,
                            o[c++] = g;
                        }
                        this._indexBuffer.setData(o),
                        r = d + 6 * this._bufferMaxParticles * 2,
                        this._bufferState.bind(),
                        this._bufferState.applyVertexBuffer(this._vertexBuffer),
                        this._bufferState.applyIndexBuffer(this._indexBuffer),
                        this._bufferState.unBind();
                    }
                    t.Resource._addMemory(r, r);
                }
            }
        }, {
            key: "destroy",
            value: function() {
                _get(_getPrototypeOf(ShurikenParticleSystem.prototype), "destroy", this).call(this);
                var e = this._vertexBuffer._byteLength + 2 * this._indexBuffer.indexCount;
                t.Resource._addMemory(-e, -e),
                this._bufferState.destroy(),
                this._vertexBuffer.destroy(),
                this._indexBuffer.destroy(),
                this._emission.destroy(),
                this._bufferState = null,
                this._vertexBuffer = null,
                this._indexBuffer = null,
                this._owner = null,
                this._vertices = null,
                this._indexBuffer = null,
                this._emission = null,
                this._shape = null,
                this.startLifeTimeGradient = null,
                this.startLifeTimeGradientMin = null,
                this.startLifeTimeGradientMax = null,
                this.startSizeConstantSeparate = null,
                this.startSizeConstantMinSeparate = null,
                this.startSizeConstantMaxSeparate = null,
                this.startRotationConstantSeparate = null,
                this.startRotationConstantMinSeparate = null,
                this.startRotationConstantMaxSeparate = null,
                this.startColorConstant = null,
                this.startColorConstantMin = null,
                this.startColorConstantMax = null,
                this._velocityOverLifetime = null,
                this._colorOverLifetime = null,
                this._sizeOverLifetime = null,
                this._rotationOverLifetime = null,
                this._textureSheetAnimation = null;
            }
        }, {
            key: "emit",
            value: function(e) {
                var t = ShurikenParticleSystem._tempPosition
                  , r = ShurikenParticleSystem._tempDirection;
                return this._shape && this._shape.enable ? this.autoRandomSeed ? this._shape.generatePositionAndDirection(t, r) : this._shape.generatePositionAndDirection(t, r, this._rand, this._randomSeeds) : (t.x = t.y = t.z = 0,
                r.x = r.y = 0,
                r.z = 1),
                this.addParticle(t, r, e);
            }
        }, {
            key: "addParticle",
            value: function(e, r, n) {
                o.normalize(r, r);
                var i = this._firstFreeElement + 1;
                if (i >= this._bufferMaxParticles && (i = 0),
                i === this._firstRetiredElement)
                    return !1;
                var a, s, l, u, c, h, _, d, f, m, p = this._owner.transform;
                if (Zt.create(this, this._ownerRender, p),
                this._currentTime - n >= Zt.startLifeTime)
                    return !0;
                switch (0 == this.simulationSpace && (a = p.position,
                s = p.rotation),
                this.startSpeedType) {
                case 0:
                    l = this.startSpeedConstant;
                    break;
                case 2:
                    this.autoRandomSeed ? l = t.MathUtil.lerp(this.startSpeedConstantMin, this.startSpeedConstantMax, Math.random()) : (this._rand.seed = this._randomSeeds[8],
                    l = t.MathUtil.lerp(this.startSpeedConstantMin, this.startSpeedConstantMax, this._rand.getFloat()),
                    this._randomSeeds[8] = this._rand.seed);
                }
                var v = this._velocityOverLifetime && this._velocityOverLifetime.enable;
                if (v) {
                    var T = this._velocityOverLifetime.velocity.type;
                    2 === T || 3 === T ? this.autoRandomSeed ? (u = Math.random(),
                    c = Math.random(),
                    h = Math.random()) : (this._rand.seed = this._randomSeeds[9],
                    u = this._rand.getFloat(),
                    c = this._rand.getFloat(),
                    h = this._rand.getFloat(),
                    this._randomSeeds[9] = this._rand.seed) : v = !1;
                } else
                    v = !1;
                var E = this._colorOverLifetime && this._colorOverLifetime.enable;
                E ? 3 === this._colorOverLifetime.color.type ? this.autoRandomSeed ? _ = Math.random() : (this._rand.seed = this._randomSeeds[10],
                _ = this._rand.getFloat(),
                this._randomSeeds[10] = this._rand.seed) : E = !1 : E = !1;
                var y = this._sizeOverLifetime && this._sizeOverLifetime.enable;
                y ? 3 === this._sizeOverLifetime.size.type ? this.autoRandomSeed ? d = Math.random() : (this._rand.seed = this._randomSeeds[11],
                d = this._rand.getFloat(),
                this._randomSeeds[11] = this._rand.seed) : y = !1 : y = !1;
                var g = this._rotationOverLifetime && this._rotationOverLifetime.enable;
                if (g) {
                    var S = this._rotationOverLifetime.angularVelocity.type;
                    2 === S || 3 === S ? this.autoRandomSeed ? f = Math.random() : (this._rand.seed = this._randomSeeds[12],
                    f = this._rand.getFloat(),
                    this._randomSeeds[12] = this._rand.seed) : g = !1;
                } else
                    g = !1;
                var R = this._textureSheetAnimation && this._textureSheetAnimation.enable;
                R ? 3 === this._textureSheetAnimation.frame.type ? this.autoRandomSeed ? m = Math.random() : (this._rand.seed = this._randomSeeds[15],
                m = this._rand.getFloat(),
                this._randomSeeds[15] = this._rand.seed) : R = !1 : R = !1;
                var C, M, D, x, A, I, L = this._firstFreeElement * this._floatCountPerVertex * this._vertexStride, P = Zt.startUVInfo[0], O = Zt.startUVInfo[1], N = Zt.startUVInfo[2], b = Zt.startUVInfo[3], k = this._ownerRender;
                if (4 === k.renderMode) {
                    var V = k.mesh._vertexBuffer;
                    C = V.getFloat32Data();
                    var B = V.vertexDeclaration;
                    D = B.getVertexElementByUsage(ue.MESH_POSITION0)._offset / 4;
                    var w = B.getVertexElementByUsage(ue.MESH_COLOR0);
                    x = w ? w._offset / 4 : -1;
                    var F = B.getVertexElementByUsage(ue.MESH_TEXTURECOORDINATE0);
                    A = F ? F._offset / 4 : -1,
                    M = B.vertexStride / 4,
                    I = 0;
                } else {
                    this._vertices[L + 2] = N,
                    this._vertices[L + 3] = b + O;
                    var U = L + this._floatCountPerVertex;
                    this._vertices[U + 2] = N + P,
                    this._vertices[U + 3] = b + O;
                    var G = U + this._floatCountPerVertex;
                    this._vertices[G + 2] = N + P,
                    this._vertices[G + 3] = b;
                    var z = G + this._floatCountPerVertex;
                    this._vertices[z + 2] = N,
                    this._vertices[z + 3] = b;
                }
                for (var H = L, W = L + this._floatCountPerVertex * this._vertexStride; H < W; H += this._floatCountPerVertex) {
                    var X;
                    if (4 === k.renderMode) {
                        X = H;
                        var Y = M * I++
                          , Z = Y + D;
                        this._vertices[X++] = C[Z++],
                        this._vertices[X++] = C[Z++],
                        this._vertices[X++] = C[Z],
                        -1 === x ? (this._vertices[X++] = 1,
                        this._vertices[X++] = 1,
                        this._vertices[X++] = 1,
                        this._vertices[X++] = 1) : (Z = Y + x,
                        this._vertices[X++] = C[Z++],
                        this._vertices[X++] = C[Z++],
                        this._vertices[X++] = C[Z++],
                        this._vertices[X++] = C[Z]),
                        -1 === A ? (this._vertices[X++] = 0,
                        this._vertices[X++] = 0) : (Z = Y + A,
                        this._vertices[X++] = N + C[Z++] * P,
                        this._vertices[X++] = b + C[Z] * O);
                    } else
                        X = H + 4;
                    switch (this._vertices[X++] = e.x,
                    this._vertices[X++] = e.y,
                    this._vertices[X++] = e.z,
                    this._vertices[X++] = Zt.startLifeTime,
                    this._vertices[X++] = r.x,
                    this._vertices[X++] = r.y,
                    this._vertices[X++] = r.z,
                    this._vertices[X++] = n,
                    this._vertices[X++] = Zt.startColor.x,
                    this._vertices[X++] = Zt.startColor.y,
                    this._vertices[X++] = Zt.startColor.z,
                    this._vertices[X++] = Zt.startColor.w,
                    this._vertices[X++] = Zt.startSize[0],
                    this._vertices[X++] = Zt.startSize[1],
                    this._vertices[X++] = Zt.startSize[2],
                    this._vertices[X++] = Zt.startRotation[0],
                    this._vertices[X++] = Zt.startRotation[1],
                    this._vertices[X++] = Zt.startRotation[2],
                    this._vertices[X++] = l,
                    E && (this._vertices[X + 1] = _),
                    y && (this._vertices[X + 2] = d),
                    g && (this._vertices[X + 3] = f),
                    R && (this._vertices[X + 4] = m),
                    v && (this._vertices[X + 5] = u,
                    this._vertices[X + 6] = c,
                    this._vertices[X + 7] = h),
                    this.simulationSpace) {
                    case 0:
                        X += 8,
                        this._vertices[X++] = a.x,
                        this._vertices[X++] = a.y,
                        this._vertices[X++] = a.z,
                        this._vertices[X++] = s.x,
                        this._vertices[X++] = s.y,
                        this._vertices[X++] = s.z,
                        this._vertices[X++] = s.w;
                        break;
                    case 1:
                        break;
                    default:
                        throw new Error("ShurikenParticleMaterial: SimulationSpace value is invalid.");
                    }
                }
                return this._firstFreeElement = i,
                !0;
            }
        }, {
            key: "addNewParticlesToVertexBuffer",
            value: function() {
                var e, t = this._vertexStride * this._floatCountPerVertex * 4;
                this._firstNewElement < this._firstFreeElement ? (e = this._firstNewElement * t,
                this._vertexBuffer.setData(this._vertices.buffer, e, e, (this._firstFreeElement - this._firstNewElement) * t)) : (e = this._firstNewElement * t,
                this._vertexBuffer.setData(this._vertices.buffer, e, e, (this._bufferMaxParticles - this._firstNewElement) * t),
                this._firstFreeElement > 0 && this._vertexBuffer.setData(this._vertices.buffer, 0, 0, this._firstFreeElement * t)),
                this._firstNewElement = this._firstFreeElement;
            }
        }, {
            key: "_getType",
            value: function() {
                return ShurikenParticleSystem._type;
            }
        }, {
            key: "_prepareRender",
            value: function(e) {
                return this._updateEmission(),
                this._firstNewElement != this._firstFreeElement && this.addNewParticlesToVertexBuffer(),
                this._drawCounter++,
                this._firstActiveElement != this._firstFreeElement;
            }
        }, {
            key: "_render",
            value: function(e) {
                var r;
                this._bufferState.bind();
                var n = t.LayaGL.instance;
                this._firstActiveElement < this._firstFreeElement ? (r = (this._firstFreeElement - this._firstActiveElement) * this._indexStride,
                n.drawElements(n.TRIANGLES, r, n.UNSIGNED_SHORT, 2 * this._firstActiveElement * this._indexStride),
                t.Stat.trianglesFaces += r / 3,
                t.Stat.renderBatches++) : (r = (this._bufferMaxParticles - this._firstActiveElement) * this._indexStride,
                n.drawElements(n.TRIANGLES, r, n.UNSIGNED_SHORT, 2 * this._firstActiveElement * this._indexStride),
                t.Stat.trianglesFaces += r / 3,
                t.Stat.renderBatches++,
                this._firstFreeElement > 0 && (r = this._firstFreeElement * this._indexStride,
                n.drawElements(n.TRIANGLES, r, n.UNSIGNED_SHORT, 0),
                t.Stat.trianglesFaces += r / 3,
                t.Stat.renderBatches++));
            }
        }, {
            key: "play",
            value: function() {
                if (this._burstsIndex = 0,
                this._isEmitting = !0,
                this._isPlaying = !0,
                this._isPaused = !1,
                this._emissionTime = 0,
                this._totalDelayTime = 0,
                !this.autoRandomSeed)
                    for (var e = 0, r = this._randomSeeds.length; e < r; e++)
                        this._randomSeeds[e] = this.randomSeed[0] + ShurikenParticleSystem._RANDOMOFFSET[e];
                switch (this.startDelayType) {
                case 0:
                    this._playStartDelay = this.startDelay;
                    break;
                case 1:
                    this.autoRandomSeed ? this._playStartDelay = t.MathUtil.lerp(this.startDelayMin, this.startDelayMax, Math.random()) : (this._rand.seed = this._randomSeeds[2],
                    this._playStartDelay = t.MathUtil.lerp(this.startDelayMin, this.startDelayMax, this._rand.getFloat()),
                    this._randomSeeds[2] = this._rand.seed);
                    break;
                default:
                    throw new Error("Utils3D: startDelayType is invalid.");
                }
                this._frameRateTime = this._currentTime + this._playStartDelay,
                this._startUpdateLoopCount = t.Stat.loopCount;
            }
        }, {
            key: "pause",
            value: function() {
                this._isPaused = !0;
            }
        }, {
            key: "simulate",
            value: function(e) {
                var t = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1];
                this._simulateUpdate = !0,
                t ? this._updateParticlesSimulationRestart(e) : (this._isPaused = !1,
                this._updateParticles(e)),
                this.pause();
            }
        }, {
            key: "stop",
            value: function() {
                this._burstsIndex = 0,
                this._isEmitting = !1,
                this._emissionTime = 0;
            }
        }, {
            key: "cloneTo",
            value: function(e) {
                var t = e;
                t.duration = this.duration,
                t.looping = this.looping,
                t.prewarm = this.prewarm,
                t.startDelayType = this.startDelayType,
                t.startDelay = this.startDelay,
                t.startDelayMin = this.startDelayMin,
                t.startDelayMax = this.startDelayMax,
                t._maxStartLifetime = this._maxStartLifetime,
                t.startLifetimeType = this.startLifetimeType,
                t.startLifetimeConstant = this.startLifetimeConstant,
                this.startLifeTimeGradient.cloneTo(t.startLifeTimeGradient),
                t.startLifetimeConstantMin = this.startLifetimeConstantMin,
                t.startLifetimeConstantMax = this.startLifetimeConstantMax,
                this.startLifeTimeGradientMin.cloneTo(t.startLifeTimeGradientMin),
                this.startLifeTimeGradientMax.cloneTo(t.startLifeTimeGradientMax),
                t.startSpeedType = this.startSpeedType,
                t.startSpeedConstant = this.startSpeedConstant,
                t.startSpeedConstantMin = this.startSpeedConstantMin,
                t.startSpeedConstantMax = this.startSpeedConstantMax,
                t.threeDStartSize = this.threeDStartSize,
                t.startSizeType = this.startSizeType,
                t.startSizeConstant = this.startSizeConstant,
                this.startSizeConstantSeparate.cloneTo(t.startSizeConstantSeparate),
                t.startSizeConstantMin = this.startSizeConstantMin,
                t.startSizeConstantMax = this.startSizeConstantMax,
                this.startSizeConstantMinSeparate.cloneTo(t.startSizeConstantMinSeparate),
                this.startSizeConstantMaxSeparate.cloneTo(t.startSizeConstantMaxSeparate),
                t.threeDStartRotation = this.threeDStartRotation,
                t.startRotationType = this.startRotationType,
                t.startRotationConstant = this.startRotationConstant,
                this.startRotationConstantSeparate.cloneTo(t.startRotationConstantSeparate),
                t.startRotationConstantMin = this.startRotationConstantMin,
                t.startRotationConstantMax = this.startRotationConstantMax,
                this.startRotationConstantMinSeparate.cloneTo(t.startRotationConstantMinSeparate),
                this.startRotationConstantMaxSeparate.cloneTo(t.startRotationConstantMaxSeparate),
                t.randomizeRotationDirection = this.randomizeRotationDirection,
                t.startColorType = this.startColorType,
                this.startColorConstant.cloneTo(t.startColorConstant),
                this.startColorConstantMin.cloneTo(t.startColorConstantMin),
                this.startColorConstantMax.cloneTo(t.startColorConstantMax),
                t.gravityModifier = this.gravityModifier,
                t.simulationSpace = this.simulationSpace,
                t.scaleMode = this.scaleMode,
                t.playOnAwake = this.playOnAwake,
                t.autoRandomSeed = this.autoRandomSeed,
                t.randomSeed[0] = this.randomSeed[0],
                t.maxParticles = this.maxParticles,
                this._emission && (t._emission = this._emission.clone()),
                this.shape && (t.shape = this.shape.clone()),
                this.velocityOverLifetime && (t.velocityOverLifetime = this.velocityOverLifetime.clone()),
                this.colorOverLifetime && (t.colorOverLifetime = this.colorOverLifetime.clone()),
                this.sizeOverLifetime && (t.sizeOverLifetime = this.sizeOverLifetime.clone()),
                this.rotationOverLifetime && (t.rotationOverLifetime = this.rotationOverLifetime.clone()),
                this.textureSheetAnimation && (t.textureSheetAnimation = this.textureSheetAnimation.clone()),
                t.isPerformanceMode = this.isPerformanceMode,
                t._isEmitting = this._isEmitting,
                t._isPlaying = this._isPlaying,
                t._isPaused = this._isPaused,
                t._playStartDelay = this._playStartDelay,
                t._frameRateTime = this._frameRateTime,
                t._emissionTime = this._emissionTime,
                t._totalDelayTime = this._totalDelayTime,
                t._burstsIndex = this._burstsIndex;
            }
        }, {
            key: "clone",
            value: function() {
                var e = new ShurikenParticleSystem(null);
                return this.cloneTo(e),
                e;
            }
        }, {
            key: "maxParticles",
            get: function() {
                return this._bufferMaxParticles - 1;
            },
            set: function(e) {
                var t = e + 1;
                t !== this._bufferMaxParticles && (this._bufferMaxParticles = t,
                this._initBufferDatas());
            }
        }, {
            key: "emission",
            get: function() {
                return this._emission;
            }
        }, {
            key: "aliveParticleCount",
            get: function() {
                return this._firstNewElement >= this._firstRetiredElement ? this._firstNewElement - this._firstRetiredElement : this._bufferMaxParticles - this._firstRetiredElement + this._firstNewElement;
            }
        }, {
            key: "emissionTime",
            get: function() {
                return this._emissionTime > this.duration ? this.duration : this._emissionTime;
            }
        }, {
            key: "shape",
            get: function() {
                return this._shape;
            },
            set: function(e) {
                this._shape !== e && (e && e.enable ? this._owner._render._shaderValues.addDefine(Bt.SHADERDEFINE_SHAPE) : this._owner._render._shaderValues.removeDefine(Bt.SHADERDEFINE_SHAPE),
                this._shape = e);
            }
        }, {
            key: "isAlive",
            get: function() {
                return !!(this._isPlaying || this.aliveParticleCount > 0);
            }
        }, {
            key: "isEmitting",
            get: function() {
                return this._isEmitting;
            }
        }, {
            key: "isPlaying",
            get: function() {
                return this._isPlaying;
            }
        }, {
            key: "isPaused",
            get: function() {
                return this._isPaused;
            }
        }, {
            key: "startLifetimeType",
            get: function() {
                return this._startLifetimeType;
            },
            set: function(e) {
                var t, r;
                switch (this.startLifetimeType) {
                case 0:
                    this._maxStartLifetime = this.startLifetimeConstant;
                    break;
                case 1:
                    this._maxStartLifetime = -Number.MAX_VALUE;
                    var n = n;
                    for (t = 0,
                    r = n.gradientCount; t < r; t++)
                        this._maxStartLifetime = Math.max(this._maxStartLifetime, n.getValueByIndex(t));
                    break;
                case 2:
                    this._maxStartLifetime = Math.max(this.startLifetimeConstantMin, this.startLifetimeConstantMax);
                    break;
                case 3:
                    this._maxStartLifetime = -Number.MAX_VALUE;
                    var i = i;
                    for (t = 0,
                    r = i.gradientCount; t < r; t++)
                        this._maxStartLifetime = Math.max(this._maxStartLifetime, i.getValueByIndex(t));
                    var a = a;
                    for (t = 0,
                    r = a.gradientCount; t < r; t++)
                        this._maxStartLifetime = Math.max(this._maxStartLifetime, a.getValueByIndex(t));
                }
                this._startLifetimeType = e;
            }
        }, {
            key: "startLifetimeConstant",
            get: function() {
                return this._startLifetimeConstant;
            },
            set: function(e) {
                0 === this._startLifetimeType && (this._maxStartLifetime = e),
                this._startLifetimeConstant = e;
            }
        }, {
            key: "startLifeTimeGradient",
            get: function() {
                return this._startLifeTimeGradient;
            },
            set: function(e) {
                if (1 === this._startLifetimeType) {
                    this._maxStartLifetime = -Number.MAX_VALUE;
                    for (var t = 0, r = e.gradientCount; t < r; t++)
                        this._maxStartLifetime = Math.max(this._maxStartLifetime, e.getValueByIndex(t));
                }
                this._startLifeTimeGradient = e;
            }
        }, {
            key: "startLifetimeConstantMin",
            get: function() {
                return this._startLifetimeConstantMin;
            },
            set: function(e) {
                2 === this._startLifetimeType && (this._maxStartLifetime = Math.max(e, this._startLifetimeConstantMax)),
                this._startLifetimeConstantMin = e;
            }
        }, {
            key: "startLifetimeConstantMax",
            get: function() {
                return this._startLifetimeConstantMax;
            },
            set: function(e) {
                2 === this._startLifetimeType && (this._maxStartLifetime = Math.max(this._startLifetimeConstantMin, e)),
                this._startLifetimeConstantMax = e;
            }
        }, {
            key: "startLifeTimeGradientMin",
            get: function() {
                return this._startLifeTimeGradientMin;
            },
            set: function(e) {
                if (3 === this._startLifetimeType) {
                    var t, r;
                    for (this._maxStartLifetime = -Number.MAX_VALUE,
                    t = 0,
                    r = e.gradientCount; t < r; t++)
                        this._maxStartLifetime = Math.max(this._maxStartLifetime, e.getValueByIndex(t));
                    for (t = 0,
                    r = this._startLifeTimeGradientMax.gradientCount; t < r; t++)
                        this._maxStartLifetime = Math.max(this._maxStartLifetime, this._startLifeTimeGradientMax.getValueByIndex(t));
                }
                this._startLifeTimeGradientMin = e;
            }
        }, {
            key: "startLifeTimeGradientMax",
            get: function() {
                return this._startLifeTimeGradientMax;
            },
            set: function(e) {
                if (3 === this._startLifetimeType) {
                    var t, r;
                    for (this._maxStartLifetime = -Number.MAX_VALUE,
                    t = 0,
                    r = this._startLifeTimeGradientMin.gradientCount; t < r; t++)
                        this._maxStartLifetime = Math.max(this._maxStartLifetime, this._startLifeTimeGradientMin.getValueByIndex(t));
                    for (t = 0,
                    r = e.gradientCount; t < r; t++)
                        this._maxStartLifetime = Math.max(this._maxStartLifetime, e.getValueByIndex(t));
                }
                this._startLifeTimeGradientMax = e;
            }
        }, {
            key: "velocityOverLifetime",
            get: function() {
                return this._velocityOverLifetime;
            },
            set: function(e) {
                var t = this._owner._render._shaderValues;
                if (e) {
                    var r = e.velocity
                      , n = r.type;
                    if (e.enable)
                        switch (n) {
                        case 0:
                            t.addDefine(Bt.SHADERDEFINE_VELOCITYOVERLIFETIMECONSTANT);
                            break;
                        case 1:
                            t.addDefine(Bt.SHADERDEFINE_VELOCITYOVERLIFETIMECURVE);
                            break;
                        case 2:
                            t.addDefine(Bt.SHADERDEFINE_VELOCITYOVERLIFETIMERANDOMCONSTANT);
                            break;
                        case 3:
                            t.addDefine(Bt.SHADERDEFINE_VELOCITYOVERLIFETIMERANDOMCURVE);
                        }
                    else
                        t.removeDefine(Bt.SHADERDEFINE_VELOCITYOVERLIFETIMECONSTANT),
                        t.removeDefine(Bt.SHADERDEFINE_VELOCITYOVERLIFETIMECURVE),
                        t.removeDefine(Bt.SHADERDEFINE_VELOCITYOVERLIFETIMERANDOMCONSTANT),
                        t.removeDefine(Bt.SHADERDEFINE_VELOCITYOVERLIFETIMERANDOMCURVE);
                    switch (n) {
                    case 0:
                        t.setVector3(Bt.VOLVELOCITYCONST, r.constant);
                        break;
                    case 1:
                        t.setBuffer(Bt.VOLVELOCITYGRADIENTX, r.gradientX._elements),
                        t.setBuffer(Bt.VOLVELOCITYGRADIENTY, r.gradientY._elements),
                        t.setBuffer(Bt.VOLVELOCITYGRADIENTZ, r.gradientZ._elements);
                        break;
                    case 2:
                        t.setVector3(Bt.VOLVELOCITYCONST, r.constantMin),
                        t.setVector3(Bt.VOLVELOCITYCONSTMAX, r.constantMax);
                        break;
                    case 3:
                        t.setBuffer(Bt.VOLVELOCITYGRADIENTX, r.gradientXMin._elements),
                        t.setBuffer(Bt.VOLVELOCITYGRADIENTXMAX, r.gradientXMax._elements),
                        t.setBuffer(Bt.VOLVELOCITYGRADIENTY, r.gradientYMin._elements),
                        t.setBuffer(Bt.VOLVELOCITYGRADIENTYMAX, r.gradientYMax._elements),
                        t.setBuffer(Bt.VOLVELOCITYGRADIENTZ, r.gradientZMin._elements),
                        t.setBuffer(Bt.VOLVELOCITYGRADIENTZMAX, r.gradientZMax._elements);
                    }
                    t.setInt(Bt.VOLSPACETYPE, e.space);
                } else
                    t.removeDefine(Bt.SHADERDEFINE_VELOCITYOVERLIFETIMECONSTANT),
                    t.removeDefine(Bt.SHADERDEFINE_VELOCITYOVERLIFETIMECURVE),
                    t.removeDefine(Bt.SHADERDEFINE_VELOCITYOVERLIFETIMERANDOMCONSTANT),
                    t.removeDefine(Bt.SHADERDEFINE_VELOCITYOVERLIFETIMERANDOMCURVE);
                this._velocityOverLifetime = e;
            }
        }, {
            key: "colorOverLifetime",
            get: function() {
                return this._colorOverLifetime;
            },
            set: function(e) {
                var t = this._owner._render._shaderValues;
                if (e) {
                    var r = e.color;
                    if (e.enable)
                        switch (r.type) {
                        case 1:
                            t.addDefine(Bt.SHADERDEFINE_COLOROVERLIFETIME);
                            break;
                        case 3:
                            t.addDefine(Bt.SHADERDEFINE_RANDOMCOLOROVERLIFETIME);
                        }
                    else
                        t.removeDefine(Bt.SHADERDEFINE_COLOROVERLIFETIME),
                        t.removeDefine(Bt.SHADERDEFINE_RANDOMCOLOROVERLIFETIME);
                    switch (r.type) {
                    case 1:
                        var n = r.gradient;
                        t.setBuffer(Bt.COLOROVERLIFEGRADIENTALPHAS, n._alphaElements),
                        t.setBuffer(Bt.COLOROVERLIFEGRADIENTCOLORS, n._rgbElements);
                        break;
                    case 3:
                        var i = r.gradientMin
                          , a = r.gradientMax;
                        t.setBuffer(Bt.COLOROVERLIFEGRADIENTALPHAS, i._alphaElements),
                        t.setBuffer(Bt.COLOROVERLIFEGRADIENTCOLORS, i._rgbElements),
                        t.setBuffer(Bt.MAXCOLOROVERLIFEGRADIENTALPHAS, a._alphaElements),
                        t.setBuffer(Bt.MAXCOLOROVERLIFEGRADIENTCOLORS, a._rgbElements);
                    }
                } else
                    t.removeDefine(Bt.SHADERDEFINE_COLOROVERLIFETIME),
                    t.removeDefine(Bt.SHADERDEFINE_RANDOMCOLOROVERLIFETIME),
                    t.setBuffer(Bt.COLOROVERLIFEGRADIENTALPHAS, n._alphaElements),
                    t.setBuffer(Bt.COLOROVERLIFEGRADIENTCOLORS, n._rgbElements),
                    t.setBuffer(Bt.COLOROVERLIFEGRADIENTALPHAS, i._alphaElements),
                    t.setBuffer(Bt.COLOROVERLIFEGRADIENTCOLORS, i._rgbElements),
                    t.setBuffer(Bt.MAXCOLOROVERLIFEGRADIENTALPHAS, a._alphaElements),
                    t.setBuffer(Bt.MAXCOLOROVERLIFEGRADIENTCOLORS, a._rgbElements);
                this._colorOverLifetime = e;
            }
        }, {
            key: "sizeOverLifetime",
            get: function() {
                return this._sizeOverLifetime;
            },
            set: function(e) {
                var t = this._owner._render._shaderValues;
                if (e) {
                    var r = e.size
                      , n = r.separateAxes
                      , i = r.type;
                    if (e.enable)
                        switch (i) {
                        case 0:
                            n ? t.addDefine(Bt.SHADERDEFINE_SIZEOVERLIFETIMECURVESEPERATE) : t.addDefine(Bt.SHADERDEFINE_SIZEOVERLIFETIMECURVE);
                            break;
                        case 2:
                            n ? t.addDefine(Bt.SHADERDEFINE_SIZEOVERLIFETIMERANDOMCURVESSEPERATE) : t.addDefine(Bt.SHADERDEFINE_SIZEOVERLIFETIMERANDOMCURVES);
                        }
                    else
                        t.removeDefine(Bt.SHADERDEFINE_SIZEOVERLIFETIMECURVE),
                        t.removeDefine(Bt.SHADERDEFINE_SIZEOVERLIFETIMECURVESEPERATE),
                        t.removeDefine(Bt.SHADERDEFINE_SIZEOVERLIFETIMERANDOMCURVES),
                        t.removeDefine(Bt.SHADERDEFINE_SIZEOVERLIFETIMERANDOMCURVESSEPERATE);
                    switch (i) {
                    case 0:
                        n ? (t.setBuffer(Bt.SOLSIZEGRADIENTX, r.gradientX._elements),
                        t.setBuffer(Bt.SOLSIZEGRADIENTY, r.gradientY._elements),
                        t.setBuffer(Bt.SOLSizeGradientZ, r.gradientZ._elements)) : t.setBuffer(Bt.SOLSIZEGRADIENT, r.gradient._elements);
                        break;
                    case 2:
                        n ? (t.setBuffer(Bt.SOLSIZEGRADIENTX, r.gradientXMin._elements),
                        t.setBuffer(Bt.SOLSIZEGRADIENTXMAX, r.gradientXMax._elements),
                        t.setBuffer(Bt.SOLSIZEGRADIENTY, r.gradientYMin._elements),
                        t.setBuffer(Bt.SOLSIZEGRADIENTYMAX, r.gradientYMax._elements),
                        t.setBuffer(Bt.SOLSizeGradientZ, r.gradientZMin._elements),
                        t.setBuffer(Bt.SOLSizeGradientZMAX, r.gradientZMax._elements)) : (t.setBuffer(Bt.SOLSIZEGRADIENT, r.gradientMin._elements),
                        t.setBuffer(Bt.SOLSizeGradientMax, r.gradientMax._elements));
                    }
                } else
                    t.removeDefine(Bt.SHADERDEFINE_SIZEOVERLIFETIMECURVE),
                    t.removeDefine(Bt.SHADERDEFINE_SIZEOVERLIFETIMECURVESEPERATE),
                    t.removeDefine(Bt.SHADERDEFINE_SIZEOVERLIFETIMERANDOMCURVES),
                    t.removeDefine(Bt.SHADERDEFINE_SIZEOVERLIFETIMERANDOMCURVESSEPERATE);
                this._sizeOverLifetime = e;
            }
        }, {
            key: "rotationOverLifetime",
            get: function() {
                return this._rotationOverLifetime;
            },
            set: function(e) {
                var t = this._owner._render._shaderValues;
                if (e) {
                    var r = e.angularVelocity;
                    if (!r)
                        return;
                    var n = r.separateAxes
                      , i = r.type;
                    if (e.enable)
                        switch (n ? t.addDefine(Bt.SHADERDEFINE_ROTATIONOVERLIFETIMESEPERATE) : t.addDefine(Bt.SHADERDEFINE_ROTATIONOVERLIFETIME),
                        i) {
                        case 0:
                            t.addDefine(Bt.SHADERDEFINE_ROTATIONOVERLIFETIMECONSTANT);
                            break;
                        case 1:
                            t.addDefine(Bt.SHADERDEFINE_ROTATIONOVERLIFETIMECURVE);
                            break;
                        case 2:
                            t.addDefine(Bt.SHADERDEFINE_ROTATIONOVERLIFETIMERANDOMCONSTANTS);
                            break;
                        case 3:
                            t.addDefine(Bt.SHADERDEFINE_ROTATIONOVERLIFETIMERANDOMCURVES);
                        }
                    else
                        t.removeDefine(Bt.SHADERDEFINE_ROTATIONOVERLIFETIME),
                        t.removeDefine(Bt.SHADERDEFINE_ROTATIONOVERLIFETIMESEPERATE),
                        t.removeDefine(Bt.SHADERDEFINE_ROTATIONOVERLIFETIMECONSTANT),
                        t.removeDefine(Bt.SHADERDEFINE_ROTATIONOVERLIFETIMECURVE),
                        t.removeDefine(Bt.SHADERDEFINE_ROTATIONOVERLIFETIMERANDOMCONSTANTS),
                        t.removeDefine(Bt.SHADERDEFINE_ROTATIONOVERLIFETIMERANDOMCURVES);
                    switch (i) {
                    case 0:
                        n ? t.setVector3(Bt.ROLANGULARVELOCITYCONSTSEPRARATE, r.constantSeparate) : t.setNumber(Bt.ROLANGULARVELOCITYCONST, r.constant);
                        break;
                    case 1:
                        n ? (t.setBuffer(Bt.ROLANGULARVELOCITYGRADIENTX, r.gradientX._elements),
                        t.setBuffer(Bt.ROLANGULARVELOCITYGRADIENTY, r.gradientY._elements),
                        t.setBuffer(Bt.ROLANGULARVELOCITYGRADIENTZ, r.gradientZ._elements)) : t.setBuffer(Bt.ROLANGULARVELOCITYGRADIENT, r.gradient._elements);
                        break;
                    case 2:
                        n ? (t.setVector3(Bt.ROLANGULARVELOCITYCONSTSEPRARATE, r.constantMinSeparate),
                        t.setVector3(Bt.ROLANGULARVELOCITYCONSTMAXSEPRARATE, r.constantMaxSeparate)) : (t.setNumber(Bt.ROLANGULARVELOCITYCONST, r.constantMin),
                        t.setNumber(Bt.ROLANGULARVELOCITYCONSTMAX, r.constantMax));
                        break;
                    case 3:
                        n ? (t.setBuffer(Bt.ROLANGULARVELOCITYGRADIENTX, r.gradientXMin._elements),
                        t.setBuffer(Bt.ROLANGULARVELOCITYGRADIENTXMAX, r.gradientXMax._elements),
                        t.setBuffer(Bt.ROLANGULARVELOCITYGRADIENTY, r.gradientYMin._elements),
                        t.setBuffer(Bt.ROLANGULARVELOCITYGRADIENTYMAX, r.gradientYMax._elements),
                        t.setBuffer(Bt.ROLANGULARVELOCITYGRADIENTZ, r.gradientZMin._elements),
                        t.setBuffer(Bt.ROLANGULARVELOCITYGRADIENTZMAX, r.gradientZMax._elements)) : (t.setBuffer(Bt.ROLANGULARVELOCITYGRADIENT, r.gradientMin._elements),
                        t.setBuffer(Bt.ROLANGULARVELOCITYGRADIENTMAX, r.gradientMax._elements));
                    }
                } else
                    t.removeDefine(Bt.SHADERDEFINE_ROTATIONOVERLIFETIME),
                    t.removeDefine(Bt.SHADERDEFINE_ROTATIONOVERLIFETIMESEPERATE),
                    t.removeDefine(Bt.SHADERDEFINE_ROTATIONOVERLIFETIMECONSTANT),
                    t.removeDefine(Bt.SHADERDEFINE_ROTATIONOVERLIFETIMECURVE),
                    t.removeDefine(Bt.SHADERDEFINE_ROTATIONOVERLIFETIMERANDOMCONSTANTS),
                    t.removeDefine(Bt.SHADERDEFINE_ROTATIONOVERLIFETIMERANDOMCURVES);
                this._rotationOverLifetime = e;
            }
        }, {
            key: "textureSheetAnimation",
            get: function() {
                return this._textureSheetAnimation;
            },
            set: function(e) {
                var t = this._owner._render._shaderValues;
                if (e) {
                    var r = e.frame
                      , n = r.type;
                    if (e.enable)
                        switch (n) {
                        case 1:
                            t.addDefine(Bt.SHADERDEFINE_TEXTURESHEETANIMATIONCURVE);
                            break;
                        case 3:
                            t.addDefine(Bt.SHADERDEFINE_TEXTURESHEETANIMATIONRANDOMCURVE);
                        }
                    else
                        t.removeDefine(Bt.SHADERDEFINE_TEXTURESHEETANIMATIONCURVE),
                        t.removeDefine(Bt.SHADERDEFINE_TEXTURESHEETANIMATIONRANDOMCURVE);
                    if (1 === n || 3 === n) {
                        t.setNumber(Bt.TEXTURESHEETANIMATIONCYCLES, e.cycles);
                        var i = e.tiles
                          , a = this._uvLength;
                        a.x = 1 / i.x,
                        a.y = 1 / i.y,
                        t.setVector2(Bt.TEXTURESHEETANIMATIONSUBUVLENGTH, this._uvLength);
                    }
                    switch (n) {
                    case 1:
                        t.setBuffer(Bt.TEXTURESHEETANIMATIONGRADIENTUVS, r.frameOverTimeData._elements);
                        break;
                    case 3:
                        t.setBuffer(Bt.TEXTURESHEETANIMATIONGRADIENTUVS, r.frameOverTimeDataMin._elements),
                        t.setBuffer(Bt.TEXTURESHEETANIMATIONGRADIENTMAXUVS, r.frameOverTimeDataMax._elements);
                    }
                } else
                    t.removeDefine(Bt.SHADERDEFINE_TEXTURESHEETANIMATIONCURVE),
                    t.removeDefine(Bt.SHADERDEFINE_TEXTURESHEETANIMATIONRANDOMCURVE);
                this._textureSheetAnimation = e;
            }
        }]),
        ShurikenParticleSystem;
    }();
    jt._RANDOMOFFSET = new Uint32Array([592910910, 3276756734, 322376503, 306581307, 1793934638, 3737431713, 2527743459, 2368504881, 4085612399, 3774601268, 326370691, 1494990940, 1089181156, 3159510623, 2941263940, 2786374529, 271901988, 4233252447]),
    jt.halfKSqrtOf2 = .71,
    jt._maxElapsedTime = 1 / 3,
    jt._tempVector30 = new o(),
    jt._tempVector31 = new o(),
    jt._tempVector32 = new o(),
    jt._tempVector33 = new o(),
    jt._tempVector34 = new o(),
    jt._tempVector35 = new o(),
    jt._tempVector36 = new o(),
    jt._tempVector37 = new o(),
    jt._tempVector38 = new o(),
    jt._tempVector39 = new o(),
    jt._tempPosition = new o(),
    jt._tempDirection = new o(),
    jt._type = Me._typeCounter++;
    var Qt = function(e) {
        function ShuriKenParticle3D() {
            var e;
            _classCallCheck(this, ShuriKenParticle3D),
            (e = _possibleConstructorReturn(this, _getPrototypeOf(ShuriKenParticle3D).call(this, null)))._render = new Ut(_assertThisInitialized(e)),
            e._particleSystem = new jt(_assertThisInitialized(e));
            var t = e._render._renderElements[0] = new et();
            return t.setTransform(e._transform),
            t.render = e._render,
            t.setGeometry(e._particleSystem),
            t.material = wt.defaultMaterial,
            e;
        }
        return _inherits(ShuriKenParticle3D, ge),
        _createClass(ShuriKenParticle3D, [{
            key: "particleSystem",
            get: function() {
                return this._particleSystem;
            }
        }, {
            key: "particleRenderer",
            get: function() {
                return this._render;
            }
        }], [{
            key: "__init__",
            value: function() {
                Bt.SHADERDEFINE_RENDERMODE_BILLBOARD = G.getDefineByName("SPHERHBILLBOARD"),
                Bt.SHADERDEFINE_RENDERMODE_STRETCHEDBILLBOARD = G.getDefineByName("STRETCHEDBILLBOARD"),
                Bt.SHADERDEFINE_RENDERMODE_HORIZONTALBILLBOARD = G.getDefineByName("HORIZONTALBILLBOARD"),
                Bt.SHADERDEFINE_RENDERMODE_VERTICALBILLBOARD = G.getDefineByName("VERTICALBILLBOARD"),
                Bt.SHADERDEFINE_COLOROVERLIFETIME = G.getDefineByName("COLOROVERLIFETIME"),
                Bt.SHADERDEFINE_RANDOMCOLOROVERLIFETIME = G.getDefineByName("RANDOMCOLOROVERLIFETIME"),
                Bt.SHADERDEFINE_VELOCITYOVERLIFETIMECONSTANT = G.getDefineByName("VELOCITYOVERLIFETIMECONSTANT"),
                Bt.SHADERDEFINE_VELOCITYOVERLIFETIMECURVE = G.getDefineByName("VELOCITYOVERLIFETIMECURVE"),
                Bt.SHADERDEFINE_VELOCITYOVERLIFETIMERANDOMCONSTANT = G.getDefineByName("VELOCITYOVERLIFETIMERANDOMCONSTANT"),
                Bt.SHADERDEFINE_VELOCITYOVERLIFETIMERANDOMCURVE = G.getDefineByName("VELOCITYOVERLIFETIMERANDOMCURVE"),
                Bt.SHADERDEFINE_TEXTURESHEETANIMATIONCURVE = G.getDefineByName("TEXTURESHEETANIMATIONCURVE"),
                Bt.SHADERDEFINE_TEXTURESHEETANIMATIONRANDOMCURVE = G.getDefineByName("TEXTURESHEETANIMATIONRANDOMCURVE"),
                Bt.SHADERDEFINE_ROTATIONOVERLIFETIME = G.getDefineByName("ROTATIONOVERLIFETIME"),
                Bt.SHADERDEFINE_ROTATIONOVERLIFETIMESEPERATE = G.getDefineByName("ROTATIONOVERLIFETIMESEPERATE"),
                Bt.SHADERDEFINE_ROTATIONOVERLIFETIMECONSTANT = G.getDefineByName("ROTATIONOVERLIFETIMECONSTANT"),
                Bt.SHADERDEFINE_ROTATIONOVERLIFETIMECURVE = G.getDefineByName("ROTATIONOVERLIFETIMECURVE"),
                Bt.SHADERDEFINE_ROTATIONOVERLIFETIMERANDOMCONSTANTS = G.getDefineByName("ROTATIONOVERLIFETIMERANDOMCONSTANTS"),
                Bt.SHADERDEFINE_ROTATIONOVERLIFETIMERANDOMCURVES = G.getDefineByName("ROTATIONOVERLIFETIMERANDOMCURVES"),
                Bt.SHADERDEFINE_SIZEOVERLIFETIMECURVE = G.getDefineByName("SIZEOVERLIFETIMECURVE"),
                Bt.SHADERDEFINE_SIZEOVERLIFETIMECURVESEPERATE = G.getDefineByName("SIZEOVERLIFETIMECURVESEPERATE"),
                Bt.SHADERDEFINE_SIZEOVERLIFETIMERANDOMCURVES = G.getDefineByName("SIZEOVERLIFETIMERANDOMCURVES"),
                Bt.SHADERDEFINE_SIZEOVERLIFETIMERANDOMCURVESSEPERATE = G.getDefineByName("SIZEOVERLIFETIMERANDOMCURVESSEPERATE"),
                Bt.SHADERDEFINE_RENDERMODE_MESH = G.getDefineByName("RENDERMODE_MESH"),
                Bt.SHADERDEFINE_SHAPE = G.getDefineByName("SHAPE");
            }
        }]),
        _createClass(ShuriKenParticle3D, [{
            key: "_parseModule",
            value: function(e, r) {
                for (var n in r)
                    switch (n) {
                    case "bases":
                        var i = r.bases;
                        for (var a in i)
                            e[a] = i[a];
                        break;
                    case "vector2s":
                        var o = r.vector2s;
                        for (var a in o) {
                            var s = e[a]
                              , l = o[a];
                            s.setValue(l[0], l[1]),
                            e[a] = s;
                        }
                        break;
                    case "vector3s":
                        var u = r.vector3s;
                        for (var a in u) {
                            var c = e[a]
                              , h = u[a];
                            c.setValue(h[0], h[1], h[2]),
                            e[a] = c;
                        }
                        break;
                    case "vector4s":
                        var _ = r.vector4s;
                        for (var a in _) {
                            var d = e[a]
                              , f = _[a];
                            d.setValue(f[0], f[1], f[2], f[3]),
                            e[a] = d;
                        }
                        break;
                    case "gradientDataNumbers":
                        var m = r.gradientDataNumbers;
                        for (var a in m) {
                            for (var p = e[a], v = r[a], T = 0, E = v.length; T < E; T++) {
                                var y = v[T];
                                p.add(y.key, y.value);
                            }
                            e[a] = p;
                        }
                        break;
                    case "resources":
                        var g = r.resources;
                        for (var a in g)
                            e[a] = t.Loader.getRes(g[a]);
                        break;
                    case "bursts":
                        var S = r.bursts;
                        for (T = 0,
                        E = S.length; T < E; T++) {
                            var R = S[T];
                            e.addBurst(new pt(R.time,R.min,R.max));
                        }
                        break;
                    case "randomSeed":
                        e.randomSeed[0] = r.randomSeed;
                        break;
                    case "shapeType":
                    case "type":
                    case "color":
                    case "size":
                    case "frame":
                    case "startFrame":
                    case "angularVelocity":
                    case "velocity":
                        break;
                    default:
                        throw "ShurikenParticle3D:unknown type.";
                    }
            }
        }, {
            key: "_parse",
            value: function(e, t) {
                if (_get(_getPrototypeOf(ShuriKenParticle3D.prototype), "_parse", this).call(this, e, t),
                e.main) {
                    var r = this.particleSystem
                      , n = this.particleRenderer;
                    this._parseModule(n, e.renderer),
                    this._parseModule(r, e.main),
                    this._parseModule(r.emission, e.emission);
                    var a = e.shape;
                    if (a) {
                        var s;
                        switch (a.shapeType) {
                        case 0:
                            s = new Ot();
                            break;
                        case 1:
                            s = new Pt();
                            break;
                        case 2:
                            s = new Lt();
                            break;
                        case 3:
                            s = new At();
                            break;
                        case 7:
                            s = new It();
                            break;
                        default:
                            throw "ShuriKenParticle3D:unknown shape type.";
                        }
                        this._parseModule(s, a),
                        r.shape = s;
                    }
                    var l = e.velocityOverLifetime;
                    if (l) {
                        var u, c = l.velocity;
                        switch (c.type) {
                        case 0:
                            var h = c.constant;
                            u = Ct.createByConstant(h ? new o(h[0],h[1],h[2]) : new o(0,0,0));
                            break;
                        case 1:
                            u = Ct.createByGradient(this._initParticleVelocity(c.gradientX), this._initParticleVelocity(c.gradientY), this._initParticleVelocity(c.gradientZ));
                            break;
                        case 2:
                            var _ = c.constantMin
                              , d = c.constantMax;
                            u = Ct.createByRandomTwoConstant(_ ? new o(_[0],_[1],_[2]) : new o(0,0,0), d ? new o(d[0],d[1],d[2]) : new o(0,0,0));
                            break;
                        case 3:
                            u = Ct.createByRandomTwoGradient(this._initParticleVelocity(c.gradientXMin), this._initParticleVelocity(c.gradientXMax), this._initParticleVelocity(c.gradientYMin), this._initParticleVelocity(c.gradientYMax), this._initParticleVelocity(c.gradientZMin), this._initParticleVelocity(c.gradientZMax));
                        }
                        var f = new Vt(u);
                        this._parseModule(f, l),
                        r.velocityOverLifetime = f;
                    }
                    var m = e.colorOverLifetime;
                    if (m) {
                        var p, v = m.color;
                        switch (v.type) {
                        case 0:
                            var T = v.constant;
                            p = vt.createByConstant(T ? new i(T[0],T[1],T[2],T[3]) : new i(0,0,0,0));
                            break;
                        case 1:
                            p = vt.createByGradient(this._initParticleColor(v.gradient));
                            break;
                        case 2:
                            var E = v.constantMin
                              , y = v.constantMax;
                            p = vt.createByRandomTwoConstant(E ? new i(E[0],E[1],E[2],E[3]) : new i(0,0,0,0), E ? new i(y[0],y[1],y[2],y[3]) : new i(0,0,0,0));
                            break;
                        case 3:
                            p = vt.createByRandomTwoGradient(this._initParticleColor(v.gradientMin), this._initParticleColor(v.gradientMax));
                        }
                        var g = new Tt(p);
                        this._parseModule(g, m),
                        r.colorOverLifetime = g;
                    }
                    var S = e.sizeOverLifetime;
                    if (S) {
                        var R, C = S.size;
                        switch (C.type) {
                        case 0:
                            R = C.separateAxes ? Rt.createByGradientSeparate(this._initParticleSize(C.gradientX), this._initParticleSize(C.gradientY), this._initParticleSize(C.gradientZ)) : Rt.createByGradient(this._initParticleSize(C.gradient));
                            break;
                        case 1:
                            if (C.separateAxes) {
                                var M = C.constantMinSeparate
                                  , D = C.constantMaxSeparate;
                                R = Rt.createByRandomTwoConstantSeparate(M ? new o(M[0],M[1],M[2]) : new o(0,0,0), D ? new o(D[0],D[1],D[2]) : new o(0,0,0));
                            } else
                                R = Rt.createByRandomTwoConstant(C.constantMin || 0, C.constantMax || 0);
                            break;
                        case 2:
                            R = C.separateAxes ? Rt.createByRandomTwoGradientSeparate(this._initParticleSize(C.gradientXMin), this._initParticleSize(C.gradientYMin), this._initParticleSize(C.gradientZMin), this._initParticleSize(C.gradientXMax), this._initParticleSize(C.gradientYMax), this._initParticleSize(C.gradientZMax)) : Rt.createByRandomTwoGradient(this._initParticleSize(C.gradientMin), this._initParticleSize(C.gradientMax));
                        }
                        var x = new Nt(R);
                        this._parseModule(x, S),
                        r.sizeOverLifetime = x;
                    }
                    var A = e.rotationOverLifetime;
                    if (A) {
                        var I, L = A.angularVelocity;
                        switch (L.type) {
                        case 0:
                            if (L.separateAxes) {
                                var P = L.constantSeparate;
                                I = yt.createByConstantSeparate(P ? new o(P[0],P[1],P[2]) : new o(0,0,Math.PI / 4));
                            } else
                                I = yt.createByConstant(L.constant || Math.PI / 4);
                            break;
                        case 1:
                            I = L.separateAxes ? yt.createByGradientSeparate(this._initParticleRotation(L.gradientX), this._initParticleRotation(L.gradientY), this._initParticleRotation(L.gradientZ)) : yt.createByGradient(this._initParticleRotation(L.gradient));
                            break;
                        case 2:
                            if (L.separateAxes) {
                                var O = L.constantMinSeparate
                                  , N = L.constantMaxSeparate;
                                I = yt.createByRandomTwoConstantSeparate(O ? new o(O[0],O[1],O[2]) : new o(0,0,0), N ? new o(N[0],N[1],N[2]) : new o(0,0,Math.PI / 4));
                            } else
                                I = yt.createByRandomTwoConstant(L.constantMin || 0, L.constantMax || Math.PI / 4);
                            break;
                        case 3:
                            L.separateAxes || (I = yt.createByRandomTwoGradient(this._initParticleRotation(L.gradientMin), this._initParticleRotation(L.gradientMax)));
                        }
                        var b = new Mt(I);
                        this._parseModule(b, A),
                        r.rotationOverLifetime = b;
                    }
                    var k = e.textureSheetAnimation;
                    if (k) {
                        var V, B = k.frame;
                        switch (B.type) {
                        case 0:
                            V = Et.createByConstant(B.constant);
                            break;
                        case 1:
                            V = Et.createByOverTime(this._initParticleFrame(B.overTime));
                            break;
                        case 2:
                            V = Et.createByRandomTwoConstant(B.constantMin, B.constantMax);
                            break;
                        case 3:
                            V = Et.createByRandomTwoOverTime(this._initParticleFrame(B.overTimeMin), this._initParticleFrame(B.overTimeMax));
                        }
                        var w, F = k.startFrame;
                        switch (F.type) {
                        case 0:
                            w = bt.createByConstant(F.constant);
                            break;
                        case 1:
                            w = bt.createByRandomTwoConstant(F.constantMin, F.constantMax);
                        }
                        var U = new kt(V,w);
                        this._parseModule(U, k),
                        r.textureSheetAnimation = U;
                    }
                } else
                    this._parseOld(e);
            }
        }, {
            key: "_activeHierarchy",
            value: function(e) {
                _get(_getPrototypeOf(ShuriKenParticle3D.prototype), "_activeHierarchy", this).call(this, e),
                this.particleSystem.playOnAwake && this.particleSystem.play();
            }
        }, {
            key: "_inActiveHierarchy",
            value: function(e) {
                _get(_getPrototypeOf(ShuriKenParticle3D.prototype), "_inActiveHierarchy", this).call(this, e),
                this.particleSystem.isAlive && this.particleSystem.simulate(0, !0);
            }
        }, {
            key: "_cloneTo",
            value: function(e, t, r) {
                var n = e
                  , i = n._particleSystem;
                this._particleSystem.cloneTo(i);
                var a = n._render
                  , o = this._render;
                a.sharedMaterials = o.sharedMaterials,
                a.enable = o.enable,
                a.renderMode = o.renderMode,
                a.mesh = o.mesh,
                a.stretchedBillboardCameraSpeedScale = o.stretchedBillboardCameraSpeedScale,
                a.stretchedBillboardSpeedScale = o.stretchedBillboardSpeedScale,
                a.stretchedBillboardLengthScale = o.stretchedBillboardLengthScale,
                a.sortingFudge = o.sortingFudge,
                _get(_getPrototypeOf(ShuriKenParticle3D.prototype), "_cloneTo", this).call(this, e, t, r);
            }
        }, {
            key: "destroy",
            value: function() {
                var e = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0];
                this.destroyed || (_get(_getPrototypeOf(ShuriKenParticle3D.prototype), "destroy", this).call(this, e),
                this._particleSystem.destroy(),
                this._particleSystem = null);
            }
        }, {
            key: "_create",
            value: function() {
                return new ShuriKenParticle3D();
            }
        }, {
            key: "_parseOld",
            value: function(e) {
                var r, a, s, l = Math.PI / 180, u = this.particleRenderer, c = e.material;
                c && (s = t.Loader.getRes(c.path)),
                u.sharedMaterial = s;
                var h = e.meshPath;
                h && (u.mesh = t.Loader.getRes(h)),
                u.renderMode = e.renderMode,
                u.stretchedBillboardCameraSpeedScale = e.stretchedBillboardCameraSpeedScale,
                u.stretchedBillboardSpeedScale = e.stretchedBillboardSpeedScale,
                u.stretchedBillboardLengthScale = e.stretchedBillboardLengthScale,
                u.sortingFudge = e.sortingFudge ? e.sortingFudge : 0;
                var _ = this.particleSystem;
                _.isPerformanceMode = e.isPerformanceMode,
                _.duration = e.duration,
                _.looping = e.looping,
                _.prewarm = e.prewarm,
                _.startDelayType = e.startDelayType,
                _.startDelay = e.startDelay,
                _.startDelayMin = e.startDelayMin,
                _.startDelayMax = e.startDelayMax,
                _.startLifetimeType = e.startLifetimeType,
                _.startLifetimeConstant = e.startLifetimeConstant,
                _.startLifeTimeGradient = ShuriKenParticle3D._initStartLife(e.startLifetimeGradient),
                _.startLifetimeConstantMin = e.startLifetimeConstantMin,
                _.startLifetimeConstantMax = e.startLifetimeConstantMax,
                _.startLifeTimeGradientMin = ShuriKenParticle3D._initStartLife(e.startLifetimeGradientMin),
                _.startLifeTimeGradientMax = ShuriKenParticle3D._initStartLife(e.startLifetimeGradientMax),
                _.startSpeedType = e.startSpeedType,
                _.startSpeedConstant = e.startSpeedConstant,
                _.startSpeedConstantMin = e.startSpeedConstantMin,
                _.startSpeedConstantMax = e.startSpeedConstantMax,
                _.threeDStartSize = e.threeDStartSize,
                _.startSizeType = e.startSizeType,
                _.startSizeConstant = e.startSizeConstant;
                var d = e.startSizeConstantSeparate
                  , f = _.startSizeConstantSeparate;
                f.x = d[0],
                f.y = d[1],
                f.z = d[2],
                _.startSizeConstantMin = e.startSizeConstantMin,
                _.startSizeConstantMax = e.startSizeConstantMax;
                var m = e.startSizeConstantMinSeparate
                  , p = _.startSizeConstantMinSeparate;
                p.x = m[0],
                p.y = m[1],
                p.z = m[2];
                var v = e.startSizeConstantMaxSeparate
                  , T = _.startSizeConstantMaxSeparate;
                T.x = v[0],
                T.y = v[1],
                T.z = v[2],
                _.threeDStartRotation = e.threeDStartRotation,
                _.startRotationType = e.startRotationType,
                _.startRotationConstant = e.startRotationConstant * l;
                var E = e.startRotationConstantSeparate
                  , y = _.startRotationConstantSeparate;
                y.x = E[0] * l,
                y.y = E[1] * l,
                y.z = E[2] * l,
                _.startRotationConstantMin = e.startRotationConstantMin * l,
                _.startRotationConstantMax = e.startRotationConstantMax * l;
                var g = e.startRotationConstantMinSeparate
                  , S = _.startRotationConstantMinSeparate;
                S.x = g[0] * l,
                S.y = g[1] * l,
                S.z = g[2] * l;
                var R = e.startRotationConstantMaxSeparate
                  , C = _.startRotationConstantMaxSeparate;
                C.x = R[0] * l,
                C.y = R[1] * l,
                C.z = R[2] * l,
                _.randomizeRotationDirection = e.randomizeRotationDirection,
                _.startColorType = e.startColorType;
                var M = e.startColorConstant
                  , D = _.startColorConstant;
                D.x = M[0],
                D.y = M[1],
                D.z = M[2],
                D.w = M[3];
                var x = e.startColorConstantMin
                  , A = _.startColorConstantMin;
                A.x = x[0],
                A.y = x[1],
                A.z = x[2],
                A.w = x[3];
                var I = e.startColorConstantMax
                  , L = _.startColorConstantMax;
                L.x = I[0],
                L.y = I[1],
                L.z = I[2],
                L.w = I[3],
                _.gravityModifier = e.gravityModifier,
                _.simulationSpace = e.simulationSpace,
                void 0 !== e.simulationSpeed && (_.simulationSpeed = e.simulationSpeed),
                _.scaleMode = e.scaleMode,
                _.playOnAwake = e.playOnAwake,
                _.maxParticles = e.maxParticles;
                var P = e.autoRandomSeed;
                null != P && (_.autoRandomSeed = P);
                var O = e.randomSeed;
                null != O && (_.randomSeed[0] = O);
                var N = e.emission
                  , b = _.emission;
                if (N) {
                    b.emissionRate = N.emissionRate;
                    var k = N.bursts;
                    if (k)
                        for (r = 0,
                        a = k.length; r < a; r++) {
                            var V = k[r];
                            b.addBurst(new pt(V.time,V.min,V.max));
                        }
                    b.enable = N.enable;
                } else
                    b.enable = !1;
                var B = e.shape;
                if (B) {
                    var w;
                    switch (B.shapeType) {
                    case 0:
                        var F;
                        w = F = new Ot(),
                        F.radius = B.sphereRadius,
                        F.emitFromShell = B.sphereEmitFromShell,
                        F.randomDirection = B.sphereRandomDirection;
                        break;
                    case 1:
                        var U;
                        w = U = new Pt(),
                        U.radius = B.hemiSphereRadius,
                        U.emitFromShell = B.hemiSphereEmitFromShell,
                        U.randomDirection = B.hemiSphereRandomDirection;
                        break;
                    case 2:
                        var G;
                        w = G = new Lt(),
                        G.angle = B.coneAngle * l,
                        G.radius = B.coneRadius,
                        G.length = B.coneLength,
                        G.emitType = B.coneEmitType,
                        G.randomDirection = B.coneRandomDirection;
                        break;
                    case 3:
                        var z;
                        w = z = new At(),
                        z.x = B.boxX,
                        z.y = B.boxY,
                        z.z = B.boxZ,
                        z.randomDirection = B.boxRandomDirection;
                        break;
                    case 7:
                        var H;
                        w = H = new It(),
                        H.radius = B.circleRadius,
                        H.arc = B.circleArc * l,
                        H.emitFromEdge = B.circleEmitFromEdge,
                        H.randomDirection = B.circleRandomDirection;
                        break;
                    default:
                        var W;
                        w = W = new It(),
                        W.radius = B.circleRadius,
                        W.arc = B.circleArc * l,
                        W.emitFromEdge = B.circleEmitFromEdge,
                        W.randomDirection = B.circleRandomDirection;
                    }
                    w.enable = B.enable,
                    _.shape = w;
                }
                var X = e.velocityOverLifetime;
                if (X) {
                    var Y, Z = X.velocity;
                    switch (Z.type) {
                    case 0:
                        var j = Z.constant;
                        Y = Ct.createByConstant(new o(j[0],j[1],j[2]));
                        break;
                    case 1:
                        Y = Ct.createByGradient(this._initParticleVelocity(Z.gradientX), this._initParticleVelocity(Z.gradientY), this._initParticleVelocity(Z.gradientZ));
                        break;
                    case 2:
                        var Q = Z.constantMin
                          , q = Z.constantMax;
                        Y = Ct.createByRandomTwoConstant(new o(Q[0],Q[1],Q[2]), new o(q[0],q[1],q[2]));
                        break;
                    case 3:
                        Y = Ct.createByRandomTwoGradient(this._initParticleVelocity(Z.gradientXMin), this._initParticleVelocity(Z.gradientXMax), this._initParticleVelocity(Z.gradientYMin), this._initParticleVelocity(Z.gradientYMax), this._initParticleVelocity(Z.gradientZMin), this._initParticleVelocity(Z.gradientZMax));
                    }
                    var K = new Vt(Y);
                    K.space = X.space,
                    K.enable = X.enable,
                    _.velocityOverLifetime = K;
                }
                var J = e.colorOverLifetime;
                if (J) {
                    var $, ee = J.color;
                    switch (ee.type) {
                    case 0:
                        var te = ee.constant;
                        $ = vt.createByConstant(new i(te[0],te[1],te[2],te[3]));
                        break;
                    case 1:
                        $ = vt.createByGradient(this._initParticleColor(ee.gradient));
                        break;
                    case 2:
                        var re = ee.constantMin
                          , ne = ee.constantMax;
                        $ = vt.createByRandomTwoConstant(new i(re[0],re[1],re[2],re[3]), new i(ne[0],ne[1],ne[2],ne[3]));
                        break;
                    case 3:
                        $ = vt.createByRandomTwoGradient(this._initParticleColor(ee.gradientMin), this._initParticleColor(ee.gradientMax));
                    }
                    var ie = new Tt($);
                    ie.enable = J.enable,
                    _.colorOverLifetime = ie;
                }
                var ae = e.sizeOverLifetime;
                if (ae) {
                    var oe, se = ae.size;
                    switch (se.type) {
                    case 0:
                        oe = se.separateAxes ? Rt.createByGradientSeparate(this._initParticleSize(se.gradientX), this._initParticleSize(se.gradientY), this._initParticleSize(se.gradientZ)) : Rt.createByGradient(this._initParticleSize(se.gradient));
                        break;
                    case 1:
                        if (se.separateAxes) {
                            var le = se.constantMinSeparate
                              , ue = se.constantMaxSeparate;
                            oe = Rt.createByRandomTwoConstantSeparate(new o(le[0],le[1],le[2]), new o(ue[0],ue[1],ue[2]));
                        } else
                            oe = Rt.createByRandomTwoConstant(se.constantMin, se.constantMax);
                        break;
                    case 2:
                        oe = se.separateAxes ? Rt.createByRandomTwoGradientSeparate(this._initParticleSize(se.gradientXMin), this._initParticleSize(se.gradientYMin), this._initParticleSize(se.gradientZMin), this._initParticleSize(se.gradientXMax), this._initParticleSize(se.gradientYMax), this._initParticleSize(se.gradientZMax)) : Rt.createByRandomTwoGradient(this._initParticleSize(se.gradientMin), this._initParticleSize(se.gradientMax));
                    }
                    var ce = new Nt(oe);
                    ce.enable = ae.enable,
                    _.sizeOverLifetime = ce;
                }
                var he = e.rotationOverLifetime;
                if (he) {
                    var _e, de = he.angularVelocity;
                    switch (de.type) {
                    case 0:
                        if (de.separateAxes) {
                            var fe = de.constantSeparate;
                            _e = yt.createByConstantSeparate(new o(fe[0] * l,fe[1] * l,fe[2] * l));
                        } else
                            _e = yt.createByConstant(de.constant * l);
                        break;
                    case 1:
                        _e = de.separateAxes ? yt.createByGradientSeparate(this._initParticleRotation(de.gradientX), this._initParticleRotation(de.gradientY), this._initParticleRotation(de.gradientZ)) : yt.createByGradient(this._initParticleRotation(de.gradient));
                        break;
                    case 2:
                        if (de.separateAxes) {
                            var me = de.constantMinSeparate
                              , pe = de.constantMaxSeparate;
                            _e = yt.createByRandomTwoConstantSeparate(new o(me[0] * l,me[1] * l,me[2] * l), new o(pe[0] * l,pe[1] * l,pe[2] * l));
                        } else
                            _e = yt.createByRandomTwoConstant(de.constantMin * l, de.constantMax * l);
                        break;
                    case 3:
                        de.separateAxes || (_e = yt.createByRandomTwoGradient(this._initParticleRotation(de.gradientMin), this._initParticleRotation(de.gradientMax)));
                    }
                    var ve = new Mt(_e);
                    ve.enable = he.enable,
                    _.rotationOverLifetime = ve;
                }
                var Te = e.textureSheetAnimation;
                if (Te) {
                    var Ee, ye = Te.frame;
                    switch (ye.type) {
                    case 0:
                        Ee = Et.createByConstant(ye.constant);
                        break;
                    case 1:
                        Ee = Et.createByOverTime(this._initParticleFrame(ye.overTime));
                        break;
                    case 2:
                        Ee = Et.createByRandomTwoConstant(ye.constantMin, ye.constantMax);
                        break;
                    case 3:
                        Ee = Et.createByRandomTwoOverTime(this._initParticleFrame(ye.overTimeMin), this._initParticleFrame(ye.overTimeMax));
                    }
                    var ge, Se = Te.startFrame;
                    switch (Se.type) {
                    case 0:
                        ge = bt.createByConstant(Se.constant);
                        break;
                    case 1:
                        ge = bt.createByRandomTwoConstant(Se.constantMin, Se.constantMax);
                    }
                    var Re = new kt(Ee,ge);
                    Re.enable = Te.enable;
                    var Ce = Te.tiles;
                    Re.tiles = new n(Ce[0],Ce[1]),
                    Re.type = Te.type,
                    Re.randomRow = Te.randomRow;
                    var Me = Te.rowIndex;
                    void 0 !== Me && (Re.rowIndex = Me),
                    Re.cycles = Te.cycles,
                    _.textureSheetAnimation = Re;
                }
            }
        }, {
            key: "_initParticleColor",
            value: function(e) {
                var t = new mt(4,4);
                if (e) {
                    var r, n, i = e.alphas;
                    if (i)
                        for (r = 0,
                        n = i.length; r < n; r++) {
                            3 == r && n > 4 && (r = n - 1,
                            console.warn("GradientDataColor warning:alpha data length is large than 4, will ignore the middle data."));
                            var a = i[r];
                            t.addColorAlpha(a.key, a.value);
                        }
                    else
                        t.addColorAlpha(0, 1),
                        t.addColorAlpha(1, 1);
                    var o = e.rgbs;
                    if (o)
                        for (r = 0,
                        n = o.length; r < n; r++) {
                            3 == r && n > 4 && (r = n - 1,
                            console.warn("GradientDataColor warning:rgb data length is large than 4, will ignore the middle data."));
                            var s = o[r]
                              , l = s.value;
                            t.addColorRGB(s.key, new ve(l[0],l[1],l[2],1));
                        }
                    else
                        t.addColorRGB(0, new ve(1,1,1,1)),
                        t.addColorRGB(1, new ve(1,1,1,1));
                } else
                    t.addColorAlpha(0, 1),
                    t.addColorAlpha(1, 1),
                    t.addColorRGB(0, new ve(1,1,1,1)),
                    t.addColorRGB(1, new ve(1,1,1,1));
                return t;
            }
        }, {
            key: "_initParticleFrame",
            value: function(e) {
                var t = new gt();
                if (e)
                    for (var r = e.frames, n = 0, i = r.length; n < i; n++) {
                        var a = r[n];
                        t.add(a.key, a.value);
                    }
                else
                    t.add(0, 0),
                    t.add(1, 1);
                return t;
            }
        }, {
            key: "_initParticleVelocity",
            value: function(e) {
                for (var t = new St(), r = e.velocitys, n = 0, i = r.length; n < i; n++) {
                    var a = r[n];
                    t.add(a.key, a.value);
                }
                return t;
            }
        }, {
            key: "_initParticleSize",
            value: function(e) {
                var t = new St();
                if (e)
                    for (var r = e.sizes, n = 0, i = r.length; n < i; n++) {
                        var a = r[n];
                        t.add(a.key, a.value);
                    }
                else
                    t.add(0, 0),
                    t.add(1, 1);
                return t;
            }
        }, {
            key: "_initParticleRotation",
            value: function(e) {
                for (var t = new St(), r = e.angularVelocitys, n = 0, i = r.length; n < i; n++) {
                    var a = r[n];
                    t.add(a.key, a.value / 180 * Math.PI);
                }
                return t;
            }
        }], [{
            key: "_initStartLife",
            value: function(e) {
                for (var t = new St(), r = e.startLifetimes, n = 0, i = r.length; n < i; n++) {
                    var a = r[n];
                    t.add(a.key, a.value);
                }
                return t;
            }
        }]),
        ShuriKenParticle3D;
    }()
      , qt = function(e) {
        function PixelLineMaterial() {
            var e;
            return _classCallCheck(this, PixelLineMaterial),
            (e = _possibleConstructorReturn(this, _getPrototypeOf(PixelLineMaterial).call(this))).setShaderName("LineShader"),
            e._shaderValues.setVector(PixelLineMaterial.COLOR, new i(1,1,1,1)),
            e;
        }
        return _inherits(PixelLineMaterial, Z),
        _createClass(PixelLineMaterial, [{
            key: "clone",
            value: function() {
                var e = new PixelLineMaterial();
                return this.cloneTo(e),
                e;
            }
        }, {
            key: "color",
            get: function() {
                return this._shaderValues.getVector(PixelLineMaterial.COLOR);
            },
            set: function(e) {
                this._shaderValues.setVector(PixelLineMaterial.COLOR, e);
            }
        }, {
            key: "depthWrite",
            set: function(e) {
                this._shaderValues.setBool(PixelLineMaterial.DEPTH_WRITE, e);
            },
            get: function() {
                return this._shaderValues.getBool(PixelLineMaterial.DEPTH_WRITE);
            }
        }, {
            key: "cull",
            set: function(e) {
                this._shaderValues.setInt(PixelLineMaterial.CULL, e);
            },
            get: function() {
                return this._shaderValues.getInt(PixelLineMaterial.CULL);
            }
        }, {
            key: "blend",
            set: function(e) {
                this._shaderValues.setInt(PixelLineMaterial.BLEND, e);
            },
            get: function() {
                return this._shaderValues.getInt(PixelLineMaterial.BLEND);
            }
        }, {
            key: "blendSrc",
            set: function(e) {
                this._shaderValues.setInt(PixelLineMaterial.BLEND_SRC, e);
            },
            get: function() {
                return this._shaderValues.getInt(PixelLineMaterial.BLEND_SRC);
            }
        }, {
            key: "blendDst",
            set: function(e) {
                this._shaderValues.setInt(PixelLineMaterial.BLEND_DST, e);
            },
            get: function() {
                return this._shaderValues.getInt(PixelLineMaterial.BLEND_DST);
            }
        }, {
            key: "depthTest",
            set: function(e) {
                this._shaderValues.setInt(PixelLineMaterial.DEPTH_TEST, e);
            },
            get: function() {
                return this._shaderValues.getInt(PixelLineMaterial.DEPTH_TEST);
            }
        }], [{
            key: "__initDefine__",
            value: function() {}
        }]),
        PixelLineMaterial;
    }();
    qt.COLOR = G.propertyNameToID("u_Color"),
    qt.CULL = G.propertyNameToID("s_Cull"),
    qt.BLEND = G.propertyNameToID("s_Blend"),
    qt.BLEND_SRC = G.propertyNameToID("s_BlendSrc"),
    qt.BLEND_DST = G.propertyNameToID("s_BlendDst"),
    qt.DEPTH_TEST = G.propertyNameToID("s_DepthTest"),
    qt.DEPTH_WRITE = G.propertyNameToID("s_DepthWrite");
    var Kt = function() {
        function PixelLineVertex() {
            _classCallCheck(this, PixelLineVertex);
        }
        return _createClass(PixelLineVertex, [{
            key: "vertexDeclaration",
            get: function() {
                return PixelLineVertex._vertexDeclaration;
            }
        }], [{
            key: "__init__",
            value: function() {
                PixelLineVertex._vertexDeclaration = new oe(28,[new le(0,ae.Vector3,ue.MESH_POSITION0), new le(12,ae.Vector4,ue.MESH_COLOR0)]);
            }
        }, {
            key: "vertexDeclaration",
            get: function() {
                return PixelLineVertex._vertexDeclaration;
            }
        }]),
        PixelLineVertex;
    }()
      , Jt = function(e) {
        function SimpleSingletonList() {
            return _classCallCheck(this, SimpleSingletonList),
            _possibleConstructorReturn(this, _getPrototypeOf(SimpleSingletonList).call(this));
        }
        return _inherits(SimpleSingletonList, nt),
        _createClass(SimpleSingletonList, [{
            key: "add",
            value: function(e) {
                if (-1 !== e._getIndexInList())
                    throw "SimpleSingletonList:" + e + " has  in  SingletonList.";
                this._add(e),
                e._setIndexInList(this.length++);
            }
        }, {
            key: "remove",
            value: function(e) {
                var t = e._getIndexInList();
                if (this.length--,
                t !== this.length) {
                    var r = this.elements[this.length];
                    this.elements[t] = r,
                    r._setIndexInList(t);
                }
                e._setIndexInList(-1);
            }
        }, {
            key: "clear",
            value: function() {
                for (var e, t = this.elements, r = this.length; e < r; e++)
                    t[e]._setIndexInList(-1);
                this.length = 0;
            }
        }]),
        SimpleSingletonList;
    }()
      , $t = function() {
        function SphericalHarmonicsL2() {
            _classCallCheck(this, SphericalHarmonicsL2),
            this._coefficients = new Float32Array(27);
        }
        return _createClass(SphericalHarmonicsL2, [{
            key: "getCoefficient",
            value: function(e, t) {
                return this._coefficients[9 * e + t];
            }
        }, {
            key: "setCoefficient",
            value: function(e, t, r) {
                this._coefficients[9 * e + t] = r;
            }
        }, {
            key: "setCoefficients",
            value: function(e, t, r, n, i, a, o, s, l, u) {
                var c = 9 * e;
                this._coefficients[c] = t,
                this._coefficients[++c] = r,
                this._coefficients[++c] = n,
                this._coefficients[++c] = i,
                this._coefficients[++c] = a,
                this._coefficients[++c] = o,
                this._coefficients[++c] = s,
                this._coefficients[++c] = l,
                this._coefficients[++c] = u;
            }
        }, {
            key: "cloneTo",
            value: function(e) {
                if (this !== e)
                    for (var t = this._coefficients, r = e._coefficients, n = 0; n < 27; n++)
                        r[n] = t[n];
            }
        }]),
        SphericalHarmonicsL2;
    }();
    $t._default = new $t();
    var er = function MouseTouch() {
        _classCallCheck(this, MouseTouch),
        this._pressedSprite = null,
        this._pressedLoopCount = -1,
        this.sprite = null,
        this.mousePositionX = 0,
        this.mousePositionY = 0;
    }
      , tr = function() {
        function Touch() {
            _classCallCheck(this, Touch),
            this._indexInList = -1,
            this._identifier = -1,
            this._position = new n();
        }
        return _createClass(Touch, [{
            key: "_getIndexInList",
            value: function() {
                return this._indexInList;
            }
        }, {
            key: "_setIndexInList",
            value: function(e) {
                this._indexInList = e;
            }
        }, {
            key: "identifier",
            get: function() {
                return this._identifier;
            }
        }, {
            key: "position",
            get: function() {
                return this._position;
            }
        }]),
        Touch;
    }()
      , rr = function HitResult() {
        _classCallCheck(this, HitResult),
        this.succeeded = !1,
        this.collider = null,
        this.point = new o(),
        this.normal = new o(),
        this.hitFraction = 0;
    }
      , nr = function(e) {
        function PhysicsUpdateList() {
            return _classCallCheck(this, PhysicsUpdateList),
            _possibleConstructorReturn(this, _getPrototypeOf(PhysicsUpdateList).call(this));
        }
        return _inherits(PhysicsUpdateList, nt),
        _createClass(PhysicsUpdateList, [{
            key: "add",
            value: function(e) {
                if (-1 !== e._inPhysicUpdateListIndex)
                    throw "PhysicsUpdateList:element has  in  PhysicsUpdateList.";
                this._add(e),
                e._inPhysicUpdateListIndex = this.length++;
            }
        }, {
            key: "remove",
            value: function(e) {
                var t = e._inPhysicUpdateListIndex;
                if (this.length--,
                t !== this.length) {
                    var r = this.elements[this.length];
                    this.elements[t] = r,
                    r._inPhysicUpdateListIndex = t;
                }
                e._inPhysicUpdateListIndex = -1;
            }
        }]),
        PhysicsUpdateList;
    }()
      , ir = function ContactPoint() {
        _classCallCheck(this, ContactPoint),
        this._idCounter = 0,
        this.colliderA = null,
        this.colliderB = null,
        this.distance = 0,
        this.normal = new o(),
        this.positionOnA = new o(),
        this.positionOnB = new o(),
        this._id = ++this._idCounter;
    }
      , ar = function() {
        function Collision() {
            _classCallCheck(this, Collision),
            this._lastUpdateFrame = -2147483648,
            this._updateFrame = -2147483648,
            this._isTrigger = !1,
            this.contacts = [];
        }
        return _createClass(Collision, [{
            key: "_setUpdateFrame",
            value: function(e) {
                this._lastUpdateFrame = this._updateFrame,
                this._updateFrame = e;
            }
        }]),
        Collision;
    }()
      , or = function() {
        function CollisionTool() {
            _classCallCheck(this, CollisionTool),
            this._hitResultsPoolIndex = 0,
            this._hitResultsPool = [],
            this._contactPonintsPoolIndex = 0,
            this._contactPointsPool = [],
            this._collisionsPool = [],
            this._collisions = {};
        }
        return _createClass(CollisionTool, [{
            key: "getHitResult",
            value: function() {
                var e = this._hitResultsPool[this._hitResultsPoolIndex++];
                return e || (e = new rr(),
                this._hitResultsPool.push(e)),
                e;
            }
        }, {
            key: "recoverAllHitResultsPool",
            value: function() {
                this._hitResultsPoolIndex = 0;
            }
        }, {
            key: "getContactPoints",
            value: function() {
                var e = this._contactPointsPool[this._contactPonintsPoolIndex++];
                return e || (e = new ir(),
                this._contactPointsPool.push(e)),
                e;
            }
        }, {
            key: "recoverAllContactPointsPool",
            value: function() {
                this._contactPonintsPoolIndex = 0;
            }
        }, {
            key: "getCollision",
            value: function(e, t) {
                var r, n = e.id, i = t.id, a = this._collisions[n];
                return a && (r = a[i]),
                r || (a || (a = {},
                this._collisions[n] = a),
                (r = 0 === this._collisionsPool.length ? new ar() : this._collisionsPool.pop())._colliderA = e,
                r._colliderB = t,
                a[i] = r),
                r;
            }
        }, {
            key: "recoverCollision",
            value: function(e) {
                var t = e._colliderA.id
                  , r = e._colliderB.id;
                this._collisions[t][r] = null,
                this._collisionsPool.push(e);
            }
        }, {
            key: "garbageCollection",
            value: function() {
                for (var e in this._hitResultsPoolIndex = 0,
                this._hitResultsPool.length = 0,
                this._contactPonintsPoolIndex = 0,
                this._contactPointsPool.length = 0,
                this._collisionsPool.length = 0,
                this._collisionsPool) {
                    var t = this._collisionsPool[e]
                      , r = !0;
                    for (var n in t)
                        t[n] ? r = !1 : delete t[n];
                    r && delete this._collisionsPool[e];
                }
            }
        }]),
        CollisionTool;
    }()
      , sr = function() {
        function ColliderShape() {
            _classCallCheck(this, ColliderShape),
            this._scale = new o(1,1,1),
            this._centerMatrix = new I(),
            this._attatched = !1,
            this._indexInCompound = -1,
            this._compoundParent = null,
            this._attatchedCollisionObject = null,
            this._referenceCount = 0,
            this._localOffset = new o(0,0,0),
            this._localRotation = new f(0,0,0,1),
            this.needsCustomCollisionCallback = !1;
        }
        return _createClass(ColliderShape, [{
            key: "_setScale",
            value: function(e) {
                if (this._compoundParent)
                    this.updateLocalTransformations();
                else {
                    var t = S._bullet;
                    t.btVector3_setValue(ColliderShape._btScale, e.x, e.y, e.z),
                    t.btCollisionShape_setLocalScaling(this._btShape, ColliderShape._btScale);
                }
            }
        }, {
            key: "_addReference",
            value: function() {
                this._referenceCount++;
            }
        }, {
            key: "_removeReference",
            value: function() {
                this._referenceCount--;
            }
        }, {
            key: "updateLocalTransformations",
            value: function() {
                if (this._compoundParent) {
                    var e = ColliderShape._tempVector30;
                    o.multiply(this.localOffset, this._scale, e),
                    ColliderShape._createAffineTransformation(e, this.localRotation, this._centerMatrix.elements);
                } else
                    ColliderShape._createAffineTransformation(this.localOffset, this.localRotation, this._centerMatrix.elements);
            }
        }, {
            key: "cloneTo",
            value: function(e) {
                var t = e;
                this._localOffset.cloneTo(t.localOffset),
                this._localRotation.cloneTo(t.localRotation),
                t.localOffset = t.localOffset,
                t.localRotation = t.localRotation;
            }
        }, {
            key: "clone",
            value: function() {
                return null;
            }
        }, {
            key: "destroy",
            value: function() {
                this._btShape && (S._bullet.btCollisionShape_destroy(this._btShape),
                this._btShape = null);
            }
        }, {
            key: "type",
            get: function() {
                return this._type;
            }
        }, {
            key: "localOffset",
            get: function() {
                return this._localOffset;
            },
            set: function(e) {
                this._localOffset = e,
                this._compoundParent && this._compoundParent._updateChildTransform(this);
            }
        }, {
            key: "localRotation",
            get: function() {
                return this._localRotation;
            },
            set: function(e) {
                this._localRotation = e,
                this._compoundParent && this._compoundParent._updateChildTransform(this);
            }
        }], [{
            key: "__init__",
            value: function() {
                var e = S._bullet;
                ColliderShape._btScale = e.btVector3_create(1, 1, 1),
                ColliderShape._btVector30 = e.btVector3_create(0, 0, 0),
                ColliderShape._btQuaternion0 = e.btQuaternion_create(0, 0, 0, 1),
                ColliderShape._btTransform0 = e.btTransform_create();
            }
        }, {
            key: "_createAffineTransformation",
            value: function(e, t, r) {
                var n = t.x
                  , i = t.y
                  , a = t.z
                  , o = t.w
                  , s = n + n
                  , l = i + i
                  , u = a + a
                  , c = n * s
                  , h = n * l
                  , _ = n * u
                  , d = i * l
                  , f = i * u
                  , m = a * u
                  , p = o * s
                  , v = o * l
                  , T = o * u;
                r[0] = 1 - (d + m),
                r[1] = h + T,
                r[2] = _ - v,
                r[3] = 0,
                r[4] = h - T,
                r[5] = 1 - (c + m),
                r[6] = f + p,
                r[7] = 0,
                r[8] = _ + v,
                r[9] = f - p,
                r[10] = 1 - (c + d),
                r[11] = 0,
                r[12] = e.x,
                r[13] = e.y,
                r[14] = e.z,
                r[15] = 1;
            }
        }]),
        ColliderShape;
    }();
    sr.SHAPEORIENTATION_UPX = 0,
    sr.SHAPEORIENTATION_UPY = 1,
    sr.SHAPEORIENTATION_UPZ = 2,
    sr.SHAPETYPES_BOX = 0,
    sr.SHAPETYPES_SPHERE = 1,
    sr.SHAPETYPES_CYLINDER = 2,
    sr.SHAPETYPES_CAPSULE = 3,
    sr.SHAPETYPES_CONVEXHULL = 4,
    sr.SHAPETYPES_COMPOUND = 5,
    sr.SHAPETYPES_STATICPLANE = 6,
    sr.SHAPETYPES_CONE = 7,
    sr._tempVector30 = new o();
    var lr = function(e) {
        function BoxColliderShape() {
            var e, t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 1, r = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1, n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 1;
            _classCallCheck(this, BoxColliderShape),
            (e = _possibleConstructorReturn(this, _getPrototypeOf(BoxColliderShape).call(this)))._sizeX = t,
            e._sizeY = r,
            e._sizeZ = n,
            e._type = sr.SHAPETYPES_BOX;
            var i = S._bullet;
            return i.btVector3_setValue(BoxColliderShape._btSize, t / 2, r / 2, n / 2),
            e._btShape = i.btBoxShape_create(BoxColliderShape._btSize),
            e;
        }
        return _inherits(BoxColliderShape, sr),
        _createClass(BoxColliderShape, [{
            key: "sizeX",
            get: function() {
                return this._sizeX;
            }
        }, {
            key: "sizeY",
            get: function() {
                return this._sizeY;
            }
        }, {
            key: "sizeZ",
            get: function() {
                return this._sizeZ;
            }
        }], [{
            key: "__init__",
            value: function() {
                BoxColliderShape._btSize = S._bullet.btVector3_create(0, 0, 0);
            }
        }]),
        _createClass(BoxColliderShape, [{
            key: "clone",
            value: function() {
                var e = new BoxColliderShape(this._sizeX,this._sizeY,this._sizeZ);
                return this.cloneTo(e),
                e;
            }
        }]),
        BoxColliderShape;
    }()
      , ur = function(e) {
        function CapsuleColliderShape() {
            var e, t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : .5, r = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1.25, n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : sr.SHAPEORIENTATION_UPY;
            _classCallCheck(this, CapsuleColliderShape),
            (e = _possibleConstructorReturn(this, _getPrototypeOf(CapsuleColliderShape).call(this)))._radius = t,
            e._length = r,
            e._orientation = n,
            e._type = sr.SHAPETYPES_CAPSULE;
            var i = S._bullet;
            switch (n) {
            case sr.SHAPEORIENTATION_UPX:
                e._btShape = i.btCapsuleShapeX_create(t, r - 2 * t);
                break;
            case sr.SHAPEORIENTATION_UPY:
                e._btShape = i.btCapsuleShape_create(t, r - 2 * t);
                break;
            case sr.SHAPEORIENTATION_UPZ:
                e._btShape = i.btCapsuleShapeZ_create(t, r - 2 * t);
                break;
            default:
                throw "CapsuleColliderShape:unknown orientation.";
            }
            return e;
        }
        return _inherits(CapsuleColliderShape, sr),
        _createClass(CapsuleColliderShape, [{
            key: "_setScale",
            value: function(e) {
                var t = CapsuleColliderShape._tempVector30;
                switch (this.orientation) {
                case sr.SHAPEORIENTATION_UPX:
                    t.x = e.x,
                    t.y = t.z = Math.max(e.y, e.z);
                    break;
                case sr.SHAPEORIENTATION_UPY:
                    t.y = e.y,
                    t.x = t.z = Math.max(e.x, e.z);
                    break;
                case sr.SHAPEORIENTATION_UPZ:
                    t.z = e.z,
                    t.x = t.y = Math.max(e.x, e.y);
                    break;
                default:
                    throw "CapsuleColliderShape:unknown orientation.";
                }
                _get(_getPrototypeOf(CapsuleColliderShape.prototype), "_setScale", this).call(this, t);
            }
        }, {
            key: "clone",
            value: function() {
                var e = new CapsuleColliderShape(this._radius,this._length,this._orientation);
                return this.cloneTo(e),
                e;
            }
        }, {
            key: "radius",
            get: function() {
                return this._radius;
            }
        }, {
            key: "length",
            get: function() {
                return this._length;
            }
        }, {
            key: "orientation",
            get: function() {
                return this._orientation;
            }
        }]),
        CapsuleColliderShape;
    }();
    ur._tempVector30 = new o();
    var cr = function(e) {
        function CompoundColliderShape() {
            var e;
            return _classCallCheck(this, CompoundColliderShape),
            (e = _possibleConstructorReturn(this, _getPrototypeOf(CompoundColliderShape).call(this)))._childColliderShapes = [],
            e._type = sr.SHAPETYPES_COMPOUND,
            e._btShape = S._bullet.btCompoundShape_create(),
            e;
        }
        return _inherits(CompoundColliderShape, sr),
        _createClass(CompoundColliderShape, [{
            key: "_clearChildShape",
            value: function(e) {
                e._attatched = !1,
                e._compoundParent = null,
                e._indexInCompound = -1;
            }
        }, {
            key: "_addReference",
            value: function() {}
        }, {
            key: "_removeReference",
            value: function() {}
        }, {
            key: "_updateChildTransform",
            value: function(e) {
                var t = S._bullet
                  , r = e.localOffset
                  , n = e.localRotation
                  , i = sr._btVector30
                  , a = sr._btQuaternion0
                  , o = sr._btTransform0;
                t.btVector3_setValue(i, -r.x, r.y, r.z),
                t.btQuaternion_setValue(a, -n.x, n.y, n.z, -n.w),
                t.btTransform_setOrigin(o, i),
                t.btTransform_setRotation(o, a),
                t.btCompoundShape_updateChildTransform(this._btShape, e._indexInCompound, o, !0);
            }
        }, {
            key: "addChildShape",
            value: function(e) {
                if (e._attatched)
                    throw "CompoundColliderShape: this shape has attatched to other entity.";
                e._attatched = !0,
                e._compoundParent = this,
                e._indexInCompound = this._childColliderShapes.length,
                this._childColliderShapes.push(e);
                var t = e.localOffset
                  , r = e.localRotation
                  , n = S._bullet;
                n.btVector3_setValue(CompoundColliderShape._btOffset, -t.x, t.y, t.z),
                n.btQuaternion_setValue(CompoundColliderShape._btRotation, -r.x, r.y, r.z, -r.w),
                n.btTransform_setOrigin(CompoundColliderShape._btTransform, CompoundColliderShape._btOffset),
                n.btTransform_setRotation(CompoundColliderShape._btTransform, CompoundColliderShape._btRotation);
                var i = n.btCollisionShape_getLocalScaling(this._btShape);
                n.btCollisionShape_setLocalScaling(this._btShape, CompoundColliderShape._btVector3One),
                n.btCompoundShape_addChildShape(this._btShape, CompoundColliderShape._btTransform, e._btShape),
                n.btCollisionShape_setLocalScaling(this._btShape, i),
                this._attatchedCollisionObject && (this._attatchedCollisionObject.colliderShape = this);
            }
        }, {
            key: "removeChildShape",
            value: function(e) {
                if (e._compoundParent === this) {
                    var t = e._indexInCompound;
                    this._clearChildShape(e);
                    var r = this._childColliderShapes[this._childColliderShapes.length - 1];
                    r._indexInCompound = t,
                    this._childColliderShapes[t] = r,
                    this._childColliderShapes.pop(),
                    S._bullet.btCompoundShape_removeChildShapeByIndex(this._btShape, t);
                }
            }
        }, {
            key: "clearChildShape",
            value: function() {
                for (var e = 0, t = this._childColliderShapes.length; e < t; e++)
                    this._clearChildShape(this._childColliderShapes[e]),
                    S._bullet.btCompoundShape_removeChildShapeByIndex(this._btShape, 0);
                this._childColliderShapes.length = 0;
            }
        }, {
            key: "getChildShapeCount",
            value: function() {
                return this._childColliderShapes.length;
            }
        }, {
            key: "cloneTo",
            value: function(e) {
                var t = e;
                t.clearChildShape();
                for (var r = 0, n = this._childColliderShapes.length; r < n; r++)
                    t.addChildShape(this._childColliderShapes[r].clone());
            }
        }, {
            key: "clone",
            value: function() {
                var e = new CompoundColliderShape();
                return this.cloneTo(e),
                e;
            }
        }, {
            key: "destroy",
            value: function() {
                _get(_getPrototypeOf(CompoundColliderShape.prototype), "destroy", this).call(this);
                for (var e = 0, t = this._childColliderShapes.length; e < t; e++) {
                    var r = this._childColliderShapes[e];
                    0 === r._referenceCount && r.destroy();
                }
            }
        }], [{
            key: "__init__",
            value: function() {
                var e = S._bullet;
                CompoundColliderShape._btVector3One = e.btVector3_create(1, 1, 1),
                CompoundColliderShape._btTransform = e.btTransform_create(),
                CompoundColliderShape._btOffset = e.btVector3_create(0, 0, 0),
                CompoundColliderShape._btRotation = e.btQuaternion_create(0, 0, 0, 1);
            }
        }]),
        CompoundColliderShape;
    }()
      , hr = function(e) {
        function ConeColliderShape() {
            var e, t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : .5, r = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1, n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : sr.SHAPEORIENTATION_UPY;
            _classCallCheck(this, ConeColliderShape),
            (e = _possibleConstructorReturn(this, _getPrototypeOf(ConeColliderShape).call(this)))._radius = 1,
            e._height = .5,
            e._radius = t,
            e._height = r,
            e._orientation = n,
            e._type = sr.SHAPETYPES_CYLINDER;
            var i = S._bullet;
            switch (n) {
            case sr.SHAPEORIENTATION_UPX:
                e._btShape = i.btConeShapeX_create(t, r);
                break;
            case sr.SHAPEORIENTATION_UPY:
                e._btShape = i.btConeShape_create(t, r);
                break;
            case sr.SHAPEORIENTATION_UPZ:
                e._btShape = i.btConeShapeZ_create(t, r);
                break;
            default:
                throw "ConeColliderShape:unknown orientation.";
            }
            return e;
        }
        return _inherits(ConeColliderShape, sr),
        _createClass(ConeColliderShape, [{
            key: "clone",
            value: function() {
                var e = new ConeColliderShape(this._radius,this._height,this._orientation);
                return this.cloneTo(e),
                e;
            }
        }, {
            key: "radius",
            get: function() {
                return this._radius;
            }
        }, {
            key: "height",
            get: function() {
                return this._height;
            }
        }, {
            key: "orientation",
            get: function() {
                return this._orientation;
            }
        }]),
        ConeColliderShape;
    }()
      , _r = function(e) {
        function CylinderColliderShape() {
            var e, t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : .5, r = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1, n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : sr.SHAPEORIENTATION_UPY;
            _classCallCheck(this, CylinderColliderShape),
            (e = _possibleConstructorReturn(this, _getPrototypeOf(CylinderColliderShape).call(this)))._radius = 1,
            e._height = .5,
            e._radius = t,
            e._height = r,
            e._orientation = n,
            e._type = sr.SHAPETYPES_CYLINDER;
            var i = S._bullet;
            switch (n) {
            case sr.SHAPEORIENTATION_UPX:
                i.btVector3_setValue(CylinderColliderShape._btSize, r / 2, t, t),
                e._btShape = i.btCylinderShapeX_create(CylinderColliderShape._btSize);
                break;
            case sr.SHAPEORIENTATION_UPY:
                i.btVector3_setValue(CylinderColliderShape._btSize, t, r / 2, t),
                e._btShape = i.btCylinderShape_create(CylinderColliderShape._btSize);
                break;
            case sr.SHAPEORIENTATION_UPZ:
                i.btVector3_setValue(CylinderColliderShape._btSize, t, t, r / 2),
                e._btShape = i.btCylinderShapeZ_create(CylinderColliderShape._btSize);
                break;
            default:
                throw "CapsuleColliderShape:unknown orientation.";
            }
            return e;
        }
        return _inherits(CylinderColliderShape, sr),
        _createClass(CylinderColliderShape, [{
            key: "clone",
            value: function() {
                var e = new CylinderColliderShape(this._radius,this._height,this._orientation);
                return this.cloneTo(e),
                e;
            }
        }, {
            key: "radius",
            get: function() {
                return this._radius;
            }
        }, {
            key: "height",
            get: function() {
                return this._height;
            }
        }, {
            key: "orientation",
            get: function() {
                return this._orientation;
            }
        }], [{
            key: "__init__",
            value: function() {
                CylinderColliderShape._btSize = S._bullet.btVector3_create(0, 0, 0);
            }
        }]),
        CylinderColliderShape;
    }()
      , dr = function(e) {
        function MeshColliderShape() {
            var e;
            return _classCallCheck(this, MeshColliderShape),
            (e = _possibleConstructorReturn(this, _getPrototypeOf(MeshColliderShape).call(this)))._mesh = null,
            e._convex = !1,
            e;
        }
        return _inherits(MeshColliderShape, sr),
        _createClass(MeshColliderShape, [{
            key: "_setScale",
            value: function(e) {
                if (this._compoundParent)
                    this.updateLocalTransformations();
                else {
                    var t = S._bullet;
                    t.btVector3_setValue(sr._btScale, e.x, e.y, e.z),
                    t.btCollisionShape_setLocalScaling(this._btShape, sr._btScale),
                    t.btGImpactShapeInterface_updateBound(this._btShape);
                }
            }
        }, {
            key: "cloneTo",
            value: function(e) {
                var t = e;
                t.convex = this._convex,
                t.mesh = this._mesh,
                _get(_getPrototypeOf(MeshColliderShape.prototype), "cloneTo", this).call(this, e);
            }
        }, {
            key: "clone",
            value: function() {
                var e = new MeshColliderShape();
                return this.cloneTo(e),
                e;
            }
        }, {
            key: "destroy",
            value: function() {
                this._btShape && (S._bullet.btCollisionShape_destroy(this._btShape),
                this._btShape = null);
            }
        }, {
            key: "mesh",
            get: function() {
                return this._mesh;
            },
            set: function(e) {
                if (this._mesh !== e) {
                    var t = S._bullet;
                    this._mesh && t.destroy(this._btShape),
                    e && (this._btShape = t.btGImpactMeshShape_create(e._getPhysicMesh()),
                    t.btGImpactShapeInterface_updateBound(this._btShape)),
                    this._mesh = e;
                }
            }
        }, {
            key: "convex",
            get: function() {
                return this._convex;
            },
            set: function(e) {
                this._convex = e;
            }
        }]),
        MeshColliderShape;
    }()
      , fr = function(e) {
        function SphereColliderShape() {
            var e, t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : .5;
            return _classCallCheck(this, SphereColliderShape),
            (e = _possibleConstructorReturn(this, _getPrototypeOf(SphereColliderShape).call(this)))._radius = t,
            e._type = sr.SHAPETYPES_SPHERE,
            e._btShape = S._bullet.btSphereShape_create(t),
            e;
        }
        return _inherits(SphereColliderShape, sr),
        _createClass(SphereColliderShape, [{
            key: "radius",
            get: function() {
                return this._radius;
            }
        }]),
        _createClass(SphereColliderShape, [{
            key: "clone",
            value: function() {
                var e = new SphereColliderShape(this._radius);
                return this.cloneTo(e),
                e;
            }
        }]),
        SphereColliderShape;
    }()
      , mr = function(e) {
        function PhysicsComponent(e, t) {
            var r;
            return _classCallCheck(this, PhysicsComponent),
            (r = _possibleConstructorReturn(this, _getPrototypeOf(PhysicsComponent).call(this)))._restitution = 0,
            r._friction = .5,
            r._rollingFriction = 0,
            r._ccdMotionThreshold = 0,
            r._ccdSweptSphereRadius = 0,
            r._collisionGroup = Ft.COLLISIONFILTERGROUP_DEFAULTFILTER,
            r._canCollideWith = Ft.COLLISIONFILTERGROUP_ALLFILTER,
            r._colliderShape = null,
            r._transformFlag = 2147483647,
            r._enableProcessCollisions = !0,
            r._inPhysicUpdateListIndex = -1,
            r.canScaleShape = !0,
            r._collisionGroup = e,
            r._canCollideWith = t,
            PhysicsComponent._physicObjectsMap[r.id] = _assertThisInitialized(r),
            r;
        }
        return _inherits(PhysicsComponent, t.Component),
        _createClass(PhysicsComponent, [{
            key: "_parseShape",
            value: function(e) {
                var t = e.length;
                if (1 === t) {
                    var r = PhysicsComponent._creatShape(e[0]);
                    this.colliderShape = r;
                } else {
                    for (var n = new cr(), i = 0; i < t; i++)
                        r = PhysicsComponent._creatShape(e[i]),
                        n.addChildShape(r);
                    this.colliderShape = n;
                }
            }
        }, {
            key: "_onScaleChange",
            value: function(e) {
                this._colliderShape._setScale(e);
            }
        }, {
            key: "_onEnable",
            value: function() {
                this._simulation = this.owner._scene.physicsSimulation,
                S._bullet.btCollisionObject_setContactProcessingThreshold(this._btColliderObject, 1e30),
                this._colliderShape && this._enabled && (this._derivePhysicsTransformation(!0),
                this._addToSimulation());
            }
        }, {
            key: "_onDisable",
            value: function() {
                this._colliderShape && this._enabled && (this._removeFromSimulation(),
                -1 !== this._inPhysicUpdateListIndex && this._simulation._physicsUpdateList.remove(this)),
                this._simulation = null;
            }
        }, {
            key: "_onDestroy",
            value: function() {
                delete PhysicsComponent._physicObjectsMap[this.id],
                S._bullet.btCollisionObject_destroy(this._btColliderObject),
                this._colliderShape.destroy(),
                _get(_getPrototypeOf(PhysicsComponent.prototype), "_onDestroy", this).call(this),
                this._btColliderObject = null,
                this._colliderShape = null,
                this._simulation = null,
                this.owner.transform.off(t.Event.TRANSFORM_CHANGED, this, this._onTransformChanged);
            }
        }, {
            key: "_isValid",
            value: function() {
                return this._simulation && this._colliderShape && this._enabled;
            }
        }, {
            key: "_parse",
            value: function(e) {
                null != e.collisionGroup && (this.collisionGroup = e.collisionGroup),
                null != e.canCollideWith && (this.canCollideWith = e.canCollideWith),
                null != e.ccdMotionThreshold && (this.ccdMotionThreshold = e.ccdMotionThreshold),
                null != e.ccdSweptSphereRadius && (this.ccdSweptSphereRadius = e.ccdSweptSphereRadius);
            }
        }, {
            key: "_setTransformFlag",
            value: function(e, t) {
                t ? this._transformFlag |= e : this._transformFlag &= ~e;
            }
        }, {
            key: "_getTransformFlag",
            value: function(e) {
                return 0 != (this._transformFlag & e);
            }
        }, {
            key: "_addToSimulation",
            value: function() {}
        }, {
            key: "_removeFromSimulation",
            value: function() {}
        }, {
            key: "_derivePhysicsTransformation",
            value: function(e) {
                this._innerDerivePhysicsTransformation(S._bullet.btCollisionObject_getWorldTransform(this._btColliderObject), e);
            }
        }, {
            key: "_innerDerivePhysicsTransformation",
            value: function(e, t) {
                var r = S._bullet
                  , n = this.owner._transform;
                if (t || this._getTransformFlag(Ee.TRANSFORM_WORLDPOSITION)) {
                    var i = this._colliderShape.localOffset
                      , a = n.position
                      , s = PhysicsComponent._btVector30;
                    if (0 !== i.x || 0 !== i.y || 0 !== i.z) {
                        var l = PhysicsComponent._tempVector30
                          , u = n.worldMatrix;
                        o.transformCoordinate(i, u, l),
                        r.btVector3_setValue(s, -l.x, l.y, l.z);
                    } else
                        r.btVector3_setValue(s, -a.x, a.y, a.z);
                    r.btTransform_setOrigin(e, s),
                    this._setTransformFlag(Ee.TRANSFORM_WORLDPOSITION, !1);
                }
                if (t || this._getTransformFlag(Ee.TRANSFORM_WORLDQUATERNION)) {
                    var c = this._colliderShape.localRotation
                      , h = PhysicsComponent._btQuaternion0
                      , _ = n.rotation;
                    if (0 !== c.x || 0 !== c.y || 0 !== c.z || 1 !== c.w) {
                        var d = PhysicsComponent._tempQuaternion0;
                        PhysicsComponent.physicQuaternionMultiply(_.x, _.y, _.z, _.w, c, d),
                        r.btQuaternion_setValue(h, -d.x, d.y, d.z, -d.w);
                    } else
                        r.btQuaternion_setValue(h, -_.x, _.y, _.z, -_.w);
                    r.btTransform_setRotation(e, h),
                    this._setTransformFlag(Ee.TRANSFORM_WORLDQUATERNION, !1);
                }
                (t || this._getTransformFlag(Ee.TRANSFORM_WORLDSCALE)) && (this._onScaleChange(n.getWorldLossyScale()),
                this._setTransformFlag(Ee.TRANSFORM_WORLDSCALE, !1));
            }
        }, {
            key: "_updateTransformComponent",
            value: function(e) {
                var t = S._bullet
                  , r = this._colliderShape.localOffset
                  , n = this._colliderShape.localRotation
                  , i = this.owner._transform
                  , a = i.position
                  , o = i.rotation
                  , s = t.btTransform_getOrigin(e)
                  , l = t.btTransform_getRotation(e)
                  , u = -t.btQuaternion_x(l)
                  , c = t.btQuaternion_y(l)
                  , h = t.btQuaternion_z(l)
                  , _ = -t.btQuaternion_w(l);
                if (0 !== r.x || 0 !== r.y || 0 !== r.z) {
                    var d = PhysicsComponent._tempVector30;
                    PhysicsComponent.physicVector3TransformQuat(r, u, c, h, _, d),
                    a.x = -t.btVector3_x(s) - d.x,
                    a.y = t.btVector3_y(s) - d.y,
                    a.z = t.btVector3_z(s) - d.z;
                } else
                    a.x = -t.btVector3_x(s),
                    a.y = t.btVector3_y(s),
                    a.z = t.btVector3_z(s);
                if (i.position = a,
                0 !== n.x || 0 !== n.y || 0 !== n.z || 1 !== n.w) {
                    var f = PhysicsComponent._tempQuaternion0;
                    n.invert(f),
                    PhysicsComponent.physicQuaternionMultiply(u, c, h, _, f, o);
                } else
                    o.x = u,
                    o.y = c,
                    o.z = h,
                    o.w = _;
                i.rotation = o;
            }
        }, {
            key: "_onShapeChange",
            value: function(e) {
                var t = this._btColliderObject
                  , r = S._bullet
                  , n = r.btCollisionObject_getCollisionFlags(t);
                e.needsCustomCollisionCallback ? 0 == (n & PhysicsComponent.COLLISIONFLAGS_CUSTOM_MATERIAL_CALLBACK) && r.btCollisionObject_setCollisionFlags(t, n | PhysicsComponent.COLLISIONFLAGS_CUSTOM_MATERIAL_CALLBACK) : (n & PhysicsComponent.COLLISIONFLAGS_CUSTOM_MATERIAL_CALLBACK) > 0 && r.btCollisionObject_setCollisionFlags(t, n ^ PhysicsComponent.COLLISIONFLAGS_CUSTOM_MATERIAL_CALLBACK);
            }
        }, {
            key: "_onAdded",
            value: function() {
                this.enabled = this._enabled,
                this.restitution = this._restitution,
                this.friction = this._friction,
                this.rollingFriction = this._rollingFriction,
                this.ccdMotionThreshold = this._ccdMotionThreshold,
                this.ccdSweptSphereRadius = this._ccdSweptSphereRadius,
                this.owner.transform.on(t.Event.TRANSFORM_CHANGED, this, this._onTransformChanged);
            }
        }, {
            key: "_onTransformChanged",
            value: function(e) {
                PhysicsComponent._addUpdateList && (e &= Ee.TRANSFORM_WORLDPOSITION | Ee.TRANSFORM_WORLDQUATERNION | Ee.TRANSFORM_WORLDSCALE) && (this._transformFlag |= e,
                this._isValid() && -1 === this._inPhysicUpdateListIndex && this._simulation._physicsUpdateList.add(this));
            }
        }, {
            key: "_cloneTo",
            value: function(e) {
                var t = e;
                t.restitution = this._restitution,
                t.friction = this._friction,
                t.rollingFriction = this._rollingFriction,
                t.ccdMotionThreshold = this._ccdMotionThreshold,
                t.ccdSweptSphereRadius = this._ccdSweptSphereRadius,
                t.collisionGroup = this._collisionGroup,
                t.canCollideWith = this._canCollideWith,
                t.canScaleShape = this.canScaleShape,
                this._colliderShape && (t.colliderShape = this._colliderShape.clone());
            }
        }, {
            key: "restitution",
            get: function() {
                return this._restitution;
            },
            set: function(e) {
                this._restitution = e,
                this._btColliderObject && S._bullet.btCollisionObject_setRestitution(this._btColliderObject, e);
            }
        }, {
            key: "friction",
            get: function() {
                return this._friction;
            },
            set: function(e) {
                this._friction = e,
                this._btColliderObject && S._bullet.btCollisionObject_setFriction(this._btColliderObject, e);
            }
        }, {
            key: "rollingFriction",
            get: function() {
                return this._rollingFriction;
            },
            set: function(e) {
                this._rollingFriction = e,
                this._btColliderObject && S._bullet.btCollisionObject_setRollingFriction(this._btColliderObject, e);
            }
        }, {
            key: "ccdMotionThreshold",
            get: function() {
                return this._ccdMotionThreshold;
            },
            set: function(e) {
                this._ccdMotionThreshold = e,
                this._btColliderObject && S._bullet.btCollisionObject_setCcdMotionThreshold(this._btColliderObject, e);
            }
        }, {
            key: "ccdSweptSphereRadius",
            get: function() {
                return this._ccdSweptSphereRadius;
            },
            set: function(e) {
                this._ccdSweptSphereRadius = e,
                this._btColliderObject && S._bullet.btCollisionObject_setCcdSweptSphereRadius(this._btColliderObject, e);
            }
        }, {
            key: "isActive",
            get: function() {
                return !!this._btColliderObject && S._bullet.btCollisionObject_isActive(this._btColliderObject);
            }
        }, {
            key: "enabled",
            get: function() {
                return _get(_getPrototypeOf(PhysicsComponent.prototype), "enabled", this);
            },
            set: function(e) {
                this._enabled != e && (this._simulation && this._colliderShape && (e ? (this._derivePhysicsTransformation(!0),
                this._addToSimulation()) : this._removeFromSimulation()),
                _set(_getPrototypeOf(PhysicsComponent.prototype), "enabled", e, this, !0));
            }
        }, {
            key: "colliderShape",
            get: function() {
                return this._colliderShape;
            },
            set: function(e) {
                var t = this._colliderShape;
                if (t && (t._attatched = !1,
                t._attatchedCollisionObject = null),
                this._colliderShape = e,
                e) {
                    if (e._attatched)
                        throw "PhysicsComponent: this shape has attatched to other entity.";
                    if (e._attatched = !0,
                    e._attatchedCollisionObject = this,
                    this._btColliderObject) {
                        S._bullet.btCollisionObject_setCollisionShape(this._btColliderObject, e._btShape);
                        var r = this._simulation && this._enabled;
                        r && t && this._removeFromSimulation(),
                        this._onShapeChange(e),
                        r && (this._derivePhysicsTransformation(!0),
                        this._addToSimulation());
                    }
                } else
                    this._simulation && this._enabled && t && this._removeFromSimulation();
            }
        }, {
            key: "simulation",
            get: function() {
                return this._simulation;
            }
        }, {
            key: "collisionGroup",
            get: function() {
                return this._collisionGroup;
            },
            set: function(e) {
                this._collisionGroup !== e && (this._collisionGroup = e,
                this._simulation && this._colliderShape && this._enabled && (this._removeFromSimulation(),
                this._addToSimulation()));
            }
        }, {
            key: "canCollideWith",
            get: function() {
                return this._canCollideWith;
            },
            set: function(e) {
                this._canCollideWith !== e && (this._canCollideWith = e,
                this._simulation && this._colliderShape && this._enabled && (this._removeFromSimulation(),
                this._addToSimulation()));
            }
        }], [{
            key: "__init__",
            value: function() {
                var e = S._bullet;
                PhysicsComponent._btVector30 = e.btVector3_create(0, 0, 0),
                PhysicsComponent._btQuaternion0 = e.btQuaternion_create(0, 0, 0, 1);
            }
        }, {
            key: "_createAffineTransformationArray",
            value: function(e, t, r, n, i, a, o, s, l) {
                var u = n + n
                  , c = i + i
                  , h = a + a
                  , _ = n * u
                  , d = n * c
                  , f = n * h
                  , m = i * c
                  , p = i * h
                  , v = a * h
                  , T = o * u
                  , E = o * c
                  , y = o * h
                  , g = s[0]
                  , S = s[1]
                  , R = s[2];
                l[0] = (1 - (m + v)) * g,
                l[1] = (d + y) * g,
                l[2] = (f - E) * g,
                l[3] = 0,
                l[4] = (d - y) * S,
                l[5] = (1 - (_ + v)) * S,
                l[6] = (p + T) * S,
                l[7] = 0,
                l[8] = (f + E) * R,
                l[9] = (p - T) * R,
                l[10] = (1 - (_ + m)) * R,
                l[11] = 0,
                l[12] = e,
                l[13] = t,
                l[14] = r,
                l[15] = 1;
            }
        }, {
            key: "_creatShape",
            value: function(e) {
                var r;
                switch (e.type) {
                case "BoxColliderShape":
                    var n = e.size;
                    r = n ? new lr(n[0],n[1],n[2]) : new lr();
                    break;
                case "SphereColliderShape":
                    r = new fr(e.radius);
                    break;
                case "CapsuleColliderShape":
                    r = new ur(e.radius,e.height,e.orientation);
                    break;
                case "MeshColliderShape":
                    var i = new dr();
                    e.mesh && (i.mesh = t.Loader.getRes(e.mesh)),
                    r = i;
                    break;
                case "ConeColliderShape":
                    r = new hr(e.radius,e.height,e.orientation);
                    break;
                case "CylinderColliderShape":
                    r = new _r(e.radius,e.height,e.orientation);
                    break;
                default:
                    throw "unknown shape type.";
                }
                if (e.center) {
                    var a = r.localOffset;
                    a.fromArray(e.center),
                    r.localOffset = a;
                }
                return r;
            }
        }, {
            key: "physicVector3TransformQuat",
            value: function(e, t, r, n, i, a) {
                var o = e.x
                  , s = e.y
                  , l = e.z
                  , u = i * o + r * l - n * s
                  , c = i * s + n * o - t * l
                  , h = i * l + t * s - r * o
                  , _ = -t * o - r * s - n * l;
                a.x = u * i + _ * -t + c * -n - h * -r,
                a.y = c * i + _ * -r + h * -t - u * -n,
                a.z = h * i + _ * -n + u * -r - c * -t;
            }
        }, {
            key: "physicQuaternionMultiply",
            value: function(e, t, r, n, i, a) {
                var o = i.x
                  , s = i.y
                  , l = i.z
                  , u = i.w
                  , c = t * l - r * s
                  , h = r * o - e * l
                  , _ = e * s - t * o
                  , d = e * o + t * s + r * l;
                a.x = e * u + o * n + c,
                a.y = t * u + s * n + h,
                a.z = r * u + l * n + _,
                a.w = n * u - d;
            }
        }]),
        PhysicsComponent;
    }();
    mr.ACTIVATIONSTATE_ACTIVE_TAG = 1,
    mr.ACTIVATIONSTATE_ISLAND_SLEEPING = 2,
    mr.ACTIVATIONSTATE_WANTS_DEACTIVATION = 3,
    mr.ACTIVATIONSTATE_DISABLE_DEACTIVATION = 4,
    mr.ACTIVATIONSTATE_DISABLE_SIMULATION = 5,
    mr.COLLISIONFLAGS_STATIC_OBJECT = 1,
    mr.COLLISIONFLAGS_KINEMATIC_OBJECT = 2,
    mr.COLLISIONFLAGS_NO_CONTACT_RESPONSE = 4,
    mr.COLLISIONFLAGS_CUSTOM_MATERIAL_CALLBACK = 8,
    mr.COLLISIONFLAGS_CHARACTER_OBJECT = 16,
    mr.COLLISIONFLAGS_DISABLE_VISUALIZE_OBJECT = 32,
    mr.COLLISIONFLAGS_DISABLE_SPU_COLLISION_PROCESSING = 64,
    mr._tempVector30 = new o(),
    mr._tempQuaternion0 = new f(),
    mr._tempQuaternion1 = new f(),
    mr._tempMatrix4x40 = new I(),
    mr._physicObjectsMap = {},
    mr._addUpdateList = !0;
    var pr = function() {
        function PhysicsSimulation(e) {
            arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
            _classCallCheck(this, PhysicsSimulation),
            this._gravity = new o(0,-10,0),
            this._btVector3Zero = S._bullet.btVector3_create(0, 0, 0),
            this._btDefaultQuaternion = S._bullet.btQuaternion_create(0, 0, 0, -1),
            this._collisionsUtils = new or(),
            this._previousFrameCollisions = [],
            this._currentFrameCollisions = [],
            this._physicsUpdateList = new nr(),
            this._characters = [],
            this._updatedRigidbodies = 0,
            this.maxSubSteps = 1,
            this.fixedTimeStep = 1 / 60,
            this.maxSubSteps = e.maxSubSteps,
            this.fixedTimeStep = e.fixedTimeStep;
            var t = S._bullet;
            this._btCollisionConfiguration = t.btDefaultCollisionConfiguration_create(),
            this._btDispatcher = t.btCollisionDispatcher_create(this._btCollisionConfiguration),
            this._btBroadphase = t.btDbvtBroadphase_create(),
            t.btOverlappingPairCache_setInternalGhostPairCallback(t.btDbvtBroadphase_getOverlappingPairCache(this._btBroadphase), t.btGhostPairCallback_create());
            var r = e.flags;
            if (r & PhysicsSimulation.PHYSICSENGINEFLAGS_COLLISIONSONLY)
                this._btCollisionWorld = new t.btCollisionWorld(this._btDispatcher,this._btBroadphase,this._btCollisionConfiguration);
            else {
                if (r & PhysicsSimulation.PHYSICSENGINEFLAGS_SOFTBODYSUPPORT)
                    throw "PhysicsSimulation:SoftBody processing is not yet available";
                var n = t.btSequentialImpulseConstraintSolver_create();
                this._btDiscreteDynamicsWorld = t.btDiscreteDynamicsWorld_create(this._btDispatcher, this._btBroadphase, n, this._btCollisionConfiguration),
                this._btCollisionWorld = this._btDiscreteDynamicsWorld;
            }
            this._btDiscreteDynamicsWorld && (this._btSolverInfo = t.btDynamicsWorld_getSolverInfo(this._btDiscreteDynamicsWorld),
            this._btDispatchInfo = t.btCollisionWorld_getDispatchInfo(this._btDiscreteDynamicsWorld)),
            this._btClosestRayResultCallback = t.ClosestRayResultCallback_create(this._btVector3Zero, this._btVector3Zero),
            this._btAllHitsRayResultCallback = t.AllHitsRayResultCallback_create(this._btVector3Zero, this._btVector3Zero),
            this._btClosestConvexResultCallback = t.ClosestConvexResultCallback_create(this._btVector3Zero, this._btVector3Zero),
            this._btAllConvexResultCallback = t.AllConvexResultCallback_create(this._btVector3Zero, this._btVector3Zero),
            t.btGImpactCollisionAlgorithm_RegisterAlgorithm(this._btDispatcher);
        }
        return _createClass(PhysicsSimulation, [{
            key: "_simulate",
            value: function(e) {
                this._updatedRigidbodies = 0;
                var t = S._bullet;
                this._btDiscreteDynamicsWorld ? t.btDiscreteDynamicsWorld_stepSimulation(this._btDiscreteDynamicsWorld, e, this.maxSubSteps, this.fixedTimeStep) : t.PerformDiscreteCollisionDetection(this._btCollisionWorld);
            }
        }, {
            key: "_destroy",
            value: function() {
                var e = S._bullet;
                this._btDiscreteDynamicsWorld ? (e.btCollisionWorld_destroy(this._btDiscreteDynamicsWorld),
                this._btDiscreteDynamicsWorld = null) : (e.btCollisionWorld_destroy(this._btCollisionWorld),
                this._btCollisionWorld = null),
                e.btDbvtBroadphase_destroy(this._btBroadphase),
                this._btBroadphase = null,
                e.btCollisionDispatcher_destroy(this._btDispatcher),
                this._btDispatcher = null,
                e.btDefaultCollisionConfiguration_destroy(this._btCollisionConfiguration),
                this._btCollisionConfiguration = null;
            }
        }, {
            key: "_addPhysicsCollider",
            value: function(e, t, r) {
                S._bullet.btCollisionWorld_addCollisionObject(this._btCollisionWorld, e._btColliderObject, t, r);
            }
        }, {
            key: "_removePhysicsCollider",
            value: function(e) {
                S._bullet.btCollisionWorld_removeCollisionObject(this._btCollisionWorld, e._btColliderObject);
            }
        }, {
            key: "_addRigidBody",
            value: function(e, t, r) {
                if (!this._btDiscreteDynamicsWorld)
                    throw "Simulation:Cannot perform this action when the physics engine is set to CollisionsOnly";
                S._bullet.btDiscreteDynamicsWorld_addRigidBody(this._btCollisionWorld, e._btColliderObject, t, r);
            }
        }, {
            key: "_removeRigidBody",
            value: function(e) {
                if (!this._btDiscreteDynamicsWorld)
                    throw "Simulation:Cannot perform this action when the physics engine is set to CollisionsOnly";
                S._bullet.btDiscreteDynamicsWorld_removeRigidBody(this._btCollisionWorld, e._btColliderObject);
            }
        }, {
            key: "_addCharacter",
            value: function(e, t, r) {
                if (!this._btDiscreteDynamicsWorld)
                    throw "Simulation:Cannot perform this action when the physics engine is set to CollisionsOnly";
                var n = S._bullet;
                n.btCollisionWorld_addCollisionObject(this._btCollisionWorld, e._btColliderObject, t, r),
                n.btDynamicsWorld_addAction(this._btCollisionWorld, e._btKinematicCharacter);
            }
        }, {
            key: "_removeCharacter",
            value: function(e) {
                if (!this._btDiscreteDynamicsWorld)
                    throw "Simulation:Cannot perform this action when the physics engine is set to CollisionsOnly";
                var t = S._bullet;
                t.btCollisionWorld_removeCollisionObject(this._btCollisionWorld, e._btColliderObject),
                t.btDynamicsWorld_removeAction(this._btCollisionWorld, e._btKinematicCharacter);
            }
        }, {
            key: "raycastFromTo",
            value: function(e, t) {
                var r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null
                  , n = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : Ft.COLLISIONFILTERGROUP_ALLFILTER
                  , i = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : Ft.COLLISIONFILTERGROUP_ALLFILTER
                  , a = S._bullet
                  , o = this._btClosestRayResultCallback
                  , s = PhysicsSimulation._btTempVector30
                  , l = PhysicsSimulation._btTempVector31;
                if (a.btVector3_setValue(s, -e.x, e.y, e.z),
                a.btVector3_setValue(l, -t.x, t.y, t.z),
                a.ClosestRayResultCallback_set_m_rayFromWorld(o, s),
                a.ClosestRayResultCallback_set_m_rayToWorld(o, l),
                a.RayResultCallback_set_m_collisionFilterGroup(o, n),
                a.RayResultCallback_set_m_collisionFilterMask(o, i),
                a.RayResultCallback_set_m_collisionObject(o, null),
                a.RayResultCallback_set_m_closestHitFraction(o, 1),
                a.btCollisionWorld_rayTest(this._btCollisionWorld, s, l, o),
                a.RayResultCallback_hasHit(o)) {
                    if (r) {
                        r.succeeded = !0,
                        r.collider = mr._physicObjectsMap[a.btCollisionObject_getUserIndex(a.RayResultCallback_get_m_collisionObject(o))],
                        r.hitFraction = a.RayResultCallback_get_m_closestHitFraction(o);
                        var u = a.ClosestRayResultCallback_get_m_hitPointWorld(o)
                          , c = r.point;
                        c.x = -a.btVector3_x(u),
                        c.y = a.btVector3_y(u),
                        c.z = a.btVector3_z(u);
                        var h = a.ClosestRayResultCallback_get_m_hitNormalWorld(o)
                          , _ = r.normal;
                        _.x = -a.btVector3_x(h),
                        _.y = a.btVector3_y(h),
                        _.z = a.btVector3_z(h);
                    }
                    return !0;
                }
                return r && (r.succeeded = !1),
                !1;
            }
        }, {
            key: "raycastAllFromTo",
            value: function(e, t, r) {
                var n = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : Ft.COLLISIONFILTERGROUP_ALLFILTER
                  , i = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : Ft.COLLISIONFILTERGROUP_ALLFILTER
                  , a = S._bullet
                  , o = this._btAllHitsRayResultCallback
                  , s = PhysicsSimulation._btTempVector30
                  , l = PhysicsSimulation._btTempVector31;
                r.length = 0,
                a.btVector3_setValue(s, -e.x, e.y, e.z),
                a.btVector3_setValue(l, -t.x, t.y, t.z),
                a.AllHitsRayResultCallback_set_m_rayFromWorld(o, s),
                a.AllHitsRayResultCallback_set_m_rayToWorld(o, l),
                a.RayResultCallback_set_m_collisionFilterGroup(o, n),
                a.RayResultCallback_set_m_collisionFilterMask(o, i);
                var u = a.AllHitsRayResultCallback_get_m_collisionObjects(o)
                  , c = a.AllHitsRayResultCallback_get_m_hitPointWorld(o)
                  , h = a.AllHitsRayResultCallback_get_m_hitNormalWorld(o)
                  , _ = a.AllHitsRayResultCallback_get_m_hitFractions(o);
                a.tBtCollisionObjectArray_clear(u),
                a.tVector3Array_clear(c),
                a.tVector3Array_clear(h),
                a.tScalarArray_clear(_),
                a.btCollisionWorld_rayTest(this._btCollisionWorld, s, l, o);
                var d = a.tBtCollisionObjectArray_size(u);
                if (d > 0) {
                    this._collisionsUtils.recoverAllHitResultsPool();
                    for (var f = 0; f < d; f++) {
                        var m = this._collisionsUtils.getHitResult();
                        r.push(m),
                        m.succeeded = !0,
                        m.collider = mr._physicObjectsMap[a.btCollisionObject_getUserIndex(a.tBtCollisionObjectArray_at(u, f))],
                        m.hitFraction = a.tScalarArray_at(_, f);
                        var p = a.tVector3Array_at(c, f)
                          , v = m.point;
                        v.x = -a.btVector3_x(p),
                        v.y = a.btVector3_y(p),
                        v.z = a.btVector3_z(p);
                        var T = a.tVector3Array_at(h, f)
                          , E = m.normal;
                        E.x = -a.btVector3_x(T),
                        E.y = a.btVector3_y(T),
                        E.z = a.btVector3_z(T);
                    }
                    return !0;
                }
                return !1;
            }
        }, {
            key: "rayCast",
            value: function(e) {
                var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null
                  , r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 2147483647
                  , n = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : Ft.COLLISIONFILTERGROUP_ALLFILTER
                  , i = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : Ft.COLLISIONFILTERGROUP_ALLFILTER
                  , a = e.origin
                  , s = PhysicsSimulation._tempVector30;
                return o.normalize(e.direction, s),
                o.scale(s, r, s),
                o.add(a, s, s),
                this.raycastFromTo(a, s, t, n, i);
            }
        }, {
            key: "rayCastAll",
            value: function(e, t) {
                var r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 2147483647
                  , n = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : Ft.COLLISIONFILTERGROUP_ALLFILTER
                  , i = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : Ft.COLLISIONFILTERGROUP_ALLFILTER
                  , a = e.origin
                  , s = PhysicsSimulation._tempVector30;
                return o.normalize(e.direction, s),
                o.scale(s, r, s),
                o.add(a, s, s),
                this.raycastAllFromTo(a, s, t, n, i);
            }
        }, {
            key: "shapeCast",
            value: function(e, t, r) {
                var n = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : null
                  , i = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : null
                  , a = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : null
                  , o = arguments.length > 6 && void 0 !== arguments[6] ? arguments[6] : Ft.COLLISIONFILTERGROUP_ALLFILTER
                  , s = arguments.length > 7 && void 0 !== arguments[7] ? arguments[7] : Ft.COLLISIONFILTERGROUP_ALLFILTER
                  , l = arguments.length > 8 && void 0 !== arguments[8] ? arguments[8] : 0
                  , u = S._bullet
                  , c = this._btClosestConvexResultCallback
                  , h = PhysicsSimulation._btTempVector30
                  , _ = PhysicsSimulation._btTempVector31
                  , d = PhysicsSimulation._btTempQuaternion0
                  , f = PhysicsSimulation._btTempQuaternion1
                  , m = PhysicsSimulation._btTempTransform0
                  , p = PhysicsSimulation._btTempTransform1
                  , v = e._btShape;
                if (u.btVector3_setValue(h, -t.x, t.y, t.z),
                u.btVector3_setValue(_, -r.x, r.y, r.z),
                u.ConvexResultCallback_set_m_collisionFilterGroup(c, o),
                u.ConvexResultCallback_set_m_collisionFilterMask(c, s),
                u.btTransform_setOrigin(m, h),
                u.btTransform_setOrigin(p, _),
                i ? (u.btQuaternion_setValue(d, -i.x, i.y, i.z, -i.w),
                u.btTransform_setRotation(m, d)) : u.btTransform_setRotation(m, this._btDefaultQuaternion),
                a ? (u.btQuaternion_setValue(f, -a.x, a.y, a.z, -a.w),
                u.btTransform_setRotation(p, f)) : u.btTransform_setRotation(p, this._btDefaultQuaternion),
                u.ClosestConvexResultCallback_set_m_hitCollisionObject(c, null),
                u.ConvexResultCallback_set_m_closestHitFraction(c, 1),
                u.btCollisionWorld_convexSweepTest(this._btCollisionWorld, v, m, p, c, l),
                u.ConvexResultCallback_hasHit(c)) {
                    if (n) {
                        n.succeeded = !0,
                        n.collider = mr._physicObjectsMap[u.btCollisionObject_getUserIndex(u.ClosestConvexResultCallback_get_m_hitCollisionObject(c))],
                        n.hitFraction = u.ConvexResultCallback_get_m_closestHitFraction(c);
                        var T = u.ClosestConvexResultCallback_get_m_hitPointWorld(c)
                          , E = u.ClosestConvexResultCallback_get_m_hitNormalWorld(c)
                          , y = n.point
                          , g = n.normal;
                        y.x = -u.btVector3_x(T),
                        y.y = u.btVector3_y(T),
                        y.z = u.btVector3_z(T),
                        g.x = -u.btVector3_x(E),
                        g.y = u.btVector3_y(E),
                        g.z = u.btVector3_z(E);
                    }
                    return !0;
                }
                return n && (n.succeeded = !1),
                !1;
            }
        }, {
            key: "shapeCastAll",
            value: function(e, t, r, n) {
                var i = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : null
                  , a = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : null
                  , o = arguments.length > 6 && void 0 !== arguments[6] ? arguments[6] : Ft.COLLISIONFILTERGROUP_ALLFILTER
                  , s = arguments.length > 7 && void 0 !== arguments[7] ? arguments[7] : Ft.COLLISIONFILTERGROUP_ALLFILTER
                  , l = arguments.length > 8 && void 0 !== arguments[8] ? arguments[8] : 0
                  , u = S._bullet
                  , c = this._btAllConvexResultCallback
                  , h = PhysicsSimulation._btTempVector30
                  , _ = PhysicsSimulation._btTempVector31
                  , d = PhysicsSimulation._btTempQuaternion0
                  , f = PhysicsSimulation._btTempQuaternion1
                  , m = PhysicsSimulation._btTempTransform0
                  , p = PhysicsSimulation._btTempTransform1
                  , v = e._btShape;
                n.length = 0,
                u.btVector3_setValue(h, -t.x, t.y, t.z),
                u.btVector3_setValue(_, -r.x, r.y, r.z),
                u.ConvexResultCallback_set_m_collisionFilterGroup(c, o),
                u.ConvexResultCallback_set_m_collisionFilterMask(c, s),
                u.btTransform_setOrigin(m, h),
                u.btTransform_setOrigin(p, _),
                i ? (u.btQuaternion_setValue(d, -i.x, i.y, i.z, -i.w),
                u.btTransform_setRotation(m, d)) : u.btTransform_setRotation(m, this._btDefaultQuaternion),
                a ? (u.btQuaternion_setValue(f, -a.x, a.y, a.z, -a.w),
                u.btTransform_setRotation(p, f)) : u.btTransform_setRotation(p, this._btDefaultQuaternion);
                var T = u.AllConvexResultCallback_get_m_collisionObjects(c);
                u.tBtCollisionObjectArray_clear(T),
                u.btCollisionWorld_convexSweepTest(this._btCollisionWorld, v, m, p, c, l);
                var E = u.tBtCollisionObjectArray_size(T);
                if (E > 0) {
                    for (var y = u.AllConvexResultCallback_get_m_hitPointWorld(c), g = u.AllConvexResultCallback_get_m_hitNormalWorld(c), R = u.AllConvexResultCallback_get_m_hitFractions(c), C = 0; C < E; C++) {
                        var M = this._collisionsUtils.getHitResult();
                        n.push(M),
                        M.succeeded = !0,
                        M.collider = mr._physicObjectsMap[u.btCollisionObject_getUserIndex(u.tBtCollisionObjectArray_at(T, C))],
                        M.hitFraction = u.tScalarArray_at(R, C);
                        var D = u.tVector3Array_at(y, C)
                          , x = M.point;
                        x.x = -u.btVector3_x(D),
                        x.y = u.btVector3_y(D),
                        x.z = u.btVector3_z(D);
                        var A = u.tVector3Array_at(g, C)
                          , I = M.normal;
                        I.x = -u.btVector3_x(A),
                        I.y = u.btVector3_y(A),
                        I.z = u.btVector3_z(A);
                    }
                    return !0;
                }
                return !1;
            }
        }, {
            key: "addConstraint",
            value: function(e) {
                arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
                if (!this._btDiscreteDynamicsWorld)
                    throw "Cannot perform this action when the physics engine is set to CollisionsOnly";
                e._simulation = this;
            }
        }, {
            key: "removeConstraint",
            value: function(e) {
                if (!this._btDiscreteDynamicsWorld)
                    throw "Cannot perform this action when the physics engine is set to CollisionsOnly";
            }
        }, {
            key: "_updatePhysicsTransformFromRender",
            value: function() {
                for (var e = this._physicsUpdateList.elements, t = 0, r = this._physicsUpdateList.length; t < r; t++) {
                    var n = e[t];
                    n._derivePhysicsTransformation(!1),
                    n._inPhysicUpdateListIndex = -1;
                }
                this._physicsUpdateList.length = 0;
            }
        }, {
            key: "_updateCharacters",
            value: function() {
                for (var e = 0, t = this._characters.length; e < t; e++) {
                    var r = this._characters[e];
                    r._updateTransformComponent(S._bullet.btCollisionObject_getWorldTransform(r._btColliderObject));
                }
            }
        }, {
            key: "_updateCollisions",
            value: function() {
                this._collisionsUtils.recoverAllContactPointsPool();
                var e = this._currentFrameCollisions;
                this._currentFrameCollisions = this._previousFrameCollisions,
                this._currentFrameCollisions.length = 0,
                this._previousFrameCollisions = e;
                for (var r = t.Stat.loopCount, n = S._bullet, i = n.btDispatcher_getNumManifolds(this._btDispatcher), a = 0; a < i; a++) {
                    var o, s = n.btDispatcher_getManifoldByIndexInternal(this._btDispatcher, a), l = mr._physicObjectsMap[n.btCollisionObject_getUserIndex(n.btPersistentManifold_getBody0(s))], u = mr._physicObjectsMap[n.btCollisionObject_getUserIndex(n.btPersistentManifold_getBody1(s))], c = null, h = null;
                    if ((l.isTrigger || u.isTrigger) && (l.owner._needProcessTriggers || u.owner._needProcessTriggers))
                        for (var _ = n.btPersistentManifold_getNumContacts(s), d = 0; d < _; d++) {
                            var f = n.btPersistentManifold_getContactPoint(s, d)
                              , m = n.btManifoldPoint_getDistance(f);
                            if (m <= 0) {
                                h = (c = this._collisionsUtils.getCollision(l, u)).contacts,
                                (o = c._updateFrame !== r) && (c._isTrigger = !0,
                                h.length = 0);
                                break;
                            }
                        }
                    else if ((l.owner._needProcessCollisions || u.owner._needProcessCollisions) && (l._enableProcessCollisions || u._enableProcessCollisions))
                        for (_ = n.btPersistentManifold_getNumContacts(s),
                        d = 0; d < _; d++)
                            if (f = n.btPersistentManifold_getContactPoint(s, d),
                            (m = n.btManifoldPoint_getDistance(f)) <= 0) {
                                var p = this._collisionsUtils.getContactPoints();
                                p.colliderA = l,
                                p.colliderB = u,
                                p.distance = m;
                                var v = n.btManifoldPoint_get_m_normalWorldOnB(f)
                                  , T = p.normal;
                                T.x = -n.btVector3_x(v),
                                T.y = n.btVector3_y(v),
                                T.z = n.btVector3_z(v);
                                var E = n.btManifoldPoint_get_m_positionWorldOnA(f)
                                  , y = p.positionOnA;
                                y.x = -n.btVector3_x(E),
                                y.y = n.btVector3_y(E),
                                y.z = n.btVector3_z(E);
                                var g = n.btManifoldPoint_get_m_positionWorldOnB(f)
                                  , R = p.positionOnB;
                                R.x = -n.btVector3_x(g),
                                R.y = n.btVector3_y(g),
                                R.z = n.btVector3_z(g),
                                c || (h = (c = this._collisionsUtils.getCollision(l, u)).contacts,
                                (o = c._updateFrame !== r) && (c._isTrigger = !1,
                                h.length = 0)),
                                h.push(p);
                            }
                    c && o && (this._currentFrameCollisions.push(c),
                    c._setUpdateFrame(r));
                }
            }
        }, {
            key: "_eventScripts",
            value: function() {
                for (var e = t.Stat.loopCount, r = 0, n = this._currentFrameCollisions.length; r < n; r++) {
                    var i = this._currentFrameCollisions[r]
                      , a = i._colliderA
                      , o = i._colliderB;
                    if (!a.destroyed && !o.destroyed)
                        if (e - i._lastUpdateFrame == 1) {
                            var s = a.owner
                              , l = s._scripts;
                            if (l)
                                if (i._isTrigger) {
                                    if (s._needProcessTriggers)
                                        for (var u = 0, c = l.length; u < c; u++)
                                            l[u].onTriggerStay(o);
                                } else if (s._needProcessCollisions)
                                    for (u = 0,
                                    c = l.length; u < c; u++)
                                        i.other = o,
                                        l[u].onCollisionStay(i);
                            var h = o.owner
                              , _ = h._scripts;
                            if (_)
                                if (i._isTrigger) {
                                    if (h._needProcessTriggers)
                                        for (u = 0,
                                        c = _.length; u < c; u++)
                                            _[u].onTriggerStay(a);
                                } else if (h._needProcessCollisions)
                                    for (u = 0,
                                    c = _.length; u < c; u++)
                                        i.other = a,
                                        _[u].onCollisionStay(i);
                        } else {
                            if (l = (s = a.owner)._scripts)
                                if (i._isTrigger) {
                                    if (s._needProcessTriggers)
                                        for (u = 0,
                                        c = l.length; u < c; u++)
                                            l[u].onTriggerEnter(o);
                                } else if (s._needProcessCollisions)
                                    for (u = 0,
                                    c = l.length; u < c; u++)
                                        i.other = o,
                                        l[u].onCollisionEnter(i);
                            if (_ = (h = o.owner)._scripts)
                                if (i._isTrigger) {
                                    if (h._needProcessTriggers)
                                        for (u = 0,
                                        c = _.length; u < c; u++)
                                            _[u].onTriggerEnter(a);
                                } else if (h._needProcessCollisions)
                                    for (u = 0,
                                    c = _.length; u < c; u++)
                                        i.other = a,
                                        _[u].onCollisionEnter(i);
                        }
                }
                for (r = 0,
                n = this._previousFrameCollisions.length; r < n; r++) {
                    var d = this._previousFrameCollisions[r]
                      , f = d._colliderA
                      , m = d._colliderB;
                    if (!f.destroyed && !m.destroyed && e - d._updateFrame == 1) {
                        if (this._collisionsUtils.recoverCollision(d),
                        l = (s = f.owner)._scripts)
                            if (d._isTrigger) {
                                if (s._needProcessTriggers)
                                    for (u = 0,
                                    c = l.length; u < c; u++)
                                        l[u].onTriggerExit(m);
                            } else if (s._needProcessCollisions)
                                for (u = 0,
                                c = l.length; u < c; u++)
                                    d.other = m,
                                    l[u].onCollisionExit(d);
                        if (_ = (h = m.owner)._scripts)
                            if (d._isTrigger) {
                                if (h._needProcessTriggers)
                                    for (u = 0,
                                    c = _.length; u < c; u++)
                                        _[u].onTriggerExit(f);
                            } else if (h._needProcessCollisions)
                                for (u = 0,
                                c = _.length; u < c; u++)
                                    d.other = f,
                                    _[u].onCollisionExit(d);
                    }
                }
            }
        }, {
            key: "clearForces",
            value: function() {
                if (!this._btDiscreteDynamicsWorld)
                    throw "Cannot perform this action when the physics engine is set to CollisionsOnly";
                S._bullet.btDiscreteDynamicsWorld_clearForces(this._btDiscreteDynamicsWorld);
            }
        }, {
            key: "continuousCollisionDetection",
            get: function() {
                return S._bullet.btCollisionWorld_get_m_useContinuous(this._btDispatchInfo);
            },
            set: function(e) {
                S._bullet.btCollisionWorld_set_m_useContinuous(this._btDispatchInfo, e);
            }
        }, {
            key: "gravity",
            get: function() {
                if (!this._btDiscreteDynamicsWorld)
                    throw "Simulation:Cannot perform this action when the physics engine is set to CollisionsOnly";
                return this._gravity;
            },
            set: function(e) {
                if (!this._btDiscreteDynamicsWorld)
                    throw "Simulation:Cannot perform this action when the physics engine is set to CollisionsOnly";
                this._gravity = e;
                var t = S._bullet
                  , r = PhysicsSimulation._btTempVector30;
                t.btVector3_setValue(r, -e.x, e.y, e.z),
                t.btDiscreteDynamicsWorld_setGravity(this._btDiscreteDynamicsWorld, r);
            }
        }, {
            key: "speculativeContactRestitution",
            get: function() {
                if (!this._btDiscreteDynamicsWorld)
                    throw "Simulation:Cannot Cannot perform this action when the physics engine is set to CollisionsOnly";
                return S._bullet.btDiscreteDynamicsWorld_getApplySpeculativeContactRestitution(this._btDiscreteDynamicsWorld);
            },
            set: function(e) {
                if (!this._btDiscreteDynamicsWorld)
                    throw "Simulation:Cannot Cannot perform this action when the physics engine is set to CollisionsOnly";
                S._bullet.btDiscreteDynamicsWorld_setApplySpeculativeContactRestitution(this._btDiscreteDynamicsWorld, e);
            }
        }], [{
            key: "__init__",
            value: function() {
                var e = S._bullet;
                PhysicsSimulation._btTempVector30 = e.btVector3_create(0, 0, 0),
                PhysicsSimulation._btTempVector31 = e.btVector3_create(0, 0, 0),
                PhysicsSimulation._btTempQuaternion0 = e.btQuaternion_create(0, 0, 0, 1),
                PhysicsSimulation._btTempQuaternion1 = e.btQuaternion_create(0, 0, 0, 1),
                PhysicsSimulation._btTempTransform0 = e.btTransform_create(),
                PhysicsSimulation._btTempTransform1 = e.btTransform_create();
            }
        }, {
            key: "createConstraint",
            value: function() {}
        }]),
        PhysicsSimulation;
    }();
    pr.PHYSICSENGINEFLAGS_NONE = 0,
    pr.PHYSICSENGINEFLAGS_COLLISIONSONLY = 1,
    pr.PHYSICSENGINEFLAGS_SOFTBODYSUPPORT = 2,
    pr.PHYSICSENGINEFLAGS_MULTITHREADED = 4,
    pr.PHYSICSENGINEFLAGS_USEHARDWAREWHENPOSSIBLE = 8,
    pr.SOLVERMODE_RANDMIZE_ORDER = 1,
    pr.SOLVERMODE_FRICTION_SEPARATE = 2,
    pr.SOLVERMODE_USE_WARMSTARTING = 4,
    pr.SOLVERMODE_USE_2_FRICTION_DIRECTIONS = 16,
    pr.SOLVERMODE_ENABLE_FRICTION_DIRECTION_CACHING = 32,
    pr.SOLVERMODE_DISABLE_VELOCITY_DEPENDENT_FRICTION_DIRECTION = 64,
    pr.SOLVERMODE_CACHE_FRIENDLY = 128,
    pr.SOLVERMODE_SIMD = 256,
    pr.SOLVERMODE_INTERLEAVE_CONTACT_AND_FRICTION_CONSTRAINTS = 512,
    pr.SOLVERMODE_ALLOW_ZERO_LENGTH_FRICTION_DIRECTIONS = 1024,
    pr._tempVector30 = new o(),
    pr.disableSimulation = !1;
    var vr = function() {
        function Input3D() {
            var e = this;
            _classCallCheck(this, Input3D),
            this._eventList = [],
            this._mouseTouch = new er(),
            this._touchPool = [],
            this._touches = new Jt(),
            this._multiTouchEnabled = !0,
            this._pushEventList = function(t) {
                t.cancelable && t.preventDefault(),
                e._eventList.push(t);
            }
            .bind(this);
        }
        return _createClass(Input3D, [{
            key: "__init__",
            value: function(e, t) {
                this._scene = t,
                e.oncontextmenu = function(e) {
                    return !1;
                }
                ;
            }
        }, {
            key: "_onCanvasEvent",
            value: function(e) {
                e.addEventListener("mousedown", this._pushEventList),
                e.addEventListener("mouseup", this._pushEventList, !0),
                e.addEventListener("mousemove", this._pushEventList, !0),
                e.addEventListener("touchstart", this._pushEventList),
                e.addEventListener("touchend", this._pushEventList, !0),
                e.addEventListener("touchmove", this._pushEventList, !0),
                e.addEventListener("touchcancel", this._pushEventList, !0);
            }
        }, {
            key: "_offCanvasEvent",
            value: function(e) {
                e.removeEventListener("mousedown", this._pushEventList),
                e.removeEventListener("mouseup", this._pushEventList, !0),
                e.removeEventListener("mousemove", this._pushEventList, !0),
                e.removeEventListener("touchstart", this._pushEventList),
                e.removeEventListener("touchend", this._pushEventList, !0),
                e.removeEventListener("touchmove", this._pushEventList, !0),
                e.removeEventListener("touchcancel", this._pushEventList, !0),
                this._eventList.length = 0,
                this._touches.clear();
            }
        }, {
            key: "touchCount",
            value: function() {
                return this._touches.length;
            }
        }, {
            key: "_getTouch",
            value: function(e) {
                var t = this._touchPool[e];
                return t || (t = new tr(),
                this._touchPool[e] = t,
                t._identifier = e),
                t;
            }
        }, {
            key: "_mouseTouchDown",
            value: function() {
                var e = this._mouseTouch
                  , r = e.sprite;
                if (e._pressedSprite = r,
                e._pressedLoopCount = t.Stat.loopCount,
                r) {
                    var n = r._scripts;
                    if (n)
                        for (var i = 0, a = n.length; i < a; i++)
                            n[i].onMouseDown();
                }
            }
        }, {
            key: "_mouseTouchUp",
            value: function() {
                var e, t, r = this._mouseTouch, n = r._pressedSprite;
                r._pressedSprite = null,
                r._pressedLoopCount = -1;
                var i = r.sprite;
                if (i && i === n) {
                    var a = i._scripts;
                    if (a)
                        for (e = 0,
                        t = a.length; e < t; e++)
                            a[e].onMouseClick();
                }
                if (n) {
                    var o = n._scripts;
                    if (o)
                        for (e = 0,
                        t = o.length; e < t; e++)
                            o[e].onMouseUp();
                }
            }
        }, {
            key: "_mouseTouchRayCast",
            value: function(t) {
                var r = Input3D._tempHitResult0
                  , n = Input3D._tempVector20
                  , i = Input3D._tempRay0;
                r.succeeded = !1;
                var a = this._mouseTouch.mousePositionX
                  , o = this._mouseTouch.mousePositionY;
                n.x = a,
                n.y = o;
                for (var s = t.length - 1; s >= 0; s--) {
                    var l = t[s]
                      , u = l.viewport;
                    if (n.x >= u.x && n.y >= u.y && n.x <= u.width && n.y <= u.height)
                        if (l.viewportPointToRay(n, i),
                        this._scene._physicsSimulation.rayCast(i, r) || l.clearFlag === e.CameraClearFlags.SolidColor || l.clearFlag === e.CameraClearFlags.Sky)
                            break;
                }
                var c = this._mouseTouch
                  , h = c.sprite;
                if (r.succeeded) {
                    var _ = r.collider.owner;
                    c.sprite = _;
                    var d = _._scripts;
                    if (h !== _ && d)
                        for (var f = 0, m = d.length; f < m; f++)
                            d[f].onMouseEnter();
                } else
                    c.sprite = null;
                if (h && h !== _) {
                    var p = h._scripts;
                    if (p)
                        for (f = 0,
                        m = p.length; f < m; f++)
                            p[f].onMouseOut();
                }
            }
        }, {
            key: "_changeTouches",
            value: function(e, r) {
                for (var n = 0, i = 0, a = this._touches.length, o = 0, s = e.length; o < s; o++) {
                    var l = e[o]
                      , u = l.identifier;
                    if (this._multiTouchEnabled || 0 === u) {
                        var c = this._getTouch(u)
                          , h = c._position
                          , _ = Input3D._tempPoint;
                        _.setTo(l.pageX, l.pageY),
                        t.ILaya.stage._canvasTransform.invertTransformPoint(_);
                        var d = _.x
                          , f = _.y;
                        switch (r) {
                        case 0:
                            this._touches.add(c),
                            n += d,
                            i += f;
                            break;
                        case 1:
                            this._touches.remove(c),
                            n -= d,
                            i -= f;
                            break;
                        case 2:
                            n = d - h.x,
                            i = f - h.y;
                        }
                        h.x = d,
                        h.y = f;
                    }
                }
                var m = this._touches.length;
                0 === m ? (this._mouseTouch.mousePositionX = 0,
                this._mouseTouch.mousePositionY = 0) : (this._mouseTouch.mousePositionX = (this._mouseTouch.mousePositionX * a + n) / m,
                this._mouseTouch.mousePositionY = (this._mouseTouch.mousePositionY * a + i) / m);
            }
        }, {
            key: "_update",
            value: function() {
                var e, r, n, i, a = S._enablePhysics && !pr.disableSimulation;
                r = this._eventList.length;
                var o = this._scene._cameraPool;
                if (r > 0) {
                    var s = !1;
                    for (e = 0; e < r; e++) {
                        var l = this._eventList[e];
                        switch (l.type) {
                        case "mousedown":
                            a && this._mouseTouchDown();
                            break;
                        case "mouseup":
                            a && this._mouseTouchUp();
                            break;
                        case "mousemove":
                            var u = Input3D._tempPoint;
                            u.setTo(l.pageX, l.pageY),
                            t.ILaya.stage._canvasTransform.invertTransformPoint(u),
                            this._mouseTouch.mousePositionX = u.x,
                            this._mouseTouch.mousePositionY = u.y,
                            a && (s = !0);
                            break;
                        case "touchstart":
                            var c = this._touches.length;
                            this._changeTouches(l.changedTouches, 0),
                            a && (s = !0,
                            0 === c && this._mouseTouchDown());
                            break;
                        case "touchend":
                        case "touchcancel":
                            this._changeTouches(l.changedTouches, 1),
                            a && 0 === this._touches.length && this._mouseTouchUp();
                            break;
                        case "touchmove":
                            this._changeTouches(l.changedTouches, 2),
                            a && (s = !0);
                            break;
                        default:
                            throw "Input3D:unkonwn event type.";
                        }
                    }
                    s && this._mouseTouchRayCast(o),
                    this._eventList.length = 0;
                }
                if (a) {
                    var h = this._mouseTouch
                      , _ = h._pressedSprite;
                    if (_ && t.Stat.loopCount > h._pressedLoopCount) {
                        var d = _._scripts;
                        if (d)
                            for (n = 0,
                            i = d.length; n < i; n++)
                                d[n].onMouseDrag();
                    }
                    var f = h.sprite;
                    if (f) {
                        var m = f._scripts;
                        if (m)
                            for (n = 0,
                            i = m.length; n < i; n++)
                                m[n].onMouseOver();
                    }
                }
            }
        }, {
            key: "getTouch",
            value: function(e) {
                return e < this._touches.length ? this._touches.elements[e] : null;
            }
        }, {
            key: "multiTouchEnabled",
            get: function() {
                return this._multiTouchEnabled;
            },
            set: function(e) {
                this._multiTouchEnabled = e;
            }
        }]),
        Input3D;
    }();
    vr._tempPoint = new t.Point(),
    vr._tempVector20 = new n(),
    vr._tempRay0 = new Pe(new o(),new o()),
    vr._tempHitResult0 = new rr();
    var Tr = function PhysicsSettings() {
        _classCallCheck(this, PhysicsSettings),
        this.flags = 0,
        this.maxSubSteps = 1,
        this.fixedTimeStep = 1 / 60;
    }
      , Er = function() {
        function VertexPositionTexture0(e, t) {
            _classCallCheck(this, VertexPositionTexture0),
            this._position = e,
            this._textureCoordinate0 = t;
        }
        return _createClass(VertexPositionTexture0, [{
            key: "position",
            get: function() {
                return this._position;
            }
        }, {
            key: "textureCoordinate0",
            get: function() {
                return this._textureCoordinate0;
            }
        }, {
            key: "vertexDeclaration",
            get: function() {
                return VertexPositionTexture0._vertexDeclaration;
            }
        }], [{
            key: "__init__",
            value: function() {
                VertexPositionTexture0._vertexDeclaration = new oe(20,[new le(0,ae.Vector3,ue.MESH_POSITION0), new le(12,ae.Vector2,ue.MESH_TEXTURECOORDINATE0)]);
            }
        }, {
            key: "vertexDeclaration",
            get: function() {
                return VertexPositionTexture0._vertexDeclaration;
            }
        }]),
        VertexPositionTexture0;
    }()
      , yr = function(r) {
        function SkyDome() {
            var r, n = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 48, i = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 48;
            _classCallCheck(this, SkyDome),
            r = _possibleConstructorReturn(this, _getPrototypeOf(SkyDome).call(this));
            var a = t.LayaGL.instance;
            r._stacks = n,
            r._slices = i;
            for (var o = Er.vertexDeclaration, s = o.vertexStride / 4, l = (r._stacks + 1) * (r._slices + 1), u = 3 * r._stacks * (r._slices + 1) * 2, c = new Float32Array(l * s), h = new Uint16Array(u), _ = Math.PI / r._stacks, d = 2 * Math.PI / r._slices, f = 0, m = 0, p = 0, v = 0; v < r._stacks + 1; v++)
                for (var T = Math.sin(v * _), E = Math.cos(v * _), y = 0; y < r._slices + 1; y++) {
                    var g = T * Math.sin(y * d)
                      , S = T * Math.cos(y * d);
                    c[m + 0] = g * SkyDome._radius,
                    c[m + 1] = E * SkyDome._radius,
                    c[m + 2] = S * SkyDome._radius,
                    c[m + 3] = -y / r._slices + .75,
                    c[m + 4] = v / r._stacks,
                    m += s,
                    v != r._stacks - 1 && (h[p++] = f + 1,
                    h[p++] = f,
                    h[p++] = f + (r._slices + 1),
                    h[p++] = f + (r._slices + 1),
                    h[p++] = f,
                    h[p++] = f + r._slices,
                    f++);
                }
            r._vertexBuffer = new De(4 * c.length,a.STATIC_DRAW,!1),
            r._vertexBuffer.vertexDeclaration = o,
            r._indexBuffer = new Fe(e.IndexFormat.UInt16,h.length,a.STATIC_DRAW,!1),
            r._vertexBuffer.setData(c.buffer),
            r._indexBuffer.setData(h);
            var R = new we();
            return R.bind(),
            R.applyVertexBuffer(r._vertexBuffer),
            R.applyIndexBuffer(r._indexBuffer),
            R.unBind(),
            r._bufferState = R,
            r;
        }
        return _inherits(SkyDome, Ue),
        _createClass(SkyDome, [{
            key: "_render",
            value: function(e) {
                var r = t.LayaGL.instance
                  , n = this._indexBuffer.indexCount;
                r.drawElements(r.TRIANGLES, n, r.UNSIGNED_SHORT, 0),
                t.Stat.trianglesFaces += n / 3,
                t.Stat.renderBatches++;
            }
        }, {
            key: "stacks",
            get: function() {
                return this._stacks;
            }
        }, {
            key: "slices",
            get: function() {
                return this._slices;
            }
        }], [{
            key: "__init__",
            value: function() {
                SkyDome.instance = new SkyDome();
            }
        }]),
        SkyDome;
    }();
    yr._radius = 1;
    var gr = function(e) {
        function TextureCube(e) {
            var r, n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : t.TextureFormat.R8G8B8, i = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
            _classCallCheck(this, TextureCube),
            (r = _possibleConstructorReturn(this, _getPrototypeOf(TextureCube).call(this, n, i)))._glTextureType = t.LayaGL.instance.TEXTURE_CUBE_MAP,
            r._width = e,
            r._height = e;
            var a = t.LayaGL.instance;
            if (r._setWarpMode(a.TEXTURE_WRAP_S, r._wrapModeU),
            r._setWarpMode(a.TEXTURE_WRAP_T, r._wrapModeV),
            r._setFilterMode(r._filterMode),
            r._setAnisotropy(r._anisoLevel),
            r._mipmap) {
                r._mipmapCount = Math.ceil(Math.log2(e)) + 1;
                for (var o = 0; o < r._mipmapCount; o++)
                    r._setPixels([], o, Math.max(e >> o, 1), Math.max(e >> o, 1));
                r._setGPUMemory(e * e * 4 * (1 + 1 / 3) * 6);
            } else
                r._mipmapCount = 1,
                r._setGPUMemory(e * e * 4 * 6);
            return r;
        }
        return _inherits(TextureCube, t.BaseTexture),
        _createClass(TextureCube, [{
            key: "_setPixels",
            value: function(e, r, n, i) {
                var a = t.LayaGL.instance
                  , o = this._getGLFormat();
                t.WebGLContext.bindTexture(a, this._glTextureType, this._glTexture),
                this.format === t.TextureFormat.R8G8B8 ? (a.pixelStorei(a.UNPACK_ALIGNMENT, 1),
                a.texImage2D(a.TEXTURE_CUBE_MAP_POSITIVE_Z, r, o, n, i, 0, o, a.UNSIGNED_BYTE, e[0]),
                a.texImage2D(a.TEXTURE_CUBE_MAP_NEGATIVE_Z, r, o, n, i, 0, o, a.UNSIGNED_BYTE, e[1]),
                a.texImage2D(a.TEXTURE_CUBE_MAP_POSITIVE_X, r, o, n, i, 0, o, a.UNSIGNED_BYTE, e[2]),
                a.texImage2D(a.TEXTURE_CUBE_MAP_NEGATIVE_X, r, o, n, i, 0, o, a.UNSIGNED_BYTE, e[3]),
                a.texImage2D(a.TEXTURE_CUBE_MAP_POSITIVE_Y, r, o, n, i, 0, o, a.UNSIGNED_BYTE, e[4]),
                a.texImage2D(a.TEXTURE_CUBE_MAP_NEGATIVE_Y, r, o, n, i, 0, o, a.UNSIGNED_BYTE, e[5]),
                a.pixelStorei(a.UNPACK_ALIGNMENT, 4)) : (a.texImage2D(a.TEXTURE_CUBE_MAP_POSITIVE_Z, r, o, n, i, 0, o, a.UNSIGNED_BYTE, e[0]),
                a.texImage2D(a.TEXTURE_CUBE_MAP_NEGATIVE_Z, r, o, n, i, 0, o, a.UNSIGNED_BYTE, e[1]),
                a.texImage2D(a.TEXTURE_CUBE_MAP_POSITIVE_X, r, o, n, i, 0, o, a.UNSIGNED_BYTE, e[2]),
                a.texImage2D(a.TEXTURE_CUBE_MAP_NEGATIVE_X, r, o, n, i, 0, o, a.UNSIGNED_BYTE, e[3]),
                a.texImage2D(a.TEXTURE_CUBE_MAP_POSITIVE_Y, r, o, n, i, 0, o, a.UNSIGNED_BYTE, e[4]),
                a.texImage2D(a.TEXTURE_CUBE_MAP_NEGATIVE_Y, r, o, n, i, 0, o, a.UNSIGNED_BYTE, e[5]));
            }
        }, {
            key: "setSixSideImageSources",
            value: function(e) {
                for (var r, n, i = arguments.length > 1 && void 0 !== arguments[1] && arguments[1], a = 0; a < 6; a++) {
                    var o = e[a];
                    if (!o)
                        return void console.log("TextureCube: image Source can't be null.");
                    var s = o.width
                      , l = o.height;
                    if (a > 0 && r !== s)
                        return void console.log("TextureCube: each side image's width and height must same.");
                    if ((r = s) !== (n = l))
                        return void console.log("TextureCube: each side image's width and height must same.");
                }
                this._width = r,
                this._height = n;
                var u = t.LayaGL.instance;
                t.WebGLContext.bindTexture(u, this._glTextureType, this._glTexture);
                var c = this._getGLFormat();
                if (t.Render.isConchApp) {
                    if (1 == i)
                        for (var h = 0; h < 6; h++)
                            e[h].setPremultiplyAlpha(i);
                    u.texImage2D(u.TEXTURE_CUBE_MAP_POSITIVE_Z, 0, u.RGBA, u.RGBA, u.UNSIGNED_BYTE, e[0]),
                    u.texImage2D(u.TEXTURE_CUBE_MAP_NEGATIVE_Z, 0, u.RGBA, u.RGBA, u.UNSIGNED_BYTE, e[1]),
                    u.texImage2D(u.TEXTURE_CUBE_MAP_POSITIVE_X, 0, u.RGBA, u.RGBA, u.UNSIGNED_BYTE, e[2]),
                    u.texImage2D(u.TEXTURE_CUBE_MAP_NEGATIVE_X, 0, u.RGBA, u.RGBA, u.UNSIGNED_BYTE, e[3]),
                    u.texImage2D(u.TEXTURE_CUBE_MAP_POSITIVE_Y, 0, u.RGBA, u.RGBA, u.UNSIGNED_BYTE, e[4]),
                    u.texImage2D(u.TEXTURE_CUBE_MAP_NEGATIVE_Y, 0, u.RGBA, u.RGBA, u.UNSIGNED_BYTE, e[5]);
                } else
                    i && u.pixelStorei(u.UNPACK_PREMULTIPLY_ALPHA_WEBGL, !0),
                    u.texImage2D(u.TEXTURE_CUBE_MAP_POSITIVE_Z, 0, c, c, u.UNSIGNED_BYTE, e[0]),
                    u.texImage2D(u.TEXTURE_CUBE_MAP_NEGATIVE_Z, 0, c, c, u.UNSIGNED_BYTE, e[1]),
                    u.texImage2D(u.TEXTURE_CUBE_MAP_POSITIVE_X, 0, c, c, u.UNSIGNED_BYTE, e[2]),
                    u.texImage2D(u.TEXTURE_CUBE_MAP_NEGATIVE_X, 0, c, c, u.UNSIGNED_BYTE, e[3]),
                    u.texImage2D(u.TEXTURE_CUBE_MAP_POSITIVE_Y, 0, c, c, u.UNSIGNED_BYTE, e[4]),
                    u.texImage2D(u.TEXTURE_CUBE_MAP_NEGATIVE_Y, 0, c, c, u.UNSIGNED_BYTE, e[5]),
                    i && u.pixelStorei(u.UNPACK_PREMULTIPLY_ALPHA_WEBGL, !1);
                this._mipmap && this._isPot(r) && this._isPot(n) ? (u.generateMipmap(this._glTextureType),
                this._setGPUMemory(r * n * 4 * (1 + 1 / 3) * 6)) : this._setGPUMemory(r * n * 4 * 6),
                this._setWarpMode(u.TEXTURE_WRAP_S, this._wrapModeU),
                this._setWarpMode(u.TEXTURE_WRAP_T, this._wrapModeV),
                this._setFilterMode(this._filterMode),
                this._readyed = !0,
                this._activeResource();
            }
        }, {
            key: "setSixSidePixels",
            value: function(e) {
                var r = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
                if (!e)
                    throw new Error("TextureCube:pixels can't be null.");
                var n = Math.max(this._width >> r, 1)
                  , i = Math.max(this._height >> r, 1)
                  , a = n * i * this._getFormatByteCount();
                if (e[0].length < a)
                    throw "TextureCube:pixels length should at least " + a + ".";
                if (this._setPixels(e, r, n, i),
                0 === r) {
                    var o = t.LayaGL.instance;
                    this._setWarpMode(o.TEXTURE_WRAP_S, this._wrapModeU),
                    this._setWarpMode(o.TEXTURE_WRAP_T, this._wrapModeV);
                }
                this._readyed = !0,
                this._activeResource();
            }
        }, {
            key: "_recoverResource",
            value: function() {}
        }, {
            key: "defaulteTexture",
            get: function() {
                return TextureCube.grayTexture;
            }
        }], [{
            key: "__init__",
            value: function() {
                var e = new TextureCube(1,t.TextureFormat.R8G8B8,!1)
                  , r = new TextureCube(1,t.TextureFormat.R8G8B8,!1)
                  , n = new Uint8Array(3);
                n[0] = 0,
                n[1] = 0,
                n[2] = 0,
                e.setSixSidePixels([n, n, n, n, n, n]),
                e.lock = !0,
                n[0] = 128,
                n[1] = 128,
                n[2] = 128,
                r.setSixSidePixels([n, n, n, n, n, n]),
                r.lock = !0,
                TextureCube._grayTexture = r,
                TextureCube._blackTexture = e;
            }
        }, {
            key: "_parse",
            value: function(e) {
                arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
                var t = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null
                  , r = t ? new TextureCube(0,t[0],t[1]) : new TextureCube(0);
                return r.setSixSideImageSources(e),
                r;
            }
        }, {
            key: "_parseBin",
            value: function(e) {
                arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
                var t = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null
                  , r = t ? new TextureCube(0,t[0],t[1]) : new TextureCube(0);
                return r.setSixSideImageSources(e),
                r;
            }
        }, {
            key: "load",
            value: function(e, r) {
                t.ILaya.loader.create(e, r, null, TextureCube.TEXTURECUBE);
            }
        }, {
            key: "blackTexture",
            get: function() {
                return TextureCube._blackTexture;
            }
        }, {
            key: "grayTexture",
            get: function() {
                return TextureCube._grayTexture;
            }
        }]),
        TextureCube;
    }();
    gr.TEXTURECUBE = "TEXTURECUBE";
    var Sr = function() {
        function LightQueue() {
            _classCallCheck(this, LightQueue),
            this._length = 0,
            this._elements = [];
        }
        return _createClass(LightQueue, [{
            key: "add",
            value: function(e) {
                this._length === this._elements.length ? this._elements.push(e) : this._elements[this._length] = e,
                this._length++;
            }
        }, {
            key: "remove",
            value: function(e) {
                var t = this._elements.indexOf(e);
                if (this._length--,
                t !== this._length) {
                    var r = this._elements[this._length];
                    this._elements[t] = r;
                }
            }
        }, {
            key: "shift",
            value: function() {
                return this._length--,
                this._elements.shift();
            }
        }]),
        LightQueue;
    }()
      , Rr = function(e) {
        function DirectionLightQueue() {
            return _classCallCheck(this, DirectionLightQueue),
            _possibleConstructorReturn(this, _getPrototypeOf(DirectionLightQueue).apply(this, arguments));
        }
        return _inherits(DirectionLightQueue, Sr),
        _createClass(DirectionLightQueue, [{
            key: "getSunLight",
            value: function() {
                for (var e, t = -1, r = this._elements, n = 0; n < this._length; n++) {
                    var i = r[n]._intensity;
                    t < i && (t = i,
                    e = n);
                }
                return e;
            }
        }]),
        DirectionLightQueue;
    }()
      , Cr = function(e) {
        function AlternateLightQueue() {
            return _classCallCheck(this, AlternateLightQueue),
            _possibleConstructorReturn(this, _getPrototypeOf(AlternateLightQueue).apply(this, arguments));
        }
        return _inherits(AlternateLightQueue, Sr),
        _createClass(AlternateLightQueue, [{
            key: "remove",
            value: function(e) {
                var t = this._elements.indexOf(e);
                this._elements.splice(t, 1),
                this._length--;
            }
        }]),
        AlternateLightQueue;
    }()
      , Mr = function(e) {
        function PixelLineFilter(e, r) {
            var n;
            _classCallCheck(this, PixelLineFilter),
            (n = _possibleConstructorReturn(this, _getPrototypeOf(PixelLineFilter).call(this)))._floatCountPerVertices = 7,
            n._minUpdate = Number.MAX_VALUE,
            n._maxUpdate = Number.MIN_VALUE,
            n._bufferState = new we(),
            n._floatBound = new Float32Array(6),
            n._calculateBound = !1,
            n._maxLineCount = 0,
            n._lineCount = 0;
            var i = 2 * r;
            n._owner = e,
            n._maxLineCount = r,
            n._vertices = new Float32Array(i * n._floatCountPerVertices),
            n._vertexBuffer = new De(Kt.vertexDeclaration.vertexStride * i,t.LayaGL.instance.STATIC_DRAW,!1),
            n._vertexBuffer.vertexDeclaration = Kt.vertexDeclaration,
            n._bufferState.bind(),
            n._bufferState.applyVertexBuffer(n._vertexBuffer),
            n._bufferState.unBind();
            var a = PixelLineFilter._tempVector0
              , o = PixelLineFilter._tempVector1;
            return a.setValue(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE),
            o.setValue(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE),
            n._bounds = new st(a,o),
            n;
        }
        return _inherits(PixelLineFilter, Me),
        _createClass(PixelLineFilter, [{
            key: "_getType",
            value: function() {
                return PixelLineFilter._type;
            }
        }, {
            key: "_resizeLineData",
            value: function(e) {
                var r = 2 * e
                  , n = this._vertices;
                this._vertexBuffer.destroy(),
                this._maxLineCount = e;
                var i = r * this._floatCountPerVertices;
                this._vertices = new Float32Array(i),
                this._vertexBuffer = new De(Kt.vertexDeclaration.vertexStride * r,t.LayaGL.instance.STATIC_DRAW,!1),
                this._vertexBuffer.vertexDeclaration = Kt.vertexDeclaration,
                i < n.length ? (this._vertices.set(new Float32Array(n.buffer,0,i)),
                this._vertexBuffer.setData(this._vertices.buffer, 0, 0, 4 * i)) : (this._vertices.set(n),
                this._vertexBuffer.setData(this._vertices.buffer, 0, 0, 4 * n.length)),
                this._bufferState.bind(),
                this._bufferState.applyVertexBuffer(this._vertexBuffer),
                this._bufferState.unBind();
            }
        }, {
            key: "_updateLineVertices",
            value: function(e, t, r, n, i) {
                t && (this._vertices[e + 0] = t.x,
                this._vertices[e + 1] = t.y,
                this._vertices[e + 2] = t.z),
                n && (this._vertices[e + 3] = n.r,
                this._vertices[e + 4] = n.g,
                this._vertices[e + 5] = n.b,
                this._vertices[e + 6] = n.a),
                r && (this._vertices[e + 7] = r.x,
                this._vertices[e + 8] = r.y,
                this._vertices[e + 9] = r.z),
                i && (this._vertices[e + 10] = i.r,
                this._vertices[e + 11] = i.g,
                this._vertices[e + 12] = i.b,
                this._vertices[e + 13] = i.a),
                this._minUpdate = Math.min(this._minUpdate, e),
                this._maxUpdate = Math.max(this._maxUpdate, e + 2 * this._floatCountPerVertices);
                var a = this._bounds
                  , s = this._floatBound
                  , l = a.getMin()
                  , u = a.getMax();
                o.min(l, t, l),
                o.min(l, r, l),
                o.max(u, t, u),
                o.max(u, r, u),
                a.setMin(l),
                a.setMax(u),
                s[0] = l.x,
                s[1] = l.y,
                s[2] = l.z,
                s[3] = u.x,
                s[4] = u.y,
                s[5] = u.z;
            }
        }, {
            key: "_reCalculateBound",
            value: function() {
                if (this._calculateBound) {
                    var e = this._vertices
                      , t = PixelLineFilter._tempVector0
                      , r = PixelLineFilter._tempVector1;
                    t.setValue(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE),
                    r.setValue(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE);
                    for (var n = 0; n < 2 * this._lineCount; ++n) {
                        var i = this._floatCountPerVertices * n
                          , a = e[i + 0]
                          , o = e[i + 1]
                          , s = e[i + 2];
                        t.x = Math.min(a, t.x),
                        t.y = Math.min(o, t.y),
                        t.z = Math.min(s, t.z),
                        r.x = Math.max(a, r.x),
                        r.y = Math.max(o, r.y),
                        r.z = Math.max(s, r.z);
                    }
                    this._bounds.setMin(t),
                    this._bounds.setMax(r);
                    var l = this._floatBound;
                    l[0] = t.x,
                    l[1] = t.y,
                    l[2] = t.z,
                    l[3] = r.x,
                    l[4] = r.y,
                    l[5] = r.z,
                    this._calculateBound = !1;
                }
            }
        }, {
            key: "_removeLineData",
            value: function(e) {
                var t = 2 * this._floatCountPerVertices
                  , r = e + 1
                  , n = e * t
                  , i = this._vertices
                  , a = new Float32Array(i.buffer,r * t * 4,(this._lineCount - r) * t);
                i.set(a, n),
                this._minUpdate = Math.min(this._minUpdate, n),
                this._maxUpdate = Math.max(this._maxUpdate, n + a.length),
                this._lineCount--;
                var o = this._floatBound
                  , s = i[n]
                  , l = i[n + 1]
                  , u = i[n + 2]
                  , c = i[n + 7]
                  , h = i[n + 8]
                  , _ = i[n + 9]
                  , d = o[0]
                  , f = o[1]
                  , m = o[2]
                  , p = o[3]
                  , v = o[4]
                  , T = o[5];
                s !== d && s !== p && l !== f && l !== v && u !== m && u !== T && c !== d && c !== p && h !== f && h !== v && _ !== m && _ !== T || (this._calculateBound = !0);
            }
        }, {
            key: "_updateLineData",
            value: function(e, t, r, n, i) {
                var a = 2 * this._floatCountPerVertices;
                this._updateLineVertices(e * a, t, r, n, i);
            }
        }, {
            key: "_updateLineDatas",
            value: function(e, t) {
                for (var r = 2 * this._floatCountPerVertices, n = t.length, i = 0; i < n; i++) {
                    var a = t[i];
                    this._updateLineVertices((e + i) * r, a.startPosition, a.endPosition, a.startColor, a.endColor);
                }
            }
        }, {
            key: "_getLineData",
            value: function(e, t) {
                var r = t.startPosition
                  , n = t.startColor
                  , i = t.endPosition
                  , a = t.endColor
                  , o = this._vertices
                  , s = e * this._floatCountPerVertices * 2;
                r.x = o[s + 0],
                r.y = o[s + 1],
                r.z = o[s + 2],
                n.r = o[s + 3],
                n.g = o[s + 4],
                n.b = o[s + 5],
                n.a = o[s + 6],
                i.x = o[s + 7],
                i.y = o[s + 8],
                i.z = o[s + 9],
                a.r = o[s + 10],
                a.g = o[s + 11],
                a.b = o[s + 12],
                a.a = o[s + 13];
            }
        }, {
            key: "_prepareRender",
            value: function(e) {
                return !0;
            }
        }, {
            key: "_render",
            value: function(e) {
                if (this._minUpdate !== Number.MAX_VALUE && this._maxUpdate !== Number.MIN_VALUE && (this._vertexBuffer.setData(this._vertices.buffer, 4 * this._minUpdate, 4 * this._minUpdate, 4 * (this._maxUpdate - this._minUpdate)),
                this._minUpdate = Number.MAX_VALUE,
                this._maxUpdate = Number.MIN_VALUE),
                this._lineCount > 0) {
                    this._bufferState.bind();
                    var r = t.LayaGL.instance;
                    r.drawArrays(r.LINES, 0, 2 * this._lineCount),
                    t.Stat.renderBatches++;
                }
            }
        }, {
            key: "destroy",
            value: function() {
                this._destroyed || (_get(_getPrototypeOf(PixelLineFilter.prototype), "destroy", this).call(this),
                this._bufferState.destroy(),
                this._vertexBuffer.destroy(),
                this._bufferState = null,
                this._vertexBuffer = null,
                this._vertices = null);
            }
        }]),
        PixelLineFilter;
    }();
    Mr._tempVector0 = new o(),
    Mr._tempVector1 = new o(),
    Mr._type = Me._typeCounter++;
    var Dr = function(e) {
        function PixelLineRenderer(e) {
            var t;
            return _classCallCheck(this, PixelLineRenderer),
            (t = _possibleConstructorReturn(this, _getPrototypeOf(PixelLineRenderer).call(this, e)))._projectionViewWorldMatrix = new I(),
            t;
        }
        return _inherits(PixelLineRenderer, lt),
        _createClass(PixelLineRenderer, [{
            key: "_calculateBoundingBox",
            value: function() {
                var e = this._owner.transform.worldMatrix
                  , r = this._owner._geometryFilter;
                if (r._reCalculateBound(),
                r._bounds._tranform(e, this._bounds),
                t.Render.supportWebGLPlusCulling) {
                    var n = this._bounds.getMin()
                      , i = this._bounds.getMax()
                      , a = Re._cullingBuffer;
                    a[this._cullingBufferIndex + 1] = n.x,
                    a[this._cullingBufferIndex + 2] = n.y,
                    a[this._cullingBufferIndex + 3] = n.z,
                    a[this._cullingBufferIndex + 4] = i.x,
                    a[this._cullingBufferIndex + 5] = i.y,
                    a[this._cullingBufferIndex + 6] = i.z;
                }
            }
        }, {
            key: "_renderUpdateWithCamera",
            value: function(e, t) {
                var r = e.projectionViewMatrix
                  , n = this._shaderValues;
                if (t) {
                    var i = t.worldMatrix;
                    n.setMatrix4x4(ye.WORLDMATRIX, i),
                    I.multiply(r, i, this._projectionViewWorldMatrix),
                    n.setMatrix4x4(ye.MVPMATRIX, this._projectionViewWorldMatrix);
                } else
                    n.setMatrix4x4(ye.WORLDMATRIX, I.DEFAULT),
                    n.setMatrix4x4(ye.MVPMATRIX, r);
            }
        }]),
        PixelLineRenderer;
    }()
      , xr = function(e) {
        function PixelLineSprite3D() {
            var e, t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 2, r = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null;
            return _classCallCheck(this, PixelLineSprite3D),
            (e = _possibleConstructorReturn(this, _getPrototypeOf(PixelLineSprite3D).call(this, r)))._geometryFilter = new Mr(_assertThisInitialized(e),t),
            e._render = new Dr(_assertThisInitialized(e)),
            e._changeRenderObjects(e._render, 0, qt.defaultMaterial),
            e;
        }
        return _inherits(PixelLineSprite3D, ge),
        _createClass(PixelLineSprite3D, [{
            key: "maxLineCount",
            get: function() {
                return this._geometryFilter._maxLineCount;
            },
            set: function(e) {
                this._geometryFilter._resizeLineData(e),
                this._geometryFilter._lineCount = Math.min(this._geometryFilter._lineCount, e);
            }
        }, {
            key: "lineCount",
            get: function() {
                return this._geometryFilter._lineCount;
            },
            set: function(e) {
                if (e > this.maxLineCount)
                    throw "PixelLineSprite3D: lineCount can't large than maxLineCount";
                this._geometryFilter._lineCount = e;
            }
        }, {
            key: "pixelLineRenderer",
            get: function() {
                return this._render;
            }
        }]),
        _createClass(PixelLineSprite3D, [{
            key: "_changeRenderObjects",
            value: function(e, t, r) {
                var n = this._render._renderElements;
                r || (r = qt.defaultMaterial);
                var i = n[t];
                i || (i = n[t] = new et()),
                i.setTransform(this._transform),
                i.setGeometry(this._geometryFilter),
                i.render = this._render,
                i.material = r;
            }
        }, {
            key: "addLine",
            value: function(e, t, r, n) {
                if (this._geometryFilter._lineCount === this._geometryFilter._maxLineCount)
                    throw "PixelLineSprite3D: lineCount has equal with maxLineCount.";
                this._geometryFilter._updateLineData(this._geometryFilter._lineCount++, e, t, r, n);
            }
        }, {
            key: "addLines",
            value: function(e) {
                var t = this._geometryFilter._lineCount
                  , r = e.length;
                if (t + r > this._geometryFilter._maxLineCount)
                    throw "PixelLineSprite3D: lineCount plus lines count must less than maxLineCount.";
                this._geometryFilter._updateLineDatas(t, e),
                this._geometryFilter._lineCount += r;
            }
        }, {
            key: "removeLine",
            value: function(e) {
                if (!(e < this._geometryFilter._lineCount))
                    throw "PixelLineSprite3D: index must less than lineCount.";
                this._geometryFilter._removeLineData(e);
            }
        }, {
            key: "setLine",
            value: function(e, t, r, n, i) {
                if (!(e < this._geometryFilter._lineCount))
                    throw "PixelLineSprite3D: index must less than lineCount.";
                this._geometryFilter._updateLineData(e, t, r, n, i);
            }
        }, {
            key: "getLine",
            value: function(e, t) {
                if (!(e < this.lineCount))
                    throw "PixelLineSprite3D: index must less than lineCount.";
                this._geometryFilter._getLineData(e, t);
            }
        }, {
            key: "clear",
            value: function() {
                this._geometryFilter._lineCount = 0;
            }
        }, {
            key: "_create",
            value: function() {
                return new PixelLineSprite3D();
            }
        }]),
        PixelLineSprite3D;
    }()
      , Ar = function() {
        function RenderQueue() {
            var e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0];
            _classCallCheck(this, RenderQueue),
            this.isTransparent = !1,
            this.elements = new nt(),
            this.lastTransparentRenderElement = null,
            this.lastTransparentBatched = !1,
            this.isTransparent = e;
        }
        return _createClass(RenderQueue, [{
            key: "_compare",
            value: function(e, t) {
                var r = e.material.renderQueue - t.material.renderQueue;
                return 0 === r ? (this.isTransparent ? t.render._distanceForSort - e.render._distanceForSort : e.render._distanceForSort - t.render._distanceForSort) + t.render.sortingFudge - e.render.sortingFudge : r;
            }
        }, {
            key: "_partitionRenderObject",
            value: function(e, t) {
                for (var r = this.elements.elements, n = r[Math.floor((t + e) / 2)]; e <= t; ) {
                    for (; this._compare(r[e], n) < 0; )
                        e++;
                    for (; this._compare(r[t], n) > 0; )
                        t--;
                    if (e < t) {
                        var i = r[e];
                        r[e] = r[t],
                        r[t] = i,
                        e++,
                        t--;
                    } else if (e === t) {
                        e++;
                        break;
                    }
                }
                return e;
            }
        }, {
            key: "_quickSort",
            value: function(e, t) {
                if (this.elements.length > 1) {
                    var r = this._partitionRenderObject(e, t)
                      , n = r - 1;
                    e < n && this._quickSort(e, n),
                    r < t && this._quickSort(r, t);
                }
            }
        }, {
            key: "_render",
            value: function(e) {
                for (var t = this.elements.elements, r = 0, n = this.elements.length; r < n; r++)
                    t[r]._render(e);
            }
        }, {
            key: "clear",
            value: function() {
                this.elements.length = 0,
                this.lastTransparentRenderElement = null,
                this.lastTransparentBatched = !1;
            }
        }]),
        RenderQueue;
    }()
      , Ir = function() {
        function BoundsOctreeNode(e, t, r, n) {
            _classCallCheck(this, BoundsOctreeNode),
            this._bounds = new ot(new o(),new o()),
            this._objects = [],
            this._isContaion = !1,
            this.center = new o(),
            this.baseLength = 0,
            this._setValues(e, t, r, n);
        }
        return _createClass(BoundsOctreeNode, [{
            key: "_setValues",
            value: function(e, t, r, n) {
                this._octree = e,
                this._parent = t,
                this.baseLength = r,
                n.cloneTo(this.center);
                var i = this._bounds.min
                  , a = this._bounds.max
                  , o = e._looseness * r / 2;
                i.setValue(n.x - o, n.y - o, n.z - o),
                a.setValue(n.x + o, n.y + o, n.z + o);
            }
        }, {
            key: "_getChildBound",
            value: function(e) {
                if (null != this._children && this._children[e])
                    return this._children[e]._bounds;
                var t = this.baseLength / 4
                  , r = this.baseLength / 2 * this._octree._looseness / 2
                  , n = BoundsOctreeNode._tempBoundBox
                  , i = n.min
                  , a = n.max;
                switch (e) {
                case 0:
                    i.x = this.center.x - t - r,
                    i.y = this.center.y + t - r,
                    i.z = this.center.z - t - r,
                    a.x = this.center.x - t + r,
                    a.y = this.center.y + t + r,
                    a.z = this.center.z - t + r;
                    break;
                case 1:
                    i.x = this.center.x + t - r,
                    i.y = this.center.y + t - r,
                    i.z = this.center.z - t - r,
                    a.x = this.center.x + t + r,
                    a.y = this.center.y + t + r,
                    a.z = this.center.z - t + r;
                    break;
                case 2:
                    i.x = this.center.x - t - r,
                    i.y = this.center.y + t - r,
                    i.z = this.center.z + t - r,
                    a.x = this.center.x - t + r,
                    a.y = this.center.y + t + r,
                    a.z = this.center.z + t + r;
                    break;
                case 3:
                    i.x = this.center.x + t - r,
                    i.y = this.center.y + t - r,
                    i.z = this.center.z + t - r,
                    a.x = this.center.x + t + r,
                    a.y = this.center.y + t + r,
                    a.z = this.center.z + t + r;
                    break;
                case 4:
                    i.x = this.center.x - t - r,
                    i.y = this.center.y - t - r,
                    i.z = this.center.z - t - r,
                    a.x = this.center.x - t + r,
                    a.y = this.center.y - t + r,
                    a.z = this.center.z - t + r;
                    break;
                case 5:
                    i.x = this.center.x + t - r,
                    i.y = this.center.y - t - r,
                    i.z = this.center.z - t - r,
                    a.x = this.center.x + t + r,
                    a.y = this.center.y - t + r,
                    a.z = this.center.z - t + r;
                    break;
                case 6:
                    i.x = this.center.x - t - r,
                    i.y = this.center.y - t - r,
                    i.z = this.center.z + t - r,
                    a.x = this.center.x - t + r,
                    a.y = this.center.y - t + r,
                    a.z = this.center.z + t + r;
                    break;
                case 7:
                    i.x = this.center.x + t - r,
                    i.y = this.center.y - t - r,
                    i.z = this.center.z + t - r,
                    a.x = this.center.x + t + r,
                    a.y = this.center.y - t + r,
                    a.z = this.center.z + t + r;
                }
                return n;
            }
        }, {
            key: "_getChildCenter",
            value: function(e) {
                if (null != this._children)
                    return this._children[e].center;
                var t = this.baseLength / 4
                  , r = BoundsOctreeNode._tempVector30;
                switch (e) {
                case 0:
                    r.x = this.center.x - t,
                    r.y = this.center.y + t,
                    r.z = this.center.z - t;
                    break;
                case 1:
                    r.x = this.center.x + t,
                    r.y = this.center.y + t,
                    r.z = this.center.z - t;
                    break;
                case 2:
                    r.x = this.center.x - t,
                    r.y = this.center.y + t,
                    r.z = this.center.z + t;
                    break;
                case 3:
                    r.x = this.center.x + t,
                    r.y = this.center.y + t,
                    r.z = this.center.z + t;
                    break;
                case 4:
                    r.x = this.center.x - t,
                    r.y = this.center.y - t,
                    r.z = this.center.z - t;
                    break;
                case 5:
                    r.x = this.center.x + t,
                    r.y = this.center.y - t,
                    r.z = this.center.z - t;
                    break;
                case 6:
                    r.x = this.center.x - t,
                    r.y = this.center.y - t,
                    r.z = this.center.z + t;
                    break;
                case 7:
                    r.x = this.center.x + t,
                    r.y = this.center.y - t,
                    r.z = this.center.z + t;
                }
                return r;
            }
        }, {
            key: "_getChild",
            value: function(e) {
                var t = this.baseLength / 4;
                switch (this._children || (this._children = []),
                e) {
                case 0:
                    return this._children[0] || (this._children[0] = new BoundsOctreeNode(this._octree,this,this.baseLength / 2,new o(this.center.x + -t,this.center.y + t,this.center.z - t)));
                case 1:
                    return this._children[1] || (this._children[1] = new BoundsOctreeNode(this._octree,this,this.baseLength / 2,new o(this.center.x + t,this.center.y + t,this.center.z - t)));
                case 2:
                    return this._children[2] || (this._children[2] = new BoundsOctreeNode(this._octree,this,this.baseLength / 2,new o(this.center.x - t,this.center.y + t,this.center.z + t)));
                case 3:
                    return this._children[3] || (this._children[3] = new BoundsOctreeNode(this._octree,this,this.baseLength / 2,new o(this.center.x + t,this.center.y + t,this.center.z + t)));
                case 4:
                    return this._children[4] || (this._children[4] = new BoundsOctreeNode(this._octree,this,this.baseLength / 2,new o(this.center.x - t,this.center.y - t,this.center.z - t)));
                case 5:
                    return this._children[5] || (this._children[5] = new BoundsOctreeNode(this._octree,this,this.baseLength / 2,new o(this.center.x + t,this.center.y - t,this.center.z - t)));
                case 6:
                    return this._children[6] || (this._children[6] = new BoundsOctreeNode(this._octree,this,this.baseLength / 2,new o(this.center.x - t,this.center.y - t,this.center.z + t)));
                case 7:
                    return this._children[7] || (this._children[7] = new BoundsOctreeNode(this._octree,this,this.baseLength / 2,new o(this.center.x + t,this.center.y - t,this.center.z + t)));
                default:
                    throw "BoundsOctreeNode: unknown index.";
                }
            }
        }, {
            key: "_shouldMerge",
            value: function() {
                for (var e = this._objects.length, t = 0; t < 8; t++) {
                    var r = this._children[t];
                    if (r) {
                        if (null != r._children)
                            return !1;
                        e += r._objects.length;
                    }
                }
                return e <= BoundsOctreeNode._NUM_OBJECTS_ALLOWED;
            }
        }, {
            key: "_mergeChildren",
            value: function() {
                for (var e = 0; e < 8; e++) {
                    var t = this._children[e];
                    if (t) {
                        t._parent = null;
                        for (var r = t._objects, n = r.length - 1; n >= 0; n--) {
                            var i = r[n];
                            this._objects.push(i),
                            i._setOctreeNode(this);
                        }
                    }
                }
                this._children = null;
            }
        }, {
            key: "_merge",
            value: function() {
                if (null === this._children) {
                    var e = this._parent;
                    e && e._shouldMerge() && (e._mergeChildren(),
                    e._merge());
                }
            }
        }, {
            key: "_checkAddNode",
            value: function(e) {
                if (null == this._children) {
                    if (this._objects.length < BoundsOctreeNode._NUM_OBJECTS_ALLOWED || this.baseLength / 2 < this._octree._minSize)
                        return this;
                    for (var t = this._objects.length - 1; t >= 0; t--) {
                        var r = this._objects[t]
                          , n = this._bestFitChild(r.bounds.getCenter());
                        BoundsOctreeNode._encapsulates(this._getChildBound(n), r.bounds._getBoundBox()) && (this._objects.splice(this._objects.indexOf(r), 1),
                        this._getChild(n)._add(r));
                    }
                }
                var i = this._bestFitChild(e.bounds.getCenter());
                return BoundsOctreeNode._encapsulates(this._getChildBound(i), e.bounds._getBoundBox()) ? this._getChild(i)._checkAddNode(e) : this;
            }
        }, {
            key: "_add",
            value: function(e) {
                var t = this._checkAddNode(e);
                t._objects.push(e),
                e._setOctreeNode(t);
            }
        }, {
            key: "_remove",
            value: function(e) {
                var t = this._objects.indexOf(e);
                this._objects.splice(t, 1),
                e._setOctreeNode(null),
                this._merge();
            }
        }, {
            key: "_addUp",
            value: function(e) {
                return Ne.boxContainsBox(this._bounds, e.bounds._getBoundBox()) === Oe.Contains ? (this._add(e),
                !0) : !!this._parent && this._parent._addUp(e);
            }
        }, {
            key: "_getCollidingWithFrustum",
            value: function(e, r, n, i, a, s, l) {
                if (n) {
                    var u = r.containsBoundBox(this._bounds);
                    if (t.Stat.octreeNodeCulling++,
                    u === Oe.Disjoint)
                        return;
                    n = u === Oe.Intersects;
                }
                this._isContaion = !n;
                for (var c = e.camera, h = e.scene, _ = t.Stat.loopCount, d = 0, f = this._objects.length; d < f; d++) {
                    var m = this._objects[d];
                    if (l ? m._castShadow && m._enable : c._isLayerVisible(m._owner._layer) && m._enable) {
                        if (n && (t.Stat.frustumCulling++,
                        !m._needRender(r, e)))
                            continue;
                        m._renderMark = _,
                        m._distanceForSort = o.distance(m.bounds.getCenter(), i);
                        for (var p = m._renderElements, v = 0, T = p.length; v < T; v++) {
                            p[v]._update(h, e, a, s);
                        }
                    }
                }
                if (null != this._children)
                    for (d = 0; d < 8; d++) {
                        var E = this._children[d];
                        E && E._getCollidingWithFrustum(e, r, n, i, a, s, l);
                    }
            }
        }, {
            key: "_getCollidingWithBoundBox",
            value: function(e, t, r) {
                if (t) {
                    var n = Ne.boxContainsBox(this._bounds, e);
                    if (n === Oe.Disjoint)
                        return;
                    t = n === Oe.Intersects;
                }
                if (t)
                    for (var i = 0, a = this._objects.length; i < a; i++) {
                        var o = this._objects[i];
                        Ne.intersectsBoxAndBox(o.bounds._getBoundBox(), e) && r.push(o);
                    }
                if (null != this._children)
                    for (i = 0; i < 8; i++) {
                        this._children[i]._getCollidingWithBoundBox(e, t, r);
                    }
            }
        }, {
            key: "_bestFitChild",
            value: function(e) {
                return (e.x <= this.center.x ? 0 : 1) + (e.y >= this.center.y ? 0 : 4) + (e.z <= this.center.z ? 0 : 2);
            }
        }, {
            key: "_update",
            value: function(e) {
                if (Ne.boxContainsBox(this._bounds, e.bounds._getBoundBox()) === Oe.Contains) {
                    var t = this._checkAddNode(e);
                    if (t !== e._getOctreeNode()) {
                        t._objects.push(e),
                        e._setOctreeNode(t);
                        var r = this._objects.indexOf(e);
                        this._objects.splice(r, 1),
                        this._merge();
                    }
                    return !0;
                }
                if (this._parent) {
                    var n = this._parent._addUp(e);
                    return n && (r = this._objects.indexOf(e),
                    this._objects.splice(r, 1),
                    this._merge()),
                    n;
                }
                return !1;
            }
        }, {
            key: "add",
            value: function(e) {
                return !!BoundsOctreeNode._encapsulates(this._bounds, e.bounds._getBoundBox()) && (this._add(e),
                !0);
            }
        }, {
            key: "remove",
            value: function(e) {
                return e._getOctreeNode() === this && (this._remove(e),
                !0);
            }
        }, {
            key: "update",
            value: function(e) {
                return e._getOctreeNode() === this && this._update(e);
            }
        }, {
            key: "shrinkIfPossible",
            value: function(e) {
                if (this.baseLength < 2 * e)
                    return this;
                for (var t = -1, r = 0, n = this._objects.length; r < n; r++) {
                    var i = this._objects[r]
                      , a = this._bestFitChild(i.bounds.getCenter());
                    if (0 != r && a != t)
                        return this;
                    var o = this._getChildBound(a);
                    if (!BoundsOctreeNode._encapsulates(o, i.bounds._getBoundBox()))
                        return this;
                    0 == r && (t = a);
                }
                if (null == this._children) {
                    if (-1 != t) {
                        var s = this._getChildCenter(t);
                        this._setValues(this._octree, null, this.baseLength / 2, s);
                    }
                    return this;
                }
                var l = !1;
                for (r = 0,
                n = this._children.length; r < n; r++) {
                    var u = this._children[r];
                    if (u && u.hasAnyObjects()) {
                        if (l)
                            return this;
                        if (t >= 0 && t != r)
                            return this;
                        l = !0,
                        t = r;
                    }
                }
                if (-1 != t) {
                    var c = this._children[t];
                    return c._parent = null,
                    c;
                }
                return this;
            }
        }, {
            key: "hasAnyObjects",
            value: function() {
                if (this._objects.length > 0)
                    return !0;
                if (null != this._children)
                    for (var e = 0; e < 8; e++) {
                        var t = this._children[e];
                        if (t && t.hasAnyObjects())
                            return !0;
                    }
                return !1;
            }
        }, {
            key: "getCollidingWithBoundBox",
            value: function(e, t) {
                this._getCollidingWithBoundBox(e, !0, t);
            }
        }, {
            key: "getCollidingWithRay",
            value: function(e, t) {
                var r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : Number.MAX_VALUE
                  , n = Ne.intersectsRayAndBoxRD(e, this._bounds);
                if (!(-1 == n || n > r)) {
                    for (var i = 0, a = this._objects.length; i < a; i++) {
                        var o = this._objects[i];
                        -1 !== (n = Ne.intersectsRayAndBoxRD(e, o.bounds._getBoundBox())) && n <= r && t.push(o);
                    }
                    if (null != this._children)
                        for (i = 0; i < 8; i++) {
                            this._children[i].getCollidingWithRay(e, t, r);
                        }
                }
            }
        }, {
            key: "getCollidingWithFrustum",
            value: function(e, t, r, n) {
                var i = e.camera.transform.position
                  , a = e.camera.boundFrustum;
                this._getCollidingWithFrustum(e, a, !0, i, t, r, n);
            }
        }, {
            key: "isCollidingWithBoundBox",
            value: function(e) {
                if (!Ne.intersectsBoxAndBox(this._bounds, e))
                    return !1;
                for (var t = 0, r = this._objects.length; t < r; t++) {
                    var n = this._objects[t];
                    if (Ne.intersectsBoxAndBox(n.bounds._getBoundBox(), e))
                        return !0;
                }
                if (null != this._children)
                    for (t = 0; t < 8; t++) {
                        if (this._children[t].isCollidingWithBoundBox(e))
                            return !0;
                    }
                return !1;
            }
        }, {
            key: "isCollidingWithRay",
            value: function(e) {
                var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : Number.MAX_VALUE
                  , r = Ne.intersectsRayAndBoxRD(e, this._bounds);
                if (-1 == r || r > t)
                    return !1;
                for (var n = 0, i = this._objects.length; n < i; n++) {
                    var a = this._objects[n];
                    if (-1 !== (r = Ne.intersectsRayAndBoxRD(e, a.bounds._getBoundBox())) && r <= t)
                        return !0;
                }
                if (null != this._children)
                    for (n = 0; n < 8; n++) {
                        if (this._children[n].isCollidingWithRay(e, t))
                            return !0;
                    }
                return !1;
            }
        }, {
            key: "getBound",
            value: function() {
                return this._bounds;
            }
        }, {
            key: "drawAllBounds",
            value: function(e, t, r) {
                if (null !== this._children || 0 != this._objects.length) {
                    t++;
                    var n = BoundsOctreeNode._tempColor0;
                    if (this._isContaion)
                        n.r = 0,
                        n.g = 0,
                        n.b = 1;
                    else {
                        var i = r ? t / r : 0;
                        n.r = 1 - i,
                        n.g = i,
                        n.b = 0;
                    }
                    if (n.a = .3,
                    R._drawBound(e, this._bounds, n),
                    null != this._children)
                        for (var a = 0; a < 8; a++) {
                            var o = this._children[a];
                            o && o.drawAllBounds(e, t, r);
                        }
                }
            }
        }, {
            key: "drawAllObjects",
            value: function(e, t, r) {
                t++;
                var n = BoundsOctreeNode._tempColor0;
                if (this._isContaion)
                    n.r = 0,
                    n.g = 0,
                    n.b = 1;
                else {
                    var i = r ? t / r : 0;
                    n.r = 1 - i,
                    n.g = i,
                    n.b = 0;
                }
                n.a = 1;
                for (var a = 0, o = this._objects.length; a < o; a++)
                    R._drawBound(e, this._objects[a].bounds._getBoundBox(), n);
                if (null != this._children)
                    for (a = 0; a < 8; a++) {
                        var s = this._children[a];
                        s && s.drawAllObjects(e, t, r);
                    }
            }
        }], [{
            key: "_encapsulates",
            value: function(e, t) {
                return Ne.boxContainsBox(e, t) == Oe.Contains;
            }
        }]),
        BoundsOctreeNode;
    }();
    Ir._tempVector3 = new o(),
    Ir._tempVector30 = new o(),
    Ir._tempVector31 = new o(),
    Ir._tempColor0 = new ve(),
    Ir._tempBoundBox = new ot(new o(),new o()),
    Ir._NUM_OBJECTS_ALLOWED = 8;
    var Lr, Pr = function(e) {
        function OctreeMotionList() {
            return _classCallCheck(this, OctreeMotionList),
            _possibleConstructorReturn(this, _getPrototypeOf(OctreeMotionList).call(this));
        }
        return _inherits(OctreeMotionList, nt),
        _createClass(OctreeMotionList, [{
            key: "add",
            value: function(e) {
                if (-1 !== e._getIndexInMotionList())
                    throw "OctreeMotionList:element has  in  PhysicsUpdateList.";
                this._add(e),
                e._setIndexInMotionList(this.length++);
            }
        }, {
            key: "remove",
            value: function(e) {
                var t = e._getIndexInMotionList();
                if (this.length--,
                t !== this.length) {
                    var r = this.elements[this.length];
                    this.elements[t] = r,
                    r._setIndexInMotionList(t);
                }
                e._setIndexInMotionList(-1);
            }
        }]),
        OctreeMotionList;
    }(), Or = function() {
        function BoundsOctree(e, t, r, n) {
            _classCallCheck(this, BoundsOctree),
            this._motionObjects = new Pr(),
            this.count = 0,
            r > e && (console.warn("Minimum node size must be at least as big as the initial world size. Was: " + r + " Adjusted to: " + e),
            r = e),
            this._initialSize = e,
            this._minSize = r,
            this._looseness = Math.min(Math.max(n, 1), 2),
            this._rootNode = new Ir(this,null,e,t);
        }
        return _createClass(BoundsOctree, [{
            key: "_getMaxDepth",
            value: function(e, t) {
                t++;
                var r = e._children;
                if (null != r)
                    for (var n = t, i = 0, a = r.length; i < a; i++) {
                        var o = r[i];
                        o && (t = Math.max(this._getMaxDepth(o, n), t));
                    }
                return t;
            }
        }, {
            key: "_grow",
            value: function(e) {
                var t = e.x >= 0 ? 1 : -1
                  , r = e.y >= 0 ? 1 : -1
                  , n = e.z >= 0 ? 1 : -1
                  , i = this._rootNode
                  , a = this._rootNode.baseLength / 2
                  , s = 2 * this._rootNode.baseLength
                  , l = this._rootNode.center
                  , u = new o(l.x + t * a,l.y + r * a,l.z + n * a);
                if (this._rootNode = new Ir(this,null,s,u),
                i.hasAnyObjects()) {
                    for (var c = this._rootNode._bestFitChild(i.center), h = [], _ = 0; _ < 8; _++)
                        _ == c && (i._parent = this._rootNode,
                        h[_] = i);
                    this._rootNode._children = h;
                }
            }
        }, {
            key: "add",
            value: function(e) {
                for (var t = 0; !this._rootNode.add(e); ) {
                    var r = BoundsOctree._tempVector30;
                    if (o.subtract(e.bounds.getCenter(), this._rootNode.center, r),
                    this._grow(r),
                    ++t > 20)
                        throw "Aborted Add operation as it seemed to be going on forever (" + (t - 1) + ") attempts at growing the octree.";
                }
                this.count++;
            }
        }, {
            key: "remove",
            value: function(e) {
                var t = e._getOctreeNode().remove(e);
                return t && this.count--,
                t;
            }
        }, {
            key: "update",
            value: function(e) {
                var t = 0
                  , r = e._getOctreeNode();
                if (r) {
                    for (; !r._update(e); ) {
                        var n = BoundsOctree._tempVector30;
                        if (o.subtract(e.bounds.getCenter(), this._rootNode.center, n),
                        this._grow(n),
                        ++t > 20)
                            throw "Aborted Add operation as it seemed to be going on forever (" + (t - 1) + ") attempts at growing the octree.";
                    }
                    return !0;
                }
                return !1;
            }
        }, {
            key: "shrinkRootIfPossible",
            value: function() {
                this._rootNode = this._rootNode.shrinkIfPossible(this._initialSize);
            }
        }, {
            key: "addMotionObject",
            value: function(e) {
                this._motionObjects.add(e);
            }
        }, {
            key: "removeMotionObject",
            value: function(e) {
                this._motionObjects.remove(e);
            }
        }, {
            key: "updateMotionObjects",
            value: function() {
                for (var e = this._motionObjects.elements, t = 0, r = this._motionObjects.length; t < r; t++) {
                    var n = e[t];
                    this.update(n),
                    n._setIndexInMotionList(-1);
                }
                this._motionObjects.length = 0;
            }
        }, {
            key: "isCollidingWithBoundBox",
            value: function(e) {
                return this._rootNode.isCollidingWithBoundBox(e);
            }
        }, {
            key: "isCollidingWithRay",
            value: function(e) {
                var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : Number.MAX_VALUE;
                return this._rootNode.isCollidingWithRay(e, t);
            }
        }, {
            key: "getCollidingWithBoundBox",
            value: function(e, t) {
                this._rootNode.getCollidingWithBoundBox(e, t);
            }
        }, {
            key: "getCollidingWithRay",
            value: function(e, t) {
                var r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : Number.MAX_VALUE;
                this._rootNode.getCollidingWithRay(e, t, r);
            }
        }, {
            key: "getCollidingWithFrustum",
            value: function(e, t, r, n) {
                this._rootNode.getCollidingWithFrustum(e, t, r, n);
            }
        }, {
            key: "getMaxBounds",
            value: function() {
                return this._rootNode.getBound();
            }
        }, {
            key: "drawAllBounds",
            value: function(e) {
                var t = this._getMaxDepth(this._rootNode, -1);
                this._rootNode.drawAllBounds(e, -1, t);
            }
        }, {
            key: "drawAllObjects",
            value: function(e) {
                var t = this._getMaxDepth(this._rootNode, -1);
                this._rootNode.drawAllObjects(e, -1, t);
            }
        }]),
        BoundsOctree;
    }();
    Or._tempVector30 = new o(),
    (Lr = e.AmbientMode || (e.AmbientMode = {}))[Lr.SolidColor = 0] = "SolidColor",
    Lr[Lr.SphericalHarmonics = 1] = "SphericalHarmonics";
    var Nr = function(r) {
        function Scene3D() {
            var r;
            _classCallCheck(this, Scene3D),
            (r = _possibleConstructorReturn(this, _getPrototypeOf(Scene3D).call(this)))._lightCount = 0,
            r._pointLights = new Sr(),
            r._spotLights = new Sr(),
            r._directionLights = new Rr(),
            r._alternateLights = new Cr(),
            r._lightmaps = [],
            r._skyRenderer = new ze(),
            r._input = new vr(),
            r._timer = t.ILaya.timer,
            r._time = 0,
            r._shCoefficients = new Array(7),
            r._ambientMode = e.AmbientMode.SolidColor,
            r._ambientSphericalHarmonics = new $t(),
            r._ambientSphericalHarmonicsIntensity = 1,
            r._reflectionDecodeFormat = t.TextureDecodeFormat.Normal,
            r._reflectionIntensity = 1,
            r._collsionTestList = [],
            r._renders = new Jt(),
            r._opaqueQueue = new Ar(!1),
            r._transparentQueue = new Ar(!0),
            r._cameraPool = [],
            r._animatorPool = new Jt(),
            r._scriptPool = new Array(),
            r._tempScriptPool = new Array(),
            r._needClearScriptPool = !1,
            r._reflectionCubeHDRParams = new i(),
            r.currentCreationLayer = Math.pow(2, 0),
            r.enableLight = !0,
            r._key = new t.SubmitKey(),
            r._pickIdToSprite = new Object(),
            r._reflectionMode = 0,
            S._enablePhysics && (r._physicsSimulation = new pr(Scene3D.physicsSettings)),
            r._shaderValues = new z(null),
            r.parallelSplitShadowMaps = [],
            r.enableFog = !1,
            r.fogStart = 300,
            r.fogRange = 1e3,
            r.fogColor = new o(.7,.7,.7),
            r.ambientColor = new o(.212,.227,.259),
            r.reflectionIntensity = 1,
            r.reflection = gr.blackTexture;
            for (var n = 0; n < 7; n++)
                r._shCoefficients[n] = new i();
            var a = s._config;
            switch (a._multiLighting || r._shaderValues.addDefine(G.SHADERDEFINE_LEGACYSINGALLIGHTING),
            a.pbrRenderQuality) {
            case e.PBRRenderQuality.High:
                r._shaderValues.addDefine(ee.SHADERDEFINE_LAYA_PBR_BRDF_HIGH);
                break;
            case e.PBRRenderQuality.Low:
                r._shaderValues.addDefine(ee.SHADERDEFINE_LAYA_PBR_BRDF_LOW);
                break;
            default:
                throw "Scene3D:unknown shader quality.";
            }
            if (r._shaderValues.setVector(Scene3D.REFLECTIONCUBE_HDR_PARAMS, r._reflectionCubeHDRParams),
            t.Render.supportWebGLPlusCulling && (r._cullingBufferIndices = new Int32Array(1024),
            r._cullingBufferResult = new Int32Array(1024)),
            r._scene = _assertThisInitialized(r),
            r._input.__init__(t.Render.canvas, _assertThisInitialized(r)),
            Scene3D.octreeCulling && (r._octree = new Or(Scene3D.octreeInitialSize,Scene3D.octreeInitialCenter,Scene3D.octreeMinNodeSize,Scene3D.octreeLooseness)),
            Re.debugFrustumCulling) {
                r._debugTool = new xr();
                var l = new qt();
                l.renderQueue = Z.RENDERQUEUE_TRANSPARENT,
                l.alphaTest = !1,
                l.depthWrite = !1,
                l.cull = Q.CULL_BACK,
                l.blend = Q.BLEND_ENABLE_ALL,
                l.blendSrc = Q.BLENDPARAM_SRC_ALPHA,
                l.blendDst = Q.BLENDPARAM_ONE_MINUS_SRC_ALPHA,
                l.depthTest = Q.DEPTHTEST_LESS,
                r._debugTool.pixelLineRenderer.sharedMaterial = l;
            }
            return r;
        }
        return _inherits(Scene3D, t.Sprite),
        _createClass(Scene3D, [{
            key: "_applySHCoefficients",
            value: function(e, t) {
                for (var r = this._shCoefficients, n = 0; n < 3; n++) {
                    var i = r[n]
                      , a = r[n + 3];
                    i.setValue(e.getCoefficient(n, 3) * t, e.getCoefficient(n, 1) * t, e.getCoefficient(n, 2) * t, (e.getCoefficient(n, 0) - e.getCoefficient(n, 6)) * t),
                    a.setValue(e.getCoefficient(n, 4) * t, e.getCoefficient(n, 5) * t, 3 * e.getCoefficient(n, 6) * t, e.getCoefficient(n, 7) * t);
                }
                r[6].setValue(e.getCoefficient(0, 8) * t, e.getCoefficient(1, 8) * t, e.getCoefficient(2, 8) * t, 1);
                var o = this._shaderValues;
                o.setVector(Scene3D.AMBIENTSHAR, r[0]),
                o.setVector(Scene3D.AMBIENTSHAG, r[1]),
                o.setVector(Scene3D.AMBIENTSHAB, r[2]),
                o.setVector(Scene3D.AMBIENTSHBR, r[3]),
                o.setVector(Scene3D.AMBIENTSHBG, r[4]),
                o.setVector(Scene3D.AMBIENTSHBB, r[5]),
                o.setVector(Scene3D.AMBIENTSHC, r[6]);
            }
        }, {
            key: "_setLightmapToChildNode",
            value: function(e) {
                e instanceof ge && e._render._applyLightMapParams();
                for (var t = e._children, r = 0, n = t.length; r < n; r++)
                    this._setLightmapToChildNode(t[r]);
            }
        }, {
            key: "_update",
            value: function() {
                var e = this.timer._delta / 1e3;
                this._time += e,
                this._shaderValues.setNumber(Scene3D.TIME, this._time);
                var t = this._physicsSimulation;
                S._enablePhysics && !pr.disableSimulation && (t._updatePhysicsTransformFromRender(),
                mr._addUpdateList = !1,
                t._simulate(e),
                t._updateCharacters(),
                mr._addUpdateList = !0,
                t._updateCollisions(),
                t._eventScripts()),
                this._input._update(),
                this._clearScript(),
                this._updateScript(),
                N._update(this),
                this._lateUpdateScript();
            }
        }, {
            key: "_binarySearchIndexInCameraPool",
            value: function(e) {
                for (var t, r = 0, n = this._cameraPool.length - 1; r <= n; ) {
                    t = Math.floor((r + n) / 2);
                    var i = this._cameraPool[t]._renderingOrder;
                    if (i == e._renderingOrder)
                        return t;
                    i > e._renderingOrder ? n = t - 1 : r = t + 1;
                }
                return r;
            }
        }, {
            key: "_allotPickColorByID",
            value: function(e, t) {
                var r = Math.floor(e / 65025);
                e -= 255 * r * 255;
                var n = Math.floor(e / 255)
                  , i = e -= 255 * n;
                t.x = r / 255,
                t.y = n / 255,
                t.z = i / 255,
                t.w = 1;
            }
        }, {
            key: "_searchIDByPickColor",
            value: function(e) {
                return 255 * e.x * 255 + 255 * e.y + e.z;
            }
        }, {
            key: "onEnable",
            value: function() {
                this._input._onCanvasEvent(t.Render.canvas);
            }
        }, {
            key: "onDisable",
            value: function() {
                this._input._offCanvasEvent(t.Render.canvas);
            }
        }, {
            key: "_setCreateURL",
            value: function(e) {
                this._url = t.URL.formatURL(e);
            }
        }, {
            key: "_getGroup",
            value: function() {
                return this._group;
            }
        }, {
            key: "_setGroup",
            value: function(e) {
                this._group = e;
            }
        }, {
            key: "_clearScript",
            value: function() {
                if (this._needClearScriptPool) {
                    for (var e = this._scriptPool, t = 0, r = e.length; t < r; t++) {
                        var n = e[t];
                        n && (n._indexInPool = this._tempScriptPool.length,
                        this._tempScriptPool.push(n));
                    }
                    this._scriptPool = this._tempScriptPool,
                    e.length = 0,
                    this._tempScriptPool = e,
                    this._needClearScriptPool = !1;
                }
            }
        }, {
            key: "_updateScript",
            value: function() {
                for (var e = this._scriptPool, t = 0, r = e.length; t < r; t++) {
                    var n = e[t];
                    n && n.enabled && n.onUpdate();
                }
            }
        }, {
            key: "_lateUpdateScript",
            value: function() {
                for (var e = this._scriptPool, t = 0, r = e.length; t < r; t++) {
                    var n = e[t];
                    n && n.enabled && n.onLateUpdate();
                }
            }
        }, {
            key: "_onActive",
            value: function() {
                _get(_getPrototypeOf(Scene3D.prototype), "_onActive", this).call(this),
                t.ILaya.stage._scene3Ds.push(this);
            }
        }, {
            key: "_onInActive",
            value: function() {
                _get(_getPrototypeOf(Scene3D.prototype), "_onInActive", this).call(this);
                var e = t.ILaya.stage._scene3Ds;
                e.splice(e.indexOf(this), 1);
            }
        }, {
            key: "_prepareSceneToRender",
            value: function() {
                var e = this._shaderValues;
                if (s._config._multiLighting) {
                    var t = Scene3D._lightTexture
                      , r = Scene3D._lightPixles
                      , n = t.width
                      , i = 4 * n
                      , a = 0
                      , l = this._directionLights._length
                      , u = this._directionLights._elements;
                    if (l > 0) {
                        for (var c = this._directionLights.getSunLight(), h = 0; h < l; h++,
                        a++) {
                            var _ = (g = u[h])._direction
                              , d = g._intensityColor
                              , f = i * a;
                            o.scale(g.color, g._intensity, d),
                            g.transform.worldMatrix.getForward(_),
                            o.normalize(_, _),
                            r[f] = d.x,
                            r[f + 1] = d.y,
                            r[f + 2] = d.z,
                            r[f + 4] = _.x,
                            r[f + 5] = _.y,
                            r[f + 6] = _.z,
                            h == c && (e.setVector3(Scene3D.SUNLIGHTDIRCOLOR, d),
                            e.setVector3(Scene3D.SUNLIGHTDIRECTION, _));
                        }
                        e.addDefine(Je.SHADERDEFINE_DIRECTIONLIGHT);
                    } else
                        e.removeDefine(Je.SHADERDEFINE_DIRECTIONLIGHT);
                    var m = this._pointLights._length;
                    if (m > 0) {
                        var p = this._pointLights._elements;
                        for (h = 0; h < m; h++,
                        a++) {
                            var v = (S = p[h]).transform.position;
                            d = S._intensityColor,
                            f = i * a;
                            o.scale(S.color, S._intensity, d),
                            r[f] = d.x,
                            r[f + 1] = d.y,
                            r[f + 2] = d.z,
                            r[f + 3] = S.range,
                            r[f + 4] = v.x,
                            r[f + 5] = v.y,
                            r[f + 6] = v.z;
                        }
                        e.addDefine(Je.SHADERDEFINE_POINTLIGHT);
                    } else
                        e.removeDefine(Je.SHADERDEFINE_POINTLIGHT);
                    var T = this._spotLights._length;
                    if (T > 0) {
                        var E = this._spotLights._elements;
                        for (h = 0; h < T; h++,
                        a++) {
                            var y = E[h];
                            _ = y._direction,
                            v = y.transform.position,
                            d = y._intensityColor,
                            f = i * a;
                            o.scale(y.color, y._intensity, d),
                            y.transform.worldMatrix.getForward(_),
                            o.normalize(_, _),
                            r[f] = d.x,
                            r[f + 1] = d.y,
                            r[f + 2] = d.z,
                            r[f + 3] = y.range,
                            r[f + 4] = v.x,
                            r[f + 5] = v.y,
                            r[f + 6] = v.z,
                            r[f + 7] = y.spotAngle * Math.PI / 180,
                            r[f + 8] = _.x,
                            r[f + 9] = _.y,
                            r[f + 10] = _.z;
                        }
                        e.addDefine(Je.SHADERDEFINE_SPOTLIGHT);
                    } else
                        e.removeDefine(Je.SHADERDEFINE_SPOTLIGHT);
                    a > 0 && t.setSubPixels(0, 0, n, a, r, 0),
                    e.setTexture(Scene3D.LIGHTBUFFER, t),
                    e.setInt(Scene3D.DIRECTIONLIGHTCOUNT, this._directionLights._length),
                    e.setTexture(Scene3D.CLUSTERBUFFER, Ie.instance._clusterTexture);
                } else {
                    if (this._directionLights._length > 0) {
                        var g = this._directionLights._elements[0];
                        o.scale(g.color, g._intensity, g._intensityColor),
                        g.transform.worldMatrix.getForward(g._direction),
                        o.normalize(g._direction, g._direction),
                        e.setVector3(Scene3D.LIGHTDIRCOLOR, g._intensityColor),
                        e.setVector3(Scene3D.LIGHTDIRECTION, g._direction),
                        e.setVector3(Scene3D.SUNLIGHTDIRCOLOR, g._intensityColor),
                        e.setVector3(Scene3D.SUNLIGHTDIRECTION, g._direction),
                        e.addDefine(Je.SHADERDEFINE_DIRECTIONLIGHT);
                    } else
                        e.removeDefine(Je.SHADERDEFINE_DIRECTIONLIGHT);
                    if (this._pointLights._length > 0) {
                        var S = this._pointLights._elements[0];
                        o.scale(S.color, S._intensity, S._intensityColor),
                        e.setVector3(Scene3D.POINTLIGHTCOLOR, S._intensityColor),
                        e.setVector3(Scene3D.POINTLIGHTPOS, S.transform.position),
                        e.setNumber(Scene3D.POINTLIGHTRANGE, S.range),
                        e.addDefine(Je.SHADERDEFINE_POINTLIGHT);
                    } else
                        e.removeDefine(Je.SHADERDEFINE_POINTLIGHT);
                    if (this._spotLights._length > 0) {
                        var R = this._spotLights._elements[0];
                        o.scale(R.color, R._intensity, R._intensityColor),
                        e.setVector3(Scene3D.SPOTLIGHTCOLOR, R._intensityColor),
                        e.setVector3(Scene3D.SPOTLIGHTPOS, R.transform.position),
                        R.transform.worldMatrix.getForward(R._direction),
                        o.normalize(R._direction, R._direction),
                        e.setVector3(Scene3D.SPOTLIGHTDIRECTION, R._direction),
                        e.setNumber(Scene3D.SPOTLIGHTRANGE, R.range),
                        e.setNumber(Scene3D.SPOTLIGHTSPOTANGLE, R.spotAngle * Math.PI / 180),
                        e.addDefine(Je.SHADERDEFINE_SPOTLIGHT);
                    } else
                        e.removeDefine(Je.SHADERDEFINE_SPOTLIGHT);
                }
            }
        }, {
            key: "_addScript",
            value: function(e) {
                var t = this._scriptPool;
                e._indexInPool = t.length,
                t.push(e);
            }
        }, {
            key: "_removeScript",
            value: function(e) {
                this._scriptPool[e._indexInPool] = null,
                e._indexInPool = -1,
                this._needClearScriptPool = !0;
            }
        }, {
            key: "_preRenderScript",
            value: function() {
                for (var e = this._scriptPool, t = 0, r = e.length; t < r; t++) {
                    var n = e[t];
                    n && n.enabled && n.onPreRender();
                }
            }
        }, {
            key: "_postRenderScript",
            value: function() {
                for (var e = this._scriptPool, t = 0, r = e.length; t < r; t++) {
                    var n = e[t];
                    n && n.enabled && n.onPostRender();
                }
            }
        }, {
            key: "_addCamera",
            value: function(e) {
                for (var t = this._binarySearchIndexInCameraPool(e), r = e._renderingOrder, n = this._cameraPool.length; t < n && this._cameraPool[t]._renderingOrder <= r; )
                    t++;
                this._cameraPool.splice(t, 0, e);
            }
        }, {
            key: "_removeCamera",
            value: function(e) {
                this._cameraPool.splice(this._cameraPool.indexOf(e), 1);
            }
        }, {
            key: "_preCulling",
            value: function(e, t, r, n) {
                Re.renderObjectCulling(t, this, e, r, n, !1);
            }
        }, {
            key: "_clear",
            value: function(r, n) {
                var i, a, o, s = n.viewport, l = n.camera, u = l._getRenderTexture(), c = s.width, h = s.height;
                l._needInternalRenderTexture() ? (i = 0,
                a = 0) : (i = s.x,
                a = l._getCanvasHeight() - s.y - h),
                r.viewport(i, a, c, h);
                var _ = l.clearFlag;
                switch (_ !== e.CameraClearFlags.Sky || l.skyRenderer._isAvailable() || this._skyRenderer._isAvailable() || (_ = e.CameraClearFlags.SolidColor),
                _) {
                case e.CameraClearFlags.SolidColor:
                    var d = l.clearColor;
                    if (r.enable(r.SCISSOR_TEST),
                    r.scissor(i, a, c, h),
                    d ? r.clearColor(d.x, d.y, d.z, d.w) : r.clearColor(0, 0, 0, 0),
                    u)
                        switch (o = r.COLOR_BUFFER_BIT,
                        u.depthStencilFormat) {
                        case t.RenderTextureDepthFormat.DEPTH_16:
                            o |= r.DEPTH_BUFFER_BIT;
                            break;
                        case t.RenderTextureDepthFormat.STENCIL_8:
                            o |= r.STENCIL_BUFFER_BIT;
                            break;
                        case t.RenderTextureDepthFormat.DEPTHSTENCIL_16_8:
                            o |= r.DEPTH_BUFFER_BIT,
                            o |= r.STENCIL_BUFFER_BIT;
                        }
                    else
                        o = r.COLOR_BUFFER_BIT | r.DEPTH_BUFFER_BIT;
                    t.WebGLContext.setDepthMask(r, !0),
                    r.clear(o),
                    r.disable(r.SCISSOR_TEST);
                    break;
                case e.CameraClearFlags.Sky:
                case e.CameraClearFlags.DepthOnly:
                    if (r.enable(r.SCISSOR_TEST),
                    r.scissor(i, a, c, h),
                    u)
                        switch (u.depthStencilFormat) {
                        case t.RenderTextureDepthFormat.DEPTH_16:
                            o = r.DEPTH_BUFFER_BIT;
                            break;
                        case t.RenderTextureDepthFormat.STENCIL_8:
                            o = r.STENCIL_BUFFER_BIT;
                            break;
                        case t.RenderTextureDepthFormat.DEPTHSTENCIL_16_8:
                            o = r.DEPTH_BUFFER_BIT | r.STENCIL_BUFFER_BIT;
                        }
                    else
                        o = r.DEPTH_BUFFER_BIT;
                    t.WebGLContext.setDepthMask(r, !0),
                    r.clear(o),
                    r.disable(r.SCISSOR_TEST);
                    break;
                case e.CameraClearFlags.Nothing:
                    break;
                default:
                    throw new Error("Scene3D:camera clearFlag invalid.");
                }
            }
        }, {
            key: "_renderScene",
            value: function(t) {
                var r = t.camera;
                if (this._opaqueQueue._render(t),
                r.clearFlag === e.CameraClearFlags.Sky && (r.skyRenderer._isAvailable() ? r.skyRenderer._render(t) : this._skyRenderer._isAvailable() && this._skyRenderer._render(t)),
                this._transparentQueue._render(t),
                Re.debugFrustumCulling)
                    for (var n = this._debugTool._render._renderElements, i = 0, a = n.length; i < a; i++)
                        n[i]._update(this, t, null, null),
                        n[i]._render(t);
            }
        }, {
            key: "_parse",
            value: function(e, r) {
                var n = e.lightmaps;
                if (n) {
                    for (var i = n.length, a = [], o = 0; o < i; o++)
                        a[o] = t.Loader.getRes(n[o].path);
                    this.setlightmaps(a);
                }
                var s = e.ambientColor;
                if (s) {
                    var l = this.ambientColor;
                    l.fromArray(s),
                    this.ambientColor = l;
                }
                var u = e.sky;
                if (u)
                    switch (this._skyRenderer.material = t.Loader.getRes(u.material.path),
                    u.mesh) {
                    case "SkyBox":
                        this._skyRenderer.mesh = Ge.instance;
                        break;
                    case "SkyDome":
                        this._skyRenderer.mesh = yr.instance;
                        break;
                    default:
                        this.skyRenderer.mesh = Ge.instance;
                    }
                this.enableFog = e.enableFog,
                this.fogStart = e.fogStart,
                this.fogRange = e.fogRange;
                var c = e.fogColor;
                if (c) {
                    var h = this.fogColor;
                    h.fromArray(c),
                    this.fogColor = h;
                }
                var _ = e.ambientSphericalHarmonics;
                if (_) {
                    var d = this.ambientSphericalHarmonics;
                    for (o = 0; o < 3; o++) {
                        var f = 9 * o;
                        d.setCoefficients(o, _[f], _[f + 1], _[f + 2], _[f + 3], _[f + 4], _[f + 5], _[f + 6], _[f + 7], _[f + 8]);
                    }
                    this.ambientSphericalHarmonics = d;
                }
                var m = e.reflection;
                null != m && (this.reflection = t.Loader.getRes(m));
                var p = e.reflectionDecodingFormat;
                null != p && (this.reflectionDecodingFormat = p);
                var v = e.ambientMode;
                null != v && (this.ambientMode = v);
                var T = e.ambientSphericalHarmonicsIntensity;
                null != T && (this.ambientSphericalHarmonicsIntensity = T);
                var E = e.reflectionIntensity;
                null != E && (this.reflectionIntensity = E);
            }
        }, {
            key: "_addRenderObject",
            value: function(e) {
                if (this._octree && e._supportOctree)
                    this._octree.add(e);
                else if (this._renders.add(e),
                t.Render.supportWebGLPlusCulling) {
                    var r = e._getIndexInList()
                      , n = this._cullingBufferIndices.length;
                    if (r >= n) {
                        var i = this._cullingBufferIndices
                          , a = this._cullingBufferResult;
                        this._cullingBufferIndices = new Int32Array(n + 1024),
                        this._cullingBufferResult = new Int32Array(n + 1024),
                        this._cullingBufferIndices.set(i, 0),
                        this._cullingBufferResult.set(a, 0);
                    }
                    this._cullingBufferIndices[r] = e._cullingBufferIndex;
                }
            }
        }, {
            key: "_removeRenderObject",
            value: function(e) {
                var r;
                this._octree && e._supportOctree ? this._octree.remove(e) : (t.Render.supportWebGLPlusCulling && (r = this._renders.elements[this._renders.length - 1]),
                this._renders.remove(e),
                t.Render.supportWebGLPlusCulling && (this._cullingBufferIndices[r._getIndexInList()] = r._cullingBufferIndex));
            }
        }, {
            key: "_getRenderQueue",
            value: function(e) {
                return e <= 2500 ? this._opaqueQueue : this._transparentQueue;
            }
        }, {
            key: "setlightmaps",
            value: function(e) {
                for (var t = this._lightmaps, r = 0, n = t.length; r < n; r++)
                    t[r]._removeReference();
                if (!e)
                    throw new Error("Scene3D: value value can't be null.");
                var i = e.length;
                for (t.length = i,
                r = 0; r < i; r++) {
                    var a = e[r];
                    a._addReference(),
                    t[r] = a;
                }
                for (r = 0,
                n = this._children.length; r < n; r++)
                    this._setLightmapToChildNode(this._children[r]);
            }
        }, {
            key: "getlightmaps",
            value: function() {
                return this._lightmaps.slice();
            }
        }, {
            key: "destroy",
            value: function() {
                var e = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0];
                this.destroyed || (_get(_getPrototypeOf(Scene3D.prototype), "destroy", this).call(this, e),
                this._skyRenderer.destroy(),
                this._skyRenderer = null,
                this._directionLights = null,
                this._pointLights = null,
                this._spotLights = null,
                this._alternateLights = null,
                this._lightmaps = null,
                this._shaderValues = null,
                this._renders = null,
                this._cameraPool = null,
                this._octree = null,
                this.parallelSplitShadowMaps = null,
                this._physicsSimulation && this._physicsSimulation._destroy(),
                t.Loader.clearRes(this.url));
            }
        }, {
            key: "render",
            value: function(e, r, n) {
                e._curSubmit = t.SubmitBase.RENDERBASE,
                this._children.length > 0 && e.addRenderObject(this);
            }
        }, {
            key: "renderSubmit",
            value: function() {
                var e, r, n;
                t.LayaGL.instance;
                for (this._prepareSceneToRender(),
                e = 0,
                n = (r = this._cameraPool.length) - 1; e < r; e++) {
                    t.Render.supportWebGLPlusRendering && z.setRuntimeValueMode(e == n);
                    var i = this._cameraPool[e];
                    i.enableRender && i.render();
                }
                return t.Context.set2DRenderConfig(),
                1;
            }
        }, {
            key: "getRenderType",
            value: function() {
                return 0;
            }
        }, {
            key: "releaseRender",
            value: function() {}
        }, {
            key: "reUse",
            value: function(e, t) {
                return 0;
            }
        }, {
            key: "url",
            get: function() {
                return this._url;
            }
        }, {
            key: "enableFog",
            get: function() {
                return this._enableFog;
            },
            set: function(e) {
                this._enableFog !== e && (this._enableFog = e,
                e ? this._shaderValues.addDefine(Je.SHADERDEFINE_FOG) : this._shaderValues.removeDefine(Je.SHADERDEFINE_FOG));
            }
        }, {
            key: "fogColor",
            get: function() {
                return this._shaderValues.getVector3(Scene3D.FOGCOLOR);
            },
            set: function(e) {
                this._shaderValues.setVector3(Scene3D.FOGCOLOR, e);
            }
        }, {
            key: "fogStart",
            get: function() {
                return this._shaderValues.getNumber(Scene3D.FOGSTART);
            },
            set: function(e) {
                this._shaderValues.setNumber(Scene3D.FOGSTART, e);
            }
        }, {
            key: "fogRange",
            get: function() {
                return this._shaderValues.getNumber(Scene3D.FOGRANGE);
            },
            set: function(e) {
                this._shaderValues.setNumber(Scene3D.FOGRANGE, e);
            }
        }, {
            key: "ambientMode",
            get: function() {
                return this._ambientMode;
            },
            set: function(t) {
                if (this._ambientMode !== t) {
                    switch (t) {
                    case e.AmbientMode.SolidColor:
                        this._shaderValues.removeDefine(Je.SHADERDEFINE_GI_AMBIENT_SH);
                        break;
                    case e.AmbientMode.SphericalHarmonics:
                        this._shaderValues.addDefine(Je.SHADERDEFINE_GI_AMBIENT_SH);
                        break;
                    default:
                        throw "Scene3D: unknown ambientMode.";
                    }
                    this._ambientMode = t;
                }
            }
        }, {
            key: "ambientColor",
            get: function() {
                return this._shaderValues.getVector3(Scene3D.AMBIENTCOLOR);
            },
            set: function(e) {
                this._shaderValues.setVector3(Scene3D.AMBIENTCOLOR, e);
            }
        }, {
            key: "ambientSphericalHarmonics",
            get: function() {
                return this._ambientSphericalHarmonics;
            },
            set: function(e) {
                var t = e || $t._default;
                this._applySHCoefficients(t, Math.pow(this._ambientSphericalHarmonicsIntensity, 2.2)),
                this._ambientSphericalHarmonics != e && e.cloneTo(this._ambientSphericalHarmonics);
            }
        }, {
            key: "ambientSphericalHarmonicsIntensity",
            get: function() {
                return this._ambientSphericalHarmonicsIntensity;
            },
            set: function(e) {
                if (e = Math.max(Math.min(e, 8), 0),
                this._ambientSphericalHarmonicsIntensity !== e) {
                    var t = this._ambientSphericalHarmonics || $t._default;
                    this._applySHCoefficients(t, Math.pow(e, 2.2)),
                    this._ambientSphericalHarmonicsIntensity = e;
                }
            }
        }, {
            key: "reflection",
            get: function() {
                return this._reflection;
            },
            set: function(e) {
                this._reflection != e && (this._shaderValues.setTexture(Scene3D.REFLECTIONTEXTURE, e || gr.blackTexture),
                this._reflection = e);
            }
        }, {
            key: "reflectionDecodingFormat",
            get: function() {
                return this._reflectionDecodeFormat;
            },
            set: function(e) {
                this._reflectionDecodeFormat != e && (this._reflectionCubeHDRParams.x = this._reflectionIntensity,
                this._reflectionDecodeFormat == t.TextureDecodeFormat.RGBM && (this._reflectionCubeHDRParams.x *= 5),
                this._reflectionDecodeFormat = e);
            }
        }, {
            key: "reflectionIntensity",
            get: function() {
                return this._reflectionIntensity;
            },
            set: function(e) {
                e = Math.max(Math.min(e, 1), 0),
                this._reflectionCubeHDRParams.x = e,
                this._reflectionDecodeFormat == t.TextureDecodeFormat.RGBM && (this._reflectionCubeHDRParams.x *= 5),
                this._reflectionIntensity = e;
            }
        }, {
            key: "skyRenderer",
            get: function() {
                return this._skyRenderer;
            }
        }, {
            key: "physicsSimulation",
            get: function() {
                return this._physicsSimulation;
            }
        }, {
            key: "timer",
            get: function() {
                return this._timer;
            },
            set: function(e) {
                this._timer = e;
            }
        }, {
            key: "input",
            get: function() {
                return this._input;
            }
        }, {
            key: "customReflection",
            get: function() {
                return this._reflection;
            },
            set: function(e) {
                this._reflection != e && (this._shaderValues.setTexture(Scene3D.REFLECTIONTEXTURE, e || gr.blackTexture),
                this._reflection = e);
            }
        }, {
            key: "reflectionMode",
            get: function() {
                return this._reflectionMode;
            },
            set: function(e) {
                this._reflectionMode = e;
            }
        }], [{
            key: "__init__",
            value: function() {
                var e = s._config;
                if (e._multiLighting) {
                    var t = e.maxLightCount
                      , r = e.lightClusterCount;
                    Ie.instance = new Ie(r.x,r.y,r.z,Math.min(e.maxLightCount, e._maxAreaLightCountPerClusterAverage)),
                    Scene3D._lightTexture = R._createFloatTextureBuffer(4, t),
                    Scene3D._lightTexture.lock = !0,
                    Scene3D._lightPixles = new Float32Array(4 * t * 4);
                }
                Je.SHADERDEFINE_FOG = G.getDefineByName("FOG"),
                Je.SHADERDEFINE_DIRECTIONLIGHT = G.getDefineByName("DIRECTIONLIGHT"),
                Je.SHADERDEFINE_POINTLIGHT = G.getDefineByName("POINTLIGHT"),
                Je.SHADERDEFINE_SPOTLIGHT = G.getDefineByName("SPOTLIGHT"),
                Je.SHADERDEFINE_CAST_SHADOW = G.getDefineByName("CASTSHADOW"),
                Je.SHADERDEFINE_SHADOW_PSSM1 = G.getDefineByName("SHADOWMAP_PSSM1"),
                Je.SHADERDEFINE_SHADOW_PSSM2 = G.getDefineByName("SHADOWMAP_PSSM2"),
                Je.SHADERDEFINE_SHADOW_PSSM3 = G.getDefineByName("SHADOWMAP_PSSM3"),
                Je.SHADERDEFINE_SHADOW_PCF_NO = G.getDefineByName("SHADOWMAP_PCF_NO"),
                Je.SHADERDEFINE_SHADOW_PCF1 = G.getDefineByName("SHADOWMAP_PCF1"),
                Je.SHADERDEFINE_SHADOW_PCF2 = G.getDefineByName("SHADOWMAP_PCF2"),
                Je.SHADERDEFINE_SHADOW_PCF3 = G.getDefineByName("SHADOWMAP_PCF3"),
                Je.SHADERDEFINE_GI_AMBIENT_SH = G.getDefineByName("GI_AMBIENT_SH");
            }
        }, {
            key: "load",
            value: function(e, r) {
                t.ILaya.loader.create(e, r, null, Scene3D.HIERARCHY);
            }
        }]),
        Scene3D;
    }();
    Nr.HIERARCHY = "HIERARCHY",
    Nr.physicsSettings = new Tr(),
    Nr.octreeCulling = !1,
    Nr.octreeInitialSize = 64,
    Nr.octreeInitialCenter = new o(0,0,0),
    Nr.octreeMinNodeSize = 2,
    Nr.octreeLooseness = 1.25,
    Nr.REFLECTIONMODE_SKYBOX = 0,
    Nr.REFLECTIONMODE_CUSTOM = 1,
    Nr.FOGCOLOR = G.propertyNameToID("u_FogColor"),
    Nr.FOGSTART = G.propertyNameToID("u_FogStart"),
    Nr.FOGRANGE = G.propertyNameToID("u_FogRange"),
    Nr.DIRECTIONLIGHTCOUNT = G.propertyNameToID("u_DirationLightCount"),
    Nr.LIGHTBUFFER = G.propertyNameToID("u_LightBuffer"),
    Nr.CLUSTERBUFFER = G.propertyNameToID("u_LightClusterBuffer"),
    Nr.SUNLIGHTDIRECTION = G.propertyNameToID("u_SunLight.direction"),
    Nr.SUNLIGHTDIRCOLOR = G.propertyNameToID("u_SunLight.color"),
    Nr.AMBIENTSHAR = G.propertyNameToID("u_AmbientSHAr"),
    Nr.AMBIENTSHAG = G.propertyNameToID("u_AmbientSHAg"),
    Nr.AMBIENTSHAB = G.propertyNameToID("u_AmbientSHAb"),
    Nr.AMBIENTSHBR = G.propertyNameToID("u_AmbientSHBr"),
    Nr.AMBIENTSHBG = G.propertyNameToID("u_AmbientSHBg"),
    Nr.AMBIENTSHBB = G.propertyNameToID("u_AmbientSHBb"),
    Nr.AMBIENTSHC = G.propertyNameToID("u_AmbientSHC"),
    Nr.REFLECTIONPROBE = G.propertyNameToID("u_ReflectionProbe"),
    Nr.REFLECTIONCUBE_HDR_PARAMS = G.propertyNameToID("u_ReflectCubeHDRParams"),
    Nr.LIGHTDIRECTION = G.propertyNameToID("u_DirectionLight.direction"),
    Nr.LIGHTDIRCOLOR = G.propertyNameToID("u_DirectionLight.color"),
    Nr.POINTLIGHTPOS = G.propertyNameToID("u_PointLight.position"),
    Nr.POINTLIGHTRANGE = G.propertyNameToID("u_PointLight.range"),
    Nr.POINTLIGHTATTENUATION = G.propertyNameToID("u_PointLight.attenuation"),
    Nr.POINTLIGHTCOLOR = G.propertyNameToID("u_PointLight.color"),
    Nr.SPOTLIGHTPOS = G.propertyNameToID("u_SpotLight.position"),
    Nr.SPOTLIGHTDIRECTION = G.propertyNameToID("u_SpotLight.direction"),
    Nr.SPOTLIGHTSPOTANGLE = G.propertyNameToID("u_SpotLight.spot"),
    Nr.SPOTLIGHTRANGE = G.propertyNameToID("u_SpotLight.range"),
    Nr.SPOTLIGHTCOLOR = G.propertyNameToID("u_SpotLight.color"),
    Nr.SHADOWDISTANCE = G.propertyNameToID("u_shadowPSSMDistance"),
    Nr.SHADOWLIGHTVIEWPROJECT = G.propertyNameToID("u_lightShadowVP"),
    Nr.SHADOWMAPPCFOFFSET = G.propertyNameToID("u_shadowPCFoffset"),
    Nr.SHADOWMAPTEXTURE1 = G.propertyNameToID("u_shadowMap1"),
    Nr.SHADOWMAPTEXTURE2 = G.propertyNameToID("u_shadowMap2"),
    Nr.SHADOWMAPTEXTURE3 = G.propertyNameToID("u_shadowMap3"),
    Nr.AMBIENTCOLOR = G.propertyNameToID("u_AmbientColor"),
    Nr.REFLECTIONTEXTURE = G.propertyNameToID("u_ReflectTexture"),
    Nr.TIME = G.propertyNameToID("u_Time");
    var br = function SkinnedMeshSprite3DShaderDeclaration() {
        _classCallCheck(this, SkinnedMeshSprite3DShaderDeclaration);
    }
      , kr = function(e) {
        function SkinnedMeshRenderer(e) {
            var t;
            return _classCallCheck(this, SkinnedMeshRenderer),
            (t = _possibleConstructorReturn(this, _getPrototypeOf(SkinnedMeshRenderer).call(this, e)))._bones = [],
            t._skinnedDataLoopMarks = [],
            t._localBounds = new st(o._ZERO,o._ZERO),
            t._cacheAnimationNode = [],
            t;
        }
        return _inherits(SkinnedMeshRenderer, ut),
        _createClass(SkinnedMeshRenderer, [{
            key: "_computeSkinnedData",
            value: function() {
                if (this._cacheMesh && this._cacheAvatar || this._cacheMesh && !this._cacheAvatar)
                    for (var e = this._cacheMesh._inverseBindPoses, t = this._cacheMesh._skinnedMatrixCaches, r = 0, n = this._cacheMesh.subMeshCount; r < n; r++)
                        for (var i = this._cacheMesh.getSubMesh(r)._boneIndicesList, a = this._skinnedData[r], o = 0, s = i.length; o < s; o++) {
                            var l = i[o];
                            this._computeSubSkinnedData(e, l, a[o], t);
                        }
            }
        }, {
            key: "_computeSubSkinnedData",
            value: function(e, r, n, i) {
                for (var a = 0, o = r.length; a < o; a++) {
                    var s = r[a];
                    if (this._skinnedDataLoopMarks[s] === t.Stat.loopCount)
                        for (var l = i[s], u = this._skinnedData[l.subMeshIndex][l.batchIndex], c = 16 * l.batchBoneIndex, h = 16 * a, _ = 0; _ < 16; _++)
                            n[h + _] = u[c + _];
                    else
                        this._cacheAvatar ? R._mulMatrixArray(this._cacheAnimationNode[s].transform.getWorldMatrix(), e[s], n, 16 * a) : R._mulMatrixArray(this._bones[s].transform.worldMatrix.elements, e[s], n, 16 * a),
                        this._skinnedDataLoopMarks[s] = t.Stat.loopCount;
                }
            }
        }, {
            key: "_onWorldMatNeedChange",
            value: function(e) {
                this._boundsChange = !0,
                this._octreeNode && (this._cacheAvatar ? -1 === this._indexInOctreeMotionList && this._octreeNode._octree.addMotionObject(this) : (e &= Ee.TRANSFORM_WORLDPOSITION | Ee.TRANSFORM_WORLDQUATERNION | Ee.TRANSFORM_WORLDSCALE) && -1 === this._indexInOctreeMotionList && this._octreeNode._octree.addMotionObject(this));
            }
        }, {
            key: "_createRenderElement",
            value: function() {
                return new et();
            }
        }, {
            key: "_onMeshChange",
            value: function(e) {
                _get(_getPrototypeOf(SkinnedMeshRenderer.prototype), "_onMeshChange", this).call(this, e),
                this._cacheMesh = e;
                var t = e.subMeshCount;
                this._skinnedData = [],
                this._skinnedDataLoopMarks.length = e._inverseBindPoses.length;
                for (var r = 0; r < t; r++)
                    for (var n = e.getSubMesh(r)._boneIndicesList, i = n.length, a = this._skinnedData[r] = [], o = 0; o < i; o++)
                        a[o] = new Float32Array(16 * n[o].length);
                this._cacheAvatar && e && this._getCacheAnimationNodes();
            }
        }, {
            key: "_setCacheAnimator",
            value: function(e) {
                this._cacheAnimator = e,
                this._shaderValues.addDefine(br.SHADERDEFINE_BONE),
                this._setRootNode();
            }
        }, {
            key: "_calculateBoundingBox",
            value: function() {
                if (this._cacheAvatar)
                    if (this._cacheAnimator && this._rootBone) {
                        var e = SkinnedMeshRenderer._tempMatrix4x4;
                        R.matrix4x4MultiplyMFM(this._cacheAnimator.owner.transform.worldMatrix, this._cacheRootAnimationNode.transform.getWorldMatrix(), e),
                        this._localBounds._tranform(e, this._bounds);
                    } else
                        _get(_getPrototypeOf(SkinnedMeshRenderer.prototype), "_calculateBoundingBox", this).call(this);
                else
                    this._cacheRootBone ? this._localBounds._tranform(this._cacheRootBone.transform.worldMatrix, this._bounds) : this._localBounds._tranform(this._owner.transform.worldMatrix, this._bounds);
                if (t.Render.supportWebGLPlusCulling) {
                    var r = this._bounds.getMin()
                      , n = this._bounds.getMax()
                      , i = Re._cullingBuffer;
                    i[this._cullingBufferIndex + 1] = r.x,
                    i[this._cullingBufferIndex + 2] = r.y,
                    i[this._cullingBufferIndex + 3] = r.z,
                    i[this._cullingBufferIndex + 4] = n.x,
                    i[this._cullingBufferIndex + 5] = n.y,
                    i[this._cullingBufferIndex + 6] = n.z;
                }
            }
        }, {
            key: "_renderUpdate",
            value: function(e, t) {
                if (this._cacheAnimator)
                    if (this._computeSkinnedData(),
                    this._cacheAvatar) {
                        var r = this._cacheAnimator.owner._transform;
                        this._shaderValues.setMatrix4x4(ye.WORLDMATRIX, r.worldMatrix);
                    } else
                        this._shaderValues.setMatrix4x4(ye.WORLDMATRIX, I.DEFAULT);
                else
                    this._shaderValues.setMatrix4x4(ye.WORLDMATRIX, t.worldMatrix);
            }
        }, {
            key: "_renderUpdateWithCamera",
            value: function(e, t) {
                var r = e.projectionViewMatrix;
                if (this._cacheAnimator)
                    if (this._cacheAvatar) {
                        var n = this._cacheAnimator.owner._transform;
                        I.multiply(r, n.worldMatrix, this._projectionViewWorldMatrix),
                        this._shaderValues.setMatrix4x4(ye.MVPMATRIX, this._projectionViewWorldMatrix);
                    } else
                        this._shaderValues.setMatrix4x4(ye.MVPMATRIX, r);
                else
                    I.multiply(r, t.worldMatrix, this._projectionViewWorldMatrix),
                    this._shaderValues.setMatrix4x4(ye.MVPMATRIX, this._projectionViewWorldMatrix);
            }
        }, {
            key: "_destroy",
            value: function() {
                _get(_getPrototypeOf(SkinnedMeshRenderer.prototype), "_destroy", this).call(this),
                this._cacheAvatar ? this._cacheRootAnimationNode && this._cacheRootAnimationNode.transform.off(t.Event.TRANSFORM_CHANGED, this, this._onWorldMatNeedChange) : this._cacheRootBone ? !this._cacheRootBone.destroyed && this._cacheRootBone.transform.off(t.Event.TRANSFORM_CHANGED, this, this._onWorldMatNeedChange) : this._owner && !this._owner.destroyed && this._owner.transform.off(t.Event.TRANSFORM_CHANGED, this, this._onWorldMatNeedChange);
            }
        }, {
            key: "_setRootBone",
            value: function(e) {
                this._rootBone = e,
                this._setRootNode();
            }
        }, {
            key: "_setRootNode",
            value: function() {
                var e;
                e = this._cacheAnimator && this._rootBone && this._cacheAvatar ? this._cacheAnimator._avatarNodeMap[this._rootBone] : null,
                this._cacheRootAnimationNode != e && (this._onWorldMatNeedChange(Ee.TRANSFORM_WORLDPOSITION | Ee.TRANSFORM_WORLDQUATERNION | Ee.TRANSFORM_WORLDSCALE),
                this._owner.transform.off(t.Event.TRANSFORM_CHANGED, this, this._onWorldMatNeedChange),
                this._cacheRootAnimationNode && this._cacheRootAnimationNode.transform.off(t.Event.TRANSFORM_CHANGED, this, this._onWorldMatNeedChange),
                e && e.transform.on(t.Event.TRANSFORM_CHANGED, this, this._onWorldMatNeedChange),
                this._cacheRootAnimationNode = e);
            }
        }, {
            key: "_getCacheAnimationNodes",
            value: function() {
                var e = this._cacheMesh._boneNames
                  , r = this._cacheMesh._inverseBindPoses.length;
                if (t.Render.supportWebGLPlusAnimation) {
                    this._cacheAnimationNodeIndices = new Uint16Array(r);
                    var n = this._cacheAnimator._avatarNodeMap;
                    for (o = 0; o < r; o++) {
                        var i = n[e[o]];
                        this._cacheAnimationNodeIndices[o] = i ? i._worldMatrixIndex : 0;
                    }
                } else {
                    this._cacheAnimationNode.length = r;
                    for (var a = this._cacheAnimator._avatarNodeMap, o = 0; o < r; o++) {
                        var s = a[e[o]];
                        this._cacheAnimationNode[o] = s;
                    }
                }
            }
        }, {
            key: "_setCacheAvatar",
            value: function(e) {
                this._cacheAvatar !== e && (this._cacheMesh ? (this._cacheAvatar = e,
                e && (this._shaderValues.addDefine(br.SHADERDEFINE_BONE),
                this._getCacheAnimationNodes())) : this._cacheAvatar = e,
                this._setRootNode());
            }
        }, {
            key: "_computeSubSkinnedDataNative",
            value: function(e, r, n, i, a) {
                t.LayaGL.instance.computeSubSkinnedData(e, r, n, i, a);
            }
        }, {
            key: "_computeSkinnedDataForNative",
            value: function() {
                if (this._cacheMesh && this._cacheAvatar || this._cacheMesh && !this._cacheAvatar)
                    for (var e = this._cacheMesh._inverseBindPoses, r = this._cacheMesh._skinnedMatrixCaches, n = 0, i = this._cacheMesh.subMeshCount; n < i; n++)
                        for (var a = this._cacheMesh.getSubMesh(n)._boneIndicesList, o = this._skinnedData[n], s = 0, l = a.length; s < l; s++) {
                            var u = a[s];
                            this._cacheAvatar && t.Render.supportWebGLPlusAnimation ? this._computeSubSkinnedDataNative(this._cacheAnimator._animationNodeWorldMatrixs, this._cacheAnimationNodeIndices, this._cacheMesh._inverseBindPosesBuffer, u, o[s]) : this._computeSubSkinnedData(e, u, o[s], r);
                        }
            }
        }, {
            key: "localBounds",
            get: function() {
                return this._localBounds;
            },
            set: function(e) {
                this._localBounds = e;
            }
        }, {
            key: "rootBone",
            get: function() {
                return this._cacheRootBone;
            },
            set: function(e) {
                this._cacheRootBone != e && (this._cacheRootBone ? this._cacheRootBone.transform.off(t.Event.TRANSFORM_CHANGED, this, this._onWorldMatNeedChange) : this._owner.transform.off(t.Event.TRANSFORM_CHANGED, this, this._onWorldMatNeedChange),
                e ? e.transform.on(t.Event.TRANSFORM_CHANGED, this, this._onWorldMatNeedChange) : this._owner.transform.on(t.Event.TRANSFORM_CHANGED, this, this._onWorldMatNeedChange),
                this._cacheRootBone = e,
                this._onWorldMatNeedChange(Ee.TRANSFORM_WORLDPOSITION | Ee.TRANSFORM_WORLDQUATERNION | Ee.TRANSFORM_WORLDSCALE));
            }
        }, {
            key: "bones",
            get: function() {
                return this._bones;
            }
        }, {
            key: "bounds",
            get: function() {
                return (this._boundsChange || this._cacheAvatar) && (this._calculateBoundingBox(),
                this._boundsChange = !1),
                this._bounds;
            }
        }]),
        SkinnedMeshRenderer;
    }();
    kr._tempMatrix4x4 = new I();
    var Vr = function(e) {
        function SkinnedMeshSprite3D() {
            var e, t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null, r = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null;
            return _classCallCheck(this, SkinnedMeshSprite3D),
            (e = _possibleConstructorReturn(this, _getPrototypeOf(SkinnedMeshSprite3D).call(this, r)))._meshFilter = new ct(_assertThisInitialized(e)),
            e._render = new kr(_assertThisInitialized(e)),
            t && (e._meshFilter.sharedMesh = t),
            e;
        }
        return _inherits(SkinnedMeshSprite3D, ge),
        _createClass(SkinnedMeshSprite3D, [{
            key: "_parse",
            value: function(e, r) {
                _get(_getPrototypeOf(SkinnedMeshSprite3D.prototype), "_parse", this).call(this, e, r);
                var n = this.skinnedMeshRenderer
                  , a = e.lightmapIndex;
                null != a && (n.lightmapIndex = a);
                var s, l = e.lightmapScaleOffset;
                if (l && (n.lightmapScaleOffset = new i(l[0],l[1],l[2],l[3])),
                s = e.meshPath) {
                    var u = t.Loader.getRes(s);
                    u && (this.meshFilter.sharedMesh = u);
                }
                var c = e.materials;
                if (c) {
                    var h = n.sharedMaterials
                      , _ = c.length;
                    h.length = _;
                    for (var d = 0; d < _; d++)
                        h[d] = t.Loader.getRes(c[d].path);
                    n.sharedMaterials = h;
                }
                var f = e.boundBox
                  , m = f.min
                  , p = f.max;
                if (n.localBounds.setMin(new o(m[0],m[1],m[2])),
                n.localBounds.setMax(new o(p[0],p[1],p[2])),
                r) {
                    var v = e.rootBone;
                    n.rootBone = r[v];
                    var T, E = e.bones;
                    for (d = 0,
                    T = E.length; d < T; d++)
                        n.bones.push(r[E[d]]);
                } else
                    e.rootBone && n._setRootBone(e.rootBone);
            }
        }, {
            key: "_changeHierarchyAnimator",
            value: function(e) {
                _get(_getPrototypeOf(SkinnedMeshSprite3D.prototype), "_changeHierarchyAnimator", this).call(this, e),
                this.skinnedMeshRenderer._setCacheAnimator(e);
            }
        }, {
            key: "_changeAnimatorAvatar",
            value: function(e) {
                this.skinnedMeshRenderer._setCacheAvatar(e);
            }
        }, {
            key: "_cloneTo",
            value: function(e, t, r) {
                var n = e;
                n.meshFilter.sharedMesh = this.meshFilter.sharedMesh;
                var i = this._render
                  , a = n._render;
                a.enable = i.enable,
                a.sharedMaterials = i.sharedMaterials,
                a.castShadow = i.castShadow;
                var o = i.lightmapScaleOffset;
                o && (a.lightmapScaleOffset = o.clone()),
                a.receiveShadow = i.receiveShadow,
                a.sortingFudge = i.sortingFudge,
                a._rootBone = i._rootBone;
                var s = i.bones
                  , l = a.bones
                  , u = s.length;
                l.length = u;
                var c = i.rootBone;
                if (c) {
                    var h = R._getHierarchyPath(t, c, SkinnedMeshSprite3D._tempArray0);
                    a.rootBone = h ? R._getNodeByHierarchyPath(r, h) : c;
                }
                for (var _ = 0; _ < s.length; _++)
                    h = R._getHierarchyPath(t, s[_], SkinnedMeshSprite3D._tempArray0),
                    l[_] = h ? R._getNodeByHierarchyPath(r, h) : s[_];
                var d = i.localBounds;
                d && d.cloneTo(a.localBounds),
                _get(_getPrototypeOf(SkinnedMeshSprite3D.prototype), "_cloneTo", this).call(this, e, t, r);
            }
        }, {
            key: "destroy",
            value: function() {
                var e = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0];
                this.destroyed || (_get(_getPrototypeOf(SkinnedMeshSprite3D.prototype), "destroy", this).call(this, e),
                this._meshFilter.destroy());
            }
        }, {
            key: "_create",
            value: function() {
                return new SkinnedMeshSprite3D();
            }
        }, {
            key: "meshFilter",
            get: function() {
                return this._meshFilter;
            }
        }, {
            key: "skinnedMeshRenderer",
            get: function() {
                return this._render;
            }
        }], [{
            key: "__init__",
            value: function() {
                br.SHADERDEFINE_BONE = G.getDefineByName("BONE");
            }
        }]),
        SkinnedMeshSprite3D;
    }();
    Vr._tempArray0 = [],
    Vr.BONES = G.propertyNameToID("u_Bones");
    var Br = function(e) {
        function TrailMaterial() {
            var e;
            return _classCallCheck(this, TrailMaterial),
            (e = _possibleConstructorReturn(this, _getPrototypeOf(TrailMaterial).call(this))).setShaderName("Trail"),
            e._color = new i(1,1,1,1),
            e._shaderValues.setVector(TrailMaterial.TINTCOLOR, new i(1,1,1,1)),
            e.renderMode = TrailMaterial.RENDERMODE_ALPHABLENDED,
            e;
        }
        return _inherits(TrailMaterial, Z),
        _createClass(TrailMaterial, [{
            key: "clone",
            value: function() {
                var e = new TrailMaterial();
                return this.cloneTo(e),
                e;
            }
        }, {
            key: "_TintColorR",
            get: function() {
                return this._color.x;
            },
            set: function(e) {
                this._color.x = e,
                this.color = this._color;
            }
        }, {
            key: "_TintColorG",
            get: function() {
                return this._color.y;
            },
            set: function(e) {
                this._color.y = e,
                this.color = this._color;
            }
        }, {
            key: "_TintColorB",
            get: function() {
                return this._color.z;
            },
            set: function(e) {
                this._color.z = e,
                this.color = this._color;
            }
        }, {
            key: "_TintColorA",
            get: function() {
                return this._color.w;
            },
            set: function(e) {
                this._color.w = e,
                this.color = this._color;
            }
        }, {
            key: "_MainTex_STX",
            get: function() {
                return this._shaderValues.getVector(TrailMaterial.TILINGOFFSET).x;
            },
            set: function(e) {
                var t = this._shaderValues.getVector(TrailMaterial.TILINGOFFSET);
                t.x = e,
                this.tilingOffset = t;
            }
        }, {
            key: "_MainTex_STY",
            get: function() {
                return this._shaderValues.getVector(TrailMaterial.TILINGOFFSET).y;
            },
            set: function(e) {
                var t = this._shaderValues.getVector(TrailMaterial.TILINGOFFSET);
                t.y = e,
                this.tilingOffset = t;
            }
        }, {
            key: "_MainTex_STZ",
            get: function() {
                return this._shaderValues.getVector(TrailMaterial.TILINGOFFSET).z;
            },
            set: function(e) {
                var t = this._shaderValues.getVector(TrailMaterial.TILINGOFFSET);
                t.z = e,
                this.tilingOffset = t;
            }
        }, {
            key: "_MainTex_STW",
            get: function() {
                return this._shaderValues.getVector(TrailMaterial.TILINGOFFSET).w;
            },
            set: function(e) {
                var t = this._shaderValues.getVector(TrailMaterial.TILINGOFFSET);
                t.w = e,
                this.tilingOffset = t;
            }
        }, {
            key: "renderMode",
            set: function(e) {
                switch (e) {
                case TrailMaterial.RENDERMODE_ADDTIVE:
                    this.renderQueue = Z.RENDERQUEUE_TRANSPARENT,
                    this.alphaTest = !1,
                    this.depthWrite = !1,
                    this.cull = Q.CULL_NONE,
                    this.blend = Q.BLEND_ENABLE_ALL,
                    this.blendSrc = Q.BLENDPARAM_SRC_ALPHA,
                    this.blendDst = Q.BLENDPARAM_ONE,
                    this.depthTest = Q.DEPTHTEST_LESS,
                    this._shaderValues.addDefine(TrailMaterial.SHADERDEFINE_ADDTIVEFOG);
                    break;
                case TrailMaterial.RENDERMODE_ALPHABLENDED:
                    this.renderQueue = Z.RENDERQUEUE_TRANSPARENT,
                    this.alphaTest = !1,
                    this.depthWrite = !1,
                    this.cull = Q.CULL_NONE,
                    this.blend = Q.BLEND_ENABLE_ALL,
                    this.blendSrc = Q.BLENDPARAM_SRC_ALPHA,
                    this.blendDst = Q.BLENDPARAM_ONE_MINUS_SRC_ALPHA,
                    this.depthTest = Q.DEPTHTEST_LESS,
                    this._shaderValues.removeDefine(TrailMaterial.SHADERDEFINE_ADDTIVEFOG);
                    break;
                default:
                    throw new Error("TrailMaterial : renderMode value error.");
                }
            }
        }, {
            key: "colorR",
            get: function() {
                return this._TintColorR;
            },
            set: function(e) {
                this._TintColorR = e;
            }
        }, {
            key: "colorG",
            get: function() {
                return this._TintColorG;
            },
            set: function(e) {
                this._TintColorG = e;
            }
        }, {
            key: "colorB",
            get: function() {
                return this._TintColorB;
            },
            set: function(e) {
                this._TintColorB = e;
            }
        }, {
            key: "colorA",
            get: function() {
                return this._TintColorA;
            },
            set: function(e) {
                this._TintColorA = e;
            }
        }, {
            key: "color",
            get: function() {
                return this._shaderValues.getVector(TrailMaterial.TINTCOLOR);
            },
            set: function(e) {
                this._shaderValues.setVector(TrailMaterial.TINTCOLOR, e);
            }
        }, {
            key: "texture",
            get: function() {
                return this._shaderValues.getTexture(TrailMaterial.MAINTEXTURE);
            },
            set: function(e) {
                e ? this._shaderValues.addDefine(TrailMaterial.SHADERDEFINE_MAINTEXTURE) : this._shaderValues.removeDefine(TrailMaterial.SHADERDEFINE_MAINTEXTURE),
                this._shaderValues.setTexture(TrailMaterial.MAINTEXTURE, e);
            }
        }, {
            key: "tilingOffsetX",
            get: function() {
                return this._MainTex_STX;
            },
            set: function(e) {
                this._MainTex_STX = e;
            }
        }, {
            key: "tilingOffsetY",
            get: function() {
                return this._MainTex_STY;
            },
            set: function(e) {
                this._MainTex_STY = e;
            }
        }, {
            key: "tilingOffsetZ",
            get: function() {
                return this._MainTex_STZ;
            },
            set: function(e) {
                this._MainTex_STZ = e;
            }
        }, {
            key: "tilingOffsetW",
            get: function() {
                return this._MainTex_STW;
            },
            set: function(e) {
                this._MainTex_STW = e;
            }
        }, {
            key: "tilingOffset",
            get: function() {
                return this._shaderValues.getVector(TrailMaterial.TILINGOFFSET);
            },
            set: function(e) {
                e && (1 != e.x || 1 != e.y || 0 != e.z || 0 != e.w) ? this._shaderValues.addDefine(TrailMaterial.SHADERDEFINE_TILINGOFFSET) : this._shaderValues.removeDefine(TrailMaterial.SHADERDEFINE_TILINGOFFSET),
                this._shaderValues.setVector(TrailMaterial.TILINGOFFSET, e);
            }
        }, {
            key: "depthWrite",
            set: function(e) {
                this._shaderValues.setBool(TrailMaterial.DEPTH_WRITE, e);
            },
            get: function() {
                return this._shaderValues.getBool(TrailMaterial.DEPTH_WRITE);
            }
        }, {
            key: "cull",
            set: function(e) {
                this._shaderValues.setInt(TrailMaterial.CULL, e);
            },
            get: function() {
                return this._shaderValues.getInt(TrailMaterial.CULL);
            }
        }, {
            key: "blend",
            set: function(e) {
                this._shaderValues.setInt(TrailMaterial.BLEND, e);
            },
            get: function() {
                return this._shaderValues.getInt(TrailMaterial.BLEND);
            }
        }, {
            key: "blendSrc",
            set: function(e) {
                this._shaderValues.setInt(TrailMaterial.BLEND_SRC, e);
            },
            get: function() {
                return this._shaderValues.getInt(TrailMaterial.BLEND_SRC);
            }
        }, {
            key: "blendDst",
            set: function(e) {
                this._shaderValues.setInt(TrailMaterial.BLEND_DST, e);
            },
            get: function() {
                return this._shaderValues.getInt(TrailMaterial.BLEND_DST);
            }
        }, {
            key: "depthTest",
            set: function(e) {
                this._shaderValues.setInt(TrailMaterial.DEPTH_TEST, e);
            },
            get: function() {
                return this._shaderValues.getInt(TrailMaterial.DEPTH_TEST);
            }
        }], [{
            key: "__initDefine__",
            value: function() {
                TrailMaterial.SHADERDEFINE_MAINTEXTURE = G.getDefineByName("MAINTEXTURE"),
                TrailMaterial.SHADERDEFINE_TILINGOFFSET = G.getDefineByName("TILINGOFFSET"),
                TrailMaterial.SHADERDEFINE_ADDTIVEFOG = G.getDefineByName("ADDTIVEFOG");
            }
        }]),
        TrailMaterial;
    }();
    Br.RENDERMODE_ALPHABLENDED = 0,
    Br.RENDERMODE_ADDTIVE = 1,
    Br.MAINTEXTURE = G.propertyNameToID("u_MainTexture"),
    Br.TINTCOLOR = G.propertyNameToID("u_MainColor"),
    Br.TILINGOFFSET = G.propertyNameToID("u_TilingOffset"),
    Br.CULL = G.propertyNameToID("s_Cull"),
    Br.BLEND = G.propertyNameToID("s_Blend"),
    Br.BLEND_SRC = G.propertyNameToID("s_BlendSrc"),
    Br.BLEND_DST = G.propertyNameToID("s_BlendDst"),
    Br.DEPTH_TEST = G.propertyNameToID("s_DepthTest"),
    Br.DEPTH_WRITE = G.propertyNameToID("s_DepthWrite");
    var wr, Fr = function TextureMode() {
        _classCallCheck(this, TextureMode);
    };
    Fr.Stretch = 0,
    Fr.Tile = 1,
    (wr = e.TrailAlignment || (e.TrailAlignment = {}))[wr.View = 0] = "View",
    wr[wr.TransformZ = 1] = "TransformZ";
    var Ur = function() {
        function VertexTrail() {
            _classCallCheck(this, VertexTrail);
        }
        return _createClass(VertexTrail, [{
            key: "vertexDeclaration",
            get: function() {
                return VertexTrail._vertexDeclaration1;
            }
        }], [{
            key: "__init__",
            value: function() {
                VertexTrail._vertexDeclaration1 = new oe(32,[new le(0,ae.Vector3,VertexTrail.TRAIL_POSITION0), new le(12,ae.Vector3,VertexTrail.TRAIL_OFFSETVECTOR), new le(24,ae.Single,VertexTrail.TRAIL_TIME0), new le(28,ae.Single,VertexTrail.TRAIL_TEXTURECOORDINATE0Y)]),
                VertexTrail._vertexDeclaration2 = new oe(20,[new le(0,ae.Single,VertexTrail.TRAIL_TEXTURECOORDINATE0X), new le(4,ae.Color,VertexTrail.TRAIL_COLOR)]);
            }
        }, {
            key: "vertexDeclaration1",
            get: function() {
                return VertexTrail._vertexDeclaration1;
            }
        }, {
            key: "vertexDeclaration2",
            get: function() {
                return VertexTrail._vertexDeclaration2;
            }
        }]),
        VertexTrail;
    }();
    Ur.TRAIL_POSITION0 = 0,
    Ur.TRAIL_OFFSETVECTOR = 1,
    Ur.TRAIL_TIME0 = 2,
    Ur.TRAIL_TEXTURECOORDINATE0Y = 3,
    Ur.TRAIL_TEXTURECOORDINATE0X = 4,
    Ur.TRAIL_COLOR = 5;
    var Gr = function(n) {
        function TrailGeometry(e) {
            var r;
            _classCallCheck(this, TrailGeometry),
            (r = _possibleConstructorReturn(this, _getPrototypeOf(TrailGeometry).call(this)))._floatCountPerVertices1 = 8,
            r._floatCountPerVertices2 = 5,
            r._increaseSegementCount = 16,
            r._activeIndex = 0,
            r._endIndex = 0,
            r._needAddFirstVertex = !1,
            r._isTempEndVertex = !1,
            r._vertices1 = null,
            r._vertices2 = null,
            r._lastFixedVertexPosition = new o(),
            r._bufferState = new we(),
            r.tmpColor = new ve(),
            r._disappearBoundsMode = !1,
            r._owner = e,
            r._segementCount = r._increaseSegementCount,
            r._resizeData(r._segementCount, r._bufferState);
            var n = r._owner._owner.trailRenderer.bounds
              , i = r._owner._owner.transform.position;
            return n.setMin(i),
            n.setMax(i),
            t.Render.supportWebGLPlusCulling && r._calculateBoundingBoxForNative(),
            r;
        }
        return _inherits(TrailGeometry, Me),
        _createClass(TrailGeometry, [{
            key: "_resizeData",
            value: function(e, r) {
                this._subBirthTime = new Float32Array(e),
                this._subDistance = new Float64Array(e);
                var n = t.LayaGL.instance
                  , i = 2 * e
                  , a = Ur.vertexDeclaration1
                  , o = Ur.vertexDeclaration2
                  , s = []
                  , l = i * a.vertexStride
                  , u = i * o.vertexStride
                  , c = l + u;
                this._vertices1 = new Float32Array(i * this._floatCountPerVertices1),
                this._vertices2 = new Float32Array(i * this._floatCountPerVertices2),
                this._vertexBuffer1 = new De(l,n.STATIC_DRAW,!1),
                this._vertexBuffer1.vertexDeclaration = a,
                this._vertexBuffer2 = new De(u,n.DYNAMIC_DRAW,!1),
                this._vertexBuffer2.vertexDeclaration = o,
                s.push(this._vertexBuffer1),
                s.push(this._vertexBuffer2),
                r.bind(),
                r.applyVertexBuffers(s),
                r.unBind(),
                t.Resource._addMemory(c, c);
            }
        }, {
            key: "_resetData",
            value: function() {
                var e = this._endIndex - this._activeIndex
                  , r = new Float32Array(this._vertices1.buffer,2 * this._floatCountPerVertices1 * this._activeIndex * 4,2 * this._floatCountPerVertices1 * e)
                  , n = new Float32Array(this._vertices2.buffer,2 * this._floatCountPerVertices2 * this._activeIndex * 4,2 * this._floatCountPerVertices2 * e)
                  , i = new Float64Array(this._subDistance.buffer,8 * this._activeIndex,e)
                  , a = new Float32Array(this._subBirthTime.buffer,4 * this._activeIndex,e);
                if (e === this._segementCount) {
                    this._vertexBuffer1.destroy(),
                    this._vertexBuffer2.destroy();
                    var o = this._vertexBuffer1._byteLength + this._vertexBuffer2._byteLength;
                    t.Resource._addMemory(-o, -o),
                    this._segementCount += this._increaseSegementCount,
                    this._resizeData(this._segementCount, this._bufferState);
                }
                this._vertices1.set(r, 0),
                this._vertices2.set(n, 0),
                this._subDistance.set(i, 0),
                this._subBirthTime.set(a, 0),
                this._endIndex = e,
                this._activeIndex = 0,
                this._vertexBuffer1.setData(this._vertices1.buffer, 0, 2 * this._floatCountPerVertices1 * this._activeIndex * 4, 2 * this._floatCountPerVertices1 * e * 4),
                this._vertexBuffer2.setData(this._vertices2.buffer, 0, 2 * this._floatCountPerVertices2 * this._activeIndex * 4, 2 * this._floatCountPerVertices2 * e * 4);
            }
        }, {
            key: "_updateTrail",
            value: function(e, t, r) {
                o.equals(t, r) || (this._endIndex - this._activeIndex == 0 ? this._addTrailByFirstPosition(e, r) : this._addTrailByNextPosition(e, r));
            }
        }, {
            key: "_addTrailByFirstPosition",
            value: function(e, t) {
                this._endIndex === this._segementCount && this._resetData(),
                this._subDistance[this._endIndex] = 0,
                this._subBirthTime[this._endIndex] = this._owner._curtime,
                this._endIndex++,
                t.cloneTo(this._lastFixedVertexPosition),
                this._needAddFirstVertex = !0;
            }
        }, {
            key: "_addTrailByNextPosition",
            value: function(t, n) {
                var i = TrailGeometry._tempVector30
                  , a = TrailGeometry._tempVector31;
                switch (this._owner.alignment) {
                case e.TrailAlignment.View:
                    var s = t.viewMatrix;
                    o.transformCoordinate(n, s, TrailGeometry._tempVector33),
                    o.transformCoordinate(this._lastFixedVertexPosition, s, TrailGeometry._tempVector34),
                    o.subtract(TrailGeometry._tempVector33, TrailGeometry._tempVector34, i),
                    o.cross(TrailGeometry._tempVector33, i, a);
                    break;
                case e.TrailAlignment.TransformZ:
                    o.subtract(n, this._lastFixedVertexPosition, i);
                    var l = TrailGeometry._tempVector32;
                    this._owner._owner.transform.localMatrix.getForward(l),
                    o.cross(i, l, a);
                }
                o.normalize(a, a),
                o.scale(a, this._owner.widthMultiplier / 2, a);
                var u, c, h = o.scalarLength(i);
                this._needAddFirstVertex && (this._updateVerticesByPositionData(n, a, this._endIndex - 1),
                this._needAddFirstVertex = !1),
                h - this._owner.minVertexDistance >= r.zeroTolerance ? (this._isTempEndVertex ? (u = this._endIndex - 1,
                c = h - this._subDistance[u],
                this._updateVerticesByPosition(n, a, h, u),
                this._owner._totalLength += c) : (this._endIndex === this._segementCount && this._resetData(),
                this._updateVerticesByPosition(n, a, h, this._endIndex),
                this._owner._totalLength += h,
                this._endIndex++),
                n.cloneTo(this._lastFixedVertexPosition),
                this._isTempEndVertex = !1) : (this._isTempEndVertex ? (u = this._endIndex - 1,
                c = h - this._subDistance[u],
                this._updateVerticesByPosition(n, a, h, u),
                this._owner._totalLength += c) : (this._endIndex === this._segementCount && this._resetData(),
                this._updateVerticesByPosition(n, a, h, this._endIndex),
                this._owner._totalLength += h,
                this._endIndex++),
                this._isTempEndVertex = !0);
            }
        }, {
            key: "_updateVerticesByPositionData",
            value: function(e, r, n) {
                var i = 2 * this._floatCountPerVertices1 * n
                  , a = this._owner._curtime;
                this._vertices1[i] = e.x,
                this._vertices1[i + 1] = e.y,
                this._vertices1[i + 2] = e.z,
                this._vertices1[i + 3] = -r.x,
                this._vertices1[i + 4] = -r.y,
                this._vertices1[i + 5] = -r.z,
                this._vertices1[i + 6] = a,
                this._vertices1[i + 7] = 1,
                this._vertices1[i + 8] = e.x,
                this._vertices1[i + 9] = e.y,
                this._vertices1[i + 10] = e.z,
                this._vertices1[i + 11] = r.x,
                this._vertices1[i + 12] = r.y,
                this._vertices1[i + 13] = r.z,
                this._vertices1[i + 14] = a,
                this._vertices1[i + 15] = 0;
                var s = this._owner._owner.trailRenderer.bounds
                  , l = s.getMin()
                  , u = s.getMax()
                  , c = TrailGeometry._tempVector35
                  , h = TrailGeometry._tempVector36
                  , _ = TrailGeometry._tempVector32;
                o.add(e, r, c),
                o.subtract(e, r, h),
                o.min(h, c, _),
                o.min(l, _, l),
                s.setMin(l),
                o.max(c, h, _),
                o.max(u, _, u),
                s.setMax(u),
                t.Render.supportWebGLPlusCulling && this._calculateBoundingBoxForNative();
                var d = 2 * this._floatCountPerVertices1;
                this._vertexBuffer1.setData(this._vertices1.buffer, 4 * i, 4 * i, 4 * d);
            }
        }, {
            key: "_updateVerticesByPosition",
            value: function(e, t, r, n) {
                this._updateVerticesByPositionData(e, t, n),
                this._subDistance[n] = r,
                this._subBirthTime[n] = this._owner._curtime;
            }
        }, {
            key: "_updateVertexBufferUV",
            value: function() {
                var e, r, n;
                if (this._disappearBoundsMode) {
                    e = this._owner._owner.trailRenderer.bounds;
                    var i = this._owner._owner.transform.position;
                    e.setMin(i),
                    e.setMax(i),
                    r = e.getMin(),
                    n = e.getMax(),
                    t.Render.supportWebGLPlusCulling && this._calculateBoundingBoxForNative();
                }
                for (var a = this._endIndex, s = 0, l = this._owner.colorGradient, u = l.colorAlphaKeysCount - 1, c = l.colorRGBKeysCount - 1, h = this._owner._totalLength, _ = 2 * this._floatCountPerVertices2, d = this._activeIndex; d < a; d++) {
                    var f, m;
                    d !== this._activeIndex && (s += this._subDistance[d]),
                    this._owner.textureMode == Fr.Stretch ? m = f = 1 - s / h : (m = 1 - s / h,
                    f = 1 - (h - s)),
                    c = l.evaluateColorRGB(m, this.tmpColor, c, !0),
                    u = l.evaluateColorAlpha(m, this.tmpColor, u, !0);
                    var p = d * _;
                    if (this._vertices2[p + 0] = f,
                    this._vertices2[p + 1] = this.tmpColor.r,
                    this._vertices2[p + 2] = this.tmpColor.g,
                    this._vertices2[p + 3] = this.tmpColor.b,
                    this._vertices2[p + 4] = this.tmpColor.a,
                    this._vertices2[p + 5] = f,
                    this._vertices2[p + 6] = this.tmpColor.r,
                    this._vertices2[p + 7] = this.tmpColor.g,
                    this._vertices2[p + 8] = this.tmpColor.b,
                    this._vertices2[p + 9] = this.tmpColor.a,
                    this._disappearBoundsMode) {
                        var v = 2 * this._floatCountPerVertices1 * d
                          , T = TrailGeometry._tempVector32
                          , E = TrailGeometry._tempVector33
                          , y = TrailGeometry._tempVector34;
                        T.setValue(this._vertices1[v + 0], this._vertices1[v + 1], this._vertices1[v + 2]),
                        E.setValue(this._vertices1[v + 3], this._vertices1[v + 4], this._vertices1[v + 5]),
                        o.add(T, E, y),
                        o.min(y, r, r),
                        o.max(y, n, n),
                        o.subtract(T, E, y),
                        o.min(y, r, r),
                        o.max(y, n, n);
                    }
                }
                this._disappearBoundsMode && (e.setMin(r),
                e.setMax(n),
                this._disappearBoundsMode = !1,
                t.Render.supportWebGLPlusCulling && this._calculateBoundingBoxForNative());
                var g = this._activeIndex * _;
                this._vertexBuffer2.setData(this._vertices2.buffer, 4 * g, 4 * g, 4 * (a * _ - g));
            }
        }, {
            key: "_updateDisappear",
            value: function() {
                for (var e = this._endIndex, t = this._activeIndex; t < e && this._owner._curtime - this._subBirthTime[t] >= this._owner.time + r.zeroTolerance; t++) {
                    var n = t + 1;
                    if (n !== e && (this._owner._totalLength -= this._subDistance[n]),
                    this._isTempEndVertex && n === e - 1) {
                        this._floatCountPerVertices1;
                        var i = this._lastFixedVertexPosition;
                        i.x = this._vertices1[0],
                        i.y = this._vertices1[1],
                        i.z = this._vertices1[2],
                        this._isTempEndVertex = !1;
                    }
                    this._activeIndex++,
                    this._disappearBoundsMode = !0;
                }
            }
        }, {
            key: "_getType",
            value: function() {
                return TrailGeometry._type;
            }
        }, {
            key: "_prepareRender",
            value: function(e) {
                return this._endIndex - this._activeIndex > 1;
            }
        }, {
            key: "_render",
            value: function(e) {
                this._bufferState.bind();
                var r = t.LayaGL.instance
                  , n = 2 * this._activeIndex
                  , i = 2 * this._endIndex - n;
                r.drawArrays(r.TRIANGLE_STRIP, n, i),
                t.Stat.renderBatches++,
                t.Stat.trianglesFaces += i - 2;
            }
        }, {
            key: "destroy",
            value: function() {
                _get(_getPrototypeOf(TrailGeometry.prototype), "destroy", this).call(this);
                var e = this._vertexBuffer1._byteLength + this._vertexBuffer2._byteLength;
                t.Resource._addMemory(-e, -e),
                this._bufferState.destroy(),
                this._vertexBuffer1.destroy(),
                this._vertexBuffer2.destroy(),
                this._bufferState = null,
                this._vertices1 = null,
                this._vertexBuffer1 = null,
                this._vertices2 = null,
                this._vertexBuffer2 = null,
                this._subBirthTime = null,
                this._subDistance = null,
                this._lastFixedVertexPosition = null,
                this._disappearBoundsMode = !1;
            }
        }, {
            key: "_calculateBoundingBoxForNative",
            value: function() {
                var e = this._owner._owner.trailRenderer
                  , t = e.bounds
                  , r = t.getMin()
                  , n = t.getMax()
                  , i = Re._cullingBuffer;
                i[e._cullingBufferIndex + 1] = r.x,
                i[e._cullingBufferIndex + 2] = r.y,
                i[e._cullingBufferIndex + 3] = r.z,
                i[e._cullingBufferIndex + 4] = n.x,
                i[e._cullingBufferIndex + 5] = n.y,
                i[e._cullingBufferIndex + 6] = n.z;
            }
        }]),
        TrailGeometry;
    }();
    Gr.ALIGNMENT_VIEW = 0,
    Gr.ALIGNMENT_TRANSFORM_Z = 1,
    Gr._tempVector30 = new o(),
    Gr._tempVector31 = new o(),
    Gr._tempVector32 = new o(),
    Gr._tempVector33 = new o(),
    Gr._tempVector34 = new o(),
    Gr._tempVector35 = new o(),
    Gr._tempVector36 = new o(),
    Gr._type = Me._typeCounter++;
    var zr = function() {
        function TrailFilter(e) {
            _classCallCheck(this, TrailFilter),
            this._totalLength = 0,
            this._lastPosition = new o(),
            this._curtime = 0,
            this.alignment = TrailFilter.ALIGNMENT_VIEW,
            this._owner = e,
            this._initDefaultData(),
            this.addRenderElement();
        }
        return _createClass(TrailFilter, [{
            key: "addRenderElement",
            value: function() {
                var e = this._owner._render
                  , t = e._renderElements
                  , r = e.sharedMaterials[0];
                r || (r = Br.defaultMaterial);
                var n = new et();
                n.setTransform(this._owner._transform),
                n.render = e,
                n.material = r,
                this._trialGeometry = new Gr(this),
                n.setGeometry(this._trialGeometry),
                t.push(n);
            }
        }, {
            key: "_update",
            value: function(e) {
                var t = this._owner._render;
                this._curtime += e.scene.timer._delta / 1e3,
                t._shaderValues.setNumber(TrailFilter.CURTIME, this._curtime);
                var r = this._owner.transform.position
                  , n = t._renderElements[0]._geometry;
                n._updateDisappear(),
                n._updateTrail(e.camera, this._lastPosition, r),
                n._updateVertexBufferUV(),
                r.cloneTo(this._lastPosition);
            }
        }, {
            key: "_initDefaultData",
            value: function() {
                this.time = 5,
                this.minVertexDistance = .1,
                this.widthMultiplier = 1,
                this.textureMode = Fr.Stretch;
                var e = []
                  , t = new _();
                t.time = 0,
                t.inTangent = 0,
                t.outTangent = 0,
                t.value = 1,
                e.push(t);
                var r = new _();
                r.time = 1,
                r.inTangent = 0,
                r.outTangent = 0,
                r.value = 1,
                e.push(r),
                this.widthCurve = e;
                var n = new mt(2,2);
                n.mode = ft.Blend,
                n.addColorRGB(0, ve.WHITE),
                n.addColorRGB(1, ve.WHITE),
                n.addColorAlpha(0, 1),
                n.addColorAlpha(1, 1),
                this.colorGradient = n;
            }
        }, {
            key: "destroy",
            value: function() {
                this._trialGeometry.destroy(),
                this._trialGeometry = null,
                this._widthCurve = null,
                this._colorGradient = null;
            }
        }, {
            key: "time",
            get: function() {
                return this._time;
            },
            set: function(e) {
                this._time = e,
                this._owner._render._shaderValues.setNumber(TrailFilter.LIFETIME, e);
            }
        }, {
            key: "minVertexDistance",
            get: function() {
                return this._minVertexDistance;
            },
            set: function(e) {
                this._minVertexDistance = e;
            }
        }, {
            key: "widthMultiplier",
            get: function() {
                return this._widthMultiplier;
            },
            set: function(e) {
                this._widthMultiplier = e;
            }
        }, {
            key: "widthCurve",
            get: function() {
                return this._widthCurve;
            },
            set: function(e) {
                this._widthCurve = e;
                var t, r, n = new Float32Array(4 * e.length), i = 0;
                for (t = 0,
                r = e.length; t < r; t++)
                    n[i++] = e[t].time,
                    n[i++] = e[t].inTangent,
                    n[i++] = e[t].outTangent,
                    n[i++] = e[t].value;
                this._owner._render._shaderValues.setBuffer(TrailFilter.WIDTHCURVE, n),
                this._owner._render._shaderValues.setInt(TrailFilter.WIDTHCURVEKEYLENGTH, e.length);
            }
        }, {
            key: "colorGradient",
            get: function() {
                return this._colorGradient;
            },
            set: function(e) {
                this._colorGradient = e;
            }
        }, {
            key: "textureMode",
            get: function() {
                return this._textureMode;
            },
            set: function(e) {
                this._textureMode = e;
            }
        }]),
        TrailFilter;
    }();
    zr.CURTIME = G.propertyNameToID("u_CurTime"),
    zr.LIFETIME = G.propertyNameToID("u_LifeTime"),
    zr.WIDTHCURVE = G.propertyNameToID("u_WidthCurve"),
    zr.WIDTHCURVEKEYLENGTH = G.propertyNameToID("u_WidthCurveKeyLength"),
    zr.ALIGNMENT_VIEW = 0,
    zr.ALIGNMENT_TRANSFORM_Z = 1;
    var Hr = function(e) {
        function TrailRenderer(e) {
            var t;
            return _classCallCheck(this, TrailRenderer),
            (t = _possibleConstructorReturn(this, _getPrototypeOf(TrailRenderer).call(this, e)))._projectionViewWorldMatrix = new I(),
            t;
        }
        return _inherits(TrailRenderer, lt),
        _createClass(TrailRenderer, [{
            key: "_calculateBoundingBox",
            value: function() {}
        }, {
            key: "_needRender",
            value: function(e, t) {
                return this._owner.trailFilter._update(t),
                !e || e.intersects(this.bounds._getBoundBox());
            }
        }, {
            key: "_updateForNative",
            value: function(e) {
                this._owner.trailFilter._update(e);
            }
        }, {
            key: "_renderUpdate",
            value: function(e, t) {
                _get(_getPrototypeOf(TrailRenderer.prototype), "_renderUpdate", this).call(this, e, t);
            }
        }, {
            key: "_renderUpdateWithCamera",
            value: function(e, t) {
                var r = e.projectionViewMatrix;
                t ? (I.multiply(r, t.worldMatrix, this._projectionViewWorldMatrix),
                this._shaderValues.setMatrix4x4(ye.MVPMATRIX, this._projectionViewWorldMatrix)) : this._shaderValues.setMatrix4x4(ye.MVPMATRIX, r);
            }
        }]),
        TrailRenderer;
    }()
      , Wr = function(e) {
        function TrailSprite3D() {
            var e, t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null;
            return _classCallCheck(this, TrailSprite3D),
            (e = _possibleConstructorReturn(this, _getPrototypeOf(TrailSprite3D).call(this, t)))._render = new Hr(_assertThisInitialized(e)),
            e._geometryFilter = new zr(_assertThisInitialized(e)),
            e;
        }
        return _inherits(TrailSprite3D, ge),
        _createClass(TrailSprite3D, [{
            key: "trailFilter",
            get: function() {
                return this._geometryFilter;
            }
        }, {
            key: "trailRenderer",
            get: function() {
                return this._render;
            }
        }], [{
            key: "__init__",
            value: function() {}
        }]),
        _createClass(TrailSprite3D, [{
            key: "_parse",
            value: function(e, r) {
                _get(_getPrototypeOf(TrailSprite3D.prototype), "_parse", this).call(this, e, r);
                var n, i, a = this._render, o = this._geometryFilter, s = e.materials;
                if (s) {
                    var l = a.sharedMaterials
                      , u = s.length;
                    for (l.length = u,
                    n = 0; n < u; n++)
                        l[n] = t.Loader.getRes(s[n].path);
                    a.sharedMaterials = l;
                }
                o.time = e.time,
                o.minVertexDistance = e.minVertexDistance,
                o.widthMultiplier = e.widthMultiplier,
                o.textureMode = e.textureMode,
                null != e.alignment && (o.alignment = e.alignment);
                var c = []
                  , h = e.widthCurve;
                for (n = 0,
                i = h.length; n < i; n++) {
                    var d = new _();
                    d.time = h[n].time,
                    d.inTangent = h[n].inTangent,
                    d.outTangent = h[n].outTangent,
                    d.value = h[n].value,
                    c.push(d);
                }
                o.widthCurve = c;
                var f = e.colorGradient
                  , m = f.colorKeys
                  , p = f.alphaKeys
                  , v = new mt(m.length,p.length);
                for (v.mode = f.mode,
                n = 0,
                i = m.length; n < i; n++) {
                    var T = m[n];
                    v.addColorRGB(T.time, new ve(T.value[0],T.value[1],T.value[2],1));
                }
                for (n = 0,
                i = p.length; n < i; n++) {
                    var E = p[n];
                    v.addColorAlpha(E.time, E.value);
                }
                o.colorGradient = v;
            }
        }, {
            key: "_onActive",
            value: function() {
                _get(_getPrototypeOf(TrailSprite3D.prototype), "_onActive", this).call(this),
                this._transform.position.cloneTo(this._geometryFilter._lastPosition);
            }
        }, {
            key: "_cloneTo",
            value: function(e, t, r) {
                var n, i;
                _get(_getPrototypeOf(TrailSprite3D.prototype), "_cloneTo", this).call(this, e, t, r);
                var a = e
                  , o = a.trailFilter;
                o.time = this.trailFilter.time,
                o.minVertexDistance = this.trailFilter.minVertexDistance,
                o.widthMultiplier = this.trailFilter.widthMultiplier,
                o.textureMode = this.trailFilter.textureMode,
                o.alignment = this.trailFilter.alignment;
                var s = this.trailFilter.widthCurve
                  , l = [];
                for (n = 0,
                i = s.length; n < i; n++) {
                    var u = new _();
                    s[n].cloneTo(u),
                    l.push(u);
                }
                o.widthCurve = l;
                var c = new mt(this.trailFilter.colorGradient.maxColorRGBKeysCount,this.trailFilter.colorGradient.maxColorAlphaKeysCount);
                this.trailFilter.colorGradient.cloneTo(c),
                o.colorGradient = c,
                a.trailRenderer.sharedMaterial = this.trailRenderer.sharedMaterial;
            }
        }, {
            key: "destroy",
            value: function() {
                var e = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0];
                this.destroyed || (_get(_getPrototypeOf(TrailSprite3D.prototype), "destroy", this).call(this, e),
                this._geometryFilter.destroy(),
                this._geometryFilter = null);
            }
        }, {
            key: "_create",
            value: function() {
                return new TrailSprite3D();
            }
        }]),
        TrailSprite3D;
    }()
      , Xr = function() {
        function VertexPositionTerrain(e, t, r, n) {
            _classCallCheck(this, VertexPositionTerrain),
            this._position = e,
            this._normal = t,
            this._textureCoord0 = r,
            this._textureCoord1 = n;
        }
        return _createClass(VertexPositionTerrain, [{
            key: "position",
            get: function() {
                return this._position;
            }
        }, {
            key: "normal",
            get: function() {
                return this._normal;
            }
        }, {
            key: "textureCoord0",
            get: function() {
                return this._textureCoord0;
            }
        }, {
            key: "textureCoord1",
            get: function() {
                return this._textureCoord1;
            }
        }, {
            key: "vertexDeclaration",
            get: function() {
                return VertexPositionTerrain._vertexDeclaration;
            }
        }], [{
            key: "__init__",
            value: function() {
                VertexPositionTerrain._vertexDeclaration = new oe(40,[new le(0,ae.Vector3,VertexPositionTerrain.TERRAIN_POSITION0), new le(12,ae.Vector3,VertexPositionTerrain.TERRAIN_NORMAL0), new le(24,ae.Vector2,VertexPositionTerrain.TERRAIN_TEXTURECOORDINATE0), new le(32,ae.Vector2,VertexPositionTerrain.TERRAIN_TEXTURECOORDINATE1)]);
            }
        }, {
            key: "vertexDeclaration",
            get: function() {
                return VertexPositionTerrain._vertexDeclaration;
            }
        }]),
        VertexPositionTerrain;
    }();
    Xr.TERRAIN_POSITION0 = 0,
    Xr.TERRAIN_NORMAL0 = 1,
    Xr.TERRAIN_TEXTURECOORDINATE0 = 2,
    Xr.TERRAIN_TEXTURECOORDINATE1 = 3;
    var Yr = function BulletInteractive() {
        _classCallCheck(this, BulletInteractive);
    };
    Yr._interactive = {
        getWorldTransform: function(e, t) {},
        setWorldTransform: function(e, t) {
            var r = mr._physicObjectsMap[e];
            r._simulation._updatedRigidbodies++,
            r._updateTransformComponent(t);
        }
    };
    var Zr = function(e) {
        function CharacterController() {
            var e, t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : .1, r = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null, n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : Ft.COLLISIONFILTERGROUP_DEFAULTFILTER, i = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : Ft.COLLISIONFILTERGROUP_ALLFILTER;
            return _classCallCheck(this, CharacterController),
            (e = _possibleConstructorReturn(this, _getPrototypeOf(CharacterController).call(this, n, i)))._upAxis = new o(0,1,0),
            e._maxSlope = 45,
            e._jumpSpeed = 10,
            e._fallSpeed = 55,
            e._gravity = new o(0,3 * -9.8,0),
            e._btKinematicCharacter = null,
            e._stepHeight = t,
            r && (e._upAxis = r),
            e;
        }
        return _inherits(CharacterController, mr),
        _createClass(CharacterController, [{
            key: "_constructCharacter",
            value: function() {
                var e = S._bullet;
                this._btKinematicCharacter && e.btKinematicCharacterController_destroy(this._btKinematicCharacter);
                var t = CharacterController._btTempVector30;
                e.btVector3_setValue(t, this._upAxis.x, this._upAxis.y, this._upAxis.z),
                this._btKinematicCharacter = e.btKinematicCharacterController_create(this._btColliderObject, this._colliderShape._btShape, this._stepHeight, t),
                this.fallSpeed = this._fallSpeed,
                this.maxSlope = this._maxSlope,
                this.jumpSpeed = this._jumpSpeed,
                this.gravity = this._gravity;
            }
        }, {
            key: "_onShapeChange",
            value: function(e) {
                _get(_getPrototypeOf(CharacterController.prototype), "_onShapeChange", this).call(this, e),
                this._constructCharacter();
            }
        }, {
            key: "_onAdded",
            value: function() {
                var e = S._bullet
                  , t = e.btPairCachingGhostObject_create();
                e.btCollisionObject_setUserIndex(t, this.id),
                e.btCollisionObject_setCollisionFlags(t, mr.COLLISIONFLAGS_CHARACTER_OBJECT),
                this._btColliderObject = t,
                this._colliderShape && this._constructCharacter(),
                _get(_getPrototypeOf(CharacterController.prototype), "_onAdded", this).call(this);
            }
        }, {
            key: "_addToSimulation",
            value: function() {
                this._simulation._characters.push(this),
                this._simulation._addCharacter(this, this._collisionGroup, this._canCollideWith);
            }
        }, {
            key: "_removeFromSimulation",
            value: function() {
                this._simulation._removeCharacter(this);
                var e = this._simulation._characters;
                e.splice(e.indexOf(this), 1);
            }
        }, {
            key: "_cloneTo",
            value: function(e) {
                _get(_getPrototypeOf(CharacterController.prototype), "_cloneTo", this).call(this, e);
                var t = e;
                t.stepHeight = this._stepHeight,
                t.upAxis = this._upAxis,
                t.maxSlope = this._maxSlope,
                t.jumpSpeed = this._jumpSpeed,
                t.fallSpeed = this._fallSpeed,
                t.gravity = this._gravity;
            }
        }, {
            key: "_onDestroy",
            value: function() {
                S._bullet.btKinematicCharacterController_destroy(this._btKinematicCharacter),
                _get(_getPrototypeOf(CharacterController.prototype), "_onDestroy", this).call(this),
                this._btKinematicCharacter = null;
            }
        }, {
            key: "move",
            value: function(e) {
                var t = CharacterController._btVector30
                  , r = S._bullet;
                r.btVector3_setValue(t, -e.x, e.y, e.z),
                r.btKinematicCharacterController_setWalkDirection(this._btKinematicCharacter, t);
            }
        }, {
            key: "jump",
            value: function() {
                var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null
                  , t = S._bullet
                  , r = CharacterController._btVector30;
                e ? (R._convertToBulletVec3(e, r, !0),
                t.btKinematicCharacterController_jump(this._btKinematicCharacter, r)) : (t.btVector3_setValue(r, 0, 0, 0),
                t.btKinematicCharacterController_jump(this._btKinematicCharacter, r));
            }
        }, {
            key: "fallSpeed",
            get: function() {
                return this._fallSpeed;
            },
            set: function(e) {
                this._fallSpeed = e,
                S._bullet.btKinematicCharacterController_setFallSpeed(this._btKinematicCharacter, e);
            }
        }, {
            key: "jumpSpeed",
            get: function() {
                return this._jumpSpeed;
            },
            set: function(e) {
                this._jumpSpeed = e,
                S._bullet.btKinematicCharacterController_setJumpSpeed(this._btKinematicCharacter, e);
            }
        }, {
            key: "gravity",
            get: function() {
                return this._gravity;
            },
            set: function(e) {
                this._gravity = e;
                var t = S._bullet
                  , r = CharacterController._btTempVector30;
                t.btVector3_setValue(r, -e.x, e.y, e.z),
                t.btKinematicCharacterController_setGravity(this._btKinematicCharacter, r);
            }
        }, {
            key: "maxSlope",
            get: function() {
                return this._maxSlope;
            },
            set: function(e) {
                this._maxSlope = e,
                S._bullet.btKinematicCharacterController_setMaxSlope(this._btKinematicCharacter, e / 180 * Math.PI);
            }
        }, {
            key: "isGrounded",
            get: function() {
                return S._bullet.btKinematicCharacterController_onGround(this._btKinematicCharacter);
            }
        }, {
            key: "stepHeight",
            get: function() {
                return this._stepHeight;
            },
            set: function(e) {
                this._stepHeight = e,
                S._bullet.btKinematicCharacterController_setStepHeight(this._btKinematicCharacter, e);
            }
        }, {
            key: "upAxis",
            get: function() {
                return this._upAxis;
            },
            set: function(e) {
                this._upAxis = e;
                var t = CharacterController._btTempVector30;
                R._convertToBulletVec3(e, t, !1),
                S._bullet.btKinematicCharacterController_setUp(this._btKinematicCharacter, t);
            }
        }], [{
            key: "__init__",
            value: function() {
                CharacterController._btTempVector30 = S._bullet.btVector3_create(0, 0, 0);
            }
        }]),
        CharacterController;
    }();
    Zr.UPAXIS_X = 0,
    Zr.UPAXIS_Y = 1,
    Zr.UPAXIS_Z = 2;
    var jr = function(e) {
        function PhysicsTriggerComponent(e, t) {
            var r;
            return _classCallCheck(this, PhysicsTriggerComponent),
            (r = _possibleConstructorReturn(this, _getPrototypeOf(PhysicsTriggerComponent).call(this, e, t)))._isTrigger = !1,
            r;
        }
        return _inherits(PhysicsTriggerComponent, mr),
        _createClass(PhysicsTriggerComponent, [{
            key: "_onAdded",
            value: function() {
                _get(_getPrototypeOf(PhysicsTriggerComponent.prototype), "_onAdded", this).call(this),
                this.isTrigger = this._isTrigger;
            }
        }, {
            key: "_cloneTo",
            value: function(e) {
                _get(_getPrototypeOf(PhysicsTriggerComponent.prototype), "_cloneTo", this).call(this, e),
                e.isTrigger = this._isTrigger;
            }
        }, {
            key: "isTrigger",
            get: function() {
                return this._isTrigger;
            },
            set: function(e) {
                this._isTrigger = e;
                var t = S._bullet;
                if (this._btColliderObject) {
                    var r = t.btCollisionObject_getCollisionFlags(this._btColliderObject);
                    e ? 0 == (r & mr.COLLISIONFLAGS_NO_CONTACT_RESPONSE) && t.btCollisionObject_setCollisionFlags(this._btColliderObject, r | mr.COLLISIONFLAGS_NO_CONTACT_RESPONSE) : 0 != (r & mr.COLLISIONFLAGS_NO_CONTACT_RESPONSE) && t.btCollisionObject_setCollisionFlags(this._btColliderObject, r ^ mr.COLLISIONFLAGS_NO_CONTACT_RESPONSE);
                }
            }
        }]),
        PhysicsTriggerComponent;
    }()
      , Qr = function(e) {
        function PhysicsCollider() {
            var e, t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Ft.COLLISIONFILTERGROUP_DEFAULTFILTER, r = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : Ft.COLLISIONFILTERGROUP_ALLFILTER;
            return _classCallCheck(this, PhysicsCollider),
            (e = _possibleConstructorReturn(this, _getPrototypeOf(PhysicsCollider).call(this, t, r)))._enableProcessCollisions = !1,
            e;
        }
        return _inherits(PhysicsCollider, jr),
        _createClass(PhysicsCollider, [{
            key: "_addToSimulation",
            value: function() {
                this._simulation._addPhysicsCollider(this, this._collisionGroup, this._canCollideWith);
            }
        }, {
            key: "_removeFromSimulation",
            value: function() {
                this._simulation._removePhysicsCollider(this);
            }
        }, {
            key: "_onTransformChanged",
            value: function(e) {
                (e &= Ee.TRANSFORM_WORLDPOSITION | Ee.TRANSFORM_WORLDQUATERNION | Ee.TRANSFORM_WORLDSCALE) && (this._transformFlag |= e,
                this._isValid() && -1 === this._inPhysicUpdateListIndex && this._simulation._physicsUpdateList.add(this));
            }
        }, {
            key: "_parse",
            value: function(e) {
                null != e.friction && (this.friction = e.friction),
                null != e.rollingFriction && (this.rollingFriction = e.rollingFriction),
                null != e.restitution && (this.restitution = e.restitution),
                null != e.isTrigger && (this.isTrigger = e.isTrigger),
                _get(_getPrototypeOf(PhysicsCollider.prototype), "_parse", this).call(this, e),
                this._parseShape(e.shapes);
            }
        }, {
            key: "_onAdded",
            value: function() {
                var e = S._bullet
                  , t = e.btCollisionObject_create();
                e.btCollisionObject_setUserIndex(t, this.id),
                e.btCollisionObject_forceActivationState(t, mr.ACTIVATIONSTATE_DISABLE_SIMULATION);
                var r = e.btCollisionObject_getCollisionFlags(t);
                this.owner.isStatic ? ((r & mr.COLLISIONFLAGS_KINEMATIC_OBJECT) > 0 && (r ^= mr.COLLISIONFLAGS_KINEMATIC_OBJECT),
                r |= mr.COLLISIONFLAGS_STATIC_OBJECT) : ((r & mr.COLLISIONFLAGS_STATIC_OBJECT) > 0 && (r ^= mr.COLLISIONFLAGS_STATIC_OBJECT),
                r |= mr.COLLISIONFLAGS_KINEMATIC_OBJECT),
                e.btCollisionObject_setCollisionFlags(t, r),
                this._btColliderObject = t,
                _get(_getPrototypeOf(PhysicsCollider.prototype), "_onAdded", this).call(this);
            }
        }]),
        PhysicsCollider;
    }()
      , qr = function(e) {
        function Rigidbody3D() {
            var e, t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Ft.COLLISIONFILTERGROUP_DEFAULTFILTER, r = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : Ft.COLLISIONFILTERGROUP_ALLFILTER;
            return _classCallCheck(this, Rigidbody3D),
            (e = _possibleConstructorReturn(this, _getPrototypeOf(Rigidbody3D).call(this, t, r)))._isKinematic = !1,
            e._mass = 1,
            e._gravity = new o(0,-10,0),
            e._angularDamping = 0,
            e._linearDamping = 0,
            e._overrideGravity = !1,
            e._totalTorque = new o(0,0,0),
            e._totalForce = new o(0,0,0),
            e._linearVelocity = new o(),
            e._angularVelocity = new o(),
            e._linearFactor = new o(1,1,1),
            e._angularFactor = new o(1,1,1),
            e._detectCollisions = !0,
            e;
        }
        return _inherits(Rigidbody3D, jr),
        _createClass(Rigidbody3D, [{
            key: "_updateMass",
            value: function(e) {
                if (this._btColliderObject && this._colliderShape) {
                    var t = S._bullet;
                    t.btCollisionShape_calculateLocalInertia(this._colliderShape._btShape, e, Rigidbody3D._btInertia),
                    t.btRigidBody_setMassProps(this._btColliderObject, e, Rigidbody3D._btInertia),
                    t.btRigidBody_updateInertiaTensor(this._btColliderObject);
                }
            }
        }, {
            key: "_onScaleChange",
            value: function(e) {
                _get(_getPrototypeOf(Rigidbody3D.prototype), "_onScaleChange", this).call(this, e),
                this._updateMass(this._isKinematic ? 0 : this._mass);
            }
        }, {
            key: "_onAdded",
            value: function() {
                var e = S._bullet
                  , t = e.layaMotionState_create();
                e.layaMotionState_set_rigidBodyID(t, this._id),
                this._btLayaMotionState = t;
                var r = e.btRigidBodyConstructionInfo_create(0, t, null, Rigidbody3D._btVector3Zero)
                  , n = e.btRigidBody_create(r);
                e.btCollisionObject_setUserIndex(n, this.id),
                this._btColliderObject = n,
                _get(_getPrototypeOf(Rigidbody3D.prototype), "_onAdded", this).call(this),
                this.mass = this._mass,
                this.linearFactor = this._linearFactor,
                this.angularFactor = this._angularFactor,
                this.linearDamping = this._linearDamping,
                this.angularDamping = this._angularDamping,
                this.overrideGravity = this._overrideGravity,
                this.gravity = this._gravity,
                this.isKinematic = this._isKinematic,
                e.btRigidBodyConstructionInfo_destroy(r);
            }
        }, {
            key: "_onShapeChange",
            value: function(e) {
                if (_get(_getPrototypeOf(Rigidbody3D.prototype), "_onShapeChange", this).call(this, e),
                this._isKinematic)
                    this._updateMass(0);
                else {
                    var t = S._bullet;
                    t.btRigidBody_setCenterOfMassTransform(this._btColliderObject, t.btCollisionObject_getWorldTransform(this._btColliderObject)),
                    this._updateMass(this._mass);
                }
            }
        }, {
            key: "_parse",
            value: function(e) {
                if (null != e.friction && (this.friction = e.friction),
                null != e.rollingFriction && (this.rollingFriction = e.rollingFriction),
                null != e.restitution && (this.restitution = e.restitution),
                null != e.isTrigger && (this.isTrigger = e.isTrigger),
                null != e.mass && (this.mass = e.mass),
                null != e.isKinematic && (this.isKinematic = e.isKinematic),
                null != e.linearDamping && (this.linearDamping = e.linearDamping),
                null != e.angularDamping && (this.angularDamping = e.angularDamping),
                null != e.overrideGravity && (this.overrideGravity = e.overrideGravity),
                null != e.linearFactor) {
                    var t = this.linearFactor;
                    t.fromArray(e.linearFactor),
                    this.linearFactor = t;
                }
                if (null != e.angularFactor) {
                    var r = this.angularFactor;
                    r.fromArray(e.angularFactor),
                    this.angularFactor = r;
                }
                e.gravity && (this.gravity.fromArray(e.gravity),
                this.gravity = this.gravity),
                _get(_getPrototypeOf(Rigidbody3D.prototype), "_parse", this).call(this, e),
                this._parseShape(e.shapes);
            }
        }, {
            key: "_onDestroy",
            value: function() {
                S._bullet.btMotionState_destroy(this._btLayaMotionState),
                _get(_getPrototypeOf(Rigidbody3D.prototype), "_onDestroy", this).call(this),
                this._btLayaMotionState = null,
                this._gravity = null,
                this._totalTorque = null,
                this._linearVelocity = null,
                this._angularVelocity = null,
                this._linearFactor = null,
                this._angularFactor = null;
            }
        }, {
            key: "_addToSimulation",
            value: function() {
                this._simulation._addRigidBody(this, this._collisionGroup, this._detectCollisions ? this._canCollideWith : 0);
            }
        }, {
            key: "_removeFromSimulation",
            value: function() {
                this._simulation._removeRigidBody(this);
            }
        }, {
            key: "_cloneTo",
            value: function(e) {
                _get(_getPrototypeOf(Rigidbody3D.prototype), "_cloneTo", this).call(this, e);
                var t = e;
                t.isKinematic = this._isKinematic,
                t.mass = this._mass,
                t.gravity = this._gravity,
                t.angularDamping = this._angularDamping,
                t.linearDamping = this._linearDamping,
                t.overrideGravity = this._overrideGravity,
                t.linearVelocity = this._linearVelocity,
                t.angularVelocity = this._angularVelocity,
                t.linearFactor = this._linearFactor,
                t.angularFactor = this._angularFactor,
                t.detectCollisions = this._detectCollisions;
            }
        }, {
            key: "applyForce",
            value: function(e) {
                var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null;
                if (null == this._btColliderObject)
                    throw "Attempted to call a Physics function that is avaliable only when the Entity has been already added to the Scene.";
                var r = S._bullet
                  , n = Rigidbody3D._btTempVector30;
                if (r.btVector3_setValue(n, -e.x, e.y, e.z),
                t) {
                    var i = Rigidbody3D._btTempVector31;
                    r.btVector3_setValue(i, -t.x, t.y, t.z),
                    r.btRigidBody_applyForce(this._btColliderObject, n, i);
                } else
                    r.btRigidBody_applyCentralForce(this._btColliderObject, n);
            }
        }, {
            key: "applyTorque",
            value: function(e) {
                if (null == this._btColliderObject)
                    throw "Attempted to call a Physics function that is avaliable only when the Entity has been already added to the Scene.";
                var t = S._bullet
                  , r = Rigidbody3D._btTempVector30;
                t.btVector3_setValue(r, -e.x, e.y, e.z),
                t.btRigidBody_applyTorque(this._btColliderObject, r);
            }
        }, {
            key: "applyImpulse",
            value: function(e) {
                var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null;
                if (null == this._btColliderObject)
                    throw "Attempted to call a Physics function that is avaliable only when the Entity has been already added to the Scene.";
                var r = S._bullet;
                r.btVector3_setValue(Rigidbody3D._btImpulse, -e.x, e.y, e.z),
                t ? (r.btVector3_setValue(Rigidbody3D._btImpulseOffset, -t.x, t.y, t.z),
                r.btRigidBody_applyImpulse(this._btColliderObject, Rigidbody3D._btImpulse, Rigidbody3D._btImpulseOffset)) : r.btRigidBody_applyCentralImpulse(this._btColliderObject, Rigidbody3D._btImpulse);
            }
        }, {
            key: "applyTorqueImpulse",
            value: function(e) {
                if (null == this._btColliderObject)
                    throw "Attempted to call a Physics function that is avaliable only when the Entity has been already added to the Scene.";
                var t = S._bullet
                  , r = Rigidbody3D._btTempVector30;
                t.btVector3_setValue(r, -e.x, e.y, e.z),
                t.btRigidBody_applyTorqueImpulse(this._btColliderObject, r);
            }
        }, {
            key: "wakeUp",
            value: function() {
                this._btColliderObject && S._bullet.btCollisionObject_activate(this._btColliderObject, !1);
            }
        }, {
            key: "clearForces",
            value: function() {
                var e = this._btColliderObject;
                if (null == e)
                    throw "Attempted to call a Physics function that is avaliable only when the Entity has been already added to the Scene.";
                var t = S._bullet;
                t.btRigidBody_clearForces(e);
                var r = Rigidbody3D._btVector3Zero;
                t.btCollisionObject_setInterpolationLinearVelocity(e, r),
                t.btRigidBody_setLinearVelocity(e, r),
                t.btCollisionObject_setInterpolationAngularVelocity(e, r),
                t.btRigidBody_setAngularVelocity(e, r);
            }
        }, {
            key: "mass",
            get: function() {
                return this._mass;
            },
            set: function(e) {
                e = Math.max(e, 1e-7),
                this._mass = e,
                this._isKinematic || this._updateMass(e);
            }
        }, {
            key: "isKinematic",
            get: function() {
                return this._isKinematic;
            },
            set: function(e) {
                this._isKinematic = e;
                var t = S._bullet
                  , r = !!(this._simulation && this._enabled && this._colliderShape);
                r && this._removeFromSimulation();
                var n = this._btColliderObject
                  , i = t.btCollisionObject_getCollisionFlags(n);
                e ? (i |= mr.COLLISIONFLAGS_KINEMATIC_OBJECT,
                t.btCollisionObject_setCollisionFlags(n, i),
                t.btCollisionObject_forceActivationState(this._btColliderObject, mr.ACTIVATIONSTATE_DISABLE_DEACTIVATION),
                this._enableProcessCollisions = !1,
                this._updateMass(0)) : ((i & mr.COLLISIONFLAGS_KINEMATIC_OBJECT) > 0 && (i ^= mr.COLLISIONFLAGS_KINEMATIC_OBJECT),
                t.btCollisionObject_setCollisionFlags(n, i),
                t.btCollisionObject_setActivationState(this._btColliderObject, mr.ACTIVATIONSTATE_ACTIVE_TAG),
                this._enableProcessCollisions = !0,
                this._updateMass(this._mass));
                var a = Rigidbody3D._btVector3Zero;
                t.btCollisionObject_setInterpolationLinearVelocity(n, a),
                t.btRigidBody_setLinearVelocity(n, a),
                t.btCollisionObject_setInterpolationAngularVelocity(n, a),
                t.btRigidBody_setAngularVelocity(n, a),
                r && this._addToSimulation();
            }
        }, {
            key: "linearDamping",
            get: function() {
                return this._linearDamping;
            },
            set: function(e) {
                this._linearDamping = e,
                this._btColliderObject && S._bullet.btRigidBody_setDamping(this._btColliderObject, e, this._angularDamping);
            }
        }, {
            key: "angularDamping",
            get: function() {
                return this._angularDamping;
            },
            set: function(e) {
                this._angularDamping = e,
                this._btColliderObject && S._bullet.btRigidBody_setDamping(this._btColliderObject, this._linearDamping, e);
            }
        }, {
            key: "overrideGravity",
            get: function() {
                return this._overrideGravity;
            },
            set: function(e) {
                this._overrideGravity = e;
                var t = S._bullet;
                if (this._btColliderObject) {
                    var r = t.btRigidBody_getFlags(this._btColliderObject);
                    e ? 0 == (r & Rigidbody3D._BT_DISABLE_WORLD_GRAVITY) && t.btRigidBody_setFlags(this._btColliderObject, r | Rigidbody3D._BT_DISABLE_WORLD_GRAVITY) : (r & Rigidbody3D._BT_DISABLE_WORLD_GRAVITY) > 0 && t.btRigidBody_setFlags(this._btColliderObject, r ^ Rigidbody3D._BT_DISABLE_WORLD_GRAVITY);
                }
            }
        }, {
            key: "gravity",
            get: function() {
                return this._gravity;
            },
            set: function(e) {
                this._gravity = e;
                var t = S._bullet;
                t.btVector3_setValue(Rigidbody3D._btGravity, -e.x, e.y, e.z),
                t.btRigidBody_setGravity(this._btColliderObject, Rigidbody3D._btGravity);
            }
        }, {
            key: "totalForce",
            get: function() {
                if (this._btColliderObject) {
                    var e = S._bullet.btRigidBody_getTotalForce(this._btColliderObject);
                    return R._convertToLayaVec3(e, this._totalForce, !0),
                    this._totalForce;
                }
                return null;
            }
        }, {
            key: "linearFactor",
            get: function() {
                return this._linearFactor;
            },
            set: function(e) {
                this._linearFactor = e;
                var t = Rigidbody3D._btTempVector30;
                R._convertToBulletVec3(e, t, !1),
                S._bullet.btRigidBody_setLinearFactor(this._btColliderObject, t);
            }
        }, {
            key: "linearVelocity",
            get: function() {
                return this._btColliderObject && R._convertToLayaVec3(S._bullet.btRigidBody_getLinearVelocity(this._btColliderObject), this._linearVelocity, !0),
                this._linearVelocity;
            },
            set: function(e) {
                if (this._linearVelocity = e,
                this._btColliderObject) {
                    var t = Rigidbody3D._btTempVector30;
                    R._convertToBulletVec3(e, t, !0),
                    this.isSleeping && this.wakeUp(),
                    S._bullet.btRigidBody_setLinearVelocity(this._btColliderObject, t);
                }
            }
        }, {
            key: "angularFactor",
            get: function() {
                return this._angularFactor;
            },
            set: function(e) {
                this._angularFactor = e;
                var t = Rigidbody3D._btTempVector30;
                R._convertToBulletVec3(e, t, !1),
                S._bullet.btRigidBody_setAngularFactor(this._btColliderObject, t);
            }
        }, {
            key: "angularVelocity",
            get: function() {
                return this._btColliderObject && R._convertToLayaVec3(S._bullet.btRigidBody_getAngularVelocity(this._btColliderObject), this._angularVelocity, !0),
                this._angularVelocity;
            },
            set: function(e) {
                if (this._angularVelocity = e,
                this._btColliderObject) {
                    var t = Rigidbody3D._btTempVector30;
                    R._convertToBulletVec3(e, t, !0),
                    this.isSleeping && this.wakeUp(),
                    S._bullet.btRigidBody_setAngularVelocity(this._btColliderObject, t);
                }
            }
        }, {
            key: "totalTorque",
            get: function() {
                if (this._btColliderObject) {
                    var e = S._bullet.btRigidBody_getTotalTorque(this._btColliderObject);
                    return R._convertToLayaVec3(e, this._totalTorque, !0),
                    this._totalTorque;
                }
                return null;
            }
        }, {
            key: "detectCollisions",
            get: function() {
                return this._detectCollisions;
            },
            set: function(e) {
                this._detectCollisions !== e && (this._detectCollisions = e,
                this._colliderShape && this._enabled && this._simulation && (this._simulation._removeRigidBody(this),
                this._simulation._addRigidBody(this, this._collisionGroup, e ? this._canCollideWith : 0)));
            }
        }, {
            key: "isSleeping",
            get: function() {
                return !!this._btColliderObject && S._bullet.btCollisionObject_getActivationState(this._btColliderObject) === mr.ACTIVATIONSTATE_ISLAND_SLEEPING;
            }
        }, {
            key: "sleepLinearVelocity",
            get: function() {
                return S._bullet.btRigidBody_getLinearSleepingThreshold(this._btColliderObject);
            },
            set: function(e) {
                var t = S._bullet;
                t.btRigidBody_setSleepingThresholds(this._btColliderObject, e, t.btRigidBody_getAngularSleepingThreshold(this._btColliderObject));
            }
        }, {
            key: "sleepAngularVelocity",
            get: function() {
                return S._bullet.btRigidBody_getAngularSleepingThreshold(this._btColliderObject);
            },
            set: function(e) {
                var t = S._bullet;
                t.btRigidBody_setSleepingThresholds(this._btColliderObject, t.btRigidBody_getLinearSleepingThreshold(this._btColliderObject), e);
            }
        }], [{
            key: "__init__",
            value: function() {
                var e = S._bullet;
                Rigidbody3D._btTempVector30 = e.btVector3_create(0, 0, 0),
                Rigidbody3D._btTempVector31 = e.btVector3_create(0, 0, 0),
                Rigidbody3D._btVector3Zero = e.btVector3_create(0, 0, 0),
                Rigidbody3D._btInertia = e.btVector3_create(0, 0, 0),
                Rigidbody3D._btImpulse = e.btVector3_create(0, 0, 0),
                Rigidbody3D._btImpulseOffset = e.btVector3_create(0, 0, 0),
                Rigidbody3D._btGravity = e.btVector3_create(0, 0, 0);
            }
        }]),
        Rigidbody3D;
    }();
    qr.TYPE_STATIC = 0,
    qr.TYPE_DYNAMIC = 1,
    qr.TYPE_KINEMATIC = 2,
    qr._BT_DISABLE_WORLD_GRAVITY = 1,
    qr._BT_ENABLE_GYROPSCOPIC_FORCE = 2;
    var Kr = function(e) {
        function StaticPlaneColliderShape(e, t) {
            var r;
            _classCallCheck(this, StaticPlaneColliderShape),
            (r = _possibleConstructorReturn(this, _getPrototypeOf(StaticPlaneColliderShape).call(this)))._normal = e,
            r._offset = t,
            r._type = sr.SHAPETYPES_STATICPLANE;
            var n = S._bullet;
            return n.btVector3_setValue(StaticPlaneColliderShape._btNormal, -e.x, e.y, e.z),
            r._btShape = n.btStaticPlaneShape_create(StaticPlaneColliderShape._btNormal, t),
            r;
        }
        return _inherits(StaticPlaneColliderShape, sr),
        _createClass(StaticPlaneColliderShape, null, [{
            key: "__init__",
            value: function() {
                StaticPlaneColliderShape._btNormal = S._bullet.btVector3_create(0, 0, 0);
            }
        }]),
        _createClass(StaticPlaneColliderShape, [{
            key: "clone",
            value: function() {
                var e = new StaticPlaneColliderShape(this._normal,this._offset);
                return this.cloneTo(e),
                e;
            }
        }]),
        StaticPlaneColliderShape;
    }()
      , Jr = function(r) {
        function SubMesh(e) {
            var t;
            return _classCallCheck(this, SubMesh),
            (t = _possibleConstructorReturn(this, _getPrototypeOf(SubMesh).call(this)))._id = ++SubMesh._uniqueIDCounter,
            t._mesh = e,
            t._boneIndicesList = [],
            t._subIndexBufferStart = [],
            t._subIndexBufferCount = [],
            t;
        }
        return _inherits(SubMesh, Me),
        _createClass(SubMesh, [{
            key: "_setIndexRange",
            value: function(e, t) {
                this._indexStart = e,
                this._indexCount = t,
                this._indices = new Uint16Array(this._indexBuffer.getData().buffer,2 * e,t);
            }
        }, {
            key: "_getType",
            value: function() {
                return SubMesh._type;
            }
        }, {
            key: "_prepareRender",
            value: function(e) {
                return this._mesh._uploadVerticesData(),
                !0;
            }
        }, {
            key: "_render",
            value: function(r) {
                var n = this._mesh;
                if (n.indexFormat !== e.IndexFormat.UInt32 || t.LayaGL.layaGPUInstance.supportElementIndexUint32()) {
                    var i, a = t.LayaGL.instance, o = r.renderElement.render._skinnedData;
                    switch (n.indexFormat) {
                    case e.IndexFormat.UInt32:
                        i = a.UNSIGNED_INT;
                        break;
                    case e.IndexFormat.UInt16:
                        i = a.UNSIGNED_SHORT;
                        break;
                    case e.IndexFormat.UInt8:
                        i = a.UNSIGNED_BYTE;
                    }
                    if (n._bufferState.bind(),
                    o)
                        for (var s = o[this._indexInMesh], l = 0, u = this._boneIndicesList.length; l < u; l++)
                            r.shader.uploadCustomUniform(Vr.BONES, s[l]),
                            a.drawElements(a.TRIANGLES, this._subIndexBufferCount[l], i, 2 * this._subIndexBufferStart[l]);
                    else
                        a.drawElements(a.TRIANGLES, this._indexCount, i, 2 * this._indexStart);
                    t.Stat.trianglesFaces += this._indexCount / 3,
                    t.Stat.renderBatches++;
                } else
                    console.warn("SubMesh:this device do not support IndexFormat.UInt32.");
            }
        }, {
            key: "getIndices",
            value: function() {
                if (this._mesh._isReadable)
                    return this._indices.slice();
                throw "SubMesh:can't get indices on subMesh,mesh's isReadable must be true.";
            }
        }, {
            key: "setIndices",
            value: function(e) {
                this._indexBuffer.setData(e, this._indexStart, 0, this._indexCount);
            }
        }, {
            key: "destroy",
            value: function() {
                this._destroyed || (_get(_getPrototypeOf(SubMesh.prototype), "destroy", this).call(this),
                this._indexBuffer.destroy(),
                this._indexBuffer = null,
                this._mesh = null,
                this._boneIndicesList = null,
                this._subIndexBufferStart = null,
                this._subIndexBufferCount = null,
                this._skinAnimationDatas = null);
            }
        }, {
            key: "indexCount",
            get: function() {
                return this._indexCount;
            }
        }]),
        SubMesh;
    }();
    Jr._uniqueIDCounter = 0,
    Jr._type = Me._typeCounter++;
    var $r = function skinnedMatrixCache(e, t, r) {
        _classCallCheck(this, skinnedMatrixCache),
        this.subMeshIndex = e,
        this.batchIndex = t,
        this.batchBoneIndex = r;
    }
      , en = function(r) {
        function Mesh() {
            var t, r = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0];
            return _classCallCheck(this, Mesh),
            (t = _possibleConstructorReturn(this, _getPrototypeOf(Mesh).call(this)))._tempVector30 = new o(),
            t._tempVector31 = new o(),
            t._tempVector32 = new o(),
            t._minVerticesUpdate = -1,
            t._maxVerticesUpdate = -1,
            t._needUpdateBounds = !0,
            t._bounds = new st(new o(),new o()),
            t._bufferState = new we(),
            t._instanceBufferState = new we(),
            t._vertexBuffer = null,
            t._indexBuffer = null,
            t._skinnedMatrixCaches = [],
            t._vertexCount = 0,
            t._indexFormat = e.IndexFormat.UInt16,
            t._isReadable = r,
            t._subMeshes = [],
            t;
        }
        return _inherits(Mesh, t.Resource),
        _createClass(Mesh, [{
            key: "_getPositionElement",
            value: function(e) {
                for (var t = e.vertexDeclaration._vertexElements, r = 0, n = t.length; r < n; r++) {
                    var i = t[r];
                    if (i._elementFormat === ae.Vector3 && i._elementUsage === ue.MESH_POSITION0)
                        return i;
                }
                return null;
            }
        }, {
            key: "_getVerticeElementData",
            value: function(e, t) {
                e.length = this._vertexCount;
                var r = this._vertexBuffer.vertexDeclaration
                  , a = r.getVertexElementByUsage(t);
                if (a) {
                    var s = this._vertexBuffer.getUint8Data()
                      , l = this._vertexBuffer.getFloat32Data()
                      , u = r.vertexStride
                      , c = u / 4
                      , h = a._offset
                      , _ = h / 4;
                    switch (t) {
                    case ue.MESH_TEXTURECOORDINATE0:
                    case ue.MESH_TEXTURECOORDINATE1:
                        for (var d = 0; d < this._vertexCount; d++) {
                            var f = c * d + _;
                            e[d] = new n(l[f],l[f + 1]);
                        }
                        break;
                    case ue.MESH_POSITION0:
                    case ue.MESH_NORMAL0:
                        for (d = 0; d < this._vertexCount; d++) {
                            f = c * d + _;
                            e[d] = new o(l[f],l[f + 1],l[f + 2]);
                        }
                        break;
                    case ue.MESH_TANGENT0:
                    case ue.MESH_BLENDWEIGHT0:
                        for (d = 0; d < this._vertexCount; d++) {
                            f = c * d + _;
                            e[d] = new i(l[f],l[f + 1],l[f + 2],l[f + 3]);
                        }
                        break;
                    case ue.MESH_COLOR0:
                        for (d = 0; d < this._vertexCount; d++) {
                            f = c * d + _;
                            e[d] = new ve(l[f],l[f + 1],l[f + 2],l[f + 3]);
                        }
                        break;
                    case ue.MESH_BLENDINDICES0:
                        for (d = 0; d < this._vertexCount; d++) {
                            f = u * d + h;
                            e[d] = new i(s[f],s[f + 1],s[f + 2],s[f + 3]);
                        }
                        break;
                    default:
                        throw "Mesh:Unknown elementUsage.";
                    }
                }
            }
        }, {
            key: "_setVerticeElementData",
            value: function(e, t) {
                var r = this._vertexBuffer.vertexDeclaration
                  , n = r.getVertexElementByUsage(t);
                if (n) {
                    var i = this._vertexBuffer.getUint8Data()
                      , a = this._vertexBuffer.getFloat32Data()
                      , o = r.vertexStride
                      , s = o / 4
                      , l = n._offset
                      , u = l / 4;
                    switch (t) {
                    case ue.MESH_TEXTURECOORDINATE0:
                    case ue.MESH_TEXTURECOORDINATE1:
                        for (var c = 0, h = e.length; c < h; c++) {
                            var _ = s * c + u
                              , d = e[c];
                            a[_] = d.x,
                            a[_ + 1] = d.y;
                        }
                        break;
                    case ue.MESH_POSITION0:
                    case ue.MESH_NORMAL0:
                        for (c = 0,
                        h = e.length; c < h; c++) {
                            _ = s * c + u;
                            var f = e[c];
                            a[_] = f.x,
                            a[_ + 1] = f.y,
                            a[_ + 2] = f.z;
                        }
                        break;
                    case ue.MESH_TANGENT0:
                    case ue.MESH_BLENDWEIGHT0:
                        for (c = 0,
                        h = e.length; c < h; c++) {
                            _ = s * c + u;
                            var m = e[c];
                            a[_] = m.x,
                            a[_ + 1] = m.y,
                            a[_ + 2] = m.z,
                            a[_ + 3] = m.w;
                        }
                        break;
                    case ue.MESH_COLOR0:
                        for (c = 0,
                        h = e.length; c < h; c++) {
                            _ = s * c + u;
                            var p = e[c];
                            a[_] = p.r,
                            a[_ + 1] = p.g,
                            a[_ + 2] = p.b,
                            a[_ + 3] = p.a;
                        }
                        break;
                    case ue.MESH_BLENDINDICES0:
                        for (c = 0,
                        h = e.length; c < h; c++) {
                            _ = o * c + l,
                            m = e[c];
                            i[_] = m.x,
                            i[_ + 1] = m.y,
                            i[_ + 2] = m.z,
                            i[_ + 3] = m.w;
                        }
                        break;
                    default:
                        throw "Mesh:Unknown elementUsage.";
                    }
                    this._minVerticesUpdate = 0,
                    this._maxVerticesUpdate = Number.MAX_SAFE_INTEGER;
                } else
                    console.warn("Mesh: the mesh don't have  this VertexElement.");
            }
        }, {
            key: "_disposeResource",
            value: function() {
                for (var e = 0, t = this._subMeshes.length; e < t; e++)
                    this._subMeshes[e].destroy();
                this._btTriangleMesh && S._bullet.btStridingMeshInterface_destroy(this._btTriangleMesh),
                this._vertexBuffer.destroy(),
                this._indexBuffer.destroy(),
                this._bufferState.destroy(),
                this._instanceBufferState.destroy(),
                this._setCPUMemory(0),
                this._setGPUMemory(0),
                this._bufferState = null,
                this._instanceBufferState = null,
                this._vertexBuffer = null,
                this._indexBuffer = null,
                this._subMeshes = null,
                this._btTriangleMesh = null,
                this._indexBuffer = null,
                this._boneNames = null,
                this._inverseBindPoses = null;
            }
        }, {
            key: "_setSubMeshes",
            value: function(e) {
                this._subMeshes = e;
                for (var t = 0, r = e.length; t < r; t++)
                    e[t]._indexInMesh = t;
            }
        }, {
            key: "_setBuffer",
            value: function(e, t) {
                var r = this._bufferState;
                r.bind(),
                r.applyVertexBuffer(e),
                r.applyIndexBuffer(t),
                r.unBind();
                var n = this._instanceBufferState;
                n.bind(),
                n.applyVertexBuffer(e),
                n.applyInstanceVertexBuffer(xe.instance.instanceWorldMatrixBuffer),
                n.applyInstanceVertexBuffer(xe.instance.instanceMVPMatrixBuffer),
                n.applyIndexBuffer(t),
                n.unBind();
            }
        }, {
            key: "_getPhysicMesh",
            value: function() {
                if (!this._btTriangleMesh) {
                    for (var e = S._bullet, t = e.btTriangleMesh_create(), r = Mesh._nativeTempVector30, n = Mesh._nativeTempVector31, i = Mesh._nativeTempVector32, a = this._tempVector30, o = this._tempVector31, s = this._tempVector32, l = this._vertexBuffer, u = this._getPositionElement(l), c = l.getFloat32Data(), h = l.vertexDeclaration.vertexStride / 4, _ = u._offset / 4, d = this._indexBuffer.getData(), f = 0, m = d.length; f < m; f += 3) {
                        var p = d[f] * h + _
                          , v = d[f + 1] * h + _
                          , T = d[f + 2] * h + _;
                        a.setValue(c[p], c[p + 1], c[p + 2]),
                        o.setValue(c[v], c[v + 1], c[v + 2]),
                        s.setValue(c[T], c[T + 1], c[T + 2]),
                        R._convertToBulletVec3(a, r, !0),
                        R._convertToBulletVec3(o, n, !0),
                        R._convertToBulletVec3(s, i, !0),
                        e.btTriangleMesh_addTriangle(t, r, n, i, !0);
                    }
                    this._btTriangleMesh = t;
                }
                return this._btTriangleMesh;
            }
        }, {
            key: "_uploadVerticesData",
            value: function() {
                var e = this._minVerticesUpdate
                  , t = this._maxVerticesUpdate;
                if (-1 !== e && -1 !== t) {
                    var r = e;
                    this._vertexBuffer.setData(this._vertexBuffer.getUint8Data().buffer, r, r, t - e),
                    this._minVerticesUpdate = -1,
                    this._maxVerticesUpdate = -1;
                }
            }
        }, {
            key: "getSubMesh",
            value: function(e) {
                return this._subMeshes[e];
            }
        }, {
            key: "getPositions",
            value: function(e) {
                if (!this._isReadable)
                    throw "Mesh:can't get positions on mesh,isReadable must be true.";
                this._getVerticeElementData(e, ue.MESH_POSITION0);
            }
        }, {
            key: "setPositions",
            value: function(e) {
                if (!this._isReadable)
                    throw "Mesh:setPosition() need isReadable must be true or use setVertices().";
                this._setVerticeElementData(e, ue.MESH_POSITION0),
                this._needUpdateBounds = !0;
            }
        }, {
            key: "getColors",
            value: function(e) {
                if (!this._isReadable)
                    throw "Mesh:can't get colors on mesh,isReadable must be true.";
                this._getVerticeElementData(e, ue.MESH_COLOR0);
            }
        }, {
            key: "setColors",
            value: function(e) {
                if (!this._isReadable)
                    throw "Mesh:setColors() need isReadable must be true or use setVertices().";
                this._setVerticeElementData(e, ue.MESH_COLOR0);
            }
        }, {
            key: "getUVs",
            value: function(e) {
                var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
                if (!this._isReadable)
                    throw "Mesh:can't get uvs on mesh,isReadable must be true.";
                switch (t) {
                case 0:
                    this._getVerticeElementData(e, ue.MESH_TEXTURECOORDINATE0);
                    break;
                case 1:
                    this._getVerticeElementData(e, ue.MESH_TEXTURECOORDINATE1);
                    break;
                default:
                    throw "Mesh:Invalid channel.";
                }
            }
        }, {
            key: "setUVs",
            value: function(e) {
                var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
                if (!this._isReadable)
                    throw "Mesh:setUVs() need isReadable must be true or use setVertices().";
                switch (t) {
                case 0:
                    this._setVerticeElementData(e, ue.MESH_TEXTURECOORDINATE0);
                    break;
                case 1:
                    this._setVerticeElementData(e, ue.MESH_TEXTURECOORDINATE1);
                    break;
                default:
                    throw "Mesh:Invalid channel.";
                }
            }
        }, {
            key: "getNormals",
            value: function(e) {
                if (!this._isReadable)
                    throw "Mesh:can't get colors on mesh,isReadable must be true.";
                this._getVerticeElementData(e, ue.MESH_NORMAL0);
            }
        }, {
            key: "setNormals",
            value: function(e) {
                if (!this._isReadable)
                    throw "Mesh:setNormals() need must be true or use setVertices().";
                this._setVerticeElementData(e, ue.MESH_NORMAL0);
            }
        }, {
            key: "getTangents",
            value: function(e) {
                if (!this._isReadable)
                    throw "Mesh:can't get colors on mesh,isReadable must be true.";
                this._getVerticeElementData(e, ue.MESH_TANGENT0);
            }
        }, {
            key: "setTangents",
            value: function(e) {
                if (!this._isReadable)
                    throw "Mesh:setTangents() need isReadable must be true or use setVertices().";
                this._setVerticeElementData(e, ue.MESH_TANGENT0);
            }
        }, {
            key: "getBoneWeights",
            value: function(e) {
                if (!this._isReadable)
                    throw "Mesh:can't get boneWeights on mesh,isReadable must be true.";
                this._getVerticeElementData(e, ue.MESH_BLENDWEIGHT0);
            }
        }, {
            key: "setBoneWeights",
            value: function(e) {
                if (!this._isReadable)
                    throw "Mesh:setBoneWeights() need isReadable must be true or use setVertices().";
                this._setVerticeElementData(e, ue.MESH_BLENDWEIGHT0);
            }
        }, {
            key: "getBoneIndices",
            value: function(e) {
                if (!this._isReadable)
                    throw "Mesh:can't get boneIndices on mesh,isReadable must be true.";
                this._getVerticeElementData(e, ue.MESH_BLENDINDICES0);
            }
        }, {
            key: "setBoneIndices",
            value: function(e) {
                if (!this._isReadable)
                    throw "Mesh:setBoneIndices() need isReadable must be true or use setVertices().";
                this._setVerticeElementData(e, ue.MESH_BLENDINDICES0);
            }
        }, {
            key: "markAsUnreadbale",
            value: function() {
                this._uploadVerticesData(),
                this._vertexBuffer.markAsUnreadbale(),
                this._isReadable = !1;
            }
        }, {
            key: "getVertexDeclaration",
            value: function() {
                return this._vertexBuffer._vertexDeclaration;
            }
        }, {
            key: "getVertices",
            value: function() {
                if (this._isReadable)
                    return this._vertexBuffer.getUint8Data().buffer.slice(0);
                throw "Mesh:can't get vertices on mesh,isReadable must be true.";
            }
        }, {
            key: "setVertices",
            value: function(e) {
                this._vertexBuffer.setData(e),
                this._needUpdateBounds = !0;
            }
        }, {
            key: "getIndices",
            value: function() {
                if (this._isReadable)
                    return this._indexBuffer.getData().slice();
                throw "Mesh:can't get indices on subMesh,mesh's isReadable must be true.";
            }
        }, {
            key: "setIndices",
            value: function(r) {
                var n;
                r instanceof Uint32Array ? n = e.IndexFormat.UInt32 : r instanceof Uint16Array ? n = e.IndexFormat.UInt16 : r instanceof Uint8Array && (n = e.IndexFormat.UInt8);
                var i = this._indexBuffer;
                this._indexFormat === n && i.indexCount === r.length || (i.destroy(),
                this._indexBuffer = i = new Fe(n,r.length,t.LayaGL.instance.STATIC_DRAW,this._isReadable)),
                i.setData(r),
                this._indexFormat = n;
            }
        }, {
            key: "calculateBounds",
            value: function() {
                if (!this._isReadable)
                    throw "Mesh:can't calculate bounds on subMesh,mesh's isReadable must be true.";
                if (this._needUpdateBounds) {
                    var e = this._tempVector30
                      , t = this._tempVector31;
                    e.x = e.y = e.z = Number.MAX_VALUE,
                    t.x = t.y = t.z = -Number.MAX_VALUE;
                    for (var r = this._vertexBuffer, n = this._getPositionElement(r), i = r.getFloat32Data(), a = r.vertexDeclaration.vertexStride / 4, o = n._offset / 4, s = 0, l = i.length; s < l; s += a) {
                        var u = s + o
                          , c = i[u]
                          , h = i[u + 1]
                          , _ = i[u + 2];
                        e.x = Math.min(e.x, c),
                        e.y = Math.min(e.y, h),
                        e.z = Math.min(e.z, _),
                        t.x = Math.max(t.x, c),
                        t.y = Math.max(t.y, h),
                        t.z = Math.max(t.z, _);
                    }
                    this._bounds.setMin(e),
                    this._bounds.setMax(t),
                    this._needUpdateBounds = !1;
                }
            }
        }, {
            key: "cloneTo",
            value: function(t) {
                var r = t
                  , n = this._vertexBuffer
                  , i = new De(n._byteLength,n.bufferUsage,n.canRead);
                i.vertexDeclaration = n.vertexDeclaration,
                i.setData(n.getUint8Data().slice().buffer),
                r._vertexBuffer = i,
                r._vertexCount = this._vertexCount;
                var a, o = this._indexBuffer, s = new Fe(e.IndexFormat.UInt16,o.indexCount,o.bufferUsage,o.canRead);
                s.setData(o.getData().slice()),
                r._indexBuffer = s,
                r._setBuffer(r._vertexBuffer, s),
                r._setCPUMemory(this.cpuMemory),
                r._setGPUMemory(this.gpuMemory);
                var l = this._boneNames
                  , u = r._boneNames = [];
                for (a = 0; a < l.length; a++)
                    u[a] = l[a];
                var c = this._inverseBindPoses
                  , h = r._inverseBindPoses = [];
                for (a = 0; a < c.length; a++)
                    h[a] = c[a];
                var _ = this._skinnedMatrixCaches.length;
                for (r._skinnedMatrixCaches.length = _,
                a = 0; a < _; a++) {
                    var d = this._skinnedMatrixCaches[a];
                    r._skinnedMatrixCaches[a] = new $r(d.subMeshIndex,d.batchIndex,d.batchBoneIndex);
                }
                for (a = 0; a < this.subMeshCount; a++) {
                    var f = this._subMeshes[a]
                      , m = f._subIndexBufferStart
                      , p = f._subIndexBufferCount
                      , v = f._boneIndicesList
                      , T = new Jr(r);
                    T._subIndexBufferStart.length = m.length,
                    T._subIndexBufferCount.length = p.length,
                    T._boneIndicesList.length = v.length;
                    for (var E = 0; E < m.length; E++)
                        T._subIndexBufferStart[E] = m[E];
                    for (E = 0; E < p.length; E++)
                        T._subIndexBufferCount[E] = p[E];
                    for (E = 0; E < v.length; E++)
                        T._boneIndicesList[E] = new Uint16Array(v[E]);
                    T._indexBuffer = s,
                    T._indexStart = f._indexStart,
                    T._indexCount = f._indexCount,
                    T._indices = new Uint16Array(s.getData().buffer,2 * f._indexStart,f._indexCount);
                    var y = r._vertexBuffer;
                    T._vertexBuffer = y,
                    r._subMeshes.push(T);
                }
                r._setSubMeshes(r._subMeshes);
            }
        }, {
            key: "clone",
            value: function() {
                var e = new Mesh();
                return this.cloneTo(e),
                e;
            }
        }, {
            key: "inverseAbsoluteBindPoses",
            get: function() {
                return this._inverseBindPoses;
            }
        }, {
            key: "vertexCount",
            get: function() {
                return this._vertexCount;
            }
        }, {
            key: "indexCount",
            get: function() {
                return this._indexBuffer.indexCount;
            }
        }, {
            key: "subMeshCount",
            get: function() {
                return this._subMeshes.length;
            }
        }, {
            key: "bounds",
            get: function() {
                return this._bounds;
            },
            set: function(e) {
                this._bounds !== e && e.cloneTo(this._bounds);
            }
        }, {
            key: "indexFormat",
            get: function() {
                return this._indexFormat;
            }
        }], [{
            key: "__init__",
            value: function() {
                var e = S._bullet;
                e && (Mesh._nativeTempVector30 = e.btVector3_create(0, 0, 0),
                Mesh._nativeTempVector31 = e.btVector3_create(0, 0, 0),
                Mesh._nativeTempVector32 = e.btVector3_create(0, 0, 0));
            }
        }, {
            key: "load",
            value: function(e, r) {
                t.ILaya.loader.create(e, r, null, Mesh.MESH);
            }
        }]),
        Mesh;
    }();
    en.MESH = "MESH";
    var tn = function() {
        function PrimitiveMesh() {
            _classCallCheck(this, PrimitiveMesh);
        }
        return _createClass(PrimitiveMesh, null, [{
            key: "__init__",
            value: function() {}
        }, {
            key: "_createMesh",
            value: function(r, n, i) {
                var a = t.LayaGL.instance
                  , o = new en()
                  , s = new Jr(o)
                  , l = new De(4 * n.length,a.STATIC_DRAW,!0);
                l.vertexDeclaration = r,
                l.setData(n.buffer),
                o._vertexBuffer = l,
                o._vertexCount = l._byteLength / r.vertexStride;
                var u = new Fe(e.IndexFormat.UInt16,i.length,a.STATIC_DRAW,!0);
                u.setData(i),
                o._indexBuffer = u,
                o._setBuffer(l, u),
                s._vertexBuffer = l,
                s._indexBuffer = u,
                s._setIndexRange(0, u.indexCount);
                var c = s._subIndexBufferStart
                  , h = s._subIndexBufferCount
                  , _ = s._boneIndicesList;
                c.length = 1,
                h.length = 1,
                _.length = 1,
                c[0] = 0,
                h[0] = u.indexCount;
                var d = [];
                d.push(s),
                o._setSubMeshes(d),
                o.calculateBounds();
                var f = l._byteLength + u._byteLength;
                return o._setCPUMemory(f),
                o._setGPUMemory(f),
                o;
            }
        }, {
            key: "createBox",
            value: function() {
                var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 1
                  , t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1
                  , r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 1
                  , n = ue.getVertexDeclaration("POSITION,NORMAL,UV")
                  , i = e / 2
                  , a = t / 2
                  , o = r / 2
                  , s = new Float32Array([-i, a, -o, 0, 1, 0, 0, 0, i, a, -o, 0, 1, 0, 1, 0, i, a, o, 0, 1, 0, 1, 1, -i, a, o, 0, 1, 0, 0, 1, -i, -a, -o, 0, -1, 0, 0, 1, i, -a, -o, 0, -1, 0, 1, 1, i, -a, o, 0, -1, 0, 1, 0, -i, -a, o, 0, -1, 0, 0, 0, -i, a, -o, -1, 0, 0, 0, 0, -i, a, o, -1, 0, 0, 1, 0, -i, -a, o, -1, 0, 0, 1, 1, -i, -a, -o, -1, 0, 0, 0, 1, i, a, -o, 1, 0, 0, 1, 0, i, a, o, 1, 0, 0, 0, 0, i, -a, o, 1, 0, 0, 0, 1, i, -a, -o, 1, 0, 0, 1, 1, -i, a, o, 0, 0, 1, 0, 0, i, a, o, 0, 0, 1, 1, 0, i, -a, o, 0, 0, 1, 1, 1, -i, -a, o, 0, 0, 1, 0, 1, -i, a, -o, 0, 0, -1, 1, 0, i, a, -o, 0, 0, -1, 0, 0, i, -a, -o, 0, 0, -1, 0, 1, -i, -a, -o, 0, 0, -1, 1, 1])
                  , l = new Uint16Array([0, 1, 2, 2, 3, 0, 4, 7, 6, 6, 5, 4, 8, 9, 10, 10, 11, 8, 12, 15, 14, 14, 13, 12, 16, 17, 18, 18, 19, 16, 20, 23, 22, 22, 21, 20]);
                return PrimitiveMesh._createMesh(n, s, l);
            }
        }, {
            key: "createCapsule",
            value: function() {
                var e, t, r = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : .5, n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 2, i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 16, a = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 32, o = (i + 1) * (a + 1) * 2 + 2 * (a + 1), s = 3 * i * (a + 1) * 2 * 2 + 2 * a * 3, l = ue.getVertexDeclaration("POSITION,NORMAL,UV"), u = l.vertexStride / 4, c = new Float32Array(o * u), h = new Uint16Array(s), _ = Math.PI / 2 / i, d = 2 * Math.PI / a, f = n / 2 - r, m = 0, p = 0, v = 0, T = 0, E = 0, y = 0;
                for (e = 0; e <= i; e++)
                    for (t = 0; t <= a; t++)
                        m = r * Math.cos(e * _) * Math.cos(t * d + Math.PI),
                        p = r * Math.sin(e * _),
                        v = r * Math.cos(e * _) * Math.sin(t * d + Math.PI),
                        c[T++] = m,
                        c[T++] = p + f,
                        c[T++] = v,
                        c[T++] = m,
                        c[T++] = p,
                        c[T++] = v,
                        c[T++] = 1 - t / a,
                        c[T++] = (1 - e / i) * (Math.PI * r / 2 / (n + Math.PI * r)),
                        e < i && (h[E++] = e * (a + 1) + t + (a + 1),
                        h[E++] = e * (a + 1) + t,
                        h[E++] = e * (a + 1) + t + 1,
                        h[E++] = e * (a + 1) + t + a,
                        h[E++] = e * (a + 1) + t,
                        h[E++] = e * (a + 1) + t + (a + 1));
                for (y += (i + 1) * (a + 1),
                e = 0; e <= i; e++)
                    for (t = 0; t <= a; t++)
                        m = r * Math.cos(e * _) * Math.cos(t * d + Math.PI),
                        p = r * Math.sin(-e * _),
                        v = r * Math.cos(e * _) * Math.sin(t * d + Math.PI),
                        c[T++] = m,
                        c[T++] = p - f,
                        c[T++] = v,
                        c[T++] = m,
                        c[T++] = p,
                        c[T++] = v,
                        c[T++] = 1 - t / a,
                        c[T++] = (e / i * (Math.PI * r / 2) + (n + Math.PI * r / 2)) / (n + Math.PI * r),
                        e < i && (h[E++] = y + e * (a + 1) + t,
                        h[E++] = y + e * (a + 1) + t + (a + 1),
                        h[E++] = y + e * (a + 1) + t + 1,
                        h[E++] = y + e * (a + 1) + t,
                        h[E++] = y + e * (a + 1) + t + a,
                        h[E++] = y + e * (a + 1) + t + (a + 1));
                for (y += (i + 1) * (a + 1),
                t = 0; t <= a; t++)
                    m = r * Math.cos(t * d + Math.PI),
                    p = f,
                    v = r * Math.sin(t * d + Math.PI),
                    c[T++] = m,
                    c[T + 8 * (a + 1) - 1] = m,
                    c[T++] = p,
                    c[T + 8 * (a + 1) - 1] = -p,
                    c[T++] = v,
                    c[T + 8 * (a + 1) - 1] = v,
                    c[T++] = m,
                    c[T + 8 * (a + 1) - 1] = m,
                    c[T++] = 0,
                    c[T + 8 * (a + 1) - 1] = 0,
                    c[T++] = v,
                    c[T + 8 * (a + 1) - 1] = v,
                    c[T++] = 1 - 1 * t / a,
                    c[T + 8 * (a + 1) - 1] = 1 - 1 * t / a,
                    c[T++] = Math.PI * r / 2 / (n + Math.PI * r),
                    c[T + 8 * (a + 1) - 1] = (Math.PI * r / 2 + n) / (n + Math.PI * r);
                for (t = 0; t < a; t++)
                    h[E++] = t + y + (a + 1),
                    h[E++] = t + y + 1,
                    h[E++] = t + y,
                    h[E++] = t + y + (a + 1),
                    h[E++] = t + y + (a + 1) + 1,
                    h[E++] = t + y + 1;
                return y += 2 * (a + 1),
                PrimitiveMesh._createMesh(l, c, h);
            }
        }, {
            key: "createCone",
            value: function() {
                for (var e, t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : .5, r = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1, n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 32, i = n + 1 + 1 + 2 * (n + 1), a = 6 * n + 3 * n, s = ue.getVertexDeclaration("POSITION,NORMAL,UV"), l = s.vertexStride / 4, u = new Float32Array(i * l), c = new Uint16Array(a), h = 2 * Math.PI / n, _ = r / 2, d = 0, m = 0, p = 0, v = 0, T = 0, E = new o(), y = new o(0,-1,0), g = new o(0,_,0), S = new o(), R = new o(), C = new f(), M = new o(), D = 0, x = 0, A = 0; A <= n; A++)
                    d = A * h,
                    p = Math.cos(d + Math.PI) * t,
                    v = _,
                    T = Math.sin(d + Math.PI) * t,
                    u[D++] = 0,
                    u[D + 8 * (n + 1) - 1] = p,
                    u[D++] = v,
                    u[D + 8 * (n + 1) - 1] = -v,
                    u[D++] = 0,
                    u[D + 8 * (n + 1) - 1] = T,
                    E.x = p,
                    E.y = 0,
                    E.z = T,
                    S.x = p,
                    S.y = -v,
                    S.z = T,
                    o.subtract(S, g, R),
                    o.normalize(R, R),
                    e = Math.acos(o.dot(y, R)),
                    o.cross(y, R, M),
                    o.normalize(M, M),
                    f.createFromAxisAngle(M, e, C),
                    o.normalize(E, E),
                    o.transformQuat(E, C, E),
                    o.normalize(E, E),
                    u[D++] = E.x,
                    u[D + 8 * (n + 1) - 1] = E.x,
                    u[D++] = E.y,
                    u[D + 8 * (n + 1) - 1] = E.y,
                    u[D++] = E.z,
                    u[D + 8 * (n + 1) - 1] = E.z,
                    u[D++] = 1 - 1 * A / n,
                    u[D + 8 * (n + 1) - 1] = 1 - 1 * A / n,
                    u[D++] = 0,
                    u[D + 8 * (n + 1) - 1] = 1;
                D += 8 * (n + 1);
                for (var I = 0; I < n; I++)
                    c[x++] = I + m + (n + 1),
                    c[x++] = I + m + 1,
                    c[x++] = I + m,
                    c[x++] = I + m + (n + 1),
                    c[x++] = I + m + (n + 1) + 1,
                    c[x++] = I + m + 1;
                m += 2 * (n + 1);
                for (var L = 0; L <= n; L++)
                    0 === L && (u[D++] = 0,
                    u[D++] = -_,
                    u[D++] = 0,
                    u[D++] = 0,
                    u[D++] = -1,
                    u[D++] = 0,
                    u[D++] = .5,
                    u[D++] = .5),
                    d = L * h,
                    p = Math.cos(d + Math.PI) * t,
                    v = -_,
                    T = Math.sin(d + Math.PI) * t,
                    u[D++] = p,
                    u[D++] = v,
                    u[D++] = T,
                    u[D++] = 0,
                    u[D++] = -1,
                    u[D++] = 0,
                    u[D++] = .5 + .5 * Math.cos(d),
                    u[D++] = .5 + .5 * Math.sin(d);
                for (var P = 0; P < n; P++)
                    c[x++] = 0 + m,
                    c[x++] = P + 2 + m,
                    c[x++] = P + 1 + m;
                return m += n + 1 + 1,
                PrimitiveMesh._createMesh(s, u, c);
            }
        }, {
            key: "createCylinder",
            value: function() {
                for (var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : .5, t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 2, r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 32, n = r + 1 + 1 + 2 * (r + 1) + (r + 1 + 1), i = 3 * r + 6 * r + 3 * r, a = ue.getVertexDeclaration("POSITION,NORMAL,UV"), o = a.vertexStride / 4, s = new Float32Array(n * o), l = new Uint16Array(i), u = 2 * Math.PI / r, c = t / 2, h = 0, _ = 0, d = 0, f = 0, m = 0, p = 0, v = 0, T = 0; T <= r; T++)
                    0 === T && (s[p++] = 0,
                    s[p++] = c,
                    s[p++] = 0,
                    s[p++] = 0,
                    s[p++] = 1,
                    s[p++] = 0,
                    s[p++] = .5,
                    s[p++] = .5),
                    h = T * u,
                    d = Math.cos(h) * e,
                    f = c,
                    m = Math.sin(h) * e,
                    s[p++] = d,
                    s[p++] = f,
                    s[p++] = m,
                    s[p++] = 0,
                    s[p++] = 1,
                    s[p++] = 0,
                    s[p++] = .5 + .5 * Math.cos(h),
                    s[p++] = .5 + .5 * Math.sin(h);
                for (var E = 0; E < r; E++)
                    l[v++] = 0,
                    l[v++] = E + 1,
                    l[v++] = E + 2;
                _ += r + 1 + 1;
                for (var y = 0; y <= r; y++)
                    h = y * u,
                    d = Math.cos(h + Math.PI) * e,
                    f = c,
                    m = Math.sin(h + Math.PI) * e,
                    s[p++] = d,
                    s[p + 8 * (r + 1) - 1] = d,
                    s[p++] = f,
                    s[p + 8 * (r + 1) - 1] = -f,
                    s[p++] = m,
                    s[p + 8 * (r + 1) - 1] = m,
                    s[p++] = d,
                    s[p + 8 * (r + 1) - 1] = d,
                    s[p++] = 0,
                    s[p + 8 * (r + 1) - 1] = 0,
                    s[p++] = m,
                    s[p + 8 * (r + 1) - 1] = m,
                    s[p++] = 1 - 1 * y / r,
                    s[p + 8 * (r + 1) - 1] = 1 - 1 * y / r,
                    s[p++] = 0,
                    s[p + 8 * (r + 1) - 1] = 1;
                p += 8 * (r + 1);
                for (var g = 0; g < r; g++)
                    l[v++] = g + _ + (r + 1),
                    l[v++] = g + _ + 1,
                    l[v++] = g + _,
                    l[v++] = g + _ + (r + 1),
                    l[v++] = g + _ + (r + 1) + 1,
                    l[v++] = g + _ + 1;
                _ += 2 * (r + 1);
                for (var S = 0; S <= r; S++)
                    0 === S && (s[p++] = 0,
                    s[p++] = -c,
                    s[p++] = 0,
                    s[p++] = 0,
                    s[p++] = -1,
                    s[p++] = 0,
                    s[p++] = .5,
                    s[p++] = .5),
                    h = S * u,
                    d = Math.cos(h + Math.PI) * e,
                    f = -c,
                    m = Math.sin(h + Math.PI) * e,
                    s[p++] = d,
                    s[p++] = f,
                    s[p++] = m,
                    s[p++] = 0,
                    s[p++] = -1,
                    s[p++] = 0,
                    s[p++] = .5 + .5 * Math.cos(h),
                    s[p++] = .5 + .5 * Math.sin(h);
                for (var R = 0; R < r; R++)
                    l[v++] = 0 + _,
                    l[v++] = R + 2 + _,
                    l[v++] = R + 1 + _;
                return _ += r + 1 + 1,
                PrimitiveMesh._createMesh(a, s, l);
            }
        }, {
            key: "createPlane",
            value: function() {
                for (var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 10, t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 10, r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 10, n = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 10, i = (r + 1) * (n + 1), a = new Uint16Array(r * n * 2 * 3), o = ue.getVertexDeclaration("POSITION,NORMAL,UV"), s = o.vertexStride / 4, l = new Float32Array(i * s), u = e / 2, c = t / 2, h = e / r, _ = t / n, d = 0, f = 0; f <= n; f++)
                    for (var m = 0; m <= r; m++)
                        l[d++] = m * h - u,
                        l[d++] = 0,
                        l[d++] = f * _ - c,
                        l[d++] = 0,
                        l[d++] = 1,
                        l[d++] = 0,
                        l[d++] = 1 * m / r,
                        l[d++] = 1 * f / n;
                var p = 0;
                for (f = 0; f < n; f++)
                    for (m = 0; m < r; m++)
                        a[p++] = (f + 1) * (r + 1) + m,
                        a[p++] = f * (r + 1) + m,
                        a[p++] = (f + 1) * (r + 1) + m + 1,
                        a[p++] = f * (r + 1) + m,
                        a[p++] = f * (r + 1) + m + 1,
                        a[p++] = (f + 1) * (r + 1) + m + 1;
                return PrimitiveMesh._createMesh(o, l, a);
            }
        }, {
            key: "createQuad",
            value: function() {
                var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 1
                  , t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1
                  , r = ue.getVertexDeclaration("POSITION,NORMAL,UV")
                  , n = e / 2
                  , i = t / 2
                  , a = new Float32Array([-n, i, 0, 0, 0, 1, 0, 0, n, i, 0, 0, 0, 1, 1, 0, -n, -i, 0, 0, 0, 1, 0, 1, n, -i, 0, 0, 0, 1, 1, 1])
                  , o = new Uint16Array([0, 1, 2, 3, 2, 1]);
                return PrimitiveMesh._createMesh(r, a, o);
            }
        }, {
            key: "createSphere",
            value: function() {
                var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : .5
                  , t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 32
                  , r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 32
                  , n = (t + 1) * (r + 1)
                  , i = 3 * t * (r + 1) * 2
                  , a = new Uint16Array(i)
                  , o = ue.getVertexDeclaration("POSITION,NORMAL,UV")
                  , s = o.vertexStride / 4
                  , l = new Float32Array(n * s)
                  , u = Math.PI / t
                  , c = 2 * Math.PI / r
                  , h = 0;
                n = 0,
                i = 0;
                for (var _ = 0; _ < t + 1; _++)
                    for (var d = Math.sin(_ * u), f = Math.cos(_ * u), m = 0; m < r + 1; m++) {
                        var p = d * Math.sin(m * c + 1 * Math.PI / 2)
                          , v = d * Math.cos(m * c + 1 * Math.PI / 2);
                        l[n + 0] = p * e,
                        l[n + 1] = f * e,
                        l[n + 2] = v * e,
                        l[n + 3] = p,
                        l[n + 4] = f,
                        l[n + 5] = v,
                        l[n + 6] = m / r,
                        l[n + 7] = _ / t,
                        n += s,
                        _ != t - 1 && (a[i++] = h + (r + 1),
                        a[i++] = h,
                        a[i++] = h + 1,
                        a[i++] = h + r,
                        a[i++] = h,
                        a[i++] = h + (r + 1),
                        h++);
                    }
                return PrimitiveMesh._createMesh(o, l, a);
            }
        }]),
        PrimitiveMesh;
    }()
      , rn = '#include "Lighting.glsl";\r\n\r\nattribute vec4 a_PositionTexcoord;\r\nvarying vec2 v_Texcoord0;\r\n\r\nvoid main() {\r\n\tgl_Position = vec4(a_PositionTexcoord.xy, 0.0, 1.0);\r\n\tv_Texcoord0 = a_PositionTexcoord.zw;\r\n\tgl_Position = remapGLPositionZ(gl_Position);\r\n}'
      , nn = function() {
        function ShaderInit3D() {
            _classCallCheck(this, ShaderInit3D);
        }
        return _createClass(ShaderInit3D, null, [{
            key: "__init__",
            value: function() {
                G.SHADERDEFINE_LEGACYSINGALLIGHTING = G.getDefineByName("LEGACYSINGLELIGHTING"),
                G.addInclude("Lighting.glsl", "struct DirectionLight {\r\n\tvec3 color;\r\n\tvec3 direction;\r\n};\r\n\r\nstruct PointLight {\r\n\tvec3 color;\r\n\tvec3 position;\r\n\tfloat range;\r\n};\r\n\r\nstruct SpotLight {\r\n\tvec3 color;\r\n\tvec3 position;\r\n\tfloat range;\r\n\tvec3 direction;\r\n\tfloat spot;\r\n};\r\n\r\nstruct LayaGI{\r\n\tvec3 diffuse;\r\n\tvec3 specular;\r\n};\r\n\r\nstruct LayaLight{\r\n\tvec3 color;\r\n\tvec3 dir;\r\n};\r\n\r\nconst int c_ClusterBufferWidth = CLUSTER_X_COUNT*CLUSTER_Y_COUNT;\r\nconst int c_ClusterBufferHeight = CLUSTER_Z_COUNT*(1+int(ceil(float(MAX_LIGHT_COUNT_PER_CLUSTER)/4.0)));\r\nconst int c_ClusterBufferFloatWidth = c_ClusterBufferWidth*4;\r\n\r\nivec4 getClusterInfo(sampler2D clusterBuffer,mat4 viewMatrix,vec4 viewport,vec3 position,vec4 fragCoord,vec4 projectParams)\r\n{\r\n\tvec3 viewPos = vec3(viewMatrix*vec4(position, 1.0)); //position in viewspace\r\n\r\n\tint clusterXIndex = int(floor(fragCoord.x/ (float(viewport.z)/float(CLUSTER_X_COUNT))));\r\n    int clusterYIndex = int(floor((viewport.w * (projectParams.z <0.0? 0.0 : 1.0) - fragCoord.y * projectParams.z)/ (float(viewport.w)/float(CLUSTER_Y_COUNT))));//Maybe Flipped ProjectMatrix\r\n\tfloat zSliceParam =float(CLUSTER_Z_COUNT)/log2(projectParams.y / projectParams.x);\r\n \tint clusterZIndex = int(floor(log2(-viewPos.z) * zSliceParam- log2(projectParams.x) * zSliceParam));//projectParams x:cameraNear y:cameraFar\r\n\r\n\tvec2 uv= vec2((float(clusterXIndex + clusterYIndex * CLUSTER_X_COUNT)+0.5)/float(c_ClusterBufferWidth),\r\n\t\t\t\t(float(clusterZIndex)+0.5)/float(c_ClusterBufferHeight));\r\n\tvec4 clusterPixel=texture2D(clusterBuffer, uv);\r\n\treturn ivec4(clusterPixel);//X:Point Count Y:Spot Count Z、W:Light Offset\r\n}\r\n\r\n\r\nint getLightIndex(sampler2D clusterBuffer,int offset,int index) \r\n{\r\n\tint totalOffset=offset+index;\r\n\tint row=totalOffset/c_ClusterBufferFloatWidth;\r\n\tint lastRowFloat=totalOffset-row*c_ClusterBufferFloatWidth;\r\n\tint col=lastRowFloat/4;\r\n\tvec2 uv=vec2((float(col)+0.5)/float(c_ClusterBufferWidth),\r\n\t\t\t\t(float(row)+0.5)/float(c_ClusterBufferHeight));\r\n\tvec4 texel = texture2D(clusterBuffer, uv);\r\n    int pixelComponent = lastRowFloat-col*4;\r\n    if (pixelComponent == 0) \r\n      return int(texel.x);\r\n    else if (pixelComponent == 1) \r\n      return int(texel.y);\r\n    else if (pixelComponent == 2) \r\n      return int(texel.z);\r\n    else if (pixelComponent == 3) \r\n      return int(texel.w);\r\n}\r\n\r\nDirectionLight getDirectionLight(sampler2D lightBuffer,int index) \r\n{\r\n    DirectionLight light;\r\n    float v = (float(index)+0.5)/ float(MAX_LIGHT_COUNT);\r\n    vec4 p1 = texture2D(lightBuffer, vec2(0.125,v));\r\n    vec4 p2 = texture2D(lightBuffer, vec2(0.375,v));\r\n\tlight.color=p1.rgb;\r\n    light.direction = p2.rgb;\r\n    return light;\r\n}\r\n\r\nPointLight getPointLight(sampler2D lightBuffer,sampler2D clusterBuffer,ivec4 clusterInfo,int index) \r\n{\r\n    PointLight light;\r\n\tint pointIndex=getLightIndex(clusterBuffer,clusterInfo.z*c_ClusterBufferFloatWidth+clusterInfo.w,index);\r\n    float v = (float(pointIndex)+0.5)/ float(MAX_LIGHT_COUNT);\r\n    vec4 p1 = texture2D(lightBuffer, vec2(0.125,v));\r\n    vec4 p2 = texture2D(lightBuffer, vec2(0.375,v));\r\n\tlight.color=p1.rgb;\r\n\tlight.range = p1.a;\r\n    light.position = p2.rgb;\r\n    return light;\r\n}\r\n\r\nSpotLight getSpotLight(sampler2D lightBuffer,sampler2D clusterBuffer,ivec4 clusterInfo,int index) \r\n{\r\n    SpotLight light;\r\n\tint spoIndex=getLightIndex(clusterBuffer,clusterInfo.z*c_ClusterBufferFloatWidth+clusterInfo.w,clusterInfo.x+index);\r\n    float v = (float(spoIndex)+0.5)/ float(MAX_LIGHT_COUNT);\r\n    vec4 p1 = texture2D(lightBuffer, vec2(0.125,v));\r\n    vec4 p2 = texture2D(lightBuffer, vec2(0.375,v));\r\n\tvec4 p3 = texture2D(lightBuffer, vec2(0.625,v));\r\n    light.color = p1.rgb;\r\n\tlight.range=p1.a;\r\n    light.position = p2.rgb;\r\n\tlight.spot = p2.a;\r\n\tlight.direction = p3.rgb;\r\n    return light;\r\n}\r\n\r\n// Laya中使用衰减纹理\r\nfloat LayaAttenuation(in vec3 L,in float invLightRadius) {\r\n\tfloat fRatio = clamp(length(L) * invLightRadius,0.0,1.0);\r\n\tfRatio *= fRatio;\r\n\treturn 1.0 / (1.0 + 25.0 * fRatio)* clamp(4.0*(1.0 - fRatio),0.0,1.0); //fade to black as if 4 pixel texture\r\n}\r\n\r\n// Same as Just Cause 2 and Crysis 2 (you can read GPU Pro 1 book for more information)\r\nfloat BasicAttenuation(in vec3 L,in float invLightRadius) {\r\n\tvec3 distance = L * invLightRadius;\r\n\tfloat attenuation = clamp(1.0 - dot(distance, distance),0.0,1.0); // Equals float attenuation = saturate(1.0f - dot(L, L) / (lightRadius *  lightRadius));\r\n\treturn attenuation * attenuation;\r\n}\r\n\r\n// Inspired on http://fools.slindev.com/viewtopic.php?f=11&t=21&view=unread#unread\r\nfloat NaturalAttenuation(in vec3 L,in float invLightRadius) {\r\n\tfloat attenuationFactor = 30.0;\r\n\tvec3 distance = L * invLightRadius;\r\n\tfloat attenuation = dot(distance, distance); // Equals float attenuation = dot(L, L) / (lightRadius *  lightRadius);\r\n\tattenuation = 1.0 / (attenuation * attenuationFactor + 1.0);\r\n\t// Second we move down the function therewith it reaches zero at abscissa 1:\r\n\tattenuationFactor = 1.0 / (attenuationFactor + 1.0); //attenuationFactor contains now the value we have to subtract\r\n\tattenuation = max(attenuation - attenuationFactor, 0.0); // The max fixes a bug.\r\n\t// Finally we expand the equation along the y-axis so that it starts with a function value of 1 again.\r\n\tattenuation /= 1.0 - attenuationFactor;\r\n\treturn attenuation;\r\n}\r\n\r\nvoid LayaAirBlinnPhongLight (in vec3 specColor,in float specColorIntensity,in vec3 normal,in vec3 gloss, in vec3 viewDir,in vec3 lightColor, in vec3 lightVec,out vec3 diffuseColor,out vec3 specularColor) {\r\n\tmediump vec3 h = normalize(viewDir-lightVec);\r\n\tlowp float ln = max (0.0, dot (-lightVec,normal));\r\n\tfloat nh = max (0.0, dot (h,normal));\r\n\tdiffuseColor=lightColor * ln;\r\n\tspecularColor=lightColor *specColor*pow (nh, specColorIntensity*128.0) * gloss;\r\n}\r\n\r\nvoid LayaAirBlinnPhongDiectionLight (in vec3 specColor,in float specColorIntensity,in vec3 normal,in vec3 gloss, in vec3 viewDir, in DirectionLight light,out vec3 diffuseColor,out vec3 specularColor) {\r\n\tvec3 lightVec=normalize(light.direction);\r\n\tLayaAirBlinnPhongLight(specColor,specColorIntensity,normal,gloss,viewDir,light.color,lightVec,diffuseColor,specularColor);\r\n}\r\n\r\nvoid LayaAirBlinnPhongPointLight (in vec3 pos,in vec3 specColor,in float specColorIntensity,in vec3 normal,in vec3 gloss, in vec3 viewDir, in PointLight light,out vec3 diffuseColor,out vec3 specularColor) {\r\n\tvec3 lightVec =  pos-light.position;\r\n\tLayaAirBlinnPhongLight(specColor,specColorIntensity,normal,gloss,viewDir,light.color,lightVec/length(lightVec),diffuseColor,specularColor);\r\n\tfloat attenuate = LayaAttenuation(lightVec, 1.0/light.range);\r\n\tdiffuseColor *= attenuate;\r\n\tspecularColor*= attenuate;\r\n}\r\n\r\nvoid LayaAirBlinnPhongSpotLight (in vec3 pos,in vec3 specColor,in float specColorIntensity,in vec3 normal,in vec3 gloss, in vec3 viewDir, in SpotLight light,out vec3 diffuseColor,out vec3 specularColor) {\r\n\tvec3 lightVec =  pos-light.position;\r\n\tvec3 normalLightVec=lightVec/length(lightVec);\r\n\tLayaAirBlinnPhongLight(specColor,specColorIntensity,normal,gloss,viewDir,light.color,normalLightVec,diffuseColor,specularColor);\r\n\tvec2 cosAngles=cos(vec2(light.spot,light.spot*0.5)*0.5);//ConeAttenuation\r\n\tfloat dl=dot(normalize(light.direction),normalLightVec);\r\n\tdl*=smoothstep(cosAngles[0],cosAngles[1],dl);\r\n\tfloat attenuate = LayaAttenuation(lightVec, 1.0/light.range)*dl;\r\n\tdiffuseColor *=attenuate;\r\n\tspecularColor *=attenuate;\r\n}\r\n\r\nvec3 NormalSampleToWorldSpace(vec3 normalMapSample, vec3 unitNormal, vec3 tangent,vec3 binormal) {\r\n\tvec3 normalT =vec3(2.0*normalMapSample.x - 1.0,1.0-2.0*normalMapSample.y,2.0*normalMapSample.z - 1.0);\r\n\tmediump vec3 N = unitNormal;\r\n\tmediump vec3 T = tangent;\r\n\tmediump vec3 B = binormal;\r\n\tmat3 TBN = mat3(T, B, N);\r\n\r\n\t// Transform from tangent space to world space.\r\n\tvec3 bumpedNormal =normalize(TBN*normalT);\r\n\treturn bumpedNormal;\r\n}\r\n\r\nvec3 NormalSampleToWorldSpace1(vec4 normalMapSample, vec3 tangent, vec3 binormal, vec3 unitNormal) {\r\n\tvec3 normalT;\r\n\tnormalT.x = 2.0 * normalMapSample.x - 1.0;\r\n\tnormalT.y = 1.0 - 2.0 * normalMapSample.y;\r\n\tnormalT.z = sqrt(1.0 - clamp(dot(normalT.xy, normalT.xy), 0.0, 1.0));\r\n\r\n\tvec3 T = normalize(tangent);\r\n\tvec3 B = normalize(binormal);\r\n\tvec3 N = normalize(unitNormal);\r\n\tmat3 TBN = mat3(T, B, N);\r\n\r\n\t// Transform from tangent space to world space.\r\n\tvec3 bumpedNormal = TBN * normalize(normalT);\r\n\r\n\treturn bumpedNormal;\r\n}\r\n\r\nvec3 DecodeLightmap(vec4 color) {\r\n\treturn color.rgb*color.a*5.0;\r\n}\r\n\r\nvec3 decodeHDR(vec4 color,float range) {\r\n\treturn color.rgb*color.a*range;\r\n}\r\n\r\nvec2 TransformUV(vec2 texcoord,vec4 tilingOffset) {\r\n\tvec2 transTexcoord=vec2(texcoord.x,texcoord.y-1.0)*tilingOffset.xy+vec2(tilingOffset.z,-tilingOffset.w);\r\n\ttransTexcoord.y+=1.0;\r\n\treturn transTexcoord;\r\n}\r\n\r\nvec4 remapGLPositionZ(vec4 position) {\r\n\tposition.z=position.z * 2.0 - position.w;\r\n\treturn position;\r\n}\r\n\r\nmat3 inverseMat(mat3 m) {\r\n  float a00 = m[0][0], a01 = m[0][1], a02 = m[0][2];\r\n  float a10 = m[1][0], a11 = m[1][1], a12 = m[1][2];\r\n  float a20 = m[2][0], a21 = m[2][1], a22 = m[2][2];\r\n\r\n  float b01 = a22 * a11 - a12 * a21;\r\n  float b11 = -a22 * a10 + a12 * a20;\r\n  float b21 = a21 * a10 - a11 * a20;\r\n\r\n  float det = a00 * b01 + a01 * b11 + a02 * b21;\r\n\r\n  return mat3(b01, (-a22 * a01 + a02 * a21), (a12 * a01 - a02 * a11),\r\n              b11, (a22 * a00 - a02 * a20), (-a12 * a00 + a02 * a10),\r\n              b21, (-a21 * a00 + a01 * a20), (a11 * a00 - a01 * a10)) / det;\r\n}\r\n\r\nmediump vec3 layaLinearToGammaSpace (mediump vec3 linRGB)\r\n{\r\n    linRGB = max(linRGB, vec3(0.0));\r\n    // An almost-perfect approximation from http://chilliant.blogspot.com.au/2012/08/srgb-approximations-for-hlsl.html?m=1\r\n    return max(1.055 * pow(linRGB,vec3(0.416666667)) - 0.055, 0.0);   \r\n}\r\n\r\nLayaLight layaDirectionLightToLight(in DirectionLight light,in float attenuate)\r\n{\r\n\tLayaLight relight;\r\n\trelight.color = light.color*attenuate;\r\n\trelight.dir = light.direction;\r\n\treturn relight;\r\n}\r\n\r\nLayaLight layaPointLightToLight(in vec3 pos,in vec3 normal, in PointLight light,in float attenuate)\r\n{\r\n\tLayaLight relight;\r\n\tvec3 lightVec =  pos-light.position;\r\n\tattenuate *= LayaAttenuation(lightVec, 1.0/light.range);\r\n\trelight.color = light.color*attenuate;\r\n\trelight.dir = normalize(lightVec);\r\n\treturn relight;\r\n}\r\n\r\nLayaLight layaSpotLightToLight(in vec3 pos,in vec3 normal, in SpotLight light,in float attenuate)\r\n{\r\n\tLayaLight relight;\r\n\tvec3 lightVec =  pos-light.position;\r\n\tvec3 normalLightVec=lightVec/length(lightVec);\r\n\tvec2 cosAngles=cos(vec2(light.spot,light.spot*0.5)*0.5);//ConeAttenuation\r\n\tfloat dl=dot(normalize(light.direction),normalLightVec);\r\n\tdl*=smoothstep(cosAngles[0],cosAngles[1],dl);\r\n\tattenuate *= LayaAttenuation(lightVec, 1.0/light.range)*dl;\r\n\trelight.dir = lightVec;\r\n\trelight.color = light.color*attenuate;\r\n\treturn relight;\r\n}\r\n\r\n"),
                G.addInclude("GlobalIllumination.glsl", 'struct LayaGIInput\r\n{\r\n\tvec2 lightmapUV;\r\n};\r\n\r\n#define LAYA_SPECCUBE_LOD_STEPS 6.0\r\n\r\nuniform vec3 u_AmbientColor;\r\n\r\n#if defined(GI_AMBIENT_SH)\r\n\tuniform vec4 u_AmbientSHAr;\r\n\tuniform vec4 u_AmbientSHAg;\r\n\tuniform vec4 u_AmbientSHAb;\r\n\tuniform vec4 u_AmbientSHBr;\r\n\tuniform vec4 u_AmbientSHBg;\r\n\tuniform vec4 u_AmbientSHBb;\r\n\tuniform vec4 u_AmbientSHC;\r\n#endif\r\n\r\nuniform samplerCube u_ReflectTexture;\r\nuniform vec4 u_ReflectCubeHDRParams;\r\n\r\n\r\n#ifdef GI_AMBIENT_SH\r\n\tmediump vec3 shEvalLinearL0L1(mediump vec4 normal)\r\n\t{\r\n\t\tmediump vec3 x;\r\n\t\t// Linear (L1) + constant (L0) polynomial terms\r\n\t\tx.r = dot(u_AmbientSHAr, normal);\r\n\t\tx.g = dot(u_AmbientSHAg, normal);\r\n\t\tx.b = dot(u_AmbientSHAb, normal);\r\n\t\treturn x;\r\n\t}\r\n\r\n\tmediump vec3 shEvalLinearL2(mediump vec4 normal)\r\n\t{\r\n\t\tmediump vec3 x1,x2;\r\n\t\t// 4 of the quadratic (L2) polynomials\r\n\t\tmediump vec4 vB = normal.xyzz * normal.yzzx;\r\n\t\tx1.r = dot(u_AmbientSHBr, vB);\r\n\t\tx1.g = dot(u_AmbientSHBg, vB);\r\n\t\tx1.b = dot(u_AmbientSHBb, vB);\r\n\r\n\t\t// Final (5th) quadratic (L2) polynomial\r\n\t\tmediump float vC = normal.x*normal.x - normal.y*normal.y;\r\n\t\tx2 = u_AmbientSHC.rgb * vC;\r\n\r\n\t\treturn x1 + x2;\r\n\t}\r\n\t\r\n\tmediump vec3 shadeSHPerPixel(mediump vec3 normal)\r\n\t{\r\n\t\tmediump vec3 ambientContrib;\r\n\t\tmediump vec4 normalV4=vec4(-normal.x,normal.yz, 1.0);//Note:SH Data is left-hand,so x need inverse\r\n\t\tambientContrib = shEvalLinearL0L1(normalV4);\r\n\t\tambientContrib += shEvalLinearL2(normalV4);\r\n\t\tmediump vec3 ambient = max(vec3(0.0), ambientContrib);\r\n\t\tambient = layaLinearToGammaSpace(ambient);\r\n\t\treturn ambient;\r\n\t}\r\n#endif\r\n\r\n\r\nvec3 layaGIBase(LayaGIInput giInput,mediump float occlusion, mediump vec3 normalWorld)\r\n{\r\n\tvec3 indirectDiffuse;\r\n\t#ifdef LIGHTMAP\t\r\n\t\tindirectDiffuse =decodeHDR(texture2D(u_LightMap, giInput.lightmapUV),5.0);\r\n\t#else\r\n\t\t#ifdef GI_AMBIENT_SH\r\n\t\t\tindirectDiffuse = shadeSHPerPixel(normalWorld);\r\n\t\t#else\r\n\t\t\tindirectDiffuse = u_AmbientColor;//already in gamma space\r\n\t\t#endif\r\n\t#endif\r\n\r\n\tindirectDiffuse*=occlusion;\r\n\treturn indirectDiffuse;\r\n}\r\n\r\nmediump vec3 layaGlossyEnvironment(mediump vec4 glossIn)\r\n{\r\n\tmediump float perceptualRoughness = glossIn.a;\r\n\r\n\t// use approximation to solve,below is more reasonable,but maybe slow. \r\n\t// float m = perceptualRoughnessToRoughness(perceptualRoughness); // m is the real roughness parameter\r\n    // const float fEps = 1.192092896e-07F;        // smallest such that 1.0+FLT_EPSILON != 1.0  (+1e-4h is NOT good here. is visibly very wrong)\r\n    // float n =  (2.0/max(fEps, m*m))-2.0;        // remap to spec power. See eq. 21 in --\x3e https://dl.dropboxusercontent.com/u/55891920/papers/mm_brdf.pdf\r\n    // n /= 4;                                     // remap from n_dot_h formulatino to n_dot_r. See section "Pre-convolved Cube Maps vs Path Tracers" --\x3e https://s3.amazonaws.com/docs.knaldtech.com/knald/1.0.0/lys_power_drops.html\r\n    // perceptualRoughness = pow( 2/(n+2), 0.25);  // remap back to square root of real roughness (0.25 include both the sqrt root of the conversion and sqrt for going from roughness to perceptualRoughness)\r\n\tperceptualRoughness = perceptualRoughness * (1.7 - 0.7*perceptualRoughness);//just a approximation,but fast.\r\n \r\n\tmediump float mip = perceptualRoughness * LAYA_SPECCUBE_LOD_STEPS;\r\n\tmediump vec3 uvw = glossIn.rgb;\r\n\tuvw.x=-uvw.x;//Note:reflectCube is left-hand,so x need inverse\r\n\tmediump vec4 rgbm=textureCubeLodEXT(u_ReflectTexture,uvw,mip);\r\n\treturn decodeHDR(rgbm,u_ReflectCubeHDRParams.x);\r\n}\r\n\r\nmediump vec3 layaGIIndirectSpecular(LayaGIInput giInput,mediump float occlusion, vec4 glossIn)\r\n{\r\n\tmediump vec3 specular = layaGlossyEnvironment(glossIn);\r\n\treturn specular * occlusion;\r\n}\r\n\r\n\r\nLayaGI layaGlobalIllumination(LayaGIInput giInput,mediump float occlusion, mediump vec3 normalWorld,mediump vec4 uvwRoughness)\r\n{\r\n\tLayaGI gi;\r\n\tgi.diffuse = layaGIBase(giInput,occlusion, normalWorld);\r\n\tgi.specular = layaGIIndirectSpecular(giInput,occlusion, uvwRoughness);\r\n\treturn gi;\r\n}\r\n\r\n\r\n\r\n'),
                G.addInclude("ShadowHelper.glsl", "uniform sampler2D u_shadowMap1;\r\nuniform sampler2D u_shadowMap2;\r\nuniform sampler2D u_shadowMap3;\r\nuniform vec2\t  u_shadowPCFoffset;\r\nuniform vec4     u_shadowPSSMDistance;\r\nvec4 packDepth(const in float depth)\r\n{\r\n\tconst vec4 bitShift = vec4(256.0*256.0*256.0, 256.0*256.0, 256.0, 1.0);\r\n\tconst vec4 bitMask\t= vec4(0.0, 1.0/256.0, 1.0/256.0, 1.0/256.0);\r\n\tvec4 res = mod(depth*bitShift*vec4(255), vec4(256))/vec4(255);\r\n\tres -= res.xxyz * bitMask;\r\n\treturn res;\r\n}\r\nfloat unpackDepth(const in vec4 rgbaDepth)\r\n{\r\n\tconst vec4 bitShift = vec4(1.0/(256.0*256.0*256.0), 1.0/(256.0*256.0), 1.0/256.0, 1.0);\r\n\tfloat depth = dot(rgbaDepth, bitShift);\r\n\treturn depth;\r\n}\r\nfloat tex2DPCF( sampler2D shadowMap,vec2 texcoord,vec2 invsize,float zRef )\r\n{\r\n\tvec2 texelpos =texcoord / invsize;\r\n\tvec2 lerps = fract( texelpos );\r\n\tfloat sourcevals[4];\r\n\tsourcevals[0] = float( unpackDepth(texture2D(shadowMap,texcoord)) > zRef );\r\n\tsourcevals[1] = float( unpackDepth(texture2D(shadowMap,texcoord + vec2(invsize.x,0))) > zRef );\r\n\tsourcevals[2] = float( unpackDepth(texture2D(shadowMap,texcoord + vec2(0,invsize.y))) > zRef );\r\n\tsourcevals[3] = float( unpackDepth(texture2D(shadowMap,texcoord + vec2(invsize.x, invsize.y) )) > zRef );\r\n\treturn mix( mix(sourcevals[0],sourcevals[2],lerps.y),mix(sourcevals[1],sourcevals[3],lerps.y),lerps.x );\r\n}\r\nfloat getShadowPSSM3( sampler2D shadowMap1,sampler2D shadowMap2,sampler2D shadowMap3,mat4 lightShadowVP[4],vec4 pssmDistance,vec2 shadowPCFOffset,vec3 worldPos,float posViewZ,float zBias )\r\n{\r\n\tfloat value = 1.0;\r\n\tint nPSNum = int(posViewZ>pssmDistance.x);\r\n\tnPSNum += int(posViewZ>pssmDistance.y);\r\n\tnPSNum += int(posViewZ>pssmDistance.z);\r\n\t//真SB,webgl不支持在PS中直接访问数组\r\n\tmat4 lightVP;\r\n\tif( nPSNum == 0 )\r\n\t{\r\n\t\tlightVP = lightShadowVP[1];\r\n\t}\r\n\telse if( nPSNum == 1 )\r\n\t{\r\n\t\tlightVP = lightShadowVP[2];\r\n\t}\r\n\telse if( nPSNum == 2 )\r\n\t{\r\n\t\tlightVP = lightShadowVP[3];\r\n\t}\r\n\tvec4 vLightMVPPos = lightVP * vec4(worldPos,1.0);\r\n\t//为了效率，在CPU计算/2.0 + 0.5\r\n\t//vec3 vText = (vLightMVPPos.xyz / vLightMVPPos.w)/2.0 + 0.5;\r\n\tvec3 vText = vLightMVPPos.xyz / vLightMVPPos.w;\r\n\tfloat fMyZ = vText.z - zBias;\r\n\t/*\r\n\tbvec4 bInFrustumVec = bvec4 ( vText.x >= 0.0, vText.x <= 1.0, vText.y >= 0.0, vText.y <= 1.0 );\r\n\tbool bInFrustum = all( bInFrustumVec );\r\n\tbvec2 bFrustumTestVec = bvec2( bInFrustum, fMyZ <= 1.0 );\r\n\tbool bFrustumTest = all( bFrustumTestVec );\r\n\tif ( bFrustumTest ) \r\n\t*/\r\n\tif( fMyZ <= 1.0 )\r\n\t{\r\n\t\tfloat zdepth=0.0;\r\n#ifdef SHADOWMAP_PCF3\r\n\t\tif ( nPSNum == 0 )\r\n\t\t{\r\n\t\t\tvalue =  tex2DPCF( shadowMap1, vText.xy,shadowPCFOffset,fMyZ );\r\n\t\t\tvalue += tex2DPCF( shadowMap1, vText.xy+vec2(shadowPCFOffset.xy),shadowPCFOffset,\tfMyZ );\r\n\t\t\tvalue += tex2DPCF( shadowMap1, vText.xy+vec2(shadowPCFOffset.x,0),shadowPCFOffset,\tfMyZ );\r\n\t\t\tvalue += tex2DPCF( shadowMap1, vText.xy+vec2(0,shadowPCFOffset.y),shadowPCFOffset,\tfMyZ );\r\n\t\t\tvalue = value/4.0;\r\n\t\t} \r\n\t\telse if( nPSNum == 1 )\r\n\t\t{\r\n\t\t\tvalue = tex2DPCF( shadowMap2,vText.xy,shadowPCFOffset,fMyZ);\r\n\t\t}\r\n\t\telse if( nPSNum == 2 )\r\n\t\t{\r\n\t\t\tvec4 color = texture2D( shadowMap3,vText.xy );\r\n\t\t\tzdepth = unpackDepth(color);\r\n\t\t\tvalue = float(fMyZ < zdepth);\r\n\t\t}\r\n#endif\r\n#ifdef SHADOWMAP_PCF2\r\n\t\tif ( nPSNum == 0 )\r\n\t\t{\r\n\t\t\tvalue = tex2DPCF( shadowMap1,vText.xy,shadowPCFOffset,fMyZ);\r\n\t\t}\r\n\t\telse if( nPSNum == 1 )\r\n\t\t{\r\n\t\t\tvalue = tex2DPCF( shadowMap2,vText.xy,shadowPCFOffset,fMyZ);\r\n\t\t}\r\n\t\telse if( nPSNum == 2 )\r\n\t\t{\r\n\t\t\tvec4 color = texture2D( shadowMap3,vText.xy );\r\n\t\t\tzdepth = unpackDepth(color);\r\n\t\t\tvalue = float(fMyZ < zdepth);\r\n\t\t}\r\n\r\n#endif\r\n#ifdef SHADOWMAP_PCF1\r\n\t\tif ( nPSNum == 0 )\r\n\t\t{\r\n\t\t\tvalue = tex2DPCF( shadowMap1,vText.xy,shadowPCFOffset,fMyZ);\r\n\t\t}\r\n\t\telse if( nPSNum == 1 )\r\n\t\t{\r\n\t\t\tvec4 color = texture2D( shadowMap2,vText.xy );\r\n\t\t\tzdepth = unpackDepth(color);\r\n\t\t\tvalue = float(fMyZ < zdepth);\r\n\t\t}\r\n\t\telse if( nPSNum == 2 )\r\n\t\t{\r\n\t\t\tvec4 color = texture2D( shadowMap3,vText.xy );\r\n\t\t\tzdepth = unpackDepth(color);\r\n\t\t\tvalue = float(fMyZ < zdepth);\r\n\t\t}\r\n#endif\r\n#ifdef SHADOWMAP_PCF_NO\r\n\t\tvec4 color;\r\n\t\tif ( nPSNum == 0 )\r\n\t\t{\r\n\t\t\tcolor = texture2D( shadowMap1,vText.xy );\r\n\t\t}\r\n\t\telse if( nPSNum == 1 )\r\n\t\t{\r\n\t\t\tcolor = texture2D( shadowMap2,vText.xy );\r\n\t\t}\r\n\t\telse if( nPSNum == 2 )\r\n\t\t{\r\n\t\t\tcolor = texture2D( shadowMap3,vText.xy );\r\n\t\t}\r\n\t\tzdepth = unpackDepth(color);\r\n\t\tvalue = float(fMyZ < zdepth);\r\n#endif\r\n\t}\r\n\treturn value;\r\n}\r\nfloat getShadowPSSM2( sampler2D shadowMap1,sampler2D shadowMap2,mat4 lightShadowVP[4],vec4 pssmDistance,vec2 shadowPCFOffset,vec3 worldPos,float posViewZ,float zBias )\r\n{\r\n\tfloat value = 1.0;\r\n\tint nPSNum = int(posViewZ>pssmDistance.x);\r\n\tnPSNum += int(posViewZ>pssmDistance.y);\r\n\t//真SB,webgl不支持在PS中直接访问数组\r\n\tmat4 lightVP;\r\n\tif( nPSNum == 0 )\r\n\t{\r\n\t\tlightVP = lightShadowVP[1];\r\n\t}\r\n\telse if( nPSNum == 1 )\r\n\t{\r\n\t\tlightVP = lightShadowVP[2];\r\n\t}\r\n\tvec4 vLightMVPPos = lightVP * vec4(worldPos,1.0);\r\n\t//为了效率，在CPU计算/2.0 + 0.5\r\n\t//vec3 vText = (vLightMVPPos.xyz / vLightMVPPos.w)/2.0 + 0.5;\r\n\tvec3 vText = vLightMVPPos.xyz / vLightMVPPos.w;\r\n\tfloat fMyZ = vText.z - zBias;\r\n\t/*\r\n\tbvec4 bInFrustumVec = bvec4 ( vText.x >= 0.0, vText.x <= 1.0, vText.y >= 0.0, vText.y <= 1.0 );\r\n\tbool bInFrustum = all( bInFrustumVec );\r\n\tbvec2 bFrustumTestVec = bvec2( bInFrustum, fMyZ <= 1.0 );\r\n\tbool bFrustumTest = all( bFrustumTestVec );\r\n\tif ( bFrustumTest ) \r\n\t*/\r\n\tif( fMyZ <= 1.0 )\r\n\t{\r\n\t\tfloat zdepth=0.0;\r\n#ifdef SHADOWMAP_PCF3\r\n\t\tif ( nPSNum == 0 )\r\n\t\t{\r\n\t\t\tvalue =  tex2DPCF( shadowMap1, vText.xy,shadowPCFOffset,fMyZ );\r\n\t\t\tvalue += tex2DPCF( shadowMap1, vText.xy+vec2(shadowPCFOffset.xy),shadowPCFOffset,\tfMyZ );\r\n\t\t\tvalue += tex2DPCF( shadowMap1, vText.xy+vec2(shadowPCFOffset.x,0),shadowPCFOffset,\tfMyZ );\r\n\t\t\tvalue += tex2DPCF( shadowMap1, vText.xy+vec2(0,shadowPCFOffset.y),shadowPCFOffset,\tfMyZ );\r\n\t\t\tvalue = value/4.0;\r\n\t\t}\r\n\t\telse if( nPSNum == 1 )\r\n\t\t{\r\n\t\t\tvalue = tex2DPCF( shadowMap2,vText.xy,shadowPCFOffset,fMyZ);\r\n\t\t}\r\n#endif\r\n#ifdef SHADOWMAP_PCF2\r\n\t\tif ( nPSNum == 0 )\r\n\t\t{\r\n\t\t\tvalue = tex2DPCF( shadowMap1,vText.xy,shadowPCFOffset,fMyZ);\r\n\t\t}\r\n\t\telse if( nPSNum == 1 )\r\n\t\t{\r\n\t\t\tvalue = tex2DPCF( shadowMap2,vText.xy,shadowPCFOffset,fMyZ);\r\n\t\t}\r\n#endif\r\n#ifdef SHADOWMAP_PCF1\r\n\t\tif ( nPSNum == 0 )\r\n\t\t{\r\n\t\t\tvalue = tex2DPCF( shadowMap1,vText.xy,shadowPCFOffset,fMyZ);\r\n\t\t}\r\n\t\telse if( nPSNum == 1 )\r\n\t\t{\r\n\t\t\tvec4 color = texture2D( shadowMap2,vText.xy );\r\n\t\t\tzdepth = unpackDepth(color);\r\n\t\t\tvalue = float(fMyZ < zdepth);\r\n\t\t}\r\n#endif\r\n#ifdef SHADOWMAP_PCF_NO\r\n\t\tvec4 color;\r\n\t\tif ( nPSNum == 0 )\r\n\t\t{\r\n\t\t\tcolor = texture2D( shadowMap1,vText.xy );\r\n\t\t}\r\n\t\telse if( nPSNum == 1 )\r\n\t\t{\r\n\t\t\tcolor = texture2D( shadowMap2,vText.xy );\r\n\t\t}\r\n\t\tzdepth = unpackDepth(color);\r\n\t\tvalue = float(fMyZ < zdepth);\r\n#endif\r\n\t}\r\n\treturn value;\r\n}\r\nfloat getShadowPSSM1( sampler2D shadowMap1,vec4 lightMVPPos,vec4 pssmDistance,vec2 shadowPCFOffset,float posViewZ,float zBias )\r\n{\r\n\tfloat value = 1.0;\r\n\tif( posViewZ < pssmDistance.x )\r\n\t{\r\n\t\tvec3 vText = lightMVPPos.xyz / lightMVPPos.w;\r\n\t\tfloat fMyZ = vText.z - zBias;\r\n\t\t/*\r\n\t\tbvec4 bInFrustumVec = bvec4 ( vText.x >= 0.0, vText.x <= 1.0, vText.y >= 0.0, vText.y <= 1.0 );\r\n\t\tbool bInFrustum = all( bInFrustumVec );\r\n\t\tbvec2 bFrustumTestVec = bvec2( bInFrustum, fMyZ <= 1.0 );\r\n\t\tbool bFrustumTest = all( bFrustumTestVec );\r\n\t\t*/\r\n\t\tif ( fMyZ <= 1.0 ) \r\n\t\t{\r\n\t\t\tfloat zdepth=0.0;\r\n#ifdef SHADOWMAP_PCF3\r\n\t\t\tvalue =  tex2DPCF( shadowMap1, vText.xy,shadowPCFOffset,fMyZ );\r\n\t\t\tvalue += tex2DPCF( shadowMap1, vText.xy+vec2(shadowPCFOffset.xy),shadowPCFOffset,fMyZ );\r\n\t\t\tvalue += tex2DPCF( shadowMap1, vText.xy+vec2(shadowPCFOffset.x,0),shadowPCFOffset,fMyZ );\r\n\t\t\tvalue += tex2DPCF( shadowMap1, vText.xy+vec2(0,shadowPCFOffset.y),shadowPCFOffset,fMyZ );\r\n\t\t\tvalue = value/4.0;\r\n#endif\r\n#ifdef SHADOWMAP_PCF2\t\t\r\n\t\t\tvalue = tex2DPCF( shadowMap1,vText.xy,shadowPCFOffset,fMyZ);\r\n#endif\r\n#ifdef SHADOWMAP_PCF1\r\n\t\t\tvalue = tex2DPCF( shadowMap1,vText.xy,shadowPCFOffset,fMyZ);\r\n#endif\r\n#ifdef SHADOWMAP_PCF_NO\t\t\r\n\t\t\tvec4 color = texture2D( shadowMap1,vText.xy );\r\n\t\t\tzdepth = unpackDepth(color);\r\n\t\t\tvalue = float(fMyZ < zdepth);\r\n#endif\r\n\t\t}\r\n\t}\r\n\treturn value;\r\n}"),
                G.addInclude("Colors.glsl", '#include "StdLib.glsl";\r\n\r\n#define EPSILON 1.0e-4\r\n\r\n// Quadratic color thresholding\r\n// curve = (threshold - knee, knee * 2, 0.25 / knee)\r\nmediump vec4 quadraticThreshold(mediump vec4 color, mediump float threshold, mediump vec3 curve) {\r\n\t// Pixel brightness\r\n\tmediump float br = max3(color.r, color.g, color.b);\r\n\r\n\t// Under-threshold part: quadratic curve\r\n\tmediump float rq = clamp(br - curve.x, 0.0, curve.y);\r\n\trq = curve.z * rq * rq;\r\n\r\n\t// Combine and apply the brightness response curve.\r\n\tcolor *= max(rq, br - threshold) / max(br, EPSILON);\r\n\r\n\treturn color;\r\n}\r\n\r\n\r\n\r\n//\r\n// sRGB transfer functions\r\n// Fast path ref: http://chilliant.blogspot.com.au/2012/08/srgb-approximations-for-hlsl.html?m=1\r\n//\r\nmediump vec3 sRGBToLinear(mediump vec3 c) {\r\n\t#ifdef USE_VERY_FAST_SRGB\r\n\t\treturn c * c;\r\n\t#elif defined(USE_FAST_SRGB)\r\n\t\treturn c * (c * (c * 0.305306011 + 0.682171111) + 0.012522878);\r\n\t#else\r\n\t\tmediump vec3 linearRGBLo = c / 12.92;\r\n\t\tmediump vec3 power=vec3(2.4, 2.4, 2.4);\r\n\t\tmediump vec3 linearRGBHi = positivePow((c + 0.055) / 1.055, power);\r\n\t\tmediump vec3 linearRGB =vec3((c.r<=0.04045) ? linearRGBLo.r : linearRGBHi.r,(c.g<=0.04045) ? linearRGBLo.g : linearRGBHi.g,(c.b<=0.04045) ? linearRGBLo.b : linearRGBHi.b);\r\n\t\treturn linearRGB;\r\n\t#endif\r\n}\r\n\r\nmediump vec4 sRGBToLinear(mediump vec4 c){\r\n    return vec4(sRGBToLinear(c.rgb), c.a);\r\n}\r\n\r\n\r\n\r\nmediump vec3 linearToSRGB(mediump vec3 c) {\r\n\t#ifdef USE_VERY_FAST_SRGB\r\n\t\treturn sqrt(c);\r\n\t#elif defined(USE_FAST_SRGB)\r\n\t\treturn max(1.055 * PositivePow(c, 0.416666667) - 0.055, 0.0);\r\n\t#else\r\n\t\tmediump vec3 sRGBLo = c * 12.92;\r\n\t\tmediump vec3 power=vec3(1.0 / 2.4, 1.0 / 2.4, 1.0 / 2.4);\r\n\t\tmediump vec3 sRGBHi = (positivePow(c, power) * 1.055) - 0.055;\r\n\t\tmediump vec3 sRGB =vec3((c.r<=0.0031308) ? sRGBLo.r : sRGBHi.r,(c.g<=0.0031308) ? sRGBLo.g : sRGBHi.g,(c.b<=0.0031308) ? sRGBLo.b : sRGBHi.b);\r\n\t\treturn sRGB;\r\n\t#endif\r\n}\r\n\r\nmediump vec4 linearToSRGB(mediump vec4 c){\r\n    return vec4(linearToSRGB(c.rgb), c.a);\r\n}'),
                G.addInclude("Sampling.glsl", "// Better, temporally stable box filtering\r\n// [Jimenez14] http://goo.gl/eomGso\r\n// . . . . . . .\r\n// . A . B . C .\r\n// . . D . E . .\r\n// . F . G . H .\r\n// . . I . J . .\r\n// . K . L . M .\r\n// . . . . . . .\r\nmediump vec4 downsampleBox13Tap(sampler2D tex, vec2 uv, vec2 texelSize)\r\n{\r\n    mediump vec4 A = texture2D(tex, uv + texelSize * vec2(-1.0, -1.0));\r\n    mediump vec4 B = texture2D(tex, uv + texelSize * vec2( 0.0, -1.0));\r\n    mediump vec4 C = texture2D(tex, uv + texelSize * vec2( 1.0, -1.0));\r\n    mediump vec4 D = texture2D(tex, uv + texelSize * vec2(-0.5, -0.5));\r\n    mediump vec4 E = texture2D(tex, uv + texelSize * vec2( 0.5, -0.5));\r\n    mediump vec4 F = texture2D(tex, uv + texelSize * vec2(-1.0,  0.0));\r\n    mediump vec4 G = texture2D(tex, uv);\r\n    mediump vec4 H = texture2D(tex, uv + texelSize * vec2( 1.0,  0.0));\r\n    mediump vec4 I = texture2D(tex, uv + texelSize * vec2(-0.5,  0.5));\r\n    mediump vec4 J = texture2D(tex, uv + texelSize * vec2( 0.5,  0.5));\r\n    mediump vec4 K = texture2D(tex, uv + texelSize * vec2(-1.0,  1.0));\r\n    mediump vec4 L = texture2D(tex, uv + texelSize * vec2( 0.0,  1.0));\r\n    mediump vec4 M = texture2D(tex, uv + texelSize * vec2( 1.0,  1.0));\r\n\r\n\tmediump vec2 scale= vec2(0.5, 0.125);\r\n    mediump vec2 div = (1.0 / 4.0) * scale;\r\n\r\n    mediump vec4 o = (D + E + I + J) * div.x;\r\n    o += (A + B + G + F) * div.y;\r\n    o += (B + C + H + G) * div.y;\r\n    o += (F + G + L + K) * div.y;\r\n    o += (G + H + M + L) * div.y;\r\n\r\n    return o;\r\n}\r\n\r\n// Standard box filtering\r\nmediump vec4 downsampleBox4Tap(sampler2D tex, vec2 uv, vec2 texelSize)\r\n{\r\n    vec4 d = texelSize.xyxy * vec4(-1.0, -1.0, 1.0, 1.0);\r\n\r\n    mediump vec4 s =  texture2D(tex, uv + d.xy);\r\n    s += texture2D(tex, uv + d.zy);\r\n    s += texture2D(tex, uv + d.xw);\r\n    s += texture2D(tex, uv + d.zw);\r\n\r\n    return s * (1.0 / 4.0);\r\n}\r\n\r\n// 9-tap bilinear upsampler (tent filter)\r\n// . . . . . . .\r\n// . 1 . 2 . 1 .\r\n// . . . . . . .\r\n// . 2 . 4 . 2 .\r\n// . . . . . . .\r\n// . 1 . 2 . 1 .\r\n// . . . . . . .\r\nmediump vec4 upsampleTent(sampler2D tex, vec2 uv, vec2 texelSize, vec4 sampleScale)\r\n{\r\n    vec4 d = texelSize.xyxy * vec4(1.0, 1.0, -1.0, 0.0) * sampleScale;\r\n\r\n    mediump vec4 s =  texture2D(tex, uv - d.xy);\r\n    s += texture2D(tex, uv - d.wy) * 2.0;\r\n    s += texture2D(tex, uv - d.zy);\r\n\r\n    s += texture2D(tex, uv + d.zw) * 2.0;\r\n    s += texture2D(tex, uv) * 4.0;\r\n    s += texture2D(tex,\tuv + d.xw) * 2.0;\r\n\r\n    s += texture2D(tex, uv + d.zy);\r\n    s += texture2D(tex, uv + d.wy) * 2.0;\r\n    s += texture2D(tex, uv + d.xy);\r\n\r\n    return s * (1.0 / 16.0);\r\n}\r\n\r\n// Standard box filtering\r\nmediump vec4 upsampleBox(sampler2D tex, vec2 uv, vec2 texelSize, vec4 sampleScale)\r\n{\r\n    vec4 d = texelSize.xyxy * vec4(-1.0, -1.0, 1.0, 1.0) * 0.5 * sampleScale;\r\n\r\n    mediump vec4 s =  texture2D(tex, uv + d.xy);\r\n    s += texture2D(tex, uv + d.zy);\r\n    s += texture2D(tex, uv + d.xw);\r\n    s += texture2D(tex, uv + d.zw);\r\n\r\n    return s * (1.0 / 4.0);\r\n}"),
                G.addInclude("StdLib.glsl", "#define HALF_MAX       65504.0 // (2 - 2^-10) * 2^15\r\n\r\n#define FLT_EPSILON    1.192092896e-07 // Smallest positive number, such that 1.0 + FLT_EPSILON != 1.0\r\n\r\nmediump vec4 safeHDR(mediump vec4 c)\r\n{\r\n    return min(c, HALF_MAX);\r\n}\r\n\r\nfloat max3(float a, float b, float c)\r\n{\r\n    return max(max(a, b), c);\r\n}\r\n\r\nvec3 positivePow(vec3 base, vec3 power)\r\n{\r\n    return pow(max(abs(base), vec3(FLT_EPSILON, FLT_EPSILON, FLT_EPSILON)), power);\r\n}"),
                G.addInclude("PBRVSInput.glsl", "attribute vec4 a_Position;\r\n\r\n#ifdef GPU_INSTANCE\r\n\tattribute mat4 a_MvpMatrix;\r\n\tattribute mat4 a_WorldMat;\r\n#else\r\n\tuniform mat4 u_MvpMatrix;\r\n\tuniform mat4 u_WorldMat;\r\n#endif\r\n\r\n#ifdef BONE\r\n\tconst int c_MaxBoneCount = 24;\r\n\tattribute vec4 a_BoneIndices;\r\n\tattribute vec4 a_BoneWeights;\r\n\tuniform mat4 u_Bones[c_MaxBoneCount];\r\n#endif\r\n\r\nattribute vec3 a_Normal;\r\nvarying vec3 v_Normal; \r\n\r\n#if defined(NORMALTEXTURE)||defined(PARALLAXTEXTURE)\r\n\tattribute vec4 a_Tangent0;\r\n\tvarying vec3 v_Tangent;\r\n\tvarying vec3 v_Binormal;\r\n    #ifdef PARALLAXTEXTURE\r\n\t    varying vec3 v_ViewDirForParallax;\r\n    #endif\r\n#endif\r\n\r\n#if defined(ALBEDOTEXTURE)||defined(METALLICGLOSSTEXTURE)||defined(NORMALTEXTURE)||defined(EMISSIONTEXTURE)||defined(OCCLUSIONTEXTURE)||defined(PARALLAXTEXTURE)||(defined(LIGHTMAP)&&defined(UV))\r\n\tattribute vec2 a_Texcoord0;\r\n\tvarying vec2 v_Texcoord0;\r\n#endif\r\n\r\n#if defined(LIGHTMAP)&&defined(UV1)\r\n\tattribute vec2 a_Texcoord1;\r\n#endif\r\n\r\n#ifdef LIGHTMAP\r\n\tuniform vec4 u_LightmapScaleOffset;\r\n\tvarying vec2 v_LightMapUV;\r\n#endif\r\n\r\nuniform vec3 u_CameraPos;\r\nvarying vec3 v_EyeVec;\r\nvarying vec3 v_PositionWorld;\r\nvarying float v_posViewZ;\r\n\r\n#ifdef RECEIVESHADOW\r\n\t#ifdef SHADOWMAP_PSSM1 \r\n\tvarying vec4 v_lightMVPPos;\r\n\tuniform mat4 u_lightShadowVP[4];\r\n\t#endif\r\n#endif\r\n\r\n#ifdef TILINGOFFSET\r\n\tuniform vec4 u_TilingOffset;\r\n#endif"),
                G.addInclude("PBRFSInput.glsl", "#ifdef ALPHATEST\r\n\tuniform float u_AlphaTestValue;\r\n#endif\r\n\r\nuniform vec4 u_AlbedoColor;\r\n\r\n#ifdef NORMALTEXTURE\r\n\tuniform sampler2D u_NormalTexture;\r\n\tuniform float u_NormalScale;\r\n#endif\r\n\r\n#ifdef ALBEDOTEXTURE\r\n\tuniform sampler2D u_AlbedoTexture;\r\n#endif\r\n\r\n#ifdef METALLICGLOSSTEXTURE\r\n\tuniform sampler2D u_MetallicGlossTexture;\r\n#endif\r\nuniform float u_Metallic;\r\n\r\n#ifdef SPECULARGLOSSTEXTURE\r\n\tuniform sampler2D u_SpecGlossTexture;\r\n#endif\r\nuniform vec3 u_SpecularColor;\r\n\r\nuniform float u_Smoothness;\r\nuniform float u_SmoothnessScale;\r\n\r\n#ifdef PARALLAXTEXTURE\r\n\tuniform sampler2D u_ParallaxTexture;\r\n\tuniform float u_ParallaxScale;\r\n\tvarying vec3 v_ViewDirForParallax;\r\n#endif\r\n\r\n#ifdef OCCLUSIONTEXTURE\r\n\tuniform sampler2D u_OcclusionTexture;\r\n\tuniform float u_occlusionStrength;\r\n#endif\r\n\r\n#ifdef EMISSION \r\n\t#ifdef EMISSIONTEXTURE\r\n\t\tuniform sampler2D u_EmissionTexture;\r\n\t#endif\r\n\tuniform vec4 u_EmissionColor;\r\n#endif\r\n\r\n#if defined(ALBEDOTEXTURE)||defined(METALLICGLOSSTEXTURE)||defined(NORMALTEXTURE)||defined(EMISSIONTEXTURE)||defined(OCCLUSIONTEXTURE)||defined(PARALLAXTEXTURE)\r\n\tvarying vec2 v_Texcoord0;\r\n#endif\r\n\r\n#ifdef LIGHTMAP\r\n\tvarying vec2 v_LightMapUV;\r\n\tuniform sampler2D u_LightMap;\r\n#endif\r\n\r\nvarying vec3 v_Normal; \r\n\r\n#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)\r\n\t#ifdef LEGACYSINGLELIGHTING\r\n\t\t#ifdef DIRECTIONLIGHT\r\n\t\t\tuniform DirectionLight u_DirectionLight;\r\n\t\t#endif\r\n\t\t#ifdef POINTLIGHT\r\n\t\t\tuniform PointLight u_PointLight;\r\n\t\t#endif\r\n\t\t#ifdef SPOTLIGHT\r\n\t\t\tuniform SpotLight u_SpotLight;\r\n\t\t#endif\r\n\t#else\r\n\t\tuniform mat4 u_View;\r\n\t\tuniform vec4 u_ProjectionParams;\r\n\t\tuniform vec4 u_Viewport;\r\n\t\tuniform int u_DirationLightCount;\r\n\t\tuniform sampler2D u_LightBuffer;\r\n\t\tuniform sampler2D u_LightClusterBuffer;\r\n\t#endif\r\n#endif\r\n\r\nvarying vec3 v_EyeVec;\r\n\r\n#ifdef NORMALTEXTURE\r\n\tvarying vec3 v_Tangent;\r\n\tvarying vec3 v_Binormal;\r\n#endif\r\n\r\n#ifdef FOG\r\n\tuniform float u_FogStart;\r\n\tuniform float u_FogRange;\r\n\tuniform vec3 u_FogColor;\r\n#endif\r\n\r\n\r\n//后面考虑宏TODO\r\nvarying vec3 v_PositionWorld;\r\n\r\nvarying float v_posViewZ;\r\n#ifdef RECEIVESHADOW\r\n\t#if defined(SHADOWMAP_PSSM2)||defined(SHADOWMAP_PSSM3)\r\n\t\tuniform mat4 u_lightShadowVP[4];\r\n\t#endif\r\n\t#ifdef SHADOWMAP_PSSM1 \r\n\t\tvarying vec4 v_lightMVPPos;\r\n\t#endif\r\n#endif\r\n\r\n\r\nmediump float lerpOneTo(mediump float b, mediump float t)\r\n{\r\n    mediump float oneMinusT = 1.0 - t;\r\n    return oneMinusT + b * t;\r\n}\r\n\r\n#ifdef EMISSION \r\n\tvec3 emission(vec2 uv)\r\n\t{\r\n\t\t#ifdef EMISSIONTEXTURE\r\n\t\t\treturn texture2D(u_EmissionTexture, uv).rgb * u_EmissionColor.rgb;\r\n\t\t#else\r\n\t\t\treturn u_EmissionColor.rgb;\r\n\t\t#endif\r\n\t}\r\n#endif\r\n\r\nmediump float alpha(vec2 uv)\r\n{\r\n\t#ifdef SMOOTHNESSSOURCE_ALBEDOTEXTURE_ALPHA\r\n\t\treturn u_AlbedoColor.a;\r\n\t#else\r\n\t\t#ifdef ALBEDOTEXTURE\r\n\t\t\treturn texture2D(u_AlbedoTexture, uv).a * u_AlbedoColor.a;\r\n\t\t#else\r\n\t\t\treturn u_AlbedoColor.a;\r\n\t\t#endif\r\n\t#endif\r\n}\r\n\r\nmediump float occlusion(vec2 uv)\r\n{\r\n\t#ifdef OCCLUSIONTEXTURE\r\n\t\tmediump float occ = texture2D(u_OcclusionTexture, uv).g;\r\n\t\treturn lerpOneTo(occ, u_occlusionStrength);\r\n\t#else\r\n\t\treturn 1.0;\r\n\t#endif\r\n}\r\n\r\nmediump vec3 albedo(vec2 uv)\r\n{\r\n\t#ifdef ALBEDOTEXTURE\r\n\t\treturn u_AlbedoColor.rgb * texture2D(u_AlbedoTexture, uv).rgb;\r\n\t#else\r\n\t\treturn u_AlbedoColor.rgb;\r\n\t#endif\r\n\t//TODO:Detail Texture\r\n}\r\n\r\nmediump vec2 metallicGloss(vec2 uv)\r\n{\r\n\tmediump vec2 ms;//x is metallic,y is smoothness\r\n\t#ifdef METALLICGLOSSTEXTURE\r\n\t\t#ifdef SMOOTHNESSSOURCE_ALBEDOTEXTURE_ALPHA\r\n\t\t\tms.x = texture2D(u_MetallicGlossTexture, uv).r;\r\n\t\t\t#ifdef ALBEDOTEXTURE\r\n\t\t\t\tms.y = texture2D(u_AlbedoTexture, uv).a*u_SmoothnessScale;\r\n\t\t\t#else\r\n\t\t\t\tms.y = u_SmoothnessScale;\r\n\t\t\t#endif\r\n\t\t#else\r\n\t\t\tms = texture2D(u_MetallicGlossTexture, uv).ra;\r\n\t\t\tms.y *= u_SmoothnessScale;\r\n\t\t#endif\r\n\t#else\r\n\t\tms.x = u_Metallic;\r\n\t\t#ifdef SMOOTHNESSSOURCE_ALBEDOTEXTURE_ALPHA\r\n\t\t\t#ifdef ALBEDOTEXTURE\r\n\t\t\t\tms.y = texture2D(u_AlbedoTexture, uv).a * u_SmoothnessScale;\r\n\t\t\t#else\r\n\t\t\t\tms.y = u_SmoothnessScale;\r\n\t\t\t#endif\r\n\t\t#else\r\n\t\t\tms.y = u_Smoothness;\r\n\t\t#endif\r\n\t#endif\r\n\treturn ms;\r\n}\r\n\r\nmediump vec4 specularGloss(vec2 uv)\r\n{\r\n\tmediump vec4 sg;\r\n\t#ifdef SPECULARGLOSSTEXTURE\r\n\t\t#ifdef SMOOTHNESSSOURCE_ALBEDOTEXTURE_ALPHA\r\n\t\t\tsg.rgb = texture2D(u_SpecGlossTexture, uv).rgb;\r\n\t\t\t#ifdef ALBEDOTEXTURE\r\n\t\t\t\tsg.a = texture2D(u_AlbedoTexture, uv).a*u_SmoothnessScale;\r\n\t\t\t#else\r\n\t\t\t\tsg.a = u_SmoothnessScale;\r\n\t\t\t#endif\r\n\t\t#else\r\n\t\t\tsg = texture2D(u_SpecGlossTexture, uv);\r\n\t\t\tsg.a *= u_SmoothnessScale;\r\n\t\t#endif\r\n\t#else\r\n\t\tsg.rgb = u_SpecularColor.rgb;\r\n\t\t#ifdef SMOOTHNESSSOURCE_ALBEDOTEXTURE_ALPHA\r\n\t\t\t#ifdef ALBEDOTEXTURE\r\n\t\t\t\tsg.a = texture2D(u_AlbedoTexture, uv).a * u_SmoothnessScale;\r\n\t\t\t#else\r\n\t\t\t\tsg.a = u_SmoothnessScale;\r\n\t\t\t#endif\r\n\t\t#else\r\n\t\t\tsg.a = u_Smoothness;\r\n\t\t#endif\r\n\t#endif\r\n\t\treturn sg;\r\n}\r\n\r\n\r\n#ifdef NORMALTEXTURE\r\n\tmediump vec3 unpackScaleNormal(mediump vec3 packednormal, mediump float bumpScale)\r\n\t{\r\n\t\tmediump vec3 normal = packednormal.xyz * 2.0 - 1.0;\r\n\t\tnormal.y=-normal.y;//NOTE:because unity to LayaAir coordSystem.\r\n\t\tnormal.xy *= bumpScale;\r\n\t\treturn normal;\r\n\t}\r\n\t\r\n\tmediump vec3 normalInTangentSpace(vec2 texcoords)\r\n\t{\r\n\t\tmediump vec3 normalTangent = unpackScaleNormal(texture2D(u_NormalTexture, texcoords).rgb,u_NormalScale);\r\n\t\treturn normalTangent;\r\n\t}\r\n#endif\r\n\r\n#ifdef PARALLAXTEXTURE\r\n\tmediump vec2 parallaxOffset1Step(mediump float h, mediump float height, mediump vec3 viewDir)\r\n\t{\r\n\t\th = h * height - height / 2.0;\r\n\t\tviewDir.z += 0.42;\r\n\t\treturn h * (viewDir.xy / viewDir.z);\r\n\t}\r\n\r\n\tvec2 parallax(vec2 texcoords, mediump vec3 viewDir)\r\n\t{\r\n\t\tmediump float h = texture2D(u_ParallaxTexture, texcoords.xy).g;\r\n\t\tvec2 offset = parallaxOffset1Step(h, u_ParallaxScale, viewDir);\r\n\t\treturn texcoords+offset;\r\n\t}\r\n#endif\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n"),
                G.addInclude("PBRVSShadow.glsl", "void main_castShadow()\r\n{\r\n\tvec4 position;\r\n\t#ifdef BONE\r\n\t\tmat4 skinTransform = u_Bones[int(a_BoneIndices.x)] * a_BoneWeights.x;\r\n\t\tskinTransform += u_Bones[int(a_BoneIndices.y)] * a_BoneWeights.y;\r\n\t\tskinTransform += u_Bones[int(a_BoneIndices.z)] * a_BoneWeights.z;\r\n\t\tskinTransform += u_Bones[int(a_BoneIndices.w)] * a_BoneWeights.w;\r\n\t\tposition=skinTransform*a_Position;\r\n\t#else\r\n\t\tposition=a_Position;\r\n\t#endif\r\n\t#ifdef GPU_INSTANCE\r\n\t\tgl_Position = a_MvpMatrix * position;\r\n\t#else\r\n\t\tgl_Position = u_MvpMatrix * position;\r\n\t#endif\r\n\t\r\n\t//TODO没考虑UV动画呢\r\n\t#if defined(ALBEDOTEXTURE)&&defined(ALPHATEST)\r\n\t\tv_Texcoord0=a_Texcoord0;\r\n\t#endif\r\n\tgl_Position=remapGLPositionZ(gl_Position);\r\n\tv_posViewZ = gl_Position.z;\r\n}"),
                G.addInclude("PBRFSShadow.glsl", "void main_castShadow()\r\n{\r\n\t//gl_FragColor=vec4(v_posViewZ,0.0,0.0,1.0);\r\n\tgl_FragColor=packDepth(v_posViewZ);\r\n\t#if defined(ALBEDOTEXTURE)&&defined(ALPHATEST)\r\n\t\tfloat alpha = texture2D(u_AlbedoTexture,v_Texcoord0).w;\r\n\t\tif( alpha < u_AlphaTestValue )\r\n\t\t{\r\n\t\t\tdiscard;\r\n\t\t}\r\n\t#endif\r\n}"),
                G.addInclude("LayaPBRBRDF.glsl", '// allow to explicitly override LAYA_BRDF_GI and LAYA_BRDF_LIGHT in custom shader,default is layaBRDFHighGI and layaBRDFHighLight\r\n#if !defined (LAYA_BRDF_GI) \r\n\t#if defined(LAYA_PBR_BRDF_LOW)\r\n\t\t#define LAYA_BRDF_GI layaBRDFLowGI\r\n\t#elif defined(LAYA_PBR_BRDF_HIGH)\r\n\t\t#define LAYA_BRDF_GI layaBRDFHighGI\r\n\t#endif\r\n#endif\r\n#if !defined (LAYA_BRDF_LIGHT)\r\n\t#if defined(LAYA_PBR_BRDF_LOW)\r\n\t\t#define LAYA_BRDF_LIGHT layaBRDFLowLight\r\n\t#elif defined(LAYA_PBR_BRDF_HIGH)\r\n\t\t#define LAYA_BRDF_LIGHT layaBRDFHighLight\r\n\t#endif\r\n#endif\r\n\r\n#define PI 3.14159265359\r\n#define INV_PI 0.31830988618\r\n\r\nmediump float pow4(mediump float x)\r\n{\r\n\treturn x * x * x * x;\r\n}\r\n\r\nmediump float pow5(mediump float x)\r\n{\r\n\treturn x * x * x * x * x;\r\n}\r\n\r\nmediump vec3 fresnelLerp(mediump vec3 F0,mediump vec3 F90,mediump float cosA)\r\n{\r\n\tfloat t = pow5(1.0 - cosA);   // ala Schlick interpoliation\r\n\treturn mix(F0, F90, t);\r\n}\r\n\r\nmediump vec3 fresnelTerm(mediump vec3 F0,mediump float cosA)\r\n{\r\n\tfloat t = pow5(1.0 - cosA);   // ala Schlick interpoliation\r\n\treturn F0 + (vec3(1.0) - F0) * t;\r\n}\r\n\r\n// approximage Schlick with ^4 instead of ^5\r\nmediump vec3 fresnelLerpFast (mediump vec3 F0, mediump vec3 F90,mediump float cosA)\r\n{\r\n    mediump float t = pow4 (1.0 - cosA);\r\n    return mix (F0, F90, t);\r\n}\r\n\r\nfloat smoothnessToPerceptualRoughness(float smoothness)\r\n{\r\n    return 1.0 - smoothness;\r\n}\r\n\r\nfloat perceptualRoughnessToRoughness(float perceptualRoughness)\r\n{\r\n    return perceptualRoughness * perceptualRoughness;\r\n}\r\n\r\nvec3 safeNormalize(vec3 inVec)\r\n{\r\n\tfloat dp3 = max(0.001,dot(inVec,inVec));\r\n\treturn inVec * inversesqrt(dp3);\r\n}\r\n\r\n// Note: Disney diffuse must be multiply by diffuseAlbedo / PI. This is done outside of this function.\r\nmediump float disneyDiffuse(mediump float NdotV,mediump float NdotL,mediump float LdotH,mediump float perceptualRoughness)\r\n{\r\n\t//https://www.cnblogs.com/herenzhiming/articles/5790389.html\r\n\tmediump float fd90 = 0.5 + 2.0 * LdotH * LdotH * perceptualRoughness;\r\n\t// Two schlick fresnel term\r\n\tmediump float lightScatter = (1.0 + (fd90 - 1.0) * pow5(1.0 - NdotL));\r\n\tmediump float viewScatter = (1.0 + (fd90 - 1.0) * pow5(1.0 - NdotV));\r\n\r\n\treturn lightScatter * viewScatter;\r\n}\r\n\r\n// Ref: http://jcgt.org/published/0003/02/03/paper.pdf\r\nfloat smithJointGGXVisibilityTerm(float NdotL, float NdotV, float roughness)\r\n{\r\n\t// Original formulation:\r\n    // lambda_v    = (-1 + sqrt(a2 * (1 - NdotL2) / NdotL2 + 1)) * 0.5f;\r\n    // lambda_l    = (-1 + sqrt(a2 * (1 - NdotV2) / NdotV2 + 1)) * 0.5f;\r\n    // G           = 1 / (1 + lambda_v + lambda_l);\r\n\r\n\t// scientific code implement:\r\n\t// Reorder code to be more optimal\r\n    // half a          = roughness;\r\n    // half a2         = a * a;\r\n\r\n    // half lambdaV    = NdotL * sqrt((-NdotV * a2 + NdotV) * NdotV + a2);\r\n    // half lambdaL    = NdotV * sqrt((-NdotL * a2 + NdotL) * NdotL + a2);\r\n\r\n    // Simplify visibility term: (2.0f * NdotL * NdotV) /  ((4.0f * NdotL * NdotV) * (lambda_v + lambda_l + 1e-5f));\r\n    // return 0.5f / (lambdaV + lambdaL + 1e-5f);  \r\n\t// This function is not intended to be running on Mobile,therefore epsilon is smaller than can be represented by half\r\n\r\n\t// Approximation of the above formulation (simplify the sqrt, not mathematically correct but close enough)\r\n\tfloat a = roughness;\r\n\tfloat lambdaV = NdotL * (NdotV * (1.0 - a) + a);\r\n\tfloat lambdaL = NdotV * (NdotL * (1.0 - a) + a);\r\n\treturn 0.5 / (lambdaV + lambdaL + 1e-5);\r\n}\r\n\r\nfloat ggxTerm(float NdotH, float roughness)\r\n{\r\n\tfloat a2 = roughness * roughness;\r\n\tfloat d = (NdotH * a2 - NdotH) * NdotH + 1.0; // 2 mad\r\n\treturn INV_PI * a2 / (d * d + 1e-7); // This function is not intended to be running on Mobile,therefore epsilon is smaller than what can be represented by half//返回值小用half来返回\r\n}\r\n\r\n// BRDF1-------------------------------------------------------------------------------------\r\n\r\n// Note: BRDF entry points use smoothness and oneMinusReflectivity for optimization purposes,\r\n// mostly for DX9 SM2.0 level. Most of the math is being done on these (1-x) values, and that saves a few precious ALU slots.\r\n\r\n// Main Physically Based BRDF\r\n// Derived from Disney work and based on Torrance-Sparrow micro-facet model\r\n//\r\n// BRDF = kD / pi + kS * (D * V * F) / 4\r\n// I = BRDF * NdotL\r\n//\r\n// *NDF GGX:\r\n// *Smith for Visiblity term\r\n// *Schlick approximation for Fresnel\r\nmediump vec4 layaBRDFHighLight(mediump vec3 diffColor, mediump vec3 specColor, mediump float oneMinusReflectivity, float perceptualRoughness,float roughness,mediump float nv,vec3 normal, vec3 viewDir,LayaLight light)\r\n{\r\n\tvec3 halfDir = safeNormalize(viewDir-light.dir);\r\n\r\n\tfloat nl = clamp(dot(normal, -light.dir),0.0,1.0);\r\n\tfloat nh = clamp(dot(normal, halfDir),0.0,1.0);\r\n\tmediump float lv = clamp(dot(light.dir, viewDir),0.0,1.0);\r\n\tmediump float lh = clamp(dot(light.dir, -halfDir),0.0,1.0);\r\n\r\n\t// Diffuse term\r\n\tmediump float diffuseTerm = disneyDiffuse(nv, nl, lh, perceptualRoughness) * nl;\r\n\r\n\t// Specular term\r\n    // HACK: theoretically we should divide diffuseTerm by Pi and not multiply specularTerm!\r\n    // BUT that will make shader look significantly darker than Legacy ones\r\n\r\n\t// GGX with roughtness to 0 would mean no specular at all, using max(roughness, 0.002) here to match HDrenderloop roughtness remapping.\r\n\troughness = max(roughness, 0.002);\r\n\tfloat V = smithJointGGXVisibilityTerm(nl, nv, roughness);\r\n\tfloat D = ggxTerm(nh, roughness);\r\n\r\n\tfloat specularTerm = V * D * PI; // Torrance-Sparrow model, Fresnel is applied later\r\n\r\n\t//#ifdef LAYA_COLORSPACE_GAMMA\r\n\tspecularTerm = sqrt(max(1e-4, specularTerm));\r\n\t//#endif\r\n\tspecularTerm = max(0.0, specularTerm * nl);\r\n\t\t\r\n\tmediump vec3 color = diffColor * light.color * diffuseTerm + specularTerm * light.color * fresnelTerm(specColor, lh);\r\n\treturn vec4(color, 1.0);\r\n}\r\n\r\nvec4 layaBRDFHighGI(mediump vec3 diffColor,mediump vec3 specColor,mediump float oneMinusReflectivity,float smoothness ,float perceptualRoughness,float roughness,mediump float nv,vec3 normal, vec3 viewDir,LayaGI gi)\r\n{\r\n\t// surfaceReduction = Int D(NdotH) * NdotH * Id(NdotL>0) dH = 1/(roughness^2+1)\r\n\tfloat surfaceReduction;\r\n\tsurfaceReduction = 1.0 - 0.28*roughness*perceptualRoughness;// 1-0.28*x^3 as approximation for (1/(x^4+1))^(1/2.2) on the domain [0;1]\r\n\tfloat grazingTerm = clamp(smoothness + (1.0 - oneMinusReflectivity),0.0,1.0);\r\n\tmediump vec3 color =diffColor * gi.diffuse + surfaceReduction * gi.specular * fresnelLerp(specColor,vec3(grazingTerm), nv);\r\n\treturn vec4(color,1.0);\r\n}\r\n// BRDF1-------------------------------------------------------------------------------------\r\n\r\n\r\n// BRDF2-------------------------------------------------------------------------------------\r\n// Based on Minimalist CookTorrance BRDF\r\n// Implementation is slightly different from original derivation: http://www.thetenthplanet.de/archives/255\r\n//\r\n// *NDF [Modified] GGX:\r\n// *Modified Kelemen and Szirmay-​Kalos for Visibility term\r\n// *Fresnel approximated with 1/LdotH\r\nmediump vec4 layaBRDFLowLight (mediump vec3 diffColor, mediump vec3 specColor,mediump float oneMinusReflectivity,float perceptualRoughness,float roughness,mediump float nv,vec3 normal,vec3 viewDir,LayaLight light)\r\n{\r\n    vec3 halfDir = safeNormalize (viewDir-light.dir);\r\n    mediump float nl = clamp(dot(normal, -light.dir),0.0,1.0);\r\n    float nh = clamp(dot(normal, halfDir),0.0,1.0);\r\n    float lh = clamp(dot(-light.dir, halfDir),0.0,1.0);\r\n\r\n    // GGX Distribution multiplied by combined approximation of Visibility and Fresnel\r\n    // See "Optimizing PBR for Mobile" from Siggraph 2015 moving mobile graphics course\r\n    // https://community.arm.com/events/1155\r\n    mediump float a = roughness;\r\n    float a2 = a*a;\r\n\r\n    float d = nh * nh * (a2 - 1.0) + 1.00001;\r\n\t// #ifdef LAYA_COLORSPACE_GAMMA\r\n\t\t// Tighter approximation for Gamma only rendering mode!\r\n\t\t// DVF = sqrt(DVF);\r\n\t\t// DVF = (a * sqrt(.25)) / (max(sqrt(0.1), lh)*sqrt(roughness + .5) * d);\r\n\t\tfloat specularTerm = a / (max(0.32, lh) * (1.5 + roughness) * d);\r\n\t// #else\r\n\t// \tfloat specularTerm = a2 / (max(0.1f, lh*lh) * (roughness + 0.5f) * (d * d) * 4);\r\n\t// #endif\r\n\r\n    // on mobiles (where half actually means something) denominator have risk of overflow\r\n    // clamp below was added specifically to "fix" that, but dx compiler (we convert bytecode to metal/gles)\r\n    // sees that specularTerm have only non-negative terms, so it skips max(0,..) in clamp (leaving only min(100,...))\r\n\r\n\t//#if defined (SHADER_API_MOBILE)\r\n    specularTerm = specularTerm - 1e-4;\r\n\t//#endif\r\n\r\n\t// #else\r\n\t\t// // Legacy\r\n\t\t// half specularPower = PerceptualRoughnessToSpecPower(perceptualRoughness);\r\n\t\t// // Modified with approximate Visibility function that takes roughness into account\r\n\t\t// // Original ((n+1)*N.H^n) / (8*Pi * L.H^3) didn\'t take into account roughness\r\n\t\t// // and produced extremely bright specular at grazing angles\r\n\r\n\t\t// half invV = lh * lh * smoothness + perceptualRoughness * perceptualRoughness; // approx ModifiedKelemenVisibilityTerm(lh, perceptualRoughness);\r\n\t\t// half invF = lh;\r\n\r\n\t\t// half specularTerm = ((specularPower + 1) * pow (nh, specularPower)) / (8 * invV * invF + 1e-4h);\r\n\r\n\t\t// #ifdef LAYA_COLORSPACE_GAMMA\r\n\t\t// \tspecularTerm = sqrt(max(1e-4f, specularTerm));\r\n\t\t// #endif\r\n\t// #endif\r\n\r\n\t// #if defined (SHADER_API_MOBILE)\r\n\t\tspecularTerm = clamp(specularTerm, 0.0, 100.0); // Prevent FP16 overflow on mobiles\r\n\t// #endif\r\n    \r\n    mediump vec3 color = (diffColor + specularTerm * specColor) * light.color * nl;\r\n\r\n    return vec4(color, 1.0);\r\n}\r\n\r\nmediump vec4 layaBRDFLowGI (mediump vec3 diffColor, mediump vec3 specColor,mediump float oneMinusReflectivity,mediump float smoothness,float perceptualRoughness,float roughness,mediump float nv,vec3 normal,vec3 viewDir,LayaGI gi)\r\n{\r\n\t// surfaceReduction = Int D(NdotH) * NdotH * Id(NdotL>0) dH = 1/(realRoughness^2+1)\r\n\r\n    // 1-0.28*x^3 as approximation for (1/(x^4+1))^(1/2.2) on the domain [0;1]\r\n    // 1-x^3*(0.6-0.08*x)   approximation for 1/(x^4+1)\r\n\t// #ifdef LAYA_COLORSPACE_GAMMA\r\n\t\tmediump float surfaceReduction = 0.28;\r\n\t// #else\r\n\t\t// mediump float surfaceReduction = (0.6-0.08*perceptualRoughness);\r\n\t// #endif\r\n\r\n    surfaceReduction = 1.0 - roughness*perceptualRoughness*surfaceReduction;\r\n\r\n\tmediump float grazingTerm = clamp(smoothness + (1.0-oneMinusReflectivity),0.0,1.0);\r\n\tmediump vec3 color =gi.diffuse * diffColor+ surfaceReduction * gi.specular * fresnelLerpFast (specColor, vec3(grazingTerm), nv);\r\n\r\n    return vec4(color, 1.0);\r\n}\r\n// BRDF2-------------------------------------------------------------------------------------'),
                G.addInclude("PBRCore.glsl", "struct FragmentCommonData{\r\n\tvec3 diffColor;\r\n\tvec3 specColor;\r\n\tfloat oneMinusReflectivity;\r\n\tfloat smoothness;\r\n\t//vec3 eyeVec;TODO:maybe can remove\r\n\t//float alpha;\r\n\t//vec3 reflUVW;\r\n};\r\n\r\n#ifndef SETUP_BRDF_INPUT\r\n    #define SETUP_BRDF_INPUT metallicSetup//default is metallicSetup,also can be other. \r\n#endif\r\n\r\nconst mediump vec4 dielectricSpecularColor = vec4(0.220916301, 0.220916301, 0.220916301, 1.0 - 0.220916301);\r\n\r\nmediump vec3 diffuseAndSpecularFromMetallic(mediump vec3 albedo,mediump float metallic, out mediump vec3 specColor, out mediump float oneMinusReflectivity)\r\n{\r\n\tspecColor = mix(dielectricSpecularColor.rgb, albedo, metallic);\r\n\toneMinusReflectivity= dielectricSpecularColor.a*(1.0-metallic);//diffuse proportion\r\n\treturn albedo * oneMinusReflectivity;\r\n}\r\n\r\nmediump float specularStrength(mediump vec3 specular)\r\n{\r\n    return max (max (specular.r, specular.g), specular.b);\r\n}\r\n\r\n// Diffuse/Spec Energy conservation\r\nmediump vec3 energyConservationBetweenDiffuseAndSpecular (mediump vec3 albedo, mediump vec3 specColor, out mediump float oneMinusReflectivity)\r\n{\r\n\toneMinusReflectivity = 1.0 - specularStrength(specColor);\r\n    return albedo * (vec3(1.0) - specColor);\r\n}\r\n\r\n#ifdef TRANSPARENTBLEND\r\n\tmediump vec3 preMultiplyAlpha (mediump vec3 diffColor, mediump float alpha, mediump float oneMinusReflectivity,out mediump float modifiedAlpha)\r\n\t{\r\n\t\t// Transparency 'removes' from Diffuse component\r\n\t\tdiffColor *= alpha;\r\n\t\t// Reflectivity 'removes' from the rest of components, including Transparency\r\n\t\t// modifiedAlpha = 1.0-(1.0-alpha)*(1.0-reflectivity) = 1.0-(oneMinusReflectivity - alpha*oneMinusReflectivity) = 1.0-oneMinusReflectivity + alpha*oneMinusReflectivity\r\n\t\tmodifiedAlpha = 1.0 - oneMinusReflectivity + alpha*oneMinusReflectivity;\r\n\t\treturn diffColor;\r\n\t}\r\n#endif\r\n\r\nFragmentCommonData metallicSetup(vec2 uv)\r\n{\r\n\tmediump vec2 metallicGloss = metallicGloss(uv);\r\n\tmediump float metallic = metallicGloss.x;\r\n\tmediump float smoothness = metallicGloss.y; // this is 1 minus the square root of real roughness m.\r\n\tmediump float oneMinusReflectivity;\r\n\tmediump vec3 specColor;\r\n\tmediump vec3 diffColor = diffuseAndSpecularFromMetallic(albedo(uv), metallic,/*out*/specColor,/*out*/oneMinusReflectivity);\r\n\r\n\tFragmentCommonData o;\r\n\to.diffColor = diffColor;\r\n\to.specColor = specColor;\r\n\to.oneMinusReflectivity = oneMinusReflectivity;\r\n\to.smoothness = smoothness;\r\n\treturn o;\r\n}\r\n\r\nFragmentCommonData specularSetup(vec2 uv)\r\n{\r\n    mediump vec4 specGloss = specularGloss(uv);\r\n    mediump vec3 specColor = specGloss.rgb;\r\n    mediump float smoothness = specGloss.a;\r\n\r\n    mediump float oneMinusReflectivity;\r\n    mediump vec3 diffColor = energyConservationBetweenDiffuseAndSpecular (albedo(uv), specColor, /*out*/ oneMinusReflectivity);\r\n\r\n    FragmentCommonData o;\r\n    o.diffColor = diffColor;\r\n    o.specColor = specColor;\r\n    o.oneMinusReflectivity = oneMinusReflectivity;\r\n    o.smoothness = smoothness;\r\n    return o;\r\n}\r\n\r\nLayaGI fragmentGI(float smoothness,vec3 eyeVec,mediump float occlusion,mediump vec2 lightmapUV,vec3 worldnormal)\r\n{\r\n\tLayaGIInput giInput;\r\n\t#ifdef LIGHTMAP\r\n\t\tgiInput.lightmapUV=lightmapUV;\r\n\t#endif\r\n\r\n\tvec3 worldViewDir = -eyeVec;\r\n\tmediump vec4 uvwRoughness;\r\n\tuvwRoughness.rgb = reflect(worldViewDir, worldnormal);//reflectUVW\r\n\tuvwRoughness.a= smoothnessToPerceptualRoughness(smoothness);//perceptualRoughness\r\n\r\n\treturn layaGlobalIllumination(giInput,occlusion, worldnormal, uvwRoughness);\r\n}\r\n\r\n\r\nvec3 perPixelWorldNormal(vec2 uv,vec3 normal,vec3 binormal,vec3 tangent)\r\n{\r\n\t#ifdef NORMALTEXTURE\r\n\t\tmediump vec3 normalTangent=normalInTangentSpace(uv);\r\n\t\tvec3 normalWorld = normalize(tangent * normalTangent.x + binormal * normalTangent.y + normal * normalTangent.z);\r\n\t#else\r\n\t\tvec3 normalWorld = normalize(normal);\r\n\t#endif\r\n\t\treturn normalWorld;\r\n}\r\n\r\nvoid fragmentForward()\r\n{\r\n\tvec2 uv;\r\n\t#if defined(ALBEDOTEXTURE)||defined(METALLICGLOSSTEXTURE)||defined(NORMALTEXTURE)||defined(EMISSIONTEXTURE)||defined(OCCLUSIONTEXTURE)||defined(PARALLAXTEXTURE)\r\n\t\t#ifdef PARALLAXTEXTURE\r\n\t\t\tuv = parallax(v_Texcoord0,normalize(v_ViewDirForParallax));\r\n\t\t#else\r\n\t\t\tuv = v_Texcoord0;\r\n\t\t#endif\r\n\t#endif\r\n\r\n\tmediump float alpha = alpha(uv);\r\n\t#ifdef ALPHATEST\r\n\t\tif(alpha<u_AlphaTestValue)\r\n\t\t\tdiscard;\r\n\t#endif\r\n\r\n\tFragmentCommonData o = SETUP_BRDF_INPUT(uv);\r\n\t\r\n\tvec3 binormal;\r\n\tvec3 tangent;\r\n\t#ifdef NORMALTEXTURE\r\n\t\ttangent = v_Tangent;\r\n\t\tbinormal = v_Binormal;\r\n\t#endif\r\n\r\n\tvec3 normal = v_Normal;\r\n\tvec3 normalWorld = perPixelWorldNormal(uv,normal,binormal,tangent);//In FS if the normal use mediump before normalize will cause precision prolem in mobile device.\r\n\tvec3 eyeVec = normalize(v_EyeVec);\r\n\tvec3 posworld = v_PositionWorld;\r\n\r\n\t#ifdef TRANSPARENTBLEND\r\n\t\to.diffColor=preMultiplyAlpha(o.diffColor,alpha,o.oneMinusReflectivity,/*out*/alpha);// shader relies on pre-multiply alpha-blend (srcBlend = One, dstBlend = OneMinusSrcAlpha)\r\n\t#endif\r\n\r\n\tmediump float occlusion = occlusion(uv);\r\n\tmediump vec2 lightMapUV;\r\n\t#ifdef LIGHTMAP\r\n\t\tlightMapUV=v_LightMapUV;\r\n\t#endif\r\n\tfloat perceptualRoughness = smoothnessToPerceptualRoughness(o.smoothness);\r\n\tfloat roughness = perceptualRoughnessToRoughness(perceptualRoughness);\r\n\tfloat nv = abs(dot(normalWorld, eyeVec));\r\n\tLayaGI gi =fragmentGI(o.smoothness,eyeVec,occlusion,lightMapUV,normalWorld);\r\n\tvec4 color = LAYA_BRDF_GI(o.diffColor,o.specColor,o.oneMinusReflectivity,o.smoothness,perceptualRoughness,roughness,nv,normalWorld,eyeVec,gi);\r\n\t\r\n\t//Shadow\r\n\tfloat shadowValue = 1.0;\r\n\t#ifdef RECEIVESHADOW\r\n\t\t#ifdef SHADOWMAP_PSSM3\r\n\t\t\tshadowValue = getShadowPSSM3(u_shadowMap1,u_shadowMap2,u_shadowMap3,u_lightShadowVP,u_shadowPSSMDistance,u_shadowPCFoffset,v_PositionWorld,v_posViewZ,0.001);\r\n\t\t#endif\r\n\t\t#ifdef SHADOWMAP_PSSM2\r\n\t\t\tshadowValue = getShadowPSSM2(u_shadowMap1,u_shadowMap2,u_lightShadowVP,u_shadowPSSMDistance,u_shadowPCFoffset,v_PositionWorld,v_posViewZ,0.001);\r\n\t\t#endif \r\n\t\t#ifdef SHADOWMAP_PSSM1\r\n\t\t\tshadowValue = getShadowPSSM1(u_shadowMap1,v_lightMVPPos,u_shadowPSSMDistance,u_shadowPCFoffset,v_posViewZ,0.001);\r\n\t\t#endif\r\n\t#endif\r\n\r\n\t #ifdef LEGACYSINGLELIGHTING\r\n\t\t#ifdef DIRECTIONLIGHT\r\n\t\t\tLayaLight dirLight = layaDirectionLightToLight(u_DirectionLight,shadowValue);\r\n\t\t\tcolor+= LAYA_BRDF_LIGHT(o.diffColor,o.specColor,o.oneMinusReflectivity,perceptualRoughness,roughness,nv,normalWorld,eyeVec,dirLight);\r\n\t\t#endif\r\n\t\r\n\t\t#ifdef POINTLIGHT\r\n\t\t\tLayaLight poiLight = layaPointLightToLight(posworld,normalWorld,u_PointLight,shadowValue);\r\n\t\t\tcolor+= LAYA_BRDF_LIGHT(o.diffColor,o.specColor,o.oneMinusReflectivity,perceptualRoughness,roughness,nv,normalWorld,eyeVec,poiLight);\r\n\t\t#endif\r\n\t\t\r\n\t\t#ifdef SPOTLIGHT\r\n\t\t    LayaLight spoLight = layaSpotLightToLight(posworld,normalWorld,u_SpotLight,shadowValue);\r\n\t\t\tcolor+= LAYA_BRDF_LIGHT(o.diffColor,o.specColor,o.oneMinusReflectivity,perceptualRoughness,roughness,nv,normalWorld,eyeVec,spoLight);\r\n\t\t#endif\r\n\t#else\r\n\t \t#ifdef DIRECTIONLIGHT\r\n\t\t\tfor (int i = 0; i < MAX_LIGHT_COUNT; i++) \r\n\t\t\t{\r\n\t\t\t\tif(i >= u_DirationLightCount)\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tDirectionLight directionLight = getDirectionLight(u_LightBuffer,i);\r\n\t\t\t\tLayaLight dirLight = layaDirectionLightToLight(directionLight,shadowValue);\r\n\t\t\t \tcolor+=LAYA_BRDF_LIGHT(o.diffColor,o.specColor,o.oneMinusReflectivity,perceptualRoughness,roughness,nv,normalWorld,eyeVec,dirLight);\r\n\t\t\t}\r\n\t \t#endif\r\n\t\t#if defined(POINTLIGHT)||defined(SPOTLIGHT)\r\n\t\t\tivec4 clusterInfo =getClusterInfo(u_LightClusterBuffer,u_View,u_Viewport, v_PositionWorld,gl_FragCoord,u_ProjectionParams);\r\n\t\t\t#ifdef POINTLIGHT\r\n\t\t\t\tfor (int i = 0; i < MAX_LIGHT_COUNT; i++) \r\n\t\t\t\t{\r\n\t\t\t\t\tif(i >= clusterInfo.x)//PointLightCount\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tPointLight pointLight = getPointLight(u_LightBuffer,u_LightClusterBuffer,clusterInfo,i);\r\n\t\t\t\t\tLayaLight poiLight = layaPointLightToLight(posworld,normalWorld,pointLight,shadowValue);\r\n\t\t\t\t\tcolor+= LAYA_BRDF_LIGHT(o.diffColor,o.specColor,o.oneMinusReflectivity,perceptualRoughness,roughness,nv,normalWorld,eyeVec,poiLight);\r\n\t\t\t\t}\r\n\t\t\t#endif\r\n\t\t\t#ifdef SPOTLIGHT\r\n\t\t\t\tfor (int i = 0; i < MAX_LIGHT_COUNT; i++) \r\n\t\t\t\t{\r\n\t\t\t\t\tif(i >= clusterInfo.y)//SpotLightCount\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tSpotLight spotLight = getSpotLight(u_LightBuffer,u_LightClusterBuffer,clusterInfo,i);\r\n\t\t\t\t\tLayaLight spoLight = layaSpotLightToLight(posworld,normalWorld,spotLight,shadowValue);\r\n\t\t\t\t\tcolor+= LAYA_BRDF_LIGHT(o.diffColor,o.specColor,o.oneMinusReflectivity,perceptualRoughness,roughness,nv,normalWorld,eyeVec,spoLight);\r\n\t\t\t\t}\r\n\t\t\t#endif\r\n\t\t#endif\r\n\t #endif\r\n\r\n\t#ifdef EMISSION\r\n\t\tcolor.rgb += emission(uv);\r\n\t#endif\r\n\r\n\t#ifdef FOG\r\n\t\tfloat lerpFact=clamp((1.0/gl_FragCoord.w-u_FogStart)/u_FogRange,0.0,1.0);\r\n\t\tcolor.rgb=mix(color.rgb,u_FogColor,lerpFact);\r\n\t#endif\r\n\t\r\n\tgl_FragColor=vec4(color.rgb,alpha);\r\n}\r\n\r\n\r\n"),
                G.addInclude("PBRVertex.glsl", "vec2 transformLightMapUV(in vec2 texcoord,in vec4 lightmapScaleOffset)\r\n{\r\n\tvec2 lightMapUV=vec2(texcoord.x,1.0-texcoord.y)*lightmapScaleOffset.xy+lightmapScaleOffset.zw;\r\n\tlightMapUV.y=1.0-lightMapUV.y;\r\n\treturn lightMapUV; \r\n}\r\n\r\nvoid vertexForward()\r\n{\r\n\tvec4 position;\r\n\t#ifdef BONE\r\n\t\tmat4 skinTransform = u_Bones[int(a_BoneIndices.x)] * a_BoneWeights.x;\r\n\t\tskinTransform += u_Bones[int(a_BoneIndices.y)] * a_BoneWeights.y;\r\n\t\tskinTransform += u_Bones[int(a_BoneIndices.z)] * a_BoneWeights.z;\r\n\t\tskinTransform += u_Bones[int(a_BoneIndices.w)] * a_BoneWeights.w;\r\n\t\tposition=skinTransform*a_Position;\r\n\t#else\r\n\t\tposition=a_Position;\r\n\t#endif\r\n\r\n\t#ifdef GPU_INSTANCE\r\n\t\tgl_Position = a_MvpMatrix * position;\r\n\t#else\r\n\t\tgl_Position = u_MvpMatrix * position;\r\n\t#endif\r\n\r\n\tmat4 worldMat;\r\n\t#ifdef GPU_INSTANCE\r\n\t\tworldMat = a_WorldMat;\r\n\t#else\r\n\t\tworldMat = u_WorldMat;\r\n\t#endif\r\n\r\n\tv_PositionWorld=(worldMat*position).xyz;\r\n\r\n\t#if defined(ALBEDOTEXTURE)||defined(METALLICGLOSSTEXTURE)||defined(NORMALTEXTURE)||defined(EMISSIONTEXTURE)||defined(OCCLUSIONTEXTURE)||defined(PARALLAXTEXTURE)\r\n\t\t#ifdef TILINGOFFSET\r\n\t\t\tv_Texcoord0=TransformUV(a_Texcoord0,u_TilingOffset);\r\n\t\t#else\r\n\t\t\tv_Texcoord0=a_Texcoord0;\r\n\t\t#endif\r\n\t#endif\r\n\r\n\tv_EyeVec =u_CameraPos-v_PositionWorld;//will normalize per-pixel\r\n\r\n\t#ifdef LIGHTMAP\r\n\t\tvec2 texcoord;\r\n\t\t#ifdef UV1\r\n\t\t\ttexcoord=a_Texcoord1;\r\n\t\t#else\r\n\t\t\ttexcoord=a_Texcoord0;\r\n\t\t#endif\r\n\t\tv_LightMapUV=transformLightMapUV(texcoord,u_LightmapScaleOffset);\r\n\t#endif\r\n\r\n\tmat3 worldInvMat;\r\n\t#ifdef BONE\r\n\t\tworldInvMat=inverseMat(mat3(worldMat*skinTransform));\r\n\t#else\r\n\t\tworldInvMat=inverseMat(mat3(worldMat));\r\n\t#endif\r\n\r\n\tv_Normal=normalize(a_Normal*worldInvMat);//if no normalize will cause precision problem.\r\n\r\n\t#ifdef NORMALTEXTURE\r\n\t\tv_Tangent=normalize(a_Tangent0.xyz*worldInvMat);\r\n\t\tv_Binormal=cross(v_Normal,v_Tangent)*a_Tangent0.w;\r\n\t#endif\r\n\r\n\t#ifdef PARALLAXTEXTURE\r\n\t\tvec3 binormal = cross(a_Normal, a_Tangent0.xyz)*a_Tangent0.w;\r\n\t\tmat3 objectTBN = mat3(a_Tangent0.xyz, binormal, a_Normal);\r\n\t\tv_ViewDirForParallax=(worldInvMat*u_CameraPos-position.xyz)*objectTBN;\r\n\t#endif\r\n\r\n\t#ifdef RECEIVESHADOW\r\n\t\tv_posViewZ = gl_Position.w;\r\n\t\t#ifdef SHADOWMAP_PSSM1 \r\n\t\t\tv_lightMVPPos = u_lightShadowVP[0] * vec4(v_PositionWorld,1.0);\r\n\t\t#endif\r\n\t#endif\r\n}");
                var e = {
                    a_Position: ue.MESH_POSITION0,
                    a_Color: ue.MESH_COLOR0,
                    a_Normal: ue.MESH_NORMAL0,
                    a_Texcoord0: ue.MESH_TEXTURECOORDINATE0,
                    a_Texcoord1: ue.MESH_TEXTURECOORDINATE1,
                    a_BoneWeights: ue.MESH_BLENDWEIGHT0,
                    a_BoneIndices: ue.MESH_BLENDINDICES0,
                    a_Tangent0: ue.MESH_TANGENT0,
                    a_MvpMatrix: ue.MESH_MVPMATRIX_ROW0,
                    a_WorldMat: ue.MESH_WORLDMATRIX_ROW0
                }
                  , t = {
                    u_Bones: G.PERIOD_CUSTOM,
                    u_DiffuseTexture: G.PERIOD_MATERIAL,
                    u_SpecularTexture: G.PERIOD_MATERIAL,
                    u_NormalTexture: G.PERIOD_MATERIAL,
                    u_AlphaTestValue: G.PERIOD_MATERIAL,
                    u_DiffuseColor: G.PERIOD_MATERIAL,
                    u_MaterialSpecular: G.PERIOD_MATERIAL,
                    u_Shininess: G.PERIOD_MATERIAL,
                    u_TilingOffset: G.PERIOD_MATERIAL,
                    u_WorldMat: G.PERIOD_SPRITE,
                    u_MvpMatrix: G.PERIOD_SPRITE,
                    u_LightmapScaleOffset: G.PERIOD_SPRITE,
                    u_LightMap: G.PERIOD_SPRITE,
                    u_CameraPos: G.PERIOD_CAMERA,
                    u_Viewport: G.PERIOD_CAMERA,
                    u_ProjectionParams: G.PERIOD_CAMERA,
                    u_View: G.PERIOD_CAMERA,
                    u_ReflectTexture: G.PERIOD_SCENE,
                    u_ReflectIntensity: G.PERIOD_SCENE,
                    u_FogStart: G.PERIOD_SCENE,
                    u_FogRange: G.PERIOD_SCENE,
                    u_FogColor: G.PERIOD_SCENE,
                    u_DirationLightCount: G.PERIOD_SCENE,
                    u_LightBuffer: G.PERIOD_SCENE,
                    u_LightClusterBuffer: G.PERIOD_SCENE,
                    u_AmbientColor: G.PERIOD_SCENE,
                    u_shadowMap1: G.PERIOD_SCENE,
                    u_shadowMap2: G.PERIOD_SCENE,
                    u_shadowMap3: G.PERIOD_SCENE,
                    u_shadowPSSMDistance: G.PERIOD_SCENE,
                    u_lightShadowVP: G.PERIOD_SCENE,
                    u_shadowPCFoffset: G.PERIOD_SCENE,
                    u_AmbientSHAr: G.PERIOD_SCENE,
                    u_AmbientSHAg: G.PERIOD_SCENE,
                    u_AmbientSHAb: G.PERIOD_SCENE,
                    u_AmbientSHBr: G.PERIOD_SCENE,
                    u_AmbientSHBg: G.PERIOD_SCENE,
                    u_AmbientSHBb: G.PERIOD_SCENE,
                    u_AmbientSHC: G.PERIOD_SCENE,
                    "u_DirectionLight.color": G.PERIOD_SCENE,
                    "u_DirectionLight.direction": G.PERIOD_SCENE,
                    "u_PointLight.position": G.PERIOD_SCENE,
                    "u_PointLight.range": G.PERIOD_SCENE,
                    "u_PointLight.color": G.PERIOD_SCENE,
                    "u_SpotLight.position": G.PERIOD_SCENE,
                    "u_SpotLight.direction": G.PERIOD_SCENE,
                    "u_SpotLight.range": G.PERIOD_SCENE,
                    "u_SpotLight.spot": G.PERIOD_SCENE,
                    "u_SpotLight.color": G.PERIOD_SCENE
                }
                  , r = {
                    s_Cull: G.RENDER_STATE_CULL,
                    s_Blend: G.RENDER_STATE_BLEND,
                    s_BlendSrc: G.RENDER_STATE_BLEND_SRC,
                    s_BlendDst: G.RENDER_STATE_BLEND_DST,
                    s_DepthTest: G.RENDER_STATE_DEPTH_TEST,
                    s_DepthWrite: G.RENDER_STATE_DEPTH_WRITE
                }
                  , n = G.add("BLINNPHONG", null, null, !0)
                  , i = new ie(e,t);
                n.addSubShader(i),
                i.addShaderPass('#include "Lighting.glsl";\r\n\r\nattribute vec4 a_Position;\r\n\r\n#ifdef GPU_INSTANCE\r\n\tattribute mat4 a_MvpMatrix;\r\n#else\r\n\tuniform mat4 u_MvpMatrix;\r\n#endif\r\n\r\n\r\n#if defined(DIFFUSEMAP)||((defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT))&&(defined(SPECULARMAP)||defined(NORMALMAP)))||(defined(LIGHTMAP)&&defined(UV))\r\n\tattribute vec2 a_Texcoord0;\r\n\tvarying vec2 v_Texcoord0;\r\n#endif\r\n\r\n#if defined(LIGHTMAP)&&defined(UV1)\r\n\tattribute vec2 a_Texcoord1;\r\n#endif\r\n\r\n#ifdef LIGHTMAP\r\n\tuniform vec4 u_LightmapScaleOffset;\r\n\tvarying vec2 v_LightMapUV;\r\n#endif\r\n\r\n#ifdef COLOR\r\n\tattribute vec4 a_Color;\r\n\tvarying vec4 v_Color;\r\n#endif\r\n\r\n#ifdef BONE\r\n\tconst int c_MaxBoneCount = 24;\r\n\tattribute vec4 a_BoneIndices;\r\n\tattribute vec4 a_BoneWeights;\r\n\tuniform mat4 u_Bones[c_MaxBoneCount];\r\n#endif\r\n\r\nattribute vec3 a_Normal;\r\nvarying vec3 v_Normal; \r\n\r\n#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)\r\n\tuniform vec3 u_CameraPos;\r\n\tvarying vec3 v_ViewDir; \r\n#endif\r\n\r\n#if defined(NORMALMAP)\r\n\tattribute vec4 a_Tangent0;\r\n\tvarying vec3 v_Tangent;\r\n\tvarying vec3 v_Binormal;\r\n#endif\r\n\r\n#ifdef GPU_INSTANCE\r\n\tattribute mat4 a_WorldMat;\r\n#else\r\n\tuniform mat4 u_WorldMat;\r\n#endif\r\n\r\n#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)||defined(RECEIVESHADOW)\r\n\tvarying vec3 v_PositionWorld;\r\n#endif\r\n\r\nvarying float v_posViewZ;\r\n#ifdef RECEIVESHADOW\r\n  #ifdef SHADOWMAP_PSSM1 \r\n  varying vec4 v_lightMVPPos;\r\n  uniform mat4 u_lightShadowVP[4];\r\n  #endif\r\n#endif\r\n\r\n#ifdef TILINGOFFSET\r\n\tuniform vec4 u_TilingOffset;\r\n#endif\r\n\r\nvoid main_castShadow()\r\n{\r\n\tvec4 position;\r\n\t#ifdef BONE\r\n\t\tmat4 skinTransform = u_Bones[int(a_BoneIndices.x)] * a_BoneWeights.x;\r\n\t\tskinTransform += u_Bones[int(a_BoneIndices.y)] * a_BoneWeights.y;\r\n\t\tskinTransform += u_Bones[int(a_BoneIndices.z)] * a_BoneWeights.z;\r\n\t\tskinTransform += u_Bones[int(a_BoneIndices.w)] * a_BoneWeights.w;\r\n\t\tposition=skinTransform*a_Position;\r\n\t#else\r\n\t\tposition=a_Position;\r\n\t#endif\r\n\t#ifdef GPU_INSTANCE\r\n\t\tgl_Position = a_MvpMatrix * position;\r\n\t#else\r\n\t\tgl_Position = u_MvpMatrix * position;\r\n\t#endif\r\n\t\r\n\t//TODO没考虑UV动画呢\r\n\t#if defined(DIFFUSEMAP)&&defined(ALPHATEST)\r\n\t\tv_Texcoord0=a_Texcoord0;\r\n\t#endif\r\n\tgl_Position=remapGLPositionZ(gl_Position);\r\n\tv_posViewZ = gl_Position.z;\r\n}\r\n\r\nvoid main_normal()\r\n{\r\n\tvec4 position;\r\n\t#ifdef BONE\r\n\t\tmat4 skinTransform = u_Bones[int(a_BoneIndices.x)] * a_BoneWeights.x;\r\n\t\tskinTransform += u_Bones[int(a_BoneIndices.y)] * a_BoneWeights.y;\r\n\t\tskinTransform += u_Bones[int(a_BoneIndices.z)] * a_BoneWeights.z;\r\n\t\tskinTransform += u_Bones[int(a_BoneIndices.w)] * a_BoneWeights.w;\r\n\t\tposition=skinTransform*a_Position;\r\n\t#else\r\n\t\tposition=a_Position;\r\n\t#endif\r\n\t#ifdef GPU_INSTANCE\r\n\t\tgl_Position = a_MvpMatrix * position;\r\n\t#else\r\n\t\tgl_Position = u_MvpMatrix * position;\r\n\t#endif\r\n\t\r\n\tmat4 worldMat;\r\n\t#ifdef GPU_INSTANCE\r\n\t\tworldMat = a_WorldMat;\r\n\t#else\r\n\t\tworldMat = u_WorldMat;\r\n\t#endif\r\n\r\n\tmat3 worldInvMat;\r\n\t#ifdef BONE\r\n\t\tworldInvMat=inverseMat(mat3(worldMat*skinTransform));\r\n\t#else\r\n\t\tworldInvMat=inverseMat(mat3(worldMat));\r\n\t#endif  \r\n\tv_Normal=normalize(a_Normal*worldInvMat);\r\n\t#if defined(NORMALMAP)\r\n\t\tv_Tangent=normalize(a_Tangent0.xyz*worldInvMat);\r\n\t\tv_Binormal=cross(v_Normal,v_Tangent)*a_Tangent0.w;\r\n\t#endif\r\n\r\n\t#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)||defined(RECEIVESHADOW)\r\n\t\tv_PositionWorld=(worldMat*position).xyz;\r\n\t#endif\r\n\t\r\n\t#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)\r\n\t\tv_ViewDir=u_CameraPos-v_PositionWorld;\r\n\t#endif\r\n\r\n\t#if defined(DIFFUSEMAP)||((defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT))&&(defined(SPECULARMAP)||defined(NORMALMAP)))\r\n\t\t#ifdef TILINGOFFSET\r\n\t\t\tv_Texcoord0=TransformUV(a_Texcoord0,u_TilingOffset);\r\n\t\t#else\r\n\t\t\tv_Texcoord0=a_Texcoord0;\r\n\t\t#endif\r\n\t#endif\r\n\r\n\t#ifdef LIGHTMAP\r\n\t\t#ifdef UV1\r\n\t\t\tv_LightMapUV=vec2(a_Texcoord1.x,1.0-a_Texcoord1.y)*u_LightmapScaleOffset.xy+u_LightmapScaleOffset.zw;\r\n\t\t#else\r\n\t\t\tv_LightMapUV=vec2(a_Texcoord0.x,1.0-a_Texcoord0.y)*u_LightmapScaleOffset.xy+u_LightmapScaleOffset.zw;\r\n\t\t#endif \r\n\t\tv_LightMapUV.y=1.0-v_LightMapUV.y;\r\n\t#endif\r\n\r\n\t#if defined(COLOR)&&defined(ENABLEVERTEXCOLOR)\r\n\t\tv_Color=a_Color;\r\n\t#endif\r\n\r\n\t#ifdef RECEIVESHADOW\r\n\t\tv_posViewZ = gl_Position.w;\r\n\t\t#ifdef SHADOWMAP_PSSM1 \r\n\t\t\tv_lightMVPPos = u_lightShadowVP[0] * vec4(v_PositionWorld,1.0);\r\n\t\t#endif\r\n\t#endif\r\n\tgl_Position=remapGLPositionZ(gl_Position);\r\n}\r\n\r\nvoid main()\r\n{\r\n\t#ifdef CASTSHADOW\r\n\t\tmain_castShadow();\r\n\t#else\r\n\t\tmain_normal();\r\n\t#endif\r\n}', '#ifdef GL_FRAGMENT_PRECISION_HIGH\r\n\tprecision highp float;\r\n\tprecision highp int;\r\n#else\r\n\tprecision mediump float;\r\n\tprecision mediump int;\r\n#endif\r\n\r\n#include "Lighting.glsl";\r\n\r\nuniform vec4 u_DiffuseColor;\r\n\r\n#if defined(COLOR)&&defined(ENABLEVERTEXCOLOR)\r\n\tvarying vec4 v_Color;\r\n#endif\r\n\r\n#ifdef ALPHATEST\r\n\tuniform float u_AlphaTestValue;\r\n#endif\r\n\r\n#ifdef DIFFUSEMAP\r\n\tuniform sampler2D u_DiffuseTexture;\r\n#endif\r\n\r\n\r\n#if defined(DIFFUSEMAP)||((defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT))&&(defined(SPECULARMAP)||defined(NORMALMAP)))\r\n\tvarying vec2 v_Texcoord0;\r\n#endif\r\n\r\n#ifdef LIGHTMAP\r\n\tvarying vec2 v_LightMapUV;\r\n\tuniform sampler2D u_LightMap;\r\n#endif\r\n\r\nvarying vec3 v_Normal;\r\n#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)\r\n\tvarying vec3 v_ViewDir; \r\n\r\n\tuniform vec3 u_MaterialSpecular;\r\n\tuniform float u_Shininess;\r\n\r\n\t#ifdef LEGACYSINGLELIGHTING\r\n\t\t#ifdef DIRECTIONLIGHT\r\n\t\t\tuniform DirectionLight u_DirectionLight;\r\n\t\t#endif\r\n\t\t#ifdef POINTLIGHT\r\n\t\t\tuniform PointLight u_PointLight;\r\n\t\t#endif\r\n\t\t#ifdef SPOTLIGHT\r\n\t\t\tuniform SpotLight u_SpotLight;\r\n\t\t#endif\r\n\t#else\r\n\t\tuniform mat4 u_View;\r\n\t\tuniform vec4 u_ProjectionParams;\r\n\t\tuniform vec4 u_Viewport;\r\n\t\tuniform int u_DirationLightCount;\r\n\t\tuniform sampler2D u_LightBuffer;\r\n\t\tuniform sampler2D u_LightClusterBuffer;\r\n\t#endif\r\n\r\n\t#ifdef SPECULARMAP \r\n\t\tuniform sampler2D u_SpecularTexture;\r\n\t#endif\r\n#endif\r\n\r\n#ifdef NORMALMAP \r\n\tuniform sampler2D u_NormalTexture;\r\n\tvarying vec3 v_Tangent;\r\n\tvarying vec3 v_Binormal;\r\n#endif\r\n\r\n#ifdef FOG\r\n\tuniform float u_FogStart;\r\n\tuniform float u_FogRange;\r\n\tuniform vec3 u_FogColor;\r\n#endif\r\n\r\n#if defined(POINTLIGHT)||defined(SPOTLIGHT)||defined(RECEIVESHADOW)\r\n\tvarying vec3 v_PositionWorld;\r\n#endif\r\n\r\n\r\n#include "GlobalIllumination.glsl";//"GlobalIllumination.glsl use uniform should at front of this\r\n\r\n#include "ShadowHelper.glsl"\r\nvarying float v_posViewZ;\r\n#ifdef RECEIVESHADOW\r\n\t#if defined(SHADOWMAP_PSSM2)||defined(SHADOWMAP_PSSM3)\r\n\t\tuniform mat4 u_lightShadowVP[4];\r\n\t#endif\r\n\t#ifdef SHADOWMAP_PSSM1 \r\n\t\tvarying vec4 v_lightMVPPos;\r\n\t#endif\r\n#endif\r\n\r\n\r\nvoid main_castShadow()\r\n{\r\n\t//gl_FragColor=vec4(v_posViewZ,0.0,0.0,1.0);\r\n\tgl_FragColor=packDepth(v_posViewZ);\r\n\t#if defined(DIFFUSEMAP)&&defined(ALPHATEST)\r\n\t\tfloat alpha = texture2D(u_DiffuseTexture,v_Texcoord0).w;\r\n\t\tif( alpha < u_AlphaTestValue )\r\n\t\t{\r\n\t\t\tdiscard;\r\n\t\t}\r\n\t#endif\r\n}\r\nvoid main_normal()\r\n{\r\n\tvec3 normal;//light and SH maybe use normal\r\n\t#if defined(NORMALMAP)\r\n\t\tvec3 normalMapSample = texture2D(u_NormalTexture, v_Texcoord0).rgb;\r\n\t\tnormal = normalize(NormalSampleToWorldSpace(normalMapSample, v_Normal, v_Tangent,v_Binormal));\r\n\t#else\r\n\t\tnormal = normalize(v_Normal);\r\n\t#endif\r\n\r\n\t#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)\r\n\t\tvec3 viewDir= normalize(v_ViewDir);\r\n\t#endif\r\n\r\n\tLayaGIInput giInput;\r\n\t#ifdef LIGHTMAP\t\r\n\t\tgiInput.lightmapUV=v_LightMapUV;\r\n\t#endif\r\n\tvec3 globalDiffuse=layaGIBase(giInput,1.0,normal);\r\n\t\r\n\tvec4 mainColor=u_DiffuseColor;\r\n\t#ifdef DIFFUSEMAP\r\n\t\tvec4 difTexColor=texture2D(u_DiffuseTexture, v_Texcoord0);\r\n\t\tmainColor=mainColor*difTexColor;\r\n\t#endif \r\n\t#if defined(COLOR)&&defined(ENABLEVERTEXCOLOR)\r\n\t\tmainColor=mainColor*v_Color;\r\n\t#endif \r\n    \r\n\t#ifdef ALPHATEST\r\n\t\tif(mainColor.a<u_AlphaTestValue)\r\n\t\t\tdiscard;\r\n\t#endif\r\n  \r\n\t\r\n\tvec3 diffuse = vec3(0.0);\r\n\tvec3 specular= vec3(0.0);\r\n\t#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)\r\n\t\tvec3 dif,spe;\r\n\t\t#ifdef SPECULARMAP\r\n\t\t\tvec3 gloss=texture2D(u_SpecularTexture, v_Texcoord0).rgb;\r\n\t\t#else\r\n\t\t\t#ifdef DIFFUSEMAP\r\n\t\t\t\tvec3 gloss=vec3(difTexColor.a);\r\n\t\t\t#else\r\n\t\t\t\tvec3 gloss=vec3(1.0);\r\n\t\t\t#endif\r\n\t\t#endif\r\n\t#endif\r\n\r\n\t#ifdef LEGACYSINGLELIGHTING\r\n\t\t#ifdef DIRECTIONLIGHT\r\n\t\t\tLayaAirBlinnPhongDiectionLight(u_MaterialSpecular,u_Shininess,normal,gloss,viewDir,u_DirectionLight,dif,spe);\r\n\t\t\tdiffuse+=dif;\r\n\t\t\tspecular+=spe;\r\n\t\t#endif\r\n\t\r\n\t\t#ifdef POINTLIGHT\r\n\t\t\tLayaAirBlinnPhongPointLight(v_PositionWorld,u_MaterialSpecular,u_Shininess,normal,gloss,viewDir,u_PointLight,dif,spe);\r\n\t\t\tdiffuse+=dif;\r\n\t\t\tspecular+=spe;\r\n\t\t#endif\r\n\r\n\t\t#ifdef SPOTLIGHT\r\n\t\t\tLayaAirBlinnPhongSpotLight(v_PositionWorld,u_MaterialSpecular,u_Shininess,normal,gloss,viewDir,u_SpotLight,dif,spe);\r\n\t\t\tdiffuse+=dif;\r\n\t\t\tspecular+=spe;\r\n\t\t#endif\r\n\t#else\r\n\t\t#ifdef DIRECTIONLIGHT\r\n\t\t\tfor (int i = 0; i < MAX_LIGHT_COUNT; i++) \r\n\t\t\t{\r\n\t\t\t\tif(i >= u_DirationLightCount)\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tDirectionLight directionLight = getDirectionLight(u_LightBuffer,i);\r\n\t\t\t\tLayaAirBlinnPhongDiectionLight(u_MaterialSpecular,u_Shininess,normal,gloss,viewDir,directionLight,dif,spe);\r\n\t\t\t\tdiffuse+=dif;\r\n\t\t\t\tspecular+=spe;\r\n\t\t\t}\r\n\t\t#endif\r\n\t\t#if defined(POINTLIGHT)||defined(SPOTLIGHT)\r\n\t\t\tivec4 clusterInfo =getClusterInfo(u_LightClusterBuffer,u_View,u_Viewport, v_PositionWorld,gl_FragCoord,u_ProjectionParams);\r\n\t\t\t#ifdef POINTLIGHT\r\n\t\t\t\tfor (int i = 0; i < MAX_LIGHT_COUNT; i++) \r\n\t\t\t\t{\r\n\t\t\t\t\tif(i >= clusterInfo.x)//PointLightCount\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tPointLight pointLight = getPointLight(u_LightBuffer,u_LightClusterBuffer,clusterInfo,i);\r\n\t\t\t\t\tLayaAirBlinnPhongPointLight(v_PositionWorld,u_MaterialSpecular,u_Shininess,normal,gloss,viewDir,pointLight,dif,spe);\r\n\t\t\t\t\tdiffuse+=dif;\r\n\t\t\t\t\tspecular+=spe;\r\n\t\t\t\t}\r\n\t\t\t#endif\r\n\t\t\t#ifdef SPOTLIGHT\r\n\t\t\t\tfor (int i = 0; i < MAX_LIGHT_COUNT; i++) \r\n\t\t\t\t{\r\n\t\t\t\t\tif(i >= clusterInfo.y)//SpotLightCount\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tSpotLight spotLight = getSpotLight(u_LightBuffer,u_LightClusterBuffer,clusterInfo,i);\r\n\t\t\t\t\tLayaAirBlinnPhongSpotLight(v_PositionWorld,u_MaterialSpecular,u_Shininess,normal,gloss,viewDir,spotLight,dif,spe);\r\n\t\t\t\t\tdiffuse+=dif;\r\n\t\t\t\t\tspecular+=spe;\r\n\t\t\t\t}\r\n\t\t\t#endif\r\n\t\t#endif\r\n\t#endif\r\n\r\n\t#ifdef RECEIVESHADOW\r\n\t\tfloat shadowValue = 1.0;\r\n\t\t#ifdef SHADOWMAP_PSSM3\r\n\t\t\tshadowValue = getShadowPSSM3(u_shadowMap1,u_shadowMap2,u_shadowMap3,u_lightShadowVP,u_shadowPSSMDistance,u_shadowPCFoffset,v_PositionWorld,v_posViewZ,0.001);\r\n\t\t#endif\r\n\t\t#ifdef SHADOWMAP_PSSM2\r\n\t\t\tshadowValue = getShadowPSSM2(u_shadowMap1,u_shadowMap2,u_lightShadowVP,u_shadowPSSMDistance,u_shadowPCFoffset,v_PositionWorld,v_posViewZ,0.001);\r\n\t\t#endif \r\n\t\t#ifdef SHADOWMAP_PSSM1\r\n\t\t\tshadowValue = getShadowPSSM1(u_shadowMap1,v_lightMVPPos,u_shadowPSSMDistance,u_shadowPCFoffset,v_posViewZ,0.001);\r\n\t\t#endif\r\n\t\tgl_FragColor =vec4(mainColor.rgb*(globalDiffuse + diffuse*shadowValue),mainColor.a);\r\n\t#else\r\n\t\tgl_FragColor =vec4(mainColor.rgb*(globalDiffuse + diffuse),mainColor.a);\r\n\t#endif\r\n\r\n\t#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)\r\n\t\t#ifdef RECEIVESHADOW\r\n\t\t\tgl_FragColor.rgb+=specular*shadowValue;\r\n\t\t#else\r\n\t\t\tgl_FragColor.rgb+=specular;\r\n\t\t#endif\r\n\t#endif\r\n\t  \r\n\t#ifdef FOG\r\n\t\tfloat lerpFact=clamp((1.0/gl_FragCoord.w-u_FogStart)/u_FogRange,0.0,1.0);\r\n\t\tgl_FragColor.rgb=mix(gl_FragColor.rgb,u_FogColor,lerpFact);\r\n\t#endif\r\n}\r\n\r\nvoid main()\r\n{\r\n\t#ifdef CASTSHADOW\t\t\r\n\t\tmain_castShadow();\r\n\t#else\r\n\t\tmain_normal();\r\n\t#endif  \r\n}\r\n\r\n', r),
                e = {
                    a_Position: ue.MESH_POSITION0,
                    a_Color: ue.MESH_COLOR0
                },
                t = {
                    u_MvpMatrix: G.PERIOD_SPRITE,
                    u_Color: G.PERIOD_MATERIAL
                },
                r = {
                    s_Cull: G.RENDER_STATE_CULL,
                    s_Blend: G.RENDER_STATE_BLEND,
                    s_BlendSrc: G.RENDER_STATE_BLEND_SRC,
                    s_BlendDst: G.RENDER_STATE_BLEND_DST,
                    s_DepthTest: G.RENDER_STATE_DEPTH_TEST,
                    s_DepthWrite: G.RENDER_STATE_DEPTH_WRITE
                },
                n = G.add("LineShader"),
                i = new ie(e,t),
                n.addSubShader(i),
                i.addShaderPass('#include "Lighting.glsl";\r\n\r\nattribute vec4 a_Position;\r\nuniform mat4 u_MvpMatrix;\r\nuniform vec4 u_Color;\r\nattribute vec4 a_Color;\r\nvarying vec4 v_Color;\r\n\r\n\r\nvoid main()\r\n{\r\n\tgl_Position = u_MvpMatrix * a_Position;\r\n\tv_Color=a_Color*u_Color;\r\n\tgl_Position=remapGLPositionZ(gl_Position);\r\n}', "#ifdef GL_FRAGMENT_PRECISION_HIGH\r\nprecision highp float;\r\n#else\r\nprecision mediump float;\r\n#endif\r\n\r\nvarying vec4 v_Color;\r\nuniform vec4 u_Color;\r\n\r\nvoid main()\r\n{\r\n  gl_FragColor = v_Color * u_Color; \r\n}\r\n\r\n", r),
                e = {
                    a_Position: ue.MESH_POSITION0,
                    a_Color: ue.MESH_COLOR0,
                    a_Texcoord0: ue.MESH_TEXTURECOORDINATE0,
                    a_BoneWeights: ue.MESH_BLENDWEIGHT0,
                    a_BoneIndices: ue.MESH_BLENDINDICES0,
                    a_MvpMatrix: ue.MESH_MVPMATRIX_ROW0
                },
                t = {
                    u_Bones: G.PERIOD_CUSTOM,
                    u_AlbedoTexture: G.PERIOD_MATERIAL,
                    u_AlbedoColor: G.PERIOD_MATERIAL,
                    u_TilingOffset: G.PERIOD_MATERIAL,
                    u_AlphaTestValue: G.PERIOD_MATERIAL,
                    u_MvpMatrix: G.PERIOD_SPRITE,
                    u_FogStart: G.PERIOD_SCENE,
                    u_FogRange: G.PERIOD_SCENE,
                    u_FogColor: G.PERIOD_SCENE
                },
                r = {
                    s_Cull: G.RENDER_STATE_CULL,
                    s_Blend: G.RENDER_STATE_BLEND,
                    s_BlendSrc: G.RENDER_STATE_BLEND_SRC,
                    s_BlendDst: G.RENDER_STATE_BLEND_DST,
                    s_DepthTest: G.RENDER_STATE_DEPTH_TEST,
                    s_DepthWrite: G.RENDER_STATE_DEPTH_WRITE
                },
                n = G.add("Unlit", null, null, !0),
                i = new ie(e,t),
                n.addSubShader(i),
                i.addShaderPass('#include "Lighting.glsl";\r\n\r\nattribute vec4 a_Position;\r\n\r\nattribute vec2 a_Texcoord0;\r\n\r\n#ifdef GPU_INSTANCE\r\n\tattribute mat4 a_MvpMatrix;\r\n#else\r\n\tuniform mat4 u_MvpMatrix;\r\n#endif\r\n\r\nattribute vec4 a_Color;\r\nvarying vec4 v_Color;\r\nvarying vec2 v_Texcoord0;\r\n\r\n#ifdef TILINGOFFSET\r\n\tuniform vec4 u_TilingOffset;\r\n#endif\r\n\r\n#ifdef BONE\r\n\tconst int c_MaxBoneCount = 24;\r\n\tattribute vec4 a_BoneIndices;\r\n\tattribute vec4 a_BoneWeights;\r\n\tuniform mat4 u_Bones[c_MaxBoneCount];\r\n#endif\r\n\r\nvoid main() {\r\n\tvec4 position;\r\n\t#ifdef BONE\r\n\t\tmat4 skinTransform = u_Bones[int(a_BoneIndices.x)] * a_BoneWeights.x;\r\n\t\tskinTransform += u_Bones[int(a_BoneIndices.y)] * a_BoneWeights.y;\r\n\t\tskinTransform += u_Bones[int(a_BoneIndices.z)] * a_BoneWeights.z;\r\n\t\tskinTransform += u_Bones[int(a_BoneIndices.w)] * a_BoneWeights.w;\r\n\t\tposition=skinTransform*a_Position;\r\n\t#else\r\n\t\tposition=a_Position;\r\n\t#endif\r\n\t#ifdef GPU_INSTANCE\r\n\t\tgl_Position = a_MvpMatrix * position;\r\n\t#else\r\n\t\tgl_Position = u_MvpMatrix * position;\r\n\t#endif\r\n\r\n\t#ifdef TILINGOFFSET\r\n\t\tv_Texcoord0=TransformUV(a_Texcoord0,u_TilingOffset);\r\n\t#else\r\n\t\tv_Texcoord0=a_Texcoord0;\r\n\t#endif\r\n\r\n\t#if defined(COLOR)&&defined(ENABLEVERTEXCOLOR)\r\n\t\tv_Color = a_Color;\r\n\t#endif\r\n\tgl_Position=remapGLPositionZ(gl_Position);\r\n}', "#ifdef GL_FRAGMENT_PRECISION_HIGH\r\n\tprecision highp float;\r\n#else\r\n\tprecision mediump float;\r\n#endif\r\n\r\n#if defined(COLOR)&&defined(ENABLEVERTEXCOLOR)\r\n\tvarying vec4 v_Color;\r\n#endif\r\n\r\n#ifdef ALBEDOTEXTURE\r\n\tuniform sampler2D u_AlbedoTexture;\r\n\tvarying vec2 v_Texcoord0;\r\n#endif\r\n\r\nuniform vec4 u_AlbedoColor;\r\n\r\n#ifdef ALPHATEST\r\n\tuniform float u_AlphaTestValue;\r\n#endif\r\n\r\n#ifdef FOG\r\n\tuniform float u_FogStart;\r\n\tuniform float u_FogRange;\r\n\t#ifdef ADDTIVEFOG\r\n\t#else\r\n\t\tuniform vec3 u_FogColor;\r\n\t#endif\r\n#endif\r\n\r\nvoid main()\r\n{\r\n\tvec4 color =  u_AlbedoColor;\r\n\t#ifdef ALBEDOTEXTURE\r\n\t\tcolor *= texture2D(u_AlbedoTexture, v_Texcoord0);\r\n\t#endif\r\n\t#if defined(COLOR)&&defined(ENABLEVERTEXCOLOR)\r\n\t\tcolor *= v_Color;\r\n\t#endif\r\n\t\r\n\t#ifdef ALPHATEST\r\n\t\tif(color.a < u_AlphaTestValue)\r\n\t\t\tdiscard;\r\n\t#endif\r\n\t\r\n\tgl_FragColor = color;\r\n\t\r\n\t#ifdef FOG\r\n\t\tfloat lerpFact = clamp((1.0 / gl_FragCoord.w - u_FogStart) / u_FogRange, 0.0, 1.0);\r\n\t\t#ifdef ADDTIVEFOG\r\n\t\t\tgl_FragColor.rgb = mix(gl_FragColor.rgb, vec3(0.0), lerpFact);\r\n\t\t#else\r\n\t\t\tgl_FragColor.rgb = mix(gl_FragColor.rgb, u_FogColor, lerpFact);\r\n\t\t#endif\r\n\t#endif\r\n\t\r\n}\r\n\r\n", r),
                e = {
                    a_Position: ue.MESH_POSITION0,
                    a_Texcoord0: ue.MESH_TEXTURECOORDINATE0,
                    a_BoneWeights: ue.MESH_BLENDWEIGHT0,
                    a_BoneIndices: ue.MESH_BLENDINDICES0,
                    a_MvpMatrix: ue.MESH_MVPMATRIX_ROW0
                },
                t = {
                    u_Bones: G.PERIOD_CUSTOM,
                    u_AlbedoTexture: G.PERIOD_MATERIAL,
                    u_AlbedoColor: G.PERIOD_MATERIAL,
                    u_TilingOffset: G.PERIOD_MATERIAL,
                    u_AlphaTestValue: G.PERIOD_MATERIAL,
                    u_MvpMatrix: G.PERIOD_SPRITE,
                    u_FogStart: G.PERIOD_SCENE,
                    u_FogRange: G.PERIOD_SCENE,
                    u_FogColor: G.PERIOD_SCENE
                },
                r = {
                    s_Cull: G.RENDER_STATE_CULL,
                    s_Blend: G.RENDER_STATE_BLEND,
                    s_BlendSrc: G.RENDER_STATE_BLEND_SRC,
                    s_BlendDst: G.RENDER_STATE_BLEND_DST,
                    s_DepthTest: G.RENDER_STATE_DEPTH_TEST,
                    s_DepthWrite: G.RENDER_STATE_DEPTH_WRITE
                },
                n = G.add("Effect", null, null, !0),
                i = new ie(e,t),
                n.addSubShader(i),
                i.addShaderPass('#include "Lighting.glsl";\r\n\r\nattribute vec4 a_Position;\r\nattribute vec4 a_Color;\r\nattribute vec2 a_Texcoord0;\r\n\r\n#ifdef GPU_INSTANCE\r\n\tattribute mat4 a_MvpMatrix;\r\n#else\r\n\tuniform mat4 u_MvpMatrix;\r\n#endif\r\n\r\n#ifdef COLOR\r\n\tvarying vec4 v_Color;\r\n#endif\r\nvarying vec2 v_Texcoord0;\r\n\r\n#ifdef TILINGOFFSET\r\n\tuniform vec4 u_TilingOffset;\r\n#endif\r\n\r\n#ifdef BONE\r\n\tconst int c_MaxBoneCount = 24;\r\n\tattribute vec4 a_BoneIndices;\r\n\tattribute vec4 a_BoneWeights;\r\n\tuniform mat4 u_Bones[c_MaxBoneCount];\r\n#endif\r\n\r\nvoid main()\r\n{\r\n\tvec4 position;\r\n\t#ifdef BONE\r\n\t\tmat4 skinTransform = u_Bones[int(a_BoneIndices.x)] * a_BoneWeights.x;\r\n\t\tskinTransform += u_Bones[int(a_BoneIndices.y)] * a_BoneWeights.y;\r\n\t\tskinTransform += u_Bones[int(a_BoneIndices.z)] * a_BoneWeights.z;\r\n\t\tskinTransform += u_Bones[int(a_BoneIndices.w)] * a_BoneWeights.w;\r\n\t\tposition=skinTransform*a_Position;\r\n\t#else\r\n\t\tposition=a_Position;\r\n\t#endif\r\n\t#ifdef GPU_INSTANCE\r\n\t\tgl_Position = a_MvpMatrix * position;\r\n\t#else\r\n\t\tgl_Position = u_MvpMatrix * position;\r\n\t#endif\r\n\t\r\n\t#ifdef TILINGOFFSET\r\n\t\tv_Texcoord0=TransformUV(a_Texcoord0,u_TilingOffset);\r\n\t#else\r\n\t\tv_Texcoord0=a_Texcoord0;\r\n\t#endif\r\n\t\t\r\n\t#ifdef COLOR\r\n\t\tv_Color = a_Color;\r\n\t#endif\r\n\tgl_Position=remapGLPositionZ(gl_Position);\r\n}', "#ifdef GL_FRAGMENT_PRECISION_HIGH\r\n\tprecision highp float;\r\n#else\r\n\tprecision mediump float;\r\n#endif\r\n\r\n#ifdef COLOR\r\n\tvarying vec4 v_Color;\r\n#endif\r\nvarying vec2 v_Texcoord0;\r\n\r\n#ifdef MAINTEXTURE\r\n\tuniform sampler2D u_AlbedoTexture;\r\n#endif\r\n\r\nuniform vec4 u_AlbedoColor;\r\n\r\n#ifdef FOG\r\n\tuniform float u_FogStart;\r\n\tuniform float u_FogRange;\r\n\t#ifdef ADDTIVEFOG\r\n\t#else\r\n\t\tuniform vec3 u_FogColor;\r\n\t#endif\r\n#endif\r\n\r\nvoid main()\r\n{\r\n\tvec4 color =  2.0 * u_AlbedoColor;\r\n\t#ifdef COLOR\r\n\t\tcolor *= v_Color;\r\n\t#endif\r\n\t#ifdef MAINTEXTURE\r\n\t\tcolor *= texture2D(u_AlbedoTexture, v_Texcoord0);\r\n\t#endif\r\n\t\r\n\tgl_FragColor = color;\r\n\t\r\n\t#ifdef FOG\r\n\t\tfloat lerpFact = clamp((1.0 / gl_FragCoord.w - u_FogStart) / u_FogRange, 0.0, 1.0);\r\n\t\t#ifdef ADDTIVEFOG\r\n\t\t\tgl_FragColor.rgb = mix(gl_FragColor.rgb, vec3(0.0), lerpFact);\r\n\t\t#else\r\n\t\t\tgl_FragColor.rgb = mix(gl_FragColor.rgb, u_FogColor, lerpFact);\r\n\t\t#endif\r\n\t#endif\r\n}\r\n\r\n", r),
                e = {
                    a_CornerTextureCoordinate: Gt.PARTICLE_CORNERTEXTURECOORDINATE0,
                    a_MeshPosition: Gt.PARTICLE_POSITION0,
                    a_MeshColor: Gt.PARTICLE_COLOR0,
                    a_MeshTextureCoordinate: Gt.PARTICLE_TEXTURECOORDINATE0,
                    a_ShapePositionStartLifeTime: Gt.PARTICLE_SHAPEPOSITIONSTARTLIFETIME,
                    a_DirectionTime: Gt.PARTICLE_DIRECTIONTIME,
                    a_StartColor: Gt.PARTICLE_STARTCOLOR0,
                    a_EndColor: Gt.PARTICLE_ENDCOLOR0,
                    a_StartSize: Gt.PARTICLE_STARTSIZE,
                    a_StartRotation0: Gt.PARTICLE_STARTROTATION,
                    a_StartSpeed: Gt.PARTICLE_STARTSPEED,
                    a_Random0: Gt.PARTICLE_RANDOM0,
                    a_Random1: Gt.PARTICLE_RANDOM1,
                    a_SimulationWorldPostion: Gt.PARTICLE_SIMULATIONWORLDPOSTION,
                    a_SimulationWorldRotation: Gt.PARTICLE_SIMULATIONWORLDROTATION
                },
                t = {
                    u_Tintcolor: G.PERIOD_MATERIAL,
                    u_TilingOffset: G.PERIOD_MATERIAL,
                    u_texture: G.PERIOD_MATERIAL,
                    u_WorldPosition: G.PERIOD_SPRITE,
                    u_WorldRotation: G.PERIOD_SPRITE,
                    u_PositionScale: G.PERIOD_SPRITE,
                    u_SizeScale: G.PERIOD_SPRITE,
                    u_ScalingMode: G.PERIOD_SPRITE,
                    u_Gravity: G.PERIOD_SPRITE,
                    u_ThreeDStartRotation: G.PERIOD_SPRITE,
                    u_StretchedBillboardLengthScale: G.PERIOD_SPRITE,
                    u_StretchedBillboardSpeedScale: G.PERIOD_SPRITE,
                    u_SimulationSpace: G.PERIOD_SPRITE,
                    u_CurrentTime: G.PERIOD_SPRITE,
                    u_ColorOverLifeGradientAlphas: G.PERIOD_SPRITE,
                    u_ColorOverLifeGradientColors: G.PERIOD_SPRITE,
                    u_MaxColorOverLifeGradientAlphas: G.PERIOD_SPRITE,
                    u_MaxColorOverLifeGradientColors: G.PERIOD_SPRITE,
                    u_VOLVelocityConst: G.PERIOD_SPRITE,
                    u_VOLVelocityGradientX: G.PERIOD_SPRITE,
                    u_VOLVelocityGradientY: G.PERIOD_SPRITE,
                    u_VOLVelocityGradientZ: G.PERIOD_SPRITE,
                    u_VOLVelocityConstMax: G.PERIOD_SPRITE,
                    u_VOLVelocityGradientMaxX: G.PERIOD_SPRITE,
                    u_VOLVelocityGradientMaxY: G.PERIOD_SPRITE,
                    u_VOLVelocityGradientMaxZ: G.PERIOD_SPRITE,
                    u_VOLSpaceType: G.PERIOD_SPRITE,
                    u_SOLSizeGradient: G.PERIOD_SPRITE,
                    u_SOLSizeGradientX: G.PERIOD_SPRITE,
                    u_SOLSizeGradientY: G.PERIOD_SPRITE,
                    u_SOLSizeGradientZ: G.PERIOD_SPRITE,
                    u_SOLSizeGradientMax: G.PERIOD_SPRITE,
                    u_SOLSizeGradientMaxX: G.PERIOD_SPRITE,
                    u_SOLSizeGradientMaxY: G.PERIOD_SPRITE,
                    u_SOLSizeGradientMaxZ: G.PERIOD_SPRITE,
                    u_ROLAngularVelocityConst: G.PERIOD_SPRITE,
                    u_ROLAngularVelocityConstSeprarate: G.PERIOD_SPRITE,
                    u_ROLAngularVelocityGradient: G.PERIOD_SPRITE,
                    u_ROLAngularVelocityGradientX: G.PERIOD_SPRITE,
                    u_ROLAngularVelocityGradientY: G.PERIOD_SPRITE,
                    u_ROLAngularVelocityGradientZ: G.PERIOD_SPRITE,
                    u_ROLAngularVelocityConstMax: G.PERIOD_SPRITE,
                    u_ROLAngularVelocityConstMaxSeprarate: G.PERIOD_SPRITE,
                    u_ROLAngularVelocityGradientMax: G.PERIOD_SPRITE,
                    u_ROLAngularVelocityGradientMaxX: G.PERIOD_SPRITE,
                    u_ROLAngularVelocityGradientMaxY: G.PERIOD_SPRITE,
                    u_ROLAngularVelocityGradientMaxZ: G.PERIOD_SPRITE,
                    u_ROLAngularVelocityGradientMaxW: G.PERIOD_SPRITE,
                    u_TSACycles: G.PERIOD_SPRITE,
                    u_TSASubUVLength: G.PERIOD_SPRITE,
                    u_TSAGradientUVs: G.PERIOD_SPRITE,
                    u_TSAMaxGradientUVs: G.PERIOD_SPRITE,
                    u_CameraPos: G.PERIOD_CAMERA,
                    u_CameraDirection: G.PERIOD_CAMERA,
                    u_CameraUp: G.PERIOD_CAMERA,
                    u_View: G.PERIOD_CAMERA,
                    u_Projection: G.PERIOD_CAMERA,
                    u_FogStart: G.PERIOD_SCENE,
                    u_FogRange: G.PERIOD_SCENE,
                    u_FogColor: G.PERIOD_SCENE
                },
                r = {
                    s_Cull: G.RENDER_STATE_CULL,
                    s_Blend: G.RENDER_STATE_BLEND,
                    s_BlendSrc: G.RENDER_STATE_BLEND_SRC,
                    s_BlendDst: G.RENDER_STATE_BLEND_DST,
                    s_DepthTest: G.RENDER_STATE_DEPTH_TEST,
                    s_DepthWrite: G.RENDER_STATE_DEPTH_WRITE
                },
                n = G.add("PARTICLESHURIKEN"),
                i = new ie(e,t),
                n.addSubShader(i),
                i.addShaderPass('#include "Lighting.glsl";\r\n\r\n#ifdef GL_FRAGMENT_PRECISION_HIGH\r\n  precision highp float;\r\n#else\r\n  precision mediump float;\r\n#endif\r\n\r\n#if defined(SPHERHBILLBOARD)||defined(STRETCHEDBILLBOARD)||defined(HORIZONTALBILLBOARD)||defined(VERTICALBILLBOARD)\r\n\tattribute vec4 a_CornerTextureCoordinate;\r\n#endif\r\n#ifdef RENDERMODE_MESH\r\n\tattribute vec3 a_MeshPosition;\r\n\tattribute vec4 a_MeshColor;\r\n\tattribute vec2 a_MeshTextureCoordinate;\r\n\tvarying vec4 v_MeshColor;\r\n#endif\r\n\r\nattribute vec4 a_ShapePositionStartLifeTime;\r\nattribute vec4 a_DirectionTime;\r\nattribute vec4 a_StartColor;\r\nattribute vec3 a_StartSize;\r\nattribute vec3 a_StartRotation0;\r\nattribute float a_StartSpeed;\r\n#if defined(COLOROVERLIFETIME)||defined(RANDOMCOLOROVERLIFETIME)||defined(SIZEOVERLIFETIMERANDOMCURVES)||defined(SIZEOVERLIFETIMERANDOMCURVESSEPERATE)||defined(ROTATIONOVERLIFETIMERANDOMCONSTANTS)||defined(ROTATIONOVERLIFETIMERANDOMCURVES)\r\n  attribute vec4 a_Random0;\r\n#endif\r\n#if defined(TEXTURESHEETANIMATIONRANDOMCURVE)||defined(VELOCITYOVERLIFETIMERANDOMCONSTANT)||defined(VELOCITYOVERLIFETIMERANDOMCURVE)\r\n  attribute vec4 a_Random1;\r\n#endif\r\nattribute vec3 a_SimulationWorldPostion;\r\nattribute vec4 a_SimulationWorldRotation;\r\n\r\nvarying vec4 v_Color;\r\n#ifdef DIFFUSEMAP\r\n\tvarying vec2 v_TextureCoordinate;\r\n#endif\r\n\r\nuniform float u_CurrentTime;\r\nuniform vec3 u_Gravity;\r\n\r\nuniform vec3 u_WorldPosition;\r\nuniform vec4 u_WorldRotation;\r\nuniform bool u_ThreeDStartRotation;\r\nuniform int u_ScalingMode;\r\nuniform vec3 u_PositionScale;\r\nuniform vec3 u_SizeScale;\r\nuniform mat4 u_View;\r\nuniform mat4 u_Projection;\r\n\r\n#ifdef STRETCHEDBILLBOARD\r\n\tuniform vec3 u_CameraPos;\r\n#endif\r\nuniform vec3 u_CameraDirection;//TODO:只有几种广告牌模式需要用\r\nuniform vec3 u_CameraUp;\r\n\r\nuniform  float u_StretchedBillboardLengthScale;\r\nuniform  float u_StretchedBillboardSpeedScale;\r\nuniform int u_SimulationSpace;\r\n\r\n#if defined(VELOCITYOVERLIFETIMECONSTANT)||defined(VELOCITYOVERLIFETIMECURVE)||defined(VELOCITYOVERLIFETIMERANDOMCONSTANT)||defined(VELOCITYOVERLIFETIMERANDOMCURVE)\r\n  uniform  int  u_VOLSpaceType;\r\n#endif\r\n#if defined(VELOCITYOVERLIFETIMECONSTANT)||defined(VELOCITYOVERLIFETIMERANDOMCONSTANT)\r\n  uniform  vec3 u_VOLVelocityConst;\r\n#endif\r\n#if defined(VELOCITYOVERLIFETIMECURVE)||defined(VELOCITYOVERLIFETIMERANDOMCURVE)\r\n  uniform  vec2 u_VOLVelocityGradientX[4];//x为key,y为速度\r\n  uniform  vec2 u_VOLVelocityGradientY[4];//x为key,y为速度\r\n  uniform  vec2 u_VOLVelocityGradientZ[4];//x为key,y为速度\r\n#endif\r\n#ifdef VELOCITYOVERLIFETIMERANDOMCONSTANT\r\n  uniform  vec3 u_VOLVelocityConstMax;\r\n#endif\r\n#ifdef VELOCITYOVERLIFETIMERANDOMCURVE\r\n  uniform  vec2 u_VOLVelocityGradientMaxX[4];//x为key,y为速度\r\n  uniform  vec2 u_VOLVelocityGradientMaxY[4];//x为key,y为速度\r\n  uniform  vec2 u_VOLVelocityGradientMaxZ[4];//x为key,y为速度\r\n#endif\r\n\r\n#ifdef COLOROVERLIFETIME\r\n  uniform  vec4 u_ColorOverLifeGradientColors[4];//x为key,yzw为Color\r\n  uniform  vec2 u_ColorOverLifeGradientAlphas[4];//x为key,y为Alpha\r\n#endif\r\n#ifdef RANDOMCOLOROVERLIFETIME\r\n  uniform  vec4 u_ColorOverLifeGradientColors[4];//x为key,yzw为Color\r\n  uniform  vec2 u_ColorOverLifeGradientAlphas[4];//x为key,y为Alpha\r\n  uniform  vec4 u_MaxColorOverLifeGradientColors[4];//x为key,yzw为Color\r\n  uniform  vec2 u_MaxColorOverLifeGradientAlphas[4];//x为key,y为Alpha\r\n#endif\r\n\r\n\r\n#if defined(SIZEOVERLIFETIMECURVE)||defined(SIZEOVERLIFETIMERANDOMCURVES)\r\n  uniform  vec2 u_SOLSizeGradient[4];//x为key,y为尺寸\r\n#endif\r\n#ifdef SIZEOVERLIFETIMERANDOMCURVES\r\n  uniform  vec2 u_SOLSizeGradientMax[4];//x为key,y为尺寸\r\n#endif\r\n#if defined(SIZEOVERLIFETIMECURVESEPERATE)||defined(SIZEOVERLIFETIMERANDOMCURVESSEPERATE)\r\n  uniform  vec2 u_SOLSizeGradientX[4];//x为key,y为尺寸\r\n  uniform  vec2 u_SOLSizeGradientY[4];//x为key,y为尺寸\r\n  uniform  vec2 u_SOLSizeGradientZ[4];//x为key,y为尺寸\r\n#endif\r\n#ifdef SIZEOVERLIFETIMERANDOMCURVESSEPERATE\r\n  uniform  vec2 u_SOLSizeGradientMaxX[4];//x为key,y为尺寸\r\n  uniform  vec2 u_SOLSizeGradientMaxY[4];//x为key,y为尺寸\r\n  uniform  vec2 u_SOLSizeGradientMaxZ[4];//x为key,y为尺寸\r\n#endif\r\n\r\n\r\n#ifdef ROTATIONOVERLIFETIME\r\n  #if defined(ROTATIONOVERLIFETIMECONSTANT)||defined(ROTATIONOVERLIFETIMERANDOMCONSTANTS)\r\n    uniform  float u_ROLAngularVelocityConst;\r\n  #endif\r\n  #ifdef ROTATIONOVERLIFETIMERANDOMCONSTANTS\r\n    uniform  float u_ROLAngularVelocityConstMax;\r\n  #endif\r\n  #if defined(ROTATIONOVERLIFETIMECURVE)||defined(ROTATIONOVERLIFETIMERANDOMCURVES)\r\n    uniform  vec2 u_ROLAngularVelocityGradient[4];//x为key,y为旋转\r\n  #endif\r\n  #ifdef ROTATIONOVERLIFETIMERANDOMCURVES\r\n    uniform  vec2 u_ROLAngularVelocityGradientMax[4];//x为key,y为旋转\r\n  #endif\r\n#endif\r\n#ifdef ROTATIONOVERLIFETIMESEPERATE\r\n  #if defined(ROTATIONOVERLIFETIMECONSTANT)||defined(ROTATIONOVERLIFETIMERANDOMCONSTANTS)\r\n    uniform  vec3 u_ROLAngularVelocityConstSeprarate;\r\n  #endif\r\n  #ifdef ROTATIONOVERLIFETIMERANDOMCONSTANTS\r\n    uniform  vec3 u_ROLAngularVelocityConstMaxSeprarate;\r\n  #endif\r\n  #if defined(ROTATIONOVERLIFETIMECURVE)||defined(ROTATIONOVERLIFETIMERANDOMCURVES)\r\n    uniform  vec2 u_ROLAngularVelocityGradientX[4];\r\n    uniform  vec2 u_ROLAngularVelocityGradientY[4];\r\n    uniform  vec2 u_ROLAngularVelocityGradientZ[4];\r\n  #endif\r\n  #ifdef ROTATIONOVERLIFETIMERANDOMCURVES\r\n    uniform  vec2 u_ROLAngularVelocityGradientMaxX[4];\r\n    uniform  vec2 u_ROLAngularVelocityGradientMaxY[4];\r\n    uniform  vec2 u_ROLAngularVelocityGradientMaxZ[4];\r\n\tuniform  vec2 u_ROLAngularVelocityGradientMaxW[4];\r\n  #endif\r\n#endif\r\n\r\n#if defined(TEXTURESHEETANIMATIONCURVE)||defined(TEXTURESHEETANIMATIONRANDOMCURVE)\r\n  uniform  float u_TSACycles;\r\n  uniform  vec2 u_TSASubUVLength;\r\n  uniform  vec2 u_TSAGradientUVs[4];//x为key,y为frame\r\n#endif\r\n#ifdef TEXTURESHEETANIMATIONRANDOMCURVE\r\n  uniform  vec2 u_TSAMaxGradientUVs[4];//x为key,y为frame\r\n#endif\r\n\r\n#ifdef TILINGOFFSET\r\n\tuniform vec4 u_TilingOffset;\r\n#endif\r\n\r\nvec3 rotationByEuler(in vec3 vector,in vec3 rot)\r\n{\r\n\tfloat halfRoll = rot.z * 0.5;\r\n    float halfPitch = rot.x * 0.5;\r\n\tfloat halfYaw = rot.y * 0.5;\r\n\r\n\tfloat sinRoll = sin(halfRoll);\r\n\tfloat cosRoll = cos(halfRoll);\r\n\tfloat sinPitch = sin(halfPitch);\r\n\tfloat cosPitch = cos(halfPitch);\r\n\tfloat sinYaw = sin(halfYaw);\r\n\tfloat cosYaw = cos(halfYaw);\r\n\r\n\tfloat quaX = (cosYaw * sinPitch * cosRoll) + (sinYaw * cosPitch * sinRoll);\r\n\tfloat quaY = (sinYaw * cosPitch * cosRoll) - (cosYaw * sinPitch * sinRoll);\r\n\tfloat quaZ = (cosYaw * cosPitch * sinRoll) - (sinYaw * sinPitch * cosRoll);\r\n\tfloat quaW = (cosYaw * cosPitch * cosRoll) + (sinYaw * sinPitch * sinRoll);\r\n\t\r\n\t//vec4 q=vec4(quaX,quaY,quaZ,quaW);\r\n\t//vec3 temp = cross(q.xyz, vector) + q.w * vector;\r\n\t//return (cross(temp, -q.xyz) + dot(q.xyz,vector) * q.xyz + q.w * temp);\r\n\t\r\n\tfloat x = quaX + quaX;\r\n    float y = quaY + quaY;\r\n    float z = quaZ + quaZ;\r\n    float wx = quaW * x;\r\n    float wy = quaW * y;\r\n    float wz = quaW * z;\r\n\tfloat xx = quaX * x;\r\n    float xy = quaX * y;\r\n\tfloat xz = quaX * z;\r\n    float yy = quaY * y;\r\n    float yz = quaY * z;\r\n    float zz = quaZ * z;\r\n\r\n    return vec3(((vector.x * ((1.0 - yy) - zz)) + (vector.y * (xy - wz))) + (vector.z * (xz + wy)),\r\n                ((vector.x * (xy + wz)) + (vector.y * ((1.0 - xx) - zz))) + (vector.z * (yz - wx)),\r\n                ((vector.x * (xz - wy)) + (vector.y * (yz + wx))) + (vector.z * ((1.0 - xx) - yy)));\r\n\t\r\n}\r\n\r\n//假定axis已经归一化\r\nvec3 rotationByAxis(in vec3 vector,in vec3 axis, in float angle)\r\n{\r\n\tfloat halfAngle = angle * 0.5;\r\n\tfloat sin = sin(halfAngle);\r\n\t\r\n\tfloat quaX = axis.x * sin;\r\n\tfloat quaY = axis.y * sin;\r\n\tfloat quaZ = axis.z * sin;\r\n\tfloat quaW = cos(halfAngle);\r\n\t\r\n\t//vec4 q=vec4(quaX,quaY,quaZ,quaW);\r\n\t//vec3 temp = cross(q.xyz, vector) + q.w * vector;\r\n\t//return (cross(temp, -q.xyz) + dot(q.xyz,vector) * q.xyz + q.w * temp);\r\n\t\r\n\tfloat x = quaX + quaX;\r\n    float y = quaY + quaY;\r\n    float z = quaZ + quaZ;\r\n    float wx = quaW * x;\r\n    float wy = quaW * y;\r\n    float wz = quaW * z;\r\n\tfloat xx = quaX * x;\r\n    float xy = quaX * y;\r\n\tfloat xz = quaX * z;\r\n    float yy = quaY * y;\r\n    float yz = quaY * z;\r\n    float zz = quaZ * z;\r\n\r\n    return vec3(((vector.x * ((1.0 - yy) - zz)) + (vector.y * (xy - wz))) + (vector.z * (xz + wy)),\r\n                ((vector.x * (xy + wz)) + (vector.y * ((1.0 - xx) - zz))) + (vector.z * (yz - wx)),\r\n                ((vector.x * (xz - wy)) + (vector.y * (yz + wx))) + (vector.z * ((1.0 - xx) - yy)));\r\n\t\r\n}\r\n\r\nvec3 rotationByQuaternions(in vec3 v,in vec4 q) \r\n{\r\n\treturn v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);\r\n}\r\n\r\n \r\n#if defined(VELOCITYOVERLIFETIMECURVE)||defined(VELOCITYOVERLIFETIMERANDOMCURVE)||defined(SIZEOVERLIFETIMECURVE)||defined(SIZEOVERLIFETIMECURVESEPERATE)||defined(SIZEOVERLIFETIMERANDOMCURVES)||defined(SIZEOVERLIFETIMERANDOMCURVESSEPERATE)\r\nfloat getCurValueFromGradientFloat(in vec2 gradientNumbers[4],in float normalizedAge)\r\n{\r\n\tfloat curValue;\r\n\tfor(int i=1;i<4;i++)\r\n\t{\r\n\t\tvec2 gradientNumber=gradientNumbers[i];\r\n\t\tfloat key=gradientNumber.x;\r\n\t\tif(key>=normalizedAge)\r\n\t\t{\r\n\t\t\tvec2 lastGradientNumber=gradientNumbers[i-1];\r\n\t\t\tfloat lastKey=lastGradientNumber.x;\r\n\t\t\tfloat age=(normalizedAge-lastKey)/(key-lastKey);\r\n\t\t\tcurValue=mix(lastGradientNumber.y,gradientNumber.y,age);\r\n\t\t\tbreak;\r\n\t\t}\r\n\t}\r\n\treturn curValue;\r\n}\r\n#endif\r\n\r\n#if defined(VELOCITYOVERLIFETIMECURVE)||defined(VELOCITYOVERLIFETIMERANDOMCURVE)||defined(ROTATIONOVERLIFETIMECURVE)||defined(ROTATIONOVERLIFETIMERANDOMCURVES)\r\nfloat getTotalValueFromGradientFloat(in vec2 gradientNumbers[4],in float normalizedAge)\r\n{\r\n\tfloat totalValue=0.0;\r\n\tfor(int i=1;i<4;i++)\r\n\t{\r\n\t\tvec2 gradientNumber=gradientNumbers[i];\r\n\t\tfloat key=gradientNumber.x;\r\n\t\tvec2 lastGradientNumber=gradientNumbers[i-1];\r\n\t\tfloat lastValue=lastGradientNumber.y;\r\n\t\t\r\n\t\tif(key>=normalizedAge){\r\n\t\t\tfloat lastKey=lastGradientNumber.x;\r\n\t\t\tfloat age=(normalizedAge-lastKey)/(key-lastKey);\r\n\t\t\ttotalValue+=(lastValue+mix(lastValue,gradientNumber.y,age))/2.0*a_ShapePositionStartLifeTime.w*(normalizedAge-lastKey);\r\n\t\t\tbreak;\r\n\t\t}\r\n\t\telse{\r\n\t\t\ttotalValue+=(lastValue+gradientNumber.y)/2.0*a_ShapePositionStartLifeTime.w*(key-lastGradientNumber.x);\r\n\t\t}\r\n\t}\r\n\treturn totalValue;\r\n}\r\n#endif\r\n\r\n#if defined(COLOROVERLIFETIME)||defined(RANDOMCOLOROVERLIFETIME)\r\nvec4 getColorFromGradient(in vec2 gradientAlphas[4],in vec4 gradientColors[4],in float normalizedAge)\r\n{\r\n\tvec4 overTimeColor;\r\n\tfor(int i=1;i<4;i++)\r\n\t{\r\n\t\tvec2 gradientAlpha=gradientAlphas[i];\r\n\t\tfloat alphaKey=gradientAlpha.x;\r\n\t\tif(alphaKey>=normalizedAge)\r\n\t\t{\r\n\t\t\tvec2 lastGradientAlpha=gradientAlphas[i-1];\r\n\t\t\tfloat lastAlphaKey=lastGradientAlpha.x;\r\n\t\t\tfloat age=(normalizedAge-lastAlphaKey)/(alphaKey-lastAlphaKey);\r\n\t\t\toverTimeColor.a=mix(lastGradientAlpha.y,gradientAlpha.y,age);\r\n\t\t\tbreak;\r\n\t\t}\r\n\t}\r\n\t\r\n\tfor(int i=1;i<4;i++)\r\n\t{\r\n\t\tvec4 gradientColor=gradientColors[i];\r\n\t\tfloat colorKey=gradientColor.x;\r\n\t\tif(colorKey>=normalizedAge)\r\n\t\t{\r\n\t\t\tvec4 lastGradientColor=gradientColors[i-1];\r\n\t\t\tfloat lastColorKey=lastGradientColor.x;\r\n\t\t\tfloat age=(normalizedAge-lastColorKey)/(colorKey-lastColorKey);\r\n\t\t\toverTimeColor.rgb=mix(gradientColors[i-1].yzw,gradientColor.yzw,age);\r\n\t\t\tbreak;\r\n\t\t}\r\n\t}\r\n\treturn overTimeColor;\r\n}\r\n#endif\r\n\r\n\r\n#if defined(TEXTURESHEETANIMATIONCURVE)||defined(TEXTURESHEETANIMATIONRANDOMCURVE)\r\nfloat getFrameFromGradient(in vec2 gradientFrames[4],in float normalizedAge)\r\n{\r\n\tfloat overTimeFrame;\r\n\tfor(int i=1;i<4;i++)\r\n\t{\r\n\t\tvec2 gradientFrame=gradientFrames[i];\r\n\t\tfloat key=gradientFrame.x;\r\n\t\tif(key>=normalizedAge)\r\n\t\t{\r\n\t\t\tvec2 lastGradientFrame=gradientFrames[i-1];\r\n\t\t\tfloat lastKey=lastGradientFrame.x;\r\n\t\t\tfloat age=(normalizedAge-lastKey)/(key-lastKey);\r\n\t\t\toverTimeFrame=mix(lastGradientFrame.y,gradientFrame.y,age);\r\n\t\t\tbreak;\r\n\t\t}\r\n\t}\r\n\treturn floor(overTimeFrame);\r\n}\r\n#endif\r\n\r\n#if defined(VELOCITYOVERLIFETIMECONSTANT)||defined(VELOCITYOVERLIFETIMECURVE)||defined(VELOCITYOVERLIFETIMERANDOMCONSTANT)||defined(VELOCITYOVERLIFETIMERANDOMCURVE)\r\nvec3 computeParticleLifeVelocity(in float normalizedAge)\r\n{\r\n  vec3 outLifeVelocity;\r\n  #ifdef VELOCITYOVERLIFETIMECONSTANT\r\n\t outLifeVelocity=u_VOLVelocityConst; \r\n  #endif\r\n  #ifdef VELOCITYOVERLIFETIMECURVE\r\n     outLifeVelocity= vec3(getCurValueFromGradientFloat(u_VOLVelocityGradientX,normalizedAge),getCurValueFromGradientFloat(u_VOLVelocityGradientY,normalizedAge),getCurValueFromGradientFloat(u_VOLVelocityGradientZ,normalizedAge));\r\n  #endif\r\n  #ifdef VELOCITYOVERLIFETIMERANDOMCONSTANT\r\n\t outLifeVelocity=mix(u_VOLVelocityConst,u_VOLVelocityConstMax,vec3(a_Random1.y,a_Random1.z,a_Random1.w)); \r\n  #endif\r\n  #ifdef VELOCITYOVERLIFETIMERANDOMCURVE\r\n     outLifeVelocity=vec3(mix(getCurValueFromGradientFloat(u_VOLVelocityGradientX,normalizedAge),getCurValueFromGradientFloat(u_VOLVelocityGradientMaxX,normalizedAge),a_Random1.y),\r\n\t                 mix(getCurValueFromGradientFloat(u_VOLVelocityGradientY,normalizedAge),getCurValueFromGradientFloat(u_VOLVelocityGradientMaxY,normalizedAge),a_Random1.z),\r\n\t\t\t\t\t mix(getCurValueFromGradientFloat(u_VOLVelocityGradientZ,normalizedAge),getCurValueFromGradientFloat(u_VOLVelocityGradientMaxZ,normalizedAge),a_Random1.w));\r\n  #endif\r\n\t\t\t\t\t\r\n  return outLifeVelocity;\r\n} \r\n#endif\r\n\r\nvec3 computeParticlePosition(in vec3 startVelocity, in vec3 lifeVelocity,in float age,in float normalizedAge,vec3 gravityVelocity,vec4 worldRotation)\r\n{\r\n   vec3 startPosition;\r\n   vec3 lifePosition;\r\n   #if defined(VELOCITYOVERLIFETIMECONSTANT)||defined(VELOCITYOVERLIFETIMECURVE)||defined(VELOCITYOVERLIFETIMERANDOMCONSTANT)||defined(VELOCITYOVERLIFETIMERANDOMCURVE)\r\n\t#ifdef VELOCITYOVERLIFETIMECONSTANT\r\n\t\t  startPosition=startVelocity*age;\r\n\t\t  lifePosition=lifeVelocity*age;\r\n\t#endif\r\n\t#ifdef VELOCITYOVERLIFETIMECURVE\r\n\t\t  startPosition=startVelocity*age;\r\n\t\t  lifePosition=vec3(getTotalValueFromGradientFloat(u_VOLVelocityGradientX,normalizedAge),getTotalValueFromGradientFloat(u_VOLVelocityGradientY,normalizedAge),getTotalValueFromGradientFloat(u_VOLVelocityGradientZ,normalizedAge));\r\n\t#endif\r\n\t#ifdef VELOCITYOVERLIFETIMERANDOMCONSTANT\r\n\t\t  startPosition=startVelocity*age;\r\n\t\t  lifePosition=lifeVelocity*age;\r\n\t#endif\r\n\t#ifdef VELOCITYOVERLIFETIMERANDOMCURVE\r\n\t\t  startPosition=startVelocity*age;\r\n\t\t  lifePosition=vec3(mix(getTotalValueFromGradientFloat(u_VOLVelocityGradientX,normalizedAge),getTotalValueFromGradientFloat(u_VOLVelocityGradientMaxX,normalizedAge),a_Random1.y)\r\n\t      ,mix(getTotalValueFromGradientFloat(u_VOLVelocityGradientY,normalizedAge),getTotalValueFromGradientFloat(u_VOLVelocityGradientMaxY,normalizedAge),a_Random1.z)\r\n\t      ,mix(getTotalValueFromGradientFloat(u_VOLVelocityGradientZ,normalizedAge),getTotalValueFromGradientFloat(u_VOLVelocityGradientMaxZ,normalizedAge),a_Random1.w));\r\n\t#endif\r\n\t\r\n\tvec3 finalPosition;\r\n\tif(u_VOLSpaceType==0){\r\n\t  if(u_ScalingMode!=2)\r\n\t   finalPosition =rotationByQuaternions(u_PositionScale*(a_ShapePositionStartLifeTime.xyz+startPosition+lifePosition),worldRotation);\r\n\t  else\r\n\t   finalPosition =rotationByQuaternions(u_PositionScale*a_ShapePositionStartLifeTime.xyz+startPosition+lifePosition,worldRotation);\r\n\t}\r\n\telse{\r\n\t  if(u_ScalingMode!=2)\r\n\t    finalPosition = rotationByQuaternions(u_PositionScale*(a_ShapePositionStartLifeTime.xyz+startPosition),worldRotation)+lifePosition;\r\n\t  else\r\n\t    finalPosition = rotationByQuaternions(u_PositionScale*a_ShapePositionStartLifeTime.xyz+startPosition,worldRotation)+lifePosition;\r\n\t}\r\n  #else\r\n\t startPosition=startVelocity*age;\r\n\t vec3 finalPosition;\r\n\t if(u_ScalingMode!=2)\r\n\t\t\tfinalPosition = rotationByQuaternions(u_PositionScale*(a_ShapePositionStartLifeTime.xyz+startPosition),worldRotation);\r\n\t else\r\n\t   \tfinalPosition = rotationByQuaternions(u_PositionScale*a_ShapePositionStartLifeTime.xyz+startPosition,worldRotation);\r\n  #endif\r\n  \r\n  if(u_SimulationSpace==0)\r\n    finalPosition=finalPosition+a_SimulationWorldPostion;\r\n  else if(u_SimulationSpace==1) \r\n    finalPosition=finalPosition+u_WorldPosition;\r\n  \r\n  finalPosition+=0.5*gravityVelocity*age;\r\n \r\n  return  finalPosition;\r\n}\r\n\r\n\r\nvec4 computeParticleColor(in vec4 color,in float normalizedAge)\r\n{\r\n\t#ifdef COLOROVERLIFETIME\r\n\t  color*=getColorFromGradient(u_ColorOverLifeGradientAlphas,u_ColorOverLifeGradientColors,normalizedAge);\r\n\t#endif\r\n\t\r\n\t#ifdef RANDOMCOLOROVERLIFETIME\r\n\t  color*=mix(getColorFromGradient(u_ColorOverLifeGradientAlphas,u_ColorOverLifeGradientColors,normalizedAge),getColorFromGradient(u_MaxColorOverLifeGradientAlphas,u_MaxColorOverLifeGradientColors,normalizedAge),a_Random0.y);\r\n\t#endif\r\n\r\n    return color;\r\n}\r\n\r\nvec2 computeParticleSizeBillbard(in vec2 size,in float normalizedAge)\r\n{\r\n\t#ifdef SIZEOVERLIFETIMECURVE\r\n\t\tsize*=getCurValueFromGradientFloat(u_SOLSizeGradient,normalizedAge);\r\n\t#endif\r\n\t#ifdef SIZEOVERLIFETIMERANDOMCURVES\r\n\t    size*=mix(getCurValueFromGradientFloat(u_SOLSizeGradient,normalizedAge),getCurValueFromGradientFloat(u_SOLSizeGradientMax,normalizedAge),a_Random0.z); \r\n\t#endif\r\n\t#ifdef SIZEOVERLIFETIMECURVESEPERATE\r\n\t\tsize*=vec2(getCurValueFromGradientFloat(u_SOLSizeGradientX,normalizedAge),getCurValueFromGradientFloat(u_SOLSizeGradientY,normalizedAge));\r\n\t#endif\r\n\t#ifdef SIZEOVERLIFETIMERANDOMCURVESSEPERATE\r\n\t    size*=vec2(mix(getCurValueFromGradientFloat(u_SOLSizeGradientX,normalizedAge),getCurValueFromGradientFloat(u_SOLSizeGradientMaxX,normalizedAge),a_Random0.z)\r\n\t    ,mix(getCurValueFromGradientFloat(u_SOLSizeGradientY,normalizedAge),getCurValueFromGradientFloat(u_SOLSizeGradientMaxY,normalizedAge),a_Random0.z));\r\n\t#endif\r\n\treturn size;\r\n}\r\n\r\n#ifdef RENDERMODE_MESH\r\nvec3 computeParticleSizeMesh(in vec3 size,in float normalizedAge)\r\n{\r\n\t#ifdef SIZEOVERLIFETIMECURVE\r\n\t\tsize*=getCurValueFromGradientFloat(u_SOLSizeGradient,normalizedAge);\r\n\t#endif\r\n\t#ifdef SIZEOVERLIFETIMERANDOMCURVES\r\n\t    size*=mix(getCurValueFromGradientFloat(u_SOLSizeGradient,normalizedAge),getCurValueFromGradientFloat(u_SOLSizeGradientMax,normalizedAge),a_Random0.z); \r\n\t#endif\r\n\t#ifdef SIZEOVERLIFETIMECURVESEPERATE\r\n\t\tsize*=vec3(getCurValueFromGradientFloat(u_SOLSizeGradientX,normalizedAge),getCurValueFromGradientFloat(u_SOLSizeGradientY,normalizedAge),getCurValueFromGradientFloat(u_SOLSizeGradientZ,normalizedAge));\r\n\t#endif\r\n\t#ifdef SIZEOVERLIFETIMERANDOMCURVESSEPERATE\r\n\t    size*=vec3(mix(getCurValueFromGradientFloat(u_SOLSizeGradientX,normalizedAge),getCurValueFromGradientFloat(u_SOLSizeGradientMaxX,normalizedAge),a_Random0.z)\r\n\t    ,mix(getCurValueFromGradientFloat(u_SOLSizeGradientY,normalizedAge),getCurValueFromGradientFloat(u_SOLSizeGradientMaxY,normalizedAge),a_Random0.z)\r\n\t\t,mix(getCurValueFromGradientFloat(u_SOLSizeGradientZ,normalizedAge),getCurValueFromGradientFloat(u_SOLSizeGradientMaxZ,normalizedAge),a_Random0.z));\r\n\t#endif\r\n\treturn size;\r\n}\r\n#endif\r\n\r\nfloat computeParticleRotationFloat(in float rotation,in float age,in float normalizedAge)\r\n{ \r\n\t#ifdef ROTATIONOVERLIFETIME\r\n\t\t#ifdef ROTATIONOVERLIFETIMECONSTANT\r\n\t\t\tfloat ageRot=u_ROLAngularVelocityConst*age;\r\n\t        rotation+=ageRot;\r\n\t\t#endif\r\n\t\t#ifdef ROTATIONOVERLIFETIMECURVE\r\n\t\t\trotation+=getTotalValueFromGradientFloat(u_ROLAngularVelocityGradient,normalizedAge);\r\n\t\t#endif\r\n\t\t#ifdef ROTATIONOVERLIFETIMERANDOMCONSTANTS\r\n\t\t\tfloat ageRot=mix(u_ROLAngularVelocityConst,u_ROLAngularVelocityConstMax,a_Random0.w)*age;\r\n\t        rotation+=ageRot;\r\n\t    #endif\r\n\t\t#ifdef ROTATIONOVERLIFETIMERANDOMCURVES\r\n\t\t\trotation+=mix(getTotalValueFromGradientFloat(u_ROLAngularVelocityGradient,normalizedAge),getTotalValueFromGradientFloat(u_ROLAngularVelocityGradientMax,normalizedAge),a_Random0.w);\r\n\t\t#endif\r\n\t#endif\r\n\t#ifdef ROTATIONOVERLIFETIMESEPERATE\r\n\t\t#ifdef ROTATIONOVERLIFETIMECONSTANT\r\n\t\t\tfloat ageRot=u_ROLAngularVelocityConstSeprarate.z*age;\r\n\t        rotation+=ageRot;\r\n\t\t#endif\r\n\t\t#ifdef ROTATIONOVERLIFETIMECURVE\r\n\t\t\trotation+=getTotalValueFromGradientFloat(u_ROLAngularVelocityGradientZ,normalizedAge);\r\n\t\t#endif\r\n\t\t#ifdef ROTATIONOVERLIFETIMERANDOMCONSTANTS\r\n\t\t\tfloat ageRot=mix(u_ROLAngularVelocityConstSeprarate.z,u_ROLAngularVelocityConstMaxSeprarate.z,a_Random0.w)*age;\r\n\t        rotation+=ageRot;\r\n\t    #endif\r\n\t\t#ifdef ROTATIONOVERLIFETIMERANDOMCURVES\r\n\t\t\trotation+=mix(getTotalValueFromGradientFloat(u_ROLAngularVelocityGradientZ,normalizedAge),getTotalValueFromGradientFloat(u_ROLAngularVelocityGradientMaxZ,normalizedAge),a_Random0.w));\r\n\t\t#endif\r\n\t#endif\r\n\treturn rotation;\r\n}\r\n\r\n#if defined(RENDERMODE_MESH)&&(defined(ROTATIONOVERLIFETIME)||defined(ROTATIONOVERLIFETIMESEPERATE))\r\nvec3 computeParticleRotationVec3(in vec3 rotation,in float age,in float normalizedAge)\r\n{ \r\n\t#ifdef ROTATIONOVERLIFETIME\r\n\t#ifdef ROTATIONOVERLIFETIMECONSTANT\r\n\t\t\tfloat ageRot=u_ROLAngularVelocityConst*age;\r\n\t        rotation+=ageRot;\r\n\t\t#endif\r\n\t\t#ifdef ROTATIONOVERLIFETIMECURVE\r\n\t\t\trotation+=getTotalValueFromGradientFloat(u_ROLAngularVelocityGradient,normalizedAge);\r\n\t\t#endif\r\n\t\t#ifdef ROTATIONOVERLIFETIMERANDOMCONSTANTS\r\n\t\t\tfloat ageRot=mix(u_ROLAngularVelocityConst,u_ROLAngularVelocityConstMax,a_Random0.w)*age;\r\n\t        rotation+=ageRot;\r\n\t    #endif\r\n\t\t#ifdef ROTATIONOVERLIFETIMERANDOMCURVES\r\n\t\t\trotation+=mix(getTotalValueFromGradientFloat(u_ROLAngularVelocityGradient,normalizedAge),getTotalValueFromGradientFloat(u_ROLAngularVelocityGradientMax,normalizedAge),a_Random0.w);\r\n\t\t#endif\r\n\t#endif\r\n\t#ifdef ROTATIONOVERLIFETIMESEPERATE\r\n\t\t#ifdef ROTATIONOVERLIFETIMECONSTANT\r\n\t\t\tvec3 ageRot=u_ROLAngularVelocityConstSeprarate*age;\r\n\t        rotation+=ageRot;\r\n\t\t#endif\r\n\t\t#ifdef ROTATIONOVERLIFETIMECURVE\r\n\t\t\trotation+=vec3(getTotalValueFromGradientFloat(u_ROLAngularVelocityGradientX,normalizedAge),getTotalValueFromGradientFloat(u_ROLAngularVelocityGradientY,normalizedAge),getTotalValueFromGradientFloat(u_ROLAngularVelocityGradientZ,normalizedAge));\r\n\t\t#endif\r\n\t\t#ifdef ROTATIONOVERLIFETIMERANDOMCONSTANTS\r\n\t\t\tvec3 ageRot=mix(u_ROLAngularVelocityConstSeprarate,u_ROLAngularVelocityConstMaxSeprarate,a_Random0.w)*age;\r\n\t        rotation+=ageRot;\r\n\t    #endif\r\n\t\t#ifdef ROTATIONOVERLIFETIMERANDOMCURVES\r\n\t\t\trotation+=vec3(mix(getTotalValueFromGradientFloat(u_ROLAngularVelocityGradientX,normalizedAge),getTotalValueFromGradientFloat(u_ROLAngularVelocityGradientMaxX,normalizedAge),a_Random0.w)\r\n\t        ,mix(getTotalValueFromGradientFloat(u_ROLAngularVelocityGradientY,normalizedAge),getTotalValueFromGradientFloat(u_ROLAngularVelocityGradientMaxY,normalizedAge),a_Random0.w)\r\n\t        ,mix(getTotalValueFromGradientFloat(u_ROLAngularVelocityGradientZ,normalizedAge),getTotalValueFromGradientFloat(u_ROLAngularVelocityGradientMaxZ,normalizedAge),a_Random0.w));\r\n\t\t#endif\r\n\t#endif\r\n\treturn rotation;\r\n}\r\n#endif\r\n\r\nvec2 computeParticleUV(in vec2 uv,in float normalizedAge)\r\n{ \r\n\t#ifdef TEXTURESHEETANIMATIONCURVE\r\n\t\tfloat cycleNormalizedAge=normalizedAge*u_TSACycles;\r\n\t\tfloat frame=getFrameFromGradient(u_TSAGradientUVs,cycleNormalizedAge-floor(cycleNormalizedAge));\r\n\t\tfloat totalULength=frame*u_TSASubUVLength.x;\r\n\t\tfloat floorTotalULength=floor(totalULength);\r\n\t    uv.x+=totalULength-floorTotalULength;\r\n\t\tuv.y+=floorTotalULength*u_TSASubUVLength.y;\r\n    #endif\r\n\t#ifdef TEXTURESHEETANIMATIONRANDOMCURVE\r\n\t\tfloat cycleNormalizedAge=normalizedAge*u_TSACycles;\r\n\t\tfloat uvNormalizedAge=cycleNormalizedAge-floor(cycleNormalizedAge);\r\n\t    float frame=floor(mix(getFrameFromGradient(u_TSAGradientUVs,uvNormalizedAge),getFrameFromGradient(u_TSAMaxGradientUVs,uvNormalizedAge),a_Random1.x));\r\n\t\tfloat totalULength=frame*u_TSASubUVLength.x;\r\n\t\tfloat floorTotalULength=floor(totalULength);\r\n\t    uv.x+=totalULength-floorTotalULength;\r\n\t\tuv.y+=floorTotalULength*u_TSASubUVLength.y;\r\n    #endif\r\n\treturn uv;\r\n}\r\n\r\nvoid main()\r\n{\r\n\tfloat age = u_CurrentTime - a_DirectionTime.w;\r\n\tfloat normalizedAge = age/a_ShapePositionStartLifeTime.w;\r\n\tvec3 lifeVelocity;\r\n\tif(normalizedAge<1.0)\r\n\t{ \r\n\t\tvec3 startVelocity=a_DirectionTime.xyz*a_StartSpeed;\r\n\t\t#if defined(VELOCITYOVERLIFETIMECONSTANT)||defined(VELOCITYOVERLIFETIMECURVE)||defined(VELOCITYOVERLIFETIMERANDOMCONSTANT)||defined(VELOCITYOVERLIFETIMERANDOMCURVE)\r\n\t\t\tlifeVelocity= computeParticleLifeVelocity(normalizedAge);//计算粒子生命周期速度\r\n\t\t#endif \r\n\t\tvec3 gravityVelocity=u_Gravity*age;\r\n\t\t\r\n\t\tvec4 worldRotation;\r\n\t\tif(u_SimulationSpace==0)\r\n\t\t\tworldRotation=a_SimulationWorldRotation;\r\n\t\telse\r\n\t\t\tworldRotation=u_WorldRotation;\r\n\t\t\r\n\t\tvec3 center=computeParticlePosition(startVelocity, lifeVelocity, age, normalizedAge,gravityVelocity,worldRotation);//计算粒子位置\r\n\t\r\n\t\r\n\t\t#ifdef SPHERHBILLBOARD\r\n\t\t\tvec2 corner=a_CornerTextureCoordinate.xy;//Billboard模式z轴无效\r\n\t\t\tvec3 cameraUpVector =normalize(u_CameraUp);//TODO:是否外面归一化\r\n\t\t\tvec3 sideVector = normalize(cross(u_CameraDirection,cameraUpVector));\r\n\t\t\tvec3 upVector = normalize(cross(sideVector,u_CameraDirection));\r\n\t\t\tcorner*=computeParticleSizeBillbard(a_StartSize.xy,normalizedAge);\r\n\t\t\t#if defined(ROTATIONOVERLIFETIME)||defined(ROTATIONOVERLIFETIMESEPERATE)\r\n\t\t\t\tif(u_ThreeDStartRotation){\r\n\t\t\t\t\tvec3 rotation=vec3(a_StartRotation0.xy,computeParticleRotationFloat(a_StartRotation0.z,age,normalizedAge));\r\n\t\t\t\t\tcenter += u_SizeScale.xzy*rotationByEuler(corner.x*sideVector+corner.y*upVector,rotation);\r\n\t\t\t\t}\r\n\t\t\t\telse{\r\n\t\t\t\t\tfloat rot = computeParticleRotationFloat(a_StartRotation0.x, age,normalizedAge);\r\n\t\t\t\t\tfloat c = cos(rot);\r\n\t\t\t\t\tfloat s = sin(rot);\r\n\t\t\t\t\tmat2 rotation= mat2(c, -s, s, c);\r\n\t\t\t\t\tcorner=rotation*corner;\r\n\t\t\t\t\tcenter += u_SizeScale.xzy*(corner.x*sideVector+corner.y*upVector);\r\n\t\t\t\t}\r\n\t\t\t#else\r\n\t\t\t\tif(u_ThreeDStartRotation){\r\n\t\t\t\t\tcenter += u_SizeScale.xzy*rotationByEuler(corner.x*sideVector+corner.y*upVector,a_StartRotation0);\r\n\t\t\t\t}\r\n\t\t\t\telse{\r\n\t\t\t\t\tfloat c = cos(a_StartRotation0.x);\r\n\t\t\t\t\tfloat s = sin(a_StartRotation0.x);\r\n\t\t\t\t\tmat2 rotation= mat2(c, -s, s, c);\r\n\t\t\t\t\tcorner=rotation*corner;\r\n\t\t\t\t\tcenter += u_SizeScale.xzy*(corner.x*sideVector+corner.y*upVector);\r\n\t\t\t\t}\r\n\t\t\t#endif\r\n\t\t#endif\r\n\t\r\n\t\t#ifdef STRETCHEDBILLBOARD\r\n\t\t\tvec2 corner=a_CornerTextureCoordinate.xy;//Billboard模式z轴无效\r\n\t\t\tvec3 velocity;\r\n\t\t\t#if defined(VELOCITYOVERLIFETIMECONSTANT)||defined(VELOCITYOVERLIFETIMECURVE)||defined(VELOCITYOVERLIFETIMERANDOMCONSTANT)||defined(VELOCITYOVERLIFETIMERANDOMCURVE)\r\n\t\t\t\tif(u_VOLSpaceType==0)\r\n\t\t\t\tvelocity=rotationByQuaternions(u_SizeScale*(startVelocity+lifeVelocity),worldRotation)+gravityVelocity;\r\n\t\t\t\telse\r\n\t\t\t\tvelocity=rotationByQuaternions(u_SizeScale*startVelocity,worldRotation)+lifeVelocity+gravityVelocity;\r\n\t\t\t#else\r\n\t\t\t\tvelocity= rotationByQuaternions(u_SizeScale*startVelocity,worldRotation)+gravityVelocity;\r\n\t\t\t#endif\t\r\n\t\t\tvec3 cameraUpVector = normalize(velocity);\r\n\t\t\tvec3 direction = normalize(center-u_CameraPos);\r\n\t\t\tvec3 sideVector = normalize(cross(direction,normalize(velocity)));\r\n\t\t\t\r\n\t\t\tsideVector=u_SizeScale.xzy*sideVector;\r\n\t\t\tcameraUpVector=length(vec3(u_SizeScale.x,0.0,0.0))*cameraUpVector;\r\n\t\t\t\r\n\t\t\tvec2 size=computeParticleSizeBillbard(a_StartSize.xy,normalizedAge);\r\n\t\t\t\r\n\t\t\tconst mat2 rotaionZHalfPI=mat2(0.0, -1.0, 1.0, 0.0);\r\n\t\t\tcorner=rotaionZHalfPI*corner;\r\n\t\t\tcorner.y=corner.y-abs(corner.y);\r\n\t\t\t\r\n\t\t\tfloat speed=length(velocity);//TODO:\r\n\t\t\tcenter +=sign(u_SizeScale.x)*(sign(u_StretchedBillboardLengthScale)*size.x*corner.x*sideVector+(speed*u_StretchedBillboardSpeedScale+size.y*u_StretchedBillboardLengthScale)*corner.y*cameraUpVector);\r\n\t\t#endif\r\n\t\r\n\t\t#ifdef HORIZONTALBILLBOARD\r\n\t\t\tvec2 corner=a_CornerTextureCoordinate.xy;//Billboard模式z轴无效\r\n\t\t\tconst vec3 cameraUpVector=vec3(0.0,0.0,1.0);\r\n\t\t\tconst vec3 sideVector = vec3(-1.0,0.0,0.0);\r\n\t\t\t\r\n\t\t\tfloat rot = computeParticleRotationFloat(a_StartRotation0.x, age,normalizedAge);\r\n\t\t\tfloat c = cos(rot);\r\n\t\t\tfloat s = sin(rot);\r\n\t\t\tmat2 rotation= mat2(c, -s, s, c);\r\n\t\t\tcorner=rotation*corner*cos(0.78539816339744830961566084581988);//TODO:临时缩小cos45,不确定U3D原因\r\n\t\t\tcorner*=computeParticleSizeBillbard(a_StartSize.xy,normalizedAge);\r\n\t\t\tcenter +=u_SizeScale.xzy*(corner.x*sideVector+ corner.y*cameraUpVector);\r\n\t\t#endif\r\n\t\r\n\t\t#ifdef VERTICALBILLBOARD\r\n\t\t\tvec2 corner=a_CornerTextureCoordinate.xy;//Billboard模式z轴无效\r\n\t\t\tconst vec3 cameraUpVector =vec3(0.0,1.0,0.0);\r\n\t\t\tvec3 sideVector = normalize(cross(u_CameraDirection,cameraUpVector));\r\n\t\t\t\r\n\t\t\tfloat rot = computeParticleRotationFloat(a_StartRotation0.x, age,normalizedAge);\r\n\t\t\tfloat c = cos(rot);\r\n\t\t\tfloat s = sin(rot);\r\n\t\t\tmat2 rotation= mat2(c, -s, s, c);\r\n\t\t\tcorner=rotation*corner*cos(0.78539816339744830961566084581988);//TODO:临时缩小cos45,不确定U3D原因\r\n\t\t\tcorner*=computeParticleSizeBillbard(a_StartSize.xy,normalizedAge);\r\n\t\t\tcenter +=u_SizeScale.xzy*(corner.x*sideVector+ corner.y*cameraUpVector);\r\n\t\t#endif\r\n\t\r\n\t\t#ifdef RENDERMODE_MESH\r\n\t\t\tvec3 size=computeParticleSizeMesh(a_StartSize,normalizedAge);\r\n\t\t\t#if defined(ROTATIONOVERLIFETIME)||defined(ROTATIONOVERLIFETIMESEPERATE)\r\n\t\t\t\tif(u_ThreeDStartRotation){\r\n\t\t\t\t\tvec3 rotation=vec3(a_StartRotation0.xy,computeParticleRotationFloat(a_StartRotation0.z, age,normalizedAge));\r\n\t\t\t\t\tcenter+= rotationByQuaternions(u_SizeScale*rotationByEuler(a_MeshPosition*size,rotation),worldRotation);\r\n\t\t\t\t}\r\n\t\t\t\telse{\r\n\t\t\t\t\t#ifdef ROTATIONOVERLIFETIME\r\n\t\t\t\t\t\tfloat angle=computeParticleRotationFloat(a_StartRotation0.x, age,normalizedAge);\r\n\t\t\t\t\t\tif(a_ShapePositionStartLifeTime.x!=0.0||a_ShapePositionStartLifeTime.y!=0.0){\r\n\t\t\t\t\t\t\tcenter+= (rotationByQuaternions(rotationByAxis(u_SizeScale*a_MeshPosition*size,normalize(cross(vec3(0.0,0.0,1.0),vec3(a_ShapePositionStartLifeTime.xy,0.0))),angle),worldRotation));//已验证\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\telse{\r\n\t\t\t\t\t\t\t#ifdef SHAPE\r\n\t\t\t\t\t\t\t\tcenter+= u_SizeScale.xzy*(rotationByQuaternions(rotationByAxis(a_MeshPosition*size,vec3(0.0,-1.0,0.0),angle),worldRotation));\r\n\t\t\t\t\t\t\t#else\r\n\t\t\t\t\t\t\t\tif(u_SimulationSpace==0)\r\n\t\t\t\t\t\t\t\t\tcenter+=rotationByAxis(u_SizeScale*a_MeshPosition*size,vec3(0.0,0.0,-1.0),angle);//已验证\r\n\t\t\t\t\t\t\t\telse if(u_SimulationSpace==1)\r\n\t\t\t\t\t\t\t\t\tcenter+=rotationByQuaternions(u_SizeScale*rotationByAxis(a_MeshPosition*size,vec3(0.0,0.0,-1.0),angle),worldRotation);//已验证\r\n\t\t\t\t\t\t\t#endif\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t#endif\r\n\t\t\t\t\t#ifdef ROTATIONOVERLIFETIMESEPERATE\r\n\t\t\t\t\t\t//TODO:是否应合并if(u_ThreeDStartRotation)分支代码,待测试\r\n\t\t\t\t\t\tvec3 angle=computeParticleRotationVec3(vec3(0.0,0.0,-a_StartRotation0.x), age,normalizedAge);\r\n\t\t\t\t\t\tcenter+= (rotationByQuaternions(rotationByEuler(u_SizeScale*a_MeshPosition*size,vec3(angle.x,angle.y,angle.z)),worldRotation));//已验证\r\n\t\t\t\t\t#endif\t\t\r\n\t\t\t\t}\r\n\t\t\t#else\r\n\t\t\t\tif(u_ThreeDStartRotation){\r\n\t\t\t\t\tcenter+= rotationByQuaternions(u_SizeScale*rotationByEuler(a_MeshPosition*size,a_StartRotation0),worldRotation);//已验证\r\n\t\t\t\t}\r\n\t\t\t\telse{\r\n\t\t\t\t\tif(a_ShapePositionStartLifeTime.x!=0.0||a_ShapePositionStartLifeTime.y!=0.0){\r\n\t\t\t\t\t\tif(u_SimulationSpace==0)\r\n\t\t\t\t\t\t\tcenter+= rotationByAxis(u_SizeScale*a_MeshPosition*size,normalize(cross(vec3(0.0,0.0,1.0),vec3(a_ShapePositionStartLifeTime.xy,0.0))),a_StartRotation0.x);\r\n\t\t\t\t\t\telse if(u_SimulationSpace==1)\r\n\t\t\t\t\t\t\tcenter+= (rotationByQuaternions(u_SizeScale*rotationByAxis(a_MeshPosition*size,normalize(cross(vec3(0.0,0.0,1.0),vec3(a_ShapePositionStartLifeTime.xy,0.0))),a_StartRotation0.x),worldRotation));//已验证\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse{\r\n\t\t\t\t\t\t#ifdef SHAPE\r\n\t\t\t\t\t\t\tif(u_SimulationSpace==0)\r\n\t\t\t\t\t\t\t\tcenter+= u_SizeScale*rotationByAxis(a_MeshPosition*size,vec3(0.0,-1.0,0.0),a_StartRotation0.x);\r\n\t\t\t\t\t\t\telse if(u_SimulationSpace==1)\r\n\t\t\t\t\t\t\t\tcenter+= rotationByQuaternions(u_SizeScale*rotationByAxis(a_MeshPosition*size,vec3(0.0,-1.0,0.0),a_StartRotation0.x),worldRotation);\t\r\n\t\t\t\t\t\t#else\r\n\t\t\t\t\t\t\tif(u_SimulationSpace==0)\r\n\t\t\t\t\t\t\t\tcenter+= rotationByAxis(u_SizeScale*a_MeshPosition*size,vec3(0.0,0.0,-1.0),a_StartRotation0.x);\r\n\t\t\t\t\t\t\telse if(u_SimulationSpace==1)\r\n\t\t\t\t\t\t\t\tcenter+= rotationByQuaternions(u_SizeScale*rotationByAxis(a_MeshPosition*size,vec3(0.0,0.0,-1.0),a_StartRotation0.x),worldRotation);//已验证\r\n\t\t\t\t\t\t#endif\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t#endif\r\n\t\t\tv_MeshColor=a_MeshColor;\r\n\t\t#endif\r\n\t\r\n\t\tgl_Position=u_Projection*u_View*vec4(center,1.0);\r\n\t\tv_Color = computeParticleColor(a_StartColor, normalizedAge);\r\n\t\t#ifdef DIFFUSEMAP\r\n\t\t\t#if defined(SPHERHBILLBOARD)||defined(STRETCHEDBILLBOARD)||defined(HORIZONTALBILLBOARD)||defined(VERTICALBILLBOARD)\r\n\t\t\t\tv_TextureCoordinate =computeParticleUV(a_CornerTextureCoordinate.zw, normalizedAge);\r\n\t\t\t#endif\r\n\t\t\t#ifdef RENDERMODE_MESH\r\n\t\t\t\tv_TextureCoordinate =computeParticleUV(a_MeshTextureCoordinate, normalizedAge);\r\n\t\t\t#endif\r\n\t\t\t\r\n\t\t\t#ifdef TILINGOFFSET\r\n\t\t\t\tv_TextureCoordinate=TransformUV(v_TextureCoordinate,u_TilingOffset);\r\n\t\t\t#endif\r\n\t\t#endif\r\n   \t}\r\n   \telse\r\n\t{\r\n\t\tgl_Position=vec4(2.0,2.0,2.0,1.0);//Discard use out of X(-1,1),Y(-1,1),Z(0,1)\r\n\t}\r\n\tgl_Position=remapGLPositionZ(gl_Position);\r\n}\r\n\r\n', "#ifdef GL_FRAGMENT_PRECISION_HIGH\r\n  precision highp float;\r\n#else\r\n  precision mediump float;\r\n#endif\r\n\r\nvarying vec4 v_Color;\r\nvarying vec2 v_TextureCoordinate;\r\nuniform sampler2D u_texture;\r\nuniform vec4 u_Tintcolor;\r\n\r\n#ifdef RENDERMODE_MESH\r\n\tvarying vec4 v_MeshColor;\r\n#endif\r\n\r\n#ifdef FOG\r\n\tuniform float u_FogStart;\r\n\tuniform float u_FogRange;\r\n\t#ifdef ADDTIVEFOG\r\n\t#else\r\n\t\tuniform vec3 u_FogColor;\r\n\t#endif\r\n#endif\r\n\r\n\r\nvoid main()\r\n{\t\r\n\t#ifdef RENDERMODE_MESH\r\n\t\tgl_FragColor=v_MeshColor;\r\n\t#else\r\n\t\tgl_FragColor=vec4(1.0);\t\r\n\t#endif\r\n\t\t\r\n\t#ifdef DIFFUSEMAP\r\n\t\t#ifdef TINTCOLOR\r\n\t\t\tgl_FragColor*=texture2D(u_texture,v_TextureCoordinate)*u_Tintcolor*2.0*v_Color;\r\n\t\t#else\r\n\t\t\tgl_FragColor*=texture2D(u_texture,v_TextureCoordinate)*v_Color;\r\n\t\t#endif\r\n\t#else\r\n\t\t#ifdef TINTCOLOR\r\n\t\t\tgl_FragColor*=u_Tintcolor*2.0*v_Color;\r\n\t\t#else\r\n\t\t\tgl_FragColor*=v_Color;\r\n\t\t#endif\r\n\t#endif\r\n\t\r\n\t#ifdef FOG\r\n\t\tfloat lerpFact=clamp((1.0/gl_FragCoord.w-u_FogStart)/u_FogRange,0.0,1.0);\r\n\t\t#ifdef ADDTIVEFOG\r\n\t\t\tgl_FragColor.rgb=mix(gl_FragColor.rgb,vec3(0.0,0.0,0.0),lerpFact);\r\n\t\t#else\r\n\t\t\tgl_FragColor.rgb=mix(gl_FragColor.rgb,u_FogColor,lerpFact);\r\n\t\t#endif\r\n\t#endif\r\n}", r),
                e = {
                    a_Position: ue.MESH_POSITION0
                },
                t = {
                    u_TintColor: G.PERIOD_MATERIAL,
                    u_Exposure: G.PERIOD_MATERIAL,
                    u_Rotation: G.PERIOD_MATERIAL,
                    u_CubeTexture: G.PERIOD_MATERIAL,
                    u_ViewProjection: G.PERIOD_CAMERA
                },
                n = G.add("SkyBox"),
                i = new ie(e,t),
                n.addSubShader(i),
                i.addShaderPass('#include "Lighting.glsl";\r\n\r\nattribute vec4 a_Position;\r\nuniform mat4 u_ViewProjection;\r\nuniform float u_Rotation;\r\nvarying vec3 v_Texcoord;\r\n\r\n\r\nvec4 rotateAroundYInDegrees (vec4 vertex, float degrees)\r\n{\r\n\tfloat angle = degrees * 3.141593 / 180.0;\r\n\tfloat sina=sin(angle);\r\n\tfloat cosa=cos(angle);\r\n\tmat2 m = mat2(cosa, -sina, sina, cosa);\r\n\treturn vec4(m*vertex.xz, vertex.yw).xzyw;\r\n}\r\n\t\t\r\nvoid main()\r\n{\r\n\tvec4 position=rotateAroundYInDegrees(a_Position,u_Rotation);\r\n\tgl_Position = u_ViewProjection*position;\r\n\tv_Texcoord=vec3(-a_Position.x,a_Position.yz);//转换坐标系\r\n\tgl_Position=remapGLPositionZ(gl_Position);\r\n}\r\n', "#ifdef GL_FRAGMENT_PRECISION_HIGH\r\nprecision highp float;\r\n#else\r\nprecision mediump float;\r\n#endif\r\n\r\nvarying vec3 v_Texcoord;\r\n\r\nuniform samplerCube u_CubeTexture;\r\nuniform float u_Exposure;\r\nuniform vec4 u_TintColor;\r\n\r\n\r\nvoid main()\r\n{\t\r\n\tvec3 color=textureCube(u_CubeTexture, v_Texcoord).rgb*u_TintColor.rgb*u_Exposure*2.0;\r\n\tgl_FragColor=vec4(color,1.0);\r\n}\r\n\r\n"),
                e = {
                    a_Position: ue.MESH_POSITION0
                },
                t = {
                    u_SunSize: G.PERIOD_MATERIAL,
                    u_SunSizeConvergence: G.PERIOD_MATERIAL,
                    u_AtmosphereThickness: G.PERIOD_MATERIAL,
                    u_SkyTint: G.PERIOD_MATERIAL,
                    u_GroundTint: G.PERIOD_MATERIAL,
                    u_Exposure: G.PERIOD_MATERIAL,
                    u_ViewProjection: G.PERIOD_CAMERA,
                    "u_SunLight.direction": G.PERIOD_SCENE,
                    "u_SunLight.color": G.PERIOD_SCENE
                },
                n = G.add("SkyBoxProcedural"),
                i = new ie(e,t),
                n.addSubShader(i),
                i.addShaderPass("#ifdef GL_FRAGMENT_PRECISION_HIGH\r\n\tprecision highp float;\r\n#else\r\n\tprecision mediump float;\r\n#endif\r\n\r\n#include \"Lighting.glsl\";\r\n\r\n#define OUTER_RADIUS 1.025\r\n#define RAYLEIGH (mix(0.0, 0.0025, pow(u_AtmosphereThickness,2.5)))// Rayleigh constant Rayleigh为夜空光和极光亮度单位\r\n#define MIE 0.0010             // Mie constant 米氏散射\r\n#define SUN_BRIGHTNESS 20.0    // Sun brightness\r\n#define MAX_SCATTER 50.0 // Maximum scattering value, to prevent math overflows on Adrenos\r\n\r\nconst float SKY_GROUND_THRESHOLD = 0.02;\r\nconst float outerRadius = OUTER_RADIUS;\r\nconst float outerRadius2 = OUTER_RADIUS*OUTER_RADIUS;\r\nconst float innerRadius = 1.0;\r\nconst float innerRadius2 = 1.0;\r\nconst float cameraHeight = 0.0001;\r\n\r\nconst float HDSundiskIntensityFactor = 15.0;\r\nconst float simpleSundiskIntensityFactor = 27.0;\r\n\r\nconst float sunScale = 400.0 * SUN_BRIGHTNESS;\r\nconst float kmESun = MIE * SUN_BRIGHTNESS;\r\nconst float km4PI = MIE * 4.0 * 3.14159265;\r\nconst float scale = 1.0 / (OUTER_RADIUS - 1.0);\r\nconst float scaleDepth = 0.25;\r\nconst float scaleOverScaleDepth = (1.0 / (OUTER_RADIUS - 1.0)) / 0.25;\r\nconst float samples = 2.0; // THIS IS UNROLLED MANUALLY, DON'T TOUCH\r\n\r\n// RGB wavelengths        .35 (.62=158), .43 (.68=174), .525 (.75=190)\r\nconst vec3 c_DefaultScatteringWavelength = vec3(0.65, 0.57, 0.475);//默认散射波长\r\nconst vec3 c_VariableRangeForScatteringWavelength = vec3(0.15, 0.15, 0.15);//散射播放的可变范围\r\n\r\nattribute vec4 a_Position;\r\n\r\nuniform mat4 u_ViewProjection;\r\nuniform vec3 u_SkyTint;\r\nuniform vec3 u_GroundTint;\r\nuniform float u_Exposure;\r\nuniform float u_AtmosphereThickness;\r\nuniform DirectionLight u_SunLight;\r\n\r\nvarying vec3 v_GroundColor;\r\nvarying vec3 v_SkyColor;\r\n\r\n#ifdef SUN_HIGH_QUALITY\r\n\tvarying vec3 v_Vertex;\r\n#elif defined(SUN_SIMPLE)\r\n\tvarying vec3 v_RayDir;\r\n#else\r\n\tvarying float v_SkyGroundFactor;\r\n#endif\r\n\r\n#if defined(SUN_HIGH_QUALITY)||defined(SUN_SIMPLE)\r\n\tvarying vec3 v_SunColor;\r\n#endif\r\n\r\n// Calculates the Rayleigh phase function\r\nfloat getRayleighPhase(vec3 light, vec3 ray) \r\n{\r\n\tfloat eyeCos = dot(light, ray);\r\n\treturn 0.75 + 0.75*eyeCos*eyeCos;\r\n}\r\n\r\nfloat scaleAngle(float inCos)\r\n{\r\n\tfloat x = 1.0 - inCos;\r\n\treturn 0.25 * exp(-0.00287 + x*(0.459 + x*(3.83 + x*(-6.80 + x*5.25))));\r\n}\r\n\r\n\r\nvoid main () {\r\n\tgl_Position = u_ViewProjection*a_Position;\r\n\r\n\tvec3 skyTintInGammaSpace = u_SkyTint;//支持非GAMMA空间后要调整\r\n\tvec3 scatteringWavelength = mix(c_DefaultScatteringWavelength-c_VariableRangeForScatteringWavelength,c_DefaultScatteringWavelength+c_VariableRangeForScatteringWavelength,vec3(1.0) - skyTintInGammaSpace); // using Tint in sRGB+ gamma allows for more visually linear interpolation and to keep (0.5) at (128, gray in sRGB) point\r\n\tvec3 invWavelength = 1.0 / pow(scatteringWavelength, vec3(4.0));\r\n\r\n\tfloat krESun = RAYLEIGH * SUN_BRIGHTNESS;\r\n\tfloat kr4PI = RAYLEIGH * 4.0 * 3.14159265;\r\n\r\n\tvec3 cameraPos = vec3(0.0,innerRadius + cameraHeight,0.0); // The camera's current position\r\n\r\n\t// Get the ray from the camera to the vertex and its length (which is the far point of the ray passing through the atmosphere)\r\n\tvec3 eyeRay = normalize(a_Position.xyz);\r\n\r\n\tfloat far = 0.0;\r\n\tvec3 cIn, cOut;\r\n\tif (eyeRay.y >= 0.0) {// Sky\r\n\t\t// Calculate the length of the \"atmosphere\"\r\n\t\tfar = sqrt(outerRadius2 + innerRadius2 * eyeRay.y * eyeRay.y - innerRadius2) - innerRadius * eyeRay.y;\r\n\r\n\t\t// Calculate the ray's starting position, then calculate its scattering offset\r\n\t\tfloat height = innerRadius + cameraHeight;\r\n\t\tfloat depth = exp(scaleOverScaleDepth * -cameraHeight);\r\n\t\tfloat startAngle = dot(eyeRay, cameraPos) / height;\r\n\t\tfloat startOffset = depth*scaleAngle(startAngle);\r\n\r\n\t\t// Initialize the scattering loop variables\r\n\t\tfloat sampleLength = far / samples;\r\n\t\tfloat scaledLength = sampleLength * scale;\r\n\t\tvec3 sampleRay = eyeRay * sampleLength;\r\n\t\tvec3 samplePoint = cameraPos + sampleRay * 0.5;\r\n\r\n\t\tvec3 frontColor = vec3(0.0);\r\n\t\t//unrolling this manually to avoid some platform for loop slow\r\n\t\t{\r\n\t\t\tfloat height = length(samplePoint);\r\n\t\t\tfloat depth = exp(scaleOverScaleDepth * (innerRadius - height));\r\n\t\t\tfloat lightAngle = dot(-u_SunLight.direction, samplePoint) / height;\r\n\t\t\tfloat cameraAngle = dot(eyeRay, samplePoint) / height;\r\n\t\t\tfloat scatter = (startOffset + depth*(scaleAngle(lightAngle) - scaleAngle(cameraAngle)));\r\n\t\t\tvec3 attenuate = exp(-clamp(scatter, 0.0, MAX_SCATTER) * (invWavelength * kr4PI + km4PI));\r\n\r\n\t\t\tfrontColor += attenuate * (depth * scaledLength);\r\n\t\t\tsamplePoint += sampleRay;\r\n\t\t}\r\n\t\t{\r\n\t\t\tfloat height = length(samplePoint);\r\n\t\t\tfloat depth = exp(scaleOverScaleDepth * (innerRadius - height));\r\n\t\t\tfloat lightAngle = dot(-u_SunLight.direction, samplePoint) / height;\r\n\t\t\tfloat cameraAngle = dot(eyeRay, samplePoint) / height;\r\n\t\t\tfloat scatter = (startOffset + depth*(scaleAngle(lightAngle) - scaleAngle(cameraAngle)));\r\n\t\t\tvec3 attenuate = exp(-clamp(scatter, 0.0, MAX_SCATTER) * (invWavelength * kr4PI + km4PI));\r\n\r\n\t\t\tfrontColor += attenuate * (depth * scaledLength);\r\n\t\t\tsamplePoint += sampleRay;\r\n\t\t}\r\n\r\n\t\t// Finally, scale the Mie and Rayleigh colors and set up the varying variables for the pixel shader\r\n\t\tcIn = frontColor * (invWavelength * krESun);\r\n\t\tcOut = frontColor * kmESun;\r\n\t} else {// Ground\r\n\t\tfar = (-cameraHeight) / (min(-0.001, eyeRay.y));\r\n\t\tvec3 pos = cameraPos + far * eyeRay;\r\n\r\n\t\t// Calculate the ray's starting position, then calculate its scattering offset\r\n\t\tfloat depth = exp((-cameraHeight) * (1.0/scaleDepth));\r\n\t\tfloat cameraAngle = dot(-eyeRay, pos);\r\n\t\tfloat lightAngle = dot(-u_SunLight.direction, pos);\r\n\t\tfloat cameraScale = scaleAngle(cameraAngle);\r\n\t\tfloat lightScale = scaleAngle(lightAngle);\r\n\t\tfloat cameraOffset = depth*cameraScale;\r\n\t\tfloat temp = lightScale + cameraScale;\r\n\r\n\t\t// Initialize the scattering loop variables\r\n\t\tfloat sampleLength = far / samples;\r\n\t\tfloat scaledLength = sampleLength * scale;\r\n\t\tvec3 sampleRay = eyeRay * sampleLength;\r\n\t\tvec3 samplePoint = cameraPos + sampleRay * 0.5;\r\n\r\n\t\t// Now loop through the sample rays\r\n\t\tvec3 frontColor = vec3(0.0, 0.0, 0.0);\r\n\t\tvec3 attenuate;\r\n\r\n\t\t// Loop removed because we kept hitting SM2.0 temp variable limits. Doesn't affect the image too much.\r\n\t\t{\r\n\t\t\tfloat height = length(samplePoint);\r\n\t\t\tfloat depth = exp(scaleOverScaleDepth * (innerRadius - height));\r\n\t\t\tfloat scatter = depth*temp - cameraOffset;\r\n\t\t\tattenuate = exp(-clamp(scatter, 0.0, MAX_SCATTER) * (invWavelength * kr4PI + km4PI));\r\n\t\t\tfrontColor += attenuate * (depth * scaledLength);\r\n\t\t\tsamplePoint += sampleRay;\r\n\t\t}\r\n\r\n\t\tcIn = frontColor * (invWavelength * krESun + kmESun);\r\n\t\tcOut = clamp(attenuate, 0.0, 1.0);\r\n\t}\r\n\r\n\t#ifdef SUN_HIGH_QUALITY\r\n\t\tv_Vertex = -a_Position.xyz;\r\n\t#elif defined(SUN_SIMPLE) \r\n\t\tv_RayDir = -eyeRay;\r\n\t#else\r\n\t\tv_SkyGroundFactor = -eyeRay.y / SKY_GROUND_THRESHOLD;\r\n\t#endif\r\n\r\n\t// if we want to calculate color in vprog:\r\n\t// in case of linear: multiply by _Exposure in here (even in case of lerp it will be common multiplier, so we can skip mul in fshader)\r\n\tv_GroundColor = u_Exposure * (cIn + u_GroundTint*u_GroundTint * cOut);//u_GroundColor*u_GroundColor is gamma space convert to linear space\r\n\tv_SkyColor    = u_Exposure * (cIn * getRayleighPhase(-u_SunLight.direction, -eyeRay));\r\n\r\n\t\r\n\t// The sun should have a stable intensity in its course in the sky. Moreover it should match the highlight of a purely specular material.\r\n\t// This matching was done using the Unity3D standard shader BRDF1 on the 5/31/2017\r\n\t// Finally we want the sun to be always bright even in LDR thus the normalization of the lightColor for low intensity.\r\n\tfloat lightColorIntensity = clamp(length(u_SunLight.color), 0.25, 1.0);\r\n\r\n\t#ifdef SUN_HIGH_QUALITY \r\n\t\tv_SunColor = HDSundiskIntensityFactor * clamp(cOut,0.0,1.0) * u_SunLight.color / lightColorIntensity;\r\n\t#elif defined(SUN_SIMPLE) \r\n\t\tv_SunColor = simpleSundiskIntensityFactor * clamp(cOut * sunScale,0.0,1.0) * u_SunLight.color / lightColorIntensity;\r\n\t#endif\r\n\tgl_Position=remapGLPositionZ(gl_Position);\r\n}\r\n", '#ifdef GL_FRAGMENT_PRECISION_HIGH\r\n\tprecision highp float;\r\n#else\r\n\tprecision mediump float;\r\n#endif\r\n\r\n#include "Lighting.glsl";\r\n\r\nconst float MIE_G = -0.990;\r\nconst float MIE_G2 = 0.9801;\r\nconst float SKY_GROUND_THRESHOLD = 0.02;\r\n\r\nuniform float u_SunSize;\r\nuniform float u_SunSizeConvergence;\r\nuniform DirectionLight u_SunLight;\r\n\r\n\r\nvarying vec3 v_GroundColor;\r\nvarying vec3 v_SkyColor;\r\n\r\n\r\n#ifdef SUN_HIGH_QUALITY\r\n\tvarying vec3 v_Vertex;\r\n#elif defined(SUN_SIMPLE)\r\n\tvarying vec3 v_RayDir;\r\n#else\r\n\tvarying float v_SkyGroundFactor;\r\n#endif\r\n\r\n#if defined(SUN_HIGH_QUALITY)||defined(SUN_SIMPLE)\r\n\tvarying vec3 v_SunColor;\r\n#endif\r\n\r\n// Calculates the Mie phase function\r\nfloat getMiePhase(float eyeCos, float eyeCos2) {\r\n\tfloat temp = 1.0 + MIE_G2 - 2.0 * MIE_G * eyeCos;\r\n\ttemp = pow(temp, pow(u_SunSize,0.65) * 10.0);\r\n\ttemp = max(temp,1.0e-4); // prevent division by zero, esp. in half precision\r\n\ttemp = 1.5 * ((1.0 - MIE_G2) / (2.0 + MIE_G2)) * (1.0 + eyeCos2) / temp;\r\n\treturn temp;\r\n}\r\n\r\n// Calculates the sun shape\r\nfloat calcSunAttenuation(vec3 lightPos, vec3 ray) {\r\n\t#ifdef SUN_HIGH_QUALITY\r\n\t\tfloat focusedEyeCos = pow(clamp(dot(lightPos, ray),0.0,1.0), u_SunSizeConvergence);\r\n\t\treturn getMiePhase(-focusedEyeCos, focusedEyeCos * focusedEyeCos);\r\n\t#else //SUN_SIMPLE\r\n\t\tvec3 delta = lightPos - ray;\r\n\t\tfloat dist = length(delta);\r\n\t\tfloat spot = 1.0 - smoothstep(0.0, u_SunSize, dist);\r\n\t\treturn spot * spot;\r\n\t#endif\r\n}\r\n\r\nvoid main() {\r\n\t// if y > 1 [eyeRay.y < -SKY_GROUND_THRESHOLD] - ground\r\n\t// if y >= 0 and < 1 [eyeRay.y <= 0 and > -SKY_GROUND_THRESHOLD] - horizon\r\n\t// if y < 0 [eyeRay.y > 0] - sky\r\n\tvec3 col = vec3(0.0, 0.0, 0.0);\r\n\r\n\t#ifdef SUN_HIGH_QUALITY\r\n\t\tvec3 ray = normalize(v_Vertex);\r\n\t\tfloat y = ray.y / SKY_GROUND_THRESHOLD;\r\n\t#elif defined(SUN_SIMPLE) \r\n\t\tvec3 ray = v_RayDir;\r\n\t\tfloat y = ray.y / SKY_GROUND_THRESHOLD;\t\r\n\t#else\r\n\t\tfloat y = v_SkyGroundFactor;\r\n\t#endif\r\n\r\n\t// if we did precalculate color in vprog: just do lerp between them\r\n\tcol = mix(v_SkyColor, v_GroundColor, clamp(y,0.0,1.0));\r\n\r\n\t#if defined(SUN_HIGH_QUALITY)||defined(SUN_SIMPLE)\r\n\t\tif (y < 0.0)\r\n\t\t\tcol += v_SunColor * calcSunAttenuation(-u_SunLight.direction, -ray);\r\n\t#endif\r\n\r\n\tcol = sqrt(col);//linear space convert to gamma space\r\n\tgl_FragColor=vec4(col,1.0);\r\n}\r\n\r\n'),
                e = {
                    a_Position: ue.MESH_POSITION0,
                    a_Normal: ue.MESH_NORMAL0,
                    a_Texcoord0: ue.MESH_TEXTURECOORDINATE0
                },
                t = {
                    u_MvpMatrix: G.PERIOD_SPRITE,
                    u_WorldMat: G.PERIOD_SPRITE,
                    u_CameraPos: G.PERIOD_CAMERA,
                    u_Viewport: G.PERIOD_CAMERA,
                    u_ProjectionParams: G.PERIOD_CAMERA,
                    u_View: G.PERIOD_CAMERA,
                    u_LightmapScaleOffset: G.PERIOD_SPRITE,
                    u_LightMap: G.PERIOD_SPRITE,
                    u_SplatAlphaTexture: G.PERIOD_MATERIAL,
                    u_DiffuseTexture1: G.PERIOD_MATERIAL,
                    u_DiffuseTexture2: G.PERIOD_MATERIAL,
                    u_DiffuseTexture3: G.PERIOD_MATERIAL,
                    u_DiffuseTexture4: G.PERIOD_MATERIAL,
                    u_DiffuseTexture5: G.PERIOD_MATERIAL,
                    u_DiffuseScaleOffset1: G.PERIOD_MATERIAL,
                    u_DiffuseScaleOffset2: G.PERIOD_MATERIAL,
                    u_DiffuseScaleOffset3: G.PERIOD_MATERIAL,
                    u_DiffuseScaleOffset4: G.PERIOD_MATERIAL,
                    u_DiffuseScaleOffset5: G.PERIOD_MATERIAL,
                    u_FogStart: G.PERIOD_SCENE,
                    u_FogRange: G.PERIOD_SCENE,
                    u_FogColor: G.PERIOD_SCENE,
                    u_DirationLightCount: G.PERIOD_SCENE,
                    u_LightBuffer: G.PERIOD_SCENE,
                    u_LightClusterBuffer: G.PERIOD_SCENE,
                    u_AmbientColor: G.PERIOD_SCENE,
                    u_shadowMap1: G.PERIOD_SCENE,
                    u_shadowMap2: G.PERIOD_SCENE,
                    u_shadowMap3: G.PERIOD_SCENE,
                    u_shadowPSSMDistance: G.PERIOD_SCENE,
                    u_lightShadowVP: G.PERIOD_SCENE,
                    u_shadowPCFoffset: G.PERIOD_SCENE,
                    "u_DirectionLight.color": G.PERIOD_SCENE,
                    "u_DirectionLight.direction": G.PERIOD_SCENE,
                    "u_PointLight.position": G.PERIOD_SCENE,
                    "u_PointLight.range": G.PERIOD_SCENE,
                    "u_PointLight.color": G.PERIOD_SCENE,
                    "u_SpotLight.position": G.PERIOD_SCENE,
                    "u_SpotLight.direction": G.PERIOD_SCENE,
                    "u_SpotLight.range": G.PERIOD_SCENE,
                    "u_SpotLight.spot": G.PERIOD_SCENE,
                    "u_SpotLight.color": G.PERIOD_SCENE
                },
                r = {
                    s_Cull: G.RENDER_STATE_CULL,
                    s_Blend: G.RENDER_STATE_BLEND,
                    s_BlendSrc: G.RENDER_STATE_BLEND_SRC,
                    s_BlendDst: G.RENDER_STATE_BLEND_DST,
                    s_DepthTest: G.RENDER_STATE_DEPTH_TEST,
                    s_DepthWrite: G.RENDER_STATE_DEPTH_WRITE
                },
                n = G.add("ExtendTerrain"),
                i = new ie(e,t),
                n.addSubShader(i),
                i.addShaderPass('#include "Lighting.glsl";\r\n\r\nattribute vec4 a_Position;\r\nattribute vec2 a_Texcoord0;\r\n\r\nuniform mat4 u_MvpMatrix;\r\n\r\nvarying vec2 v_Texcoord0;\r\n\r\n#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)||defined(LIGHTMAP)\r\n\tattribute vec3 a_Normal;\r\n\tvarying vec3 v_Normal;\r\n#endif\r\n\r\n#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)||defined(FOG)||(defined(RECEIVESHADOW)&&defined(SHADOWMAP_PSSM1))\r\n\tuniform mat4 u_WorldMat;\r\n\tvarying vec3 v_PositionWorld;\r\n#endif\r\n\r\n#ifdef LIGHTMAP\r\n\tvarying vec2 v_LightMapUV;\r\n\tuniform vec4 u_LightmapScaleOffset;\r\n#endif\r\n\r\n#ifdef RECEIVESHADOW\r\n\tvarying float v_posViewZ;\r\n\t#ifdef SHADOWMAP_PSSM1 \r\n\t\tvarying vec4 v_lightMVPPos;\r\n\t\tuniform mat4 u_lightShadowVP[4];\r\n\t#endif\r\n#endif\r\n\r\nvoid main()\r\n{\r\n\tgl_Position = u_MvpMatrix * a_Position;\r\n  \r\n\tv_Texcoord0 = a_Texcoord0;\r\n  \r\n\t#ifdef LIGHTMAP\r\n\t\tv_LightMapUV = vec2(a_Texcoord0.x, 1.0 - a_Texcoord0.y) * u_LightmapScaleOffset.xy + u_LightmapScaleOffset.zw;\r\n\t\tv_LightMapUV.y = 1.0 - v_LightMapUV.y;\r\n\t#endif\r\n  \r\n\t#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)\r\n\t\tv_Normal = a_Normal;\r\n\t#endif\r\n\r\n\t#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)||defined(FOG)||(defined(RECEIVESHADOW)&&defined(SHADOWMAP_PSSM1))\r\n\t\tv_PositionWorld=(u_WorldMat*a_Position).xyz;\r\n\t#endif\r\n\r\n\t#ifdef RECEIVESHADOW\r\n\t\tv_posViewZ = gl_Position.w;\r\n\t\t#ifdef SHADOWMAP_PSSM1\r\n\t\t\tv_lightMVPPos = u_lightShadowVP[0] * vec4(v_PositionWorld,1.0);\r\n\t\t#endif\r\n\t#endif\r\n\tgl_Position=remapGLPositionZ(gl_Position);\r\n}', '#ifdef GL_FRAGMENT_PRECISION_HIGH\r\n\tprecision highp float;\r\n#else\r\n\tprecision mediump float;\r\n#endif\r\n\r\n#include "Lighting.glsl";\r\n\r\n#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)||defined(FOG)\r\n\tuniform vec3 u_CameraPos;\r\n\tvarying vec3 v_Normal;\r\n\tvarying vec3 v_PositionWorld;\r\n#endif\r\n\r\n#ifdef FOG\r\n\tuniform float u_FogStart;\r\n\tuniform float u_FogRange;\r\n\tuniform vec3 u_FogColor;\r\n#endif\r\n\r\n#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)\r\n\t#ifdef LEGACYSINGLELIGHTING\r\n\t\t#ifdef DIRECTIONLIGHT\r\n\t\t\tuniform DirectionLight u_DirectionLight;\r\n\t\t#endif\r\n\t\t#ifdef POINTLIGHT\r\n\t\t\tuniform PointLight u_PointLight;\r\n\t\t#endif\r\n\t\t#ifdef SPOTLIGHT\r\n\t\t\tuniform SpotLight u_SpotLight;\r\n\t\t#endif\r\n\t#else\r\n\t\tuniform mat4 u_View;\r\n\t\tuniform vec4 u_ProjectionParams;\r\n\t\tuniform vec4 u_Viewport;\r\n\t\tuniform int u_DirationLightCount;\r\n\t\tuniform sampler2D u_LightBuffer;\r\n\t\tuniform sampler2D u_LightClusterBuffer;\r\n\t#endif\r\n#endif\r\n\r\n#include "ShadowHelper.glsl"\r\n#ifdef RECEIVESHADOW\r\n\t#if defined(SHADOWMAP_PSSM2)||defined(SHADOWMAP_PSSM3)\r\n\tuniform mat4 u_lightShadowVP[4];\r\n\t#endif\r\n\t#ifdef SHADOWMAP_PSSM1 \r\n\tvarying vec4 v_lightMVPPos;\r\n\t#endif\r\n#endif\r\nvarying float v_posViewZ;\r\n\r\nuniform vec3 u_AmbientColor;\r\n\r\nuniform sampler2D u_SplatAlphaTexture;\r\n\r\nuniform sampler2D u_DiffuseTexture1;\r\nuniform sampler2D u_DiffuseTexture2;\r\nuniform sampler2D u_DiffuseTexture3;\r\nuniform sampler2D u_DiffuseTexture4;\r\nuniform sampler2D u_DiffuseTexture5;\r\n\r\nuniform vec4 u_DiffuseScaleOffset1;\r\nuniform vec4 u_DiffuseScaleOffset2;\r\nuniform vec4 u_DiffuseScaleOffset3;\r\nuniform vec4 u_DiffuseScaleOffset4;\r\nuniform vec4 u_DiffuseScaleOffset5;\r\n\r\nvarying vec2 v_Texcoord0;\r\n\r\n#ifdef LIGHTMAP\r\n\tuniform sampler2D u_LightMap;\r\n\tvarying vec2 v_LightMapUV;\r\n#endif\r\n\r\nvoid main()\r\n{\r\n\tvec4 splatAlpha = vec4(1.0);\r\n\t#ifdef ExtendTerrain_DETAIL_NUM1\r\n\t\tsplatAlpha = texture2D(u_SplatAlphaTexture, v_Texcoord0);\r\n\t\tvec4 color1 = texture2D(u_DiffuseTexture1, v_Texcoord0 * u_DiffuseScaleOffset1.xy);\r\n\t\tgl_FragColor.xyz = color1.xyz * splatAlpha.r;\r\n\t#endif\r\n\t#ifdef ExtendTerrain_DETAIL_NUM2\r\n\t\tsplatAlpha = texture2D(u_SplatAlphaTexture, v_Texcoord0);\r\n\t\tvec4 color1 = texture2D(u_DiffuseTexture1, v_Texcoord0 * u_DiffuseScaleOffset1.xy);\r\n\t\tvec4 color2 = texture2D(u_DiffuseTexture2, v_Texcoord0 * u_DiffuseScaleOffset2.xy);\r\n\t\tgl_FragColor.xyz = color1.xyz * splatAlpha.r + color2.xyz * (1.0 - splatAlpha.r);\r\n\t#endif\r\n\t#ifdef ExtendTerrain_DETAIL_NUM3\r\n\t\tsplatAlpha = texture2D(u_SplatAlphaTexture, v_Texcoord0);\r\n\t\tvec4 color1 = texture2D(u_DiffuseTexture1, v_Texcoord0 * u_DiffuseScaleOffset1.xy);\r\n\t\tvec4 color2 = texture2D(u_DiffuseTexture2, v_Texcoord0 * u_DiffuseScaleOffset2.xy);\r\n\t\tvec4 color3 = texture2D(u_DiffuseTexture3, v_Texcoord0 * u_DiffuseScaleOffset3.xy);\r\n\t\tgl_FragColor.xyz = color1.xyz * splatAlpha.r  + color2.xyz * splatAlpha.g + color3.xyz * (1.0 - splatAlpha.r - splatAlpha.g);\r\n\t#endif\r\n\t#ifdef ExtendTerrain_DETAIL_NUM4\r\n\t\tsplatAlpha = texture2D(u_SplatAlphaTexture, v_Texcoord0);\r\n\t\tvec4 color1 = texture2D(u_DiffuseTexture1, v_Texcoord0 * u_DiffuseScaleOffset1.xy);\r\n\t\tvec4 color2 = texture2D(u_DiffuseTexture2, v_Texcoord0 * u_DiffuseScaleOffset2.xy);\r\n\t\tvec4 color3 = texture2D(u_DiffuseTexture3, v_Texcoord0 * u_DiffuseScaleOffset3.xy);\r\n\t\tvec4 color4 = texture2D(u_DiffuseTexture4, v_Texcoord0 * u_DiffuseScaleOffset4.xy);\r\n\t\tgl_FragColor.xyz = color1.xyz * splatAlpha.r  + color2.xyz * splatAlpha.g + color3.xyz * splatAlpha.b + color4.xyz * (1.0 - splatAlpha.r - splatAlpha.g - splatAlpha.b);\r\n\t#endif\r\n\t#ifdef ExtendTerrain_DETAIL_NUM5\r\n\t\tsplatAlpha = texture2D(u_SplatAlphaTexture, v_Texcoord0);\r\n\t\tvec4 color1 = texture2D(u_DiffuseTexture1, v_Texcoord0 * u_DiffuseScaleOffset1.xy);\r\n\t\tvec4 color2 = texture2D(u_DiffuseTexture2, v_Texcoord0 * u_DiffuseScaleOffset2.xy);\r\n\t\tvec4 color3 = texture2D(u_DiffuseTexture3, v_Texcoord0 * u_DiffuseScaleOffset3.xy);\r\n\t\tvec4 color4 = texture2D(u_DiffuseTexture4, v_Texcoord0 * u_DiffuseScaleOffset4.xy);\r\n\t\tvec4 color5 = texture2D(u_DiffuseTexture5, v_Texcoord0 * u_DiffuseScaleOffset5.xy);\r\n\t\tgl_FragColor.xyz = color1.xyz * splatAlpha.r  + color2.xyz * splatAlpha.g + color3.xyz * splatAlpha.b + color4.xyz * splatAlpha.a + color5.xyz * (1.0 - splatAlpha.r - splatAlpha.g - splatAlpha.b - splatAlpha.a);\r\n\t#endif\r\n\t\tgl_FragColor.w = splatAlpha.a;\r\n\t\t\r\n\t#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)\r\n\t\tvec3 normal = v_Normal;\r\n\t\tvec3 dif, spe;\r\n\t#endif\r\n\r\n\tvec3 diffuse = vec3(0.0);\r\n\tvec3 specular= vec3(0.0);\r\n\t#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)||defined(FOG)\r\n\t\tvec3 toEye;\r\n\t\t#ifdef FOG\r\n\t\t\ttoEye=u_CameraPos-v_PositionWorld;\r\n\t\t\tfloat toEyeLength=length(toEye);\r\n\t\t\ttoEye/=toEyeLength;\r\n\t\t#else\r\n\t\t\ttoEye=normalize(u_CameraPos-v_PositionWorld);\r\n\t\t#endif\r\n\t#endif\r\n\r\n\t#ifdef LEGACYSINGLELIGHTING\r\n\t\t#ifdef DIRECTIONLIGHT\r\n\t\t\tLayaAirBlinnPhongDiectionLight(vec3(0.0),1.0,normal,vec3(1.0),toEye,u_DirectionLight,dif,spe);\r\n\t\t\tdiffuse+=dif;\r\n\t\t\tspecular+=spe;\r\n\t\t#endif\r\n\t\r\n\t\t#ifdef POINTLIGHT\r\n\t\t\tLayaAirBlinnPhongPointLight(v_PositionWorld,vec3(0.0),1.0,normal,vec3(1.0),toEye,u_PointLight,dif,spe);\r\n\t\t\tdiffuse+=dif;\r\n\t\t\tspecular+=spe;\r\n\t\t#endif\r\n\r\n\t\t#ifdef SPOTLIGHT\r\n\t\t\tLayaAirBlinnPhongSpotLight(v_PositionWorld,vec3(0.0),1.0,normal,vec3(1.0),toEye,u_SpotLight,dif,spe);\r\n\t\t\tdiffuse+=dif;\r\n\t\t\tspecular+=spe;\r\n\t\t#endif\r\n\t#else\r\n\t\t#ifdef DIRECTIONLIGHT\r\n\t\t\tfor (int i = 0; i < MAX_LIGHT_COUNT; i++) \r\n\t\t\t{\r\n\t\t\t\tif(i >= u_DirationLightCount)\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tDirectionLight directionLight = getDirectionLight(u_LightBuffer,i);\r\n\t\t\t\tLayaAirBlinnPhongDiectionLight(vec3(0.0),1.0,normal,vec3(1.0),toEye,directionLight,dif,spe);\r\n\t\t\t\tdiffuse+=dif;\r\n\t\t\t\tspecular+=spe;\r\n\t\t\t}\r\n\t\t#endif\r\n\t\t#if defined(POINTLIGHT)||defined(SPOTLIGHT)\r\n\t\t\tivec4 clusterInfo =getClusterInfo(u_LightClusterBuffer,u_View,u_Viewport, v_PositionWorld,gl_FragCoord,u_ProjectionParams);\r\n\t\t\t#ifdef POINTLIGHT\r\n\t\t\t\tfor (int i = 0; i < MAX_LIGHT_COUNT; i++) \r\n\t\t\t\t{\r\n\t\t\t\t\tif(i >= clusterInfo.x)//PointLightCount\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tPointLight pointLight = getPointLight(u_LightBuffer,u_LightClusterBuffer,clusterInfo,i);\r\n\t\t\t\t\tLayaAirBlinnPhongPointLight(v_PositionWorld,vec3(0.0),1.0,normal,vec3(1.0),toEye,pointLight,dif,spe);\r\n\t\t\t\t\tdiffuse+=dif;\r\n\t\t\t\t\tspecular+=spe;\r\n\t\t\t\t}\r\n\t\t\t#endif\r\n\t\t\t#ifdef SPOTLIGHT\r\n\t\t\t\tfor (int i = 0; i < MAX_LIGHT_COUNT; i++) \r\n\t\t\t\t{\r\n\t\t\t\t\tif(i >= clusterInfo.y)//SpotLightCount\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tSpotLight spotLight = getSpotLight(u_LightBuffer,u_LightClusterBuffer,clusterInfo,i);\r\n\t\t\t\t\tLayaAirBlinnPhongSpotLight(v_PositionWorld,vec3(0.0),1.0,normal,vec3(1.0),toEye\t,spotLight,dif,spe);\r\n\t\t\t\t\tdiffuse+=dif;\r\n\t\t\t\t\tspecular+=spe;\r\n\t\t\t\t}\r\n\t\t\t#endif\r\n\t\t#endif\r\n\t#endif\r\n\r\nvec3 globalDiffuse = u_AmbientColor;\r\n#ifdef LIGHTMAP\r\n\tglobalDiffuse += decodeHDR(texture2D(u_LightMap, v_LightMapUV),5.0);\r\n#endif\r\n\r\n#ifdef RECEIVESHADOW\r\n\tfloat shadowValue = 1.0;\r\n\t#ifdef SHADOWMAP_PSSM3\r\n\t\tshadowValue = getShadowPSSM3( u_shadowMap1,u_shadowMap2,u_shadowMap3,u_lightShadowVP,u_shadowPSSMDistance,u_shadowPCFoffset,v_PositionWorld,v_posViewZ,0.001);\r\n\t#endif\r\n\t#ifdef SHADOWMAP_PSSM2\r\n\t\tshadowValue = getShadowPSSM2( u_shadowMap1,u_shadowMap2,u_lightShadowVP,u_shadowPSSMDistance,u_shadowPCFoffset,v_PositionWorld,v_posViewZ,0.001);\r\n\t#endif \r\n\t#ifdef SHADOWMAP_PSSM1\r\n\t\tshadowValue = getShadowPSSM1( u_shadowMap1,v_lightMVPPos,u_shadowPSSMDistance,u_shadowPCFoffset,v_posViewZ,0.001);\r\n\t#endif\r\n\tgl_FragColor = vec4(gl_FragColor.rgb * (globalDiffuse + diffuse) * shadowValue, gl_FragColor.a);\r\n#else\r\n\tgl_FragColor = vec4(gl_FragColor.rgb * (globalDiffuse + diffuse), gl_FragColor.a);\r\n#endif\r\n\r\n#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)\r\n\t#ifdef RECEIVESHADOW\r\n\t\tgl_FragColor.rgb += specular * shadowValue;\r\n\t#else\r\n\t\tgl_FragColor.rgb += specular;\r\n\t#endif\r\n#endif\r\n\r\n#ifdef FOG\r\n\tfloat lerpFact=clamp((toEyeLength-u_FogStart)/u_FogRange,0.0,1.0);\r\n\tgl_FragColor.rgb=mix(gl_FragColor.rgb,u_FogColor,lerpFact);\r\n#endif\r\n}\r\n\r\n\r\n\r\n\r\n\r\n', r),
                e = {
                    a_Position: Ur.TRAIL_POSITION0,
                    a_OffsetVector: Ur.TRAIL_OFFSETVECTOR,
                    a_Texcoord0X: Ur.TRAIL_TEXTURECOORDINATE0X,
                    a_Texcoord0Y: Ur.TRAIL_TEXTURECOORDINATE0Y,
                    a_BirthTime: Ur.TRAIL_TIME0,
                    a_Color: Ur.TRAIL_COLOR
                },
                t = {
                    u_MvpMatrix: G.PERIOD_SPRITE,
                    u_View: G.PERIOD_CAMERA,
                    u_Projection: G.PERIOD_CAMERA,
                    u_TilingOffset: G.PERIOD_MATERIAL,
                    u_MainTexture: G.PERIOD_MATERIAL,
                    u_MainColor: G.PERIOD_MATERIAL,
                    u_CurTime: G.PERIOD_SPRITE,
                    u_LifeTime: G.PERIOD_SPRITE,
                    u_WidthCurve: G.PERIOD_SPRITE,
                    u_WidthCurveKeyLength: G.PERIOD_SPRITE,
                    u_GradientColorkey: G.PERIOD_SPRITE,
                    u_GradientAlphakey: G.PERIOD_SPRITE
                },
                r = {
                    s_Cull: G.RENDER_STATE_CULL,
                    s_Blend: G.RENDER_STATE_BLEND,
                    s_BlendSrc: G.RENDER_STATE_BLEND_SRC,
                    s_BlendDst: G.RENDER_STATE_BLEND_DST,
                    s_DepthTest: G.RENDER_STATE_DEPTH_TEST,
                    s_DepthWrite: G.RENDER_STATE_DEPTH_WRITE
                },
                n = G.add("Trail"),
                i = new ie(e,t),
                n.addSubShader(i),
                i.addShaderPass('#include "Lighting.glsl";\r\n\r\nattribute vec3 a_Position;\r\nattribute vec3 a_OffsetVector;\r\nattribute vec4 a_Color;\r\nattribute float a_Texcoord0X;\r\nattribute float a_Texcoord0Y;\r\nattribute float a_BirthTime;\r\n\r\nuniform mat4 u_View;\r\nuniform mat4 u_Projection;\r\n\r\nuniform vec4 u_TilingOffset;\r\n\r\nuniform float u_CurTime;\r\nuniform float u_LifeTime;\r\nuniform vec4 u_WidthCurve[10];\r\nuniform int u_WidthCurveKeyLength;\r\n\r\nvarying vec2 v_Texcoord0;\r\nvarying vec4 v_Color;\r\n\r\nfloat hermiteInterpolate(float t, float outTangent, float inTangent, float duration, float value1, float value2)\r\n{\r\n\tfloat t2 = t * t;\r\n\tfloat t3 = t2 * t;\r\n\tfloat a = 2.0 * t3 - 3.0 * t2 + 1.0;\r\n\tfloat b = t3 - 2.0 * t2 + t;\r\n\tfloat c = t3 - t2;\r\n\tfloat d = -2.0 * t3 + 3.0 * t2;\r\n\treturn a * value1 + b * outTangent * duration + c * inTangent * duration + d * value2;\r\n}\r\n\r\nfloat getCurWidth(in float normalizeTime)\r\n{\r\n\tfloat width;\r\n\tif(normalizeTime == 0.0){\r\n\t\twidth=u_WidthCurve[0].w;\r\n\t}\r\n\telse if(normalizeTime >= 1.0){\r\n\t\twidth=u_WidthCurve[u_WidthCurveKeyLength - 1].w;\r\n\t}\r\n\telse{\r\n\t\tfor(int i = 0; i < 10; i ++ )\r\n\t\t{\r\n\t\t\tif(normalizeTime == u_WidthCurve[i].x){\r\n\t\t\t\twidth=u_WidthCurve[i].w;\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tvec4 lastFrame = u_WidthCurve[i];\r\n\t\t\tvec4 nextFrame = u_WidthCurve[i + 1];\r\n\t\t\tif(normalizeTime > lastFrame.x && normalizeTime < nextFrame.x)\r\n\t\t\t{\r\n\t\t\t\tfloat duration = nextFrame.x - lastFrame.x;\r\n\t\t\t\tfloat t = (normalizeTime - lastFrame.x) / duration;\r\n\t\t\t\tfloat outTangent = lastFrame.z;\r\n\t\t\t\tfloat inTangent = nextFrame.y;\r\n\t\t\t\tfloat value1 = lastFrame.w;\r\n\t\t\t\tfloat value2 = nextFrame.w;\r\n\t\t\t\twidth=hermiteInterpolate(t, outTangent, inTangent, duration, value1, value2);\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\treturn width;\r\n}\t\r\n\r\nvoid main()\r\n{\r\n\tfloat normalizeTime = (u_CurTime - a_BirthTime) / u_LifeTime;\r\n\t\r\n\t#ifdef TILINGOFFSET\r\n\t\tv_Texcoord0 = vec2(a_Texcoord0X, 1.0 - a_Texcoord0Y) * u_TilingOffset.xy + u_TilingOffset.zw;\r\n\t#else\r\n\t\tv_Texcoord0 = vec2(a_Texcoord0X, a_Texcoord0Y);\r\n\t#endif\r\n\t\r\n\tv_Color = a_Color;\r\n\t\r\n\tgl_Position = u_Projection * u_View * vec4(a_Position + a_OffsetVector * getCurWidth(normalizeTime),1.0);\r\n\tgl_Position=remapGLPositionZ(gl_Position);\r\n}\r\n', "#ifdef GL_FRAGMENT_PRECISION_HIGH\r\n\tprecision highp float;\r\n#else\r\n\tprecision mediump float;\r\n#endif\r\n\r\nuniform sampler2D u_MainTexture;\r\nuniform vec4 u_MainColor;\r\n\r\nvarying vec2 v_Texcoord0;\r\nvarying vec4 v_Color;\r\n\r\nvoid main()\r\n{\r\n\tvec4 color = 2.0 * u_MainColor * v_Color;\r\n\t#ifdef MAINTEXTURE\r\n\t\tvec4 mainTextureColor = texture2D(u_MainTexture, v_Texcoord0);\r\n\t\tcolor *= mainTextureColor;\r\n\t#endif\r\n\tgl_FragColor = color;\r\n}\r\n\r\n     ", r),
                e = {
                    a_Position: ue.MESH_POSITION0,
                    a_Normal: ue.MESH_NORMAL0,
                    a_Tangent0: ue.MESH_TANGENT0
                },
                t = {
                    u_MvpMatrix: G.PERIOD_SPRITE,
                    u_WorldMat: G.PERIOD_SPRITE,
                    u_CameraPos: G.PERIOD_CAMERA,
                    u_Time: G.PERIOD_SCENE,
                    u_MainTexture: G.PERIOD_MATERIAL,
                    u_NormalTexture: G.PERIOD_MATERIAL,
                    u_HorizonColor: G.PERIOD_MATERIAL,
                    u_WaveScale: G.PERIOD_MATERIAL,
                    u_WaveSpeed: G.PERIOD_MATERIAL
                },
                n = G.add("WaterPrimary"),
                i = new ie(e,t),
                n.addSubShader(i),
                i.addShaderPass('#include "Lighting.glsl";\r\n\r\nattribute vec4 a_Position;\r\nattribute vec3 a_Normal;\r\nattribute vec4 a_Tangent0;\r\n\r\nuniform mat4 u_MvpMatrix;\r\nuniform mat4 u_WorldMat;\r\nuniform vec3 u_CameraPos;\r\nuniform float u_WaveScale;\r\nuniform vec4 u_WaveSpeed;\r\nuniform float u_Time;\r\n\r\nvarying vec3 v_Normal;\r\nvarying vec3 v_Tangent;\r\nvarying vec3 v_Binormal;\r\nvarying vec3 v_ViewDir;\r\nvarying vec2 v_Texcoord0;\r\nvarying vec2 v_Texcoord1;\r\n\r\nvoid main()\r\n{\r\n\tvec4 positionWorld = u_WorldMat * a_Position;\r\n\tvec4 position = u_MvpMatrix * a_Position;\r\n\t\r\n\tvec4 temp = vec4(positionWorld.x, positionWorld.z, positionWorld.x, positionWorld.z) * u_WaveScale + u_WaveSpeed * u_WaveScale * u_Time;\r\n\t\r\n\tv_Texcoord0 = temp.xy * vec2(0.4, 0.45);\r\n\tv_Texcoord1 = temp.wz;\r\n\t\r\n\tmat3 worldMat = mat3(u_WorldMat);\r\n\tv_Normal = worldMat * a_Normal;\r\n\tv_Tangent = worldMat * a_Tangent0.xyz;\r\n\tv_Binormal = cross(v_Normal, v_Tangent) * a_Tangent0.w;\r\n\t\r\n\tv_ViewDir = u_CameraPos - positionWorld.xyz;\r\n\tgl_Position = position;\r\n\tgl_Position=remapGLPositionZ(gl_Position);\r\n}', '#ifdef GL_FRAGMENT_PRECISION_HIGH\r\n\tprecision highp float;\r\n#else\r\n\tprecision mediump float;\r\n#endif\r\n\r\n#ifdef MAINTEXTURE\r\n\tuniform sampler2D u_MainTexture;\r\n#endif\r\n\r\n#ifdef NORMALTEXTURE\r\n\tuniform sampler2D u_NormalTexture;\r\n#endif\r\n\r\nuniform vec4 u_HorizonColor;\r\n\r\nvarying vec3 v_Normal;\r\nvarying vec3 v_Tangent;\r\nvarying vec3 v_Binormal;\r\nvarying vec3 v_ViewDir;\r\nvarying vec2 v_Texcoord0;\r\nvarying vec2 v_Texcoord1;\r\n\r\n\r\n#include "Lighting.glsl"\r\n\r\n\r\n\r\nvec3 NormalSampleToWorldSpace(vec4 normalMapSample) {\r\n\tvec3 normalT;\r\n\tnormalT.x = 2.0 * normalMapSample.x - 1.0;\r\n\tnormalT.y = 1.0 - 2.0 * normalMapSample.y;\r\n\tnormalT.z = sqrt(1.0 - clamp(dot(normalT.xy, normalT.xy), 0.0, 1.0));\r\n\r\n\tvec3 bumpedNormal = normalize(normalT);\r\n\r\n\treturn bumpedNormal;\r\n}\r\n\r\n\r\nvoid main()\r\n{\r\n\tvec4 bumpColor1 = texture2D(u_NormalTexture, v_Texcoord0);\r\n\tvec4 bumpColor2 = texture2D(u_NormalTexture, v_Texcoord1);\r\n\r\n\tvec3 normal1 = NormalSampleToWorldSpace(bumpColor1);\r\n\tvec3 normal2 = NormalSampleToWorldSpace(bumpColor2);\r\n\t\r\n\tvec3 normal = normalize((normal1 + normal2) * 0.5);\r\n\tvec3 viewDir = normalize(v_ViewDir);\r\n\tfloat fresnel = dot(viewDir, normal);\r\n\t\r\n\tvec4 waterColor = texture2D(u_MainTexture, vec2(fresnel, fresnel));\r\n\t\r\n\tvec4 color;\r\n\tcolor.rgb = mix(waterColor.rgb, u_HorizonColor.rgb, vec3(waterColor.a));\r\n\tcolor.a = u_HorizonColor.a;\r\n\t\r\n\tgl_FragColor = color;\r\n}\r\n\r\n\r\n'),
                e = {
                    a_PositionTexcoord: ue.MESH_POSITION0
                },
                t = {
                    u_MainTex: G.PERIOD_MATERIAL,
                    u_OffsetScale: G.PERIOD_MATERIAL
                },
                n = G.add("BlitScreen"),
                i = new ie(e,t),
                n.addSubShader(i);
                var a = i.addShaderPass('#include "Lighting.glsl";\r\n\r\nattribute vec4 a_PositionTexcoord;\r\nuniform vec4 u_OffsetScale;\r\nvarying vec2 v_Texcoord0;\r\n\r\nvoid main() {\t\r\n\tgl_Position = vec4(u_OffsetScale.x*2.0-1.0+(a_PositionTexcoord.x+1.0)*u_OffsetScale.z,(1.0-((u_OffsetScale.y*2.0-1.0+(-a_PositionTexcoord.y+1.0)*u_OffsetScale.w)+1.0)/2.0)*2.0-1.0, 0.0, 1.0);\t\r\n\tv_Texcoord0 = a_PositionTexcoord.zw;\r\n\tgl_Position = remapGLPositionZ(gl_Position);\r\n}', "#ifdef GL_FRAGMENT_PRECISION_HIGH\r\n\tprecision highp float;\r\n#else\r\n\tprecision mediump float;\r\n#endif\r\n\r\nuniform sampler2D u_MainTex;\r\nvarying vec2 v_Texcoord0;\r\n\r\nvoid main() {\r\n\tgl_FragColor = texture2D(u_MainTex, v_Texcoord0);\r\n}\r\n\r\n")
                  , o = a.renderState;
                o.depthTest = Q.DEPTHTEST_ALWAYS,
                o.depthWrite = !1,
                o.cull = Q.CULL_NONE,
                o.blend = Q.BLEND_DISABLE,
                e = {
                    a_PositionTexcoord: ue.MESH_POSITION0
                },
                t = {
                    u_MainTex: G.PERIOD_MATERIAL,
                    u_BloomTex: G.PERIOD_MATERIAL,
                    u_AutoExposureTex: G.PERIOD_MATERIAL,
                    u_MainTex_TexelSize: G.PERIOD_MATERIAL,
                    u_SampleScale: G.PERIOD_MATERIAL,
                    u_Threshold: G.PERIOD_MATERIAL,
                    u_Params: G.PERIOD_MATERIAL
                },
                n = G.add("PostProcessBloom"),
                i = new ie(e,t),
                n.addSubShader(i),
                (o = (a = i.addShaderPass(rn, '#ifdef GL_FRAGMENT_PRECISION_HIGH\r\n\tprecision highp float;\r\n#else\r\n\tprecision mediump float;\r\n#endif\r\n\r\n#include "Colors.glsl";\r\n#include "Sampling.glsl";\r\n\r\nvarying vec2 v_Texcoord0;\r\n\r\nuniform sampler2D u_MainTex;\r\nuniform sampler2D u_AutoExposureTex;\r\nuniform vec4 u_MainTex_TexelSize;\r\nuniform vec4 u_Threshold; // x: threshold value (linear), y: threshold - knee, z: knee * 2, w: 0.25 / knee\r\nuniform vec4 u_Params; // x: clamp, yzw: unused\r\n\r\nmediump vec4 prefilter(mediump vec4 color, vec2 uv) {\r\n\tmediump float autoExposure = texture2D(u_AutoExposureTex, uv).r;\r\n\tcolor *= autoExposure;\r\n\tcolor = min(vec4(u_Params.x), color); // clamp to max\r\n\tcolor = quadraticThreshold(color, u_Threshold.x, u_Threshold.yzw);\r\n\treturn color;\r\n}\r\n\r\nvoid fragPrefilter13() {\r\n\tmediump vec4 color = downsampleBox13Tap(u_MainTex, v_Texcoord0, u_MainTex_TexelSize.xy);\r\n\tgl_FragColor = prefilter(safeHDR(color), v_Texcoord0);\r\n}\r\n\r\nvoid main() {\r\n\tfragPrefilter13();\r\n}')).renderState).depthTest = Q.DEPTHTEST_ALWAYS,
                o.depthWrite = !1,
                o.cull = Q.CULL_NONE,
                o.blend = Q.BLEND_DISABLE,
                i = new ie(e,t),
                n.addSubShader(i),
                (o = (a = i.addShaderPass(rn, '#ifdef GL_FRAGMENT_PRECISION_HIGH\r\n\tprecision highp float;\r\n#else\r\n\tprecision mediump float;\r\n#endif\r\n\r\n#include "Colors.glsl";\r\n#include "Sampling.glsl";\r\n\r\nvarying vec2 v_Texcoord0;\r\n\r\nuniform sampler2D u_MainTex;\r\nuniform sampler2D u_AutoExposureTex;\r\nuniform vec4 u_MainTex_TexelSize;\r\nuniform vec4 u_Threshold; // x: threshold value (linear), y: threshold - knee, z: knee * 2, w: 0.25 / knee\r\nuniform vec4 u_Params; // x: clamp, yzw: unused\r\n\r\nmediump vec4 prefilter(mediump vec4 color, vec2 uv) {\r\n\tmediump float autoExposure = texture2D(u_AutoExposureTex, uv).r;\r\n\tcolor *= autoExposure;\r\n\tcolor = min(vec4(u_Params.x), color); // clamp to max\r\n\tcolor = quadraticThreshold(color, u_Threshold.x, u_Threshold.yzw);\r\n\treturn color;\r\n}\r\n\r\nvoid fragPrefilter4() {\r\n\tmediump vec4 color = downsampleBox4Tap(u_MainTex, v_Texcoord0, u_MainTex_TexelSize.xy);\r\n\tgl_FragColor = prefilter(safeHDR(color), v_Texcoord0);\r\n}\r\n\r\nvoid main() {\r\n\tfragPrefilter4();\r\n}')).renderState).depthTest = Q.DEPTHTEST_ALWAYS,
                o.depthWrite = !1,
                o.cull = Q.CULL_NONE,
                o.blend = Q.BLEND_DISABLE,
                i = new ie(e,t),
                n.addSubShader(i),
                (o = (a = i.addShaderPass(rn, '#ifdef GL_FRAGMENT_PRECISION_HIGH\r\n\tprecision highp float;\r\n#else\r\n\tprecision mediump float;\r\n#endif\r\n\r\n#include "Colors.glsl";\r\n#include "Sampling.glsl";\r\n\r\nvarying vec2 v_Texcoord0;\r\n\r\nuniform sampler2D u_MainTex;\r\nuniform vec4 u_MainTex_TexelSize;\r\n\r\nvoid fragDownsample13() {\r\n\tmediump vec4 color = downsampleBox13Tap(u_MainTex, v_Texcoord0, u_MainTex_TexelSize.xy);\r\n\tgl_FragColor = color;\r\n}\r\n\r\nvoid main() {\r\n\tfragDownsample13();\r\n}')).renderState).depthTest = Q.DEPTHTEST_ALWAYS,
                o.depthWrite = !1,
                o.cull = Q.CULL_NONE,
                o.blend = Q.BLEND_DISABLE,
                i = new ie(e,t),
                n.addSubShader(i),
                (o = (a = i.addShaderPass(rn, '#ifdef GL_FRAGMENT_PRECISION_HIGH\r\n\tprecision highp float;\r\n#else\r\n\tprecision mediump float;\r\n#endif\r\n\r\n#include "Colors.glsl";\r\n#include "Sampling.glsl";\r\n\r\nvarying vec2 v_Texcoord0;\r\n\r\nuniform sampler2D u_MainTex;\r\nuniform vec4 u_MainTex_TexelSize;\r\n\r\nvoid fragDownsample4() {\r\n\tmediump vec4 color = downsampleBox4Tap(u_MainTex, v_Texcoord0, u_MainTex_TexelSize.xy);\r\n\tgl_FragColor = color;\r\n}\r\n\r\nvoid main() {\r\n\tfragDownsample4();\r\n}')).renderState).depthTest = Q.DEPTHTEST_ALWAYS,
                o.depthWrite = !1,
                o.cull = Q.CULL_NONE,
                o.blend = Q.BLEND_DISABLE,
                i = new ie(e,t),
                n.addSubShader(i),
                (o = (a = i.addShaderPass(rn, '#ifdef GL_FRAGMENT_PRECISION_HIGH\r\n\tprecision highp float;\r\n#else\r\n\tprecision mediump float;\r\n#endif\r\n\r\n#include "Colors.glsl";\r\n#include "Sampling.glsl";\r\n\r\nvarying vec2 v_Texcoord0;\r\n\r\nuniform sampler2D u_MainTex;\r\nuniform sampler2D u_BloomTex;\r\n\r\nuniform vec4 u_MainTex_TexelSize;\r\nuniform float u_SampleScale;\r\n\r\nmediump vec4 combine(mediump vec4 bloom, vec2 uv) {\r\n\tmediump vec4 color = texture2D(u_BloomTex, uv);\r\n\treturn bloom + color;\r\n}\r\n\r\nvoid fragUpsampleTent() {\r\n\tmediump vec4 bloom = upsampleTent(u_MainTex, v_Texcoord0, u_MainTex_TexelSize.xy, vec4(u_SampleScale));\r\n\tgl_FragColor = combine(bloom, v_Texcoord0);\r\n}\r\n\r\nvoid main() {\r\n\tfragUpsampleTent();\r\n}')).renderState).depthTest = Q.DEPTHTEST_ALWAYS,
                o.depthWrite = !1,
                o.cull = Q.CULL_NONE,
                o.blend = Q.BLEND_DISABLE,
                i = new ie(e,t),
                n.addSubShader(i),
                (o = (a = i.addShaderPass(rn, '#ifdef GL_FRAGMENT_PRECISION_HIGH\r\n\tprecision highp float;\r\n#else\r\n\tprecision mediump float;\r\n#endif\r\n\r\n#include "Colors.glsl";\r\n#include "Sampling.glsl";\r\n\r\nvarying vec2 v_Texcoord0;\r\n\r\nuniform sampler2D u_MainTex;\r\nuniform sampler2D u_BloomTex;\r\n\r\nuniform vec4 u_MainTex_TexelSize;\r\nuniform float u_SampleScale;\r\n\r\nmediump vec4 combine(mediump vec4 bloom, vec2 uv) {\r\n\tmediump vec4 color = texture2D(u_BloomTex, uv);\r\n\treturn bloom + color;\r\n}\r\n\r\nvoid fragUpsampleBox() {\r\n\tmediump vec4 bloom = upsampleBox(u_MainTex, v_Texcoord0, u_MainTex_TexelSize.xy, vec4(u_SampleScale));\r\n\tgl_FragColor = combine(bloom, v_Texcoord0);\r\n}\r\n\r\nvoid main() {\r\n\tfragUpsampleBox();\r\n}')).renderState).depthTest = Q.DEPTHTEST_ALWAYS,
                o.depthWrite = !1,
                o.cull = Q.CULL_NONE,
                o.blend = Q.BLEND_DISABLE,
                e = {
                    a_PositionTexcoord: ue.MESH_POSITION0
                },
                t = {
                    u_MainTex: G.PERIOD_MATERIAL,
                    u_BloomTex: G.PERIOD_MATERIAL,
                    u_AutoExposureTex: G.PERIOD_MATERIAL,
                    u_Bloom_DirtTileOffset: G.PERIOD_MATERIAL,
                    u_Bloom_DirtTex: G.PERIOD_MATERIAL,
                    u_BloomTex_TexelSize: G.PERIOD_MATERIAL,
                    u_Bloom_Settings: G.PERIOD_MATERIAL,
                    u_Bloom_Color: G.PERIOD_MATERIAL
                },
                n = G.add("PostProcessComposite"),
                i = new ie(e,t),
                n.addSubShader(i),
                (o = (a = i.addShaderPass('#include "Lighting.glsl";\r\n\r\nattribute vec4 a_PositionTexcoord;\r\nvarying vec2 v_Texcoord0;\r\n\r\nvoid main() {\r\n\tgl_Position = vec4(a_PositionTexcoord.xy, 0.0, 1.0);\r\n\tv_Texcoord0 = a_PositionTexcoord.zw;\r\n\tgl_Position = remapGLPositionZ(gl_Position);\r\n}', '#ifdef GL_FRAGMENT_PRECISION_HIGH\r\n\tprecision highp float;\r\n#else\r\n\tprecision mediump float;\r\n#endif\r\n\r\n#include "Colors.glsl";\r\n#include "Sampling.glsl";\r\n\r\nvarying vec2 v_Texcoord0;\r\n\r\nuniform sampler2D u_MainTex;\r\nuniform sampler2D u_BloomTex;\r\n\r\nuniform sampler2D u_AutoExposureTex;\r\nuniform sampler2D u_Bloom_DirtTex;\r\nuniform vec4 u_BloomTex_TexelSize;\r\nuniform vec4 u_Bloom_DirtTileOffset; // xy: tiling, zw: offset\r\nuniform mediump vec3 u_Bloom_Settings;// x: sampleScale, y: intensity, z: dirt intensity\r\nuniform mediump vec3 u_Bloom_Color;\r\n\r\nvoid main() {\r\n\tmediump float autoExposure = texture2D(u_AutoExposureTex, v_Texcoord0).r;\r\n\tmediump vec4 color=vec4(0.0);\r\n\tcolor = texture2D(u_MainTex, v_Texcoord0);\r\n\t\r\n\tcolor = sRGBToLinear(color);\r\n\tcolor.rgb *= autoExposure;\r\n\t\r\n\t#if defined(BLOOM)||defined(BLOOM_LOW)\r\n\t\t#ifdef BLOOM\r\n\t\t\tmediump vec4 bloom = upsampleTent(u_BloomTex, v_Texcoord0, u_BloomTex_TexelSize.xy, vec4(u_Bloom_Settings.x));\r\n\t\t#else\r\n\t\t\tmediump vec4 bloom = upsampleBox(u_BloomTex, v_Texcoord0, u_BloomTex_TexelSize.xy, vec4(u_Bloom_Settings.x));\r\n\t\t#endif\r\n\r\n\t\t// UVs should be Distort(uv * u_Bloom_DirtTileOffset.xy + u_Bloom_DirtTileOffset.zw)\r\n\t\t// but considering we use a cover-style scale on the dirt texture the difference\r\n\t\t// isn\'t massive so we chose to save a few ALUs here instead in case lens distortion\r\n\t\t// is active\r\n\t\tmediump vec4 dirt =vec4(texture2D(u_Bloom_DirtTex, v_Texcoord0 * u_Bloom_DirtTileOffset.xy + u_Bloom_DirtTileOffset.zw).rgb, 0.0);\r\n\r\n\t\t// Additive bloom (artist friendly)\r\n\t\tbloom *= u_Bloom_Settings.y;\r\n\t\tdirt *= u_Bloom_Settings.z;\r\n\t\tmediump vec4 bloomColor=vec4(u_Bloom_Color, 1.0);\r\n\t\tcolor += bloom * bloomColor;\r\n\t\tcolor += dirt * bloom;\r\n\t#endif\r\n\t\r\n\tmediump vec4 finalColor = color;\r\n\tfinalColor = linearToSRGB(finalColor);\r\n\t//finalColor.rgb = Dither(finalColor.rgb, v_Texcoord0);//TODO:抖动\r\n\tgl_FragColor = finalColor;\r\n}')).renderState).depthTest = Q.DEPTHTEST_ALWAYS,
                o.depthWrite = !1,
                o.cull = Q.CULL_NONE,
                o.blend = Q.BLEND_DISABLE;
            }
        }]),
        ShaderInit3D;
    }()
      , an = function() {
        function ParallelSplitShadowMap() {
            var e;
            for (_classCallCheck(this, ParallelSplitShadowMap),
            this._spiltDistance = [],
            this._currentPSSM = -1,
            this._shadowMapCount = 3,
            this._maxDistance = 200,
            this._ratioOfDistance = 1 / this._shadowMapCount,
            this._globalParallelLightDir = new o(0,-1,0),
            this._statesDirty = !0,
            this._shadowMapTextureSize = 1024,
            this._scene = null,
            this._boundingSphere = new Array(ParallelSplitShadowMap.MAX_PSSM_COUNT + 1),
            this._boundingBox = new Array(ParallelSplitShadowMap.MAX_PSSM_COUNT + 1),
            this._frustumPos = new Array(4 * (ParallelSplitShadowMap.MAX_PSSM_COUNT + 1)),
            this._uniformDistance = new Array(ParallelSplitShadowMap.MAX_PSSM_COUNT + 1),
            this._logDistance = new Array(ParallelSplitShadowMap.MAX_PSSM_COUNT + 1),
            this._dimension = new Array(ParallelSplitShadowMap.MAX_PSSM_COUNT + 1),
            this._PCFType = 0,
            this._tempLookAt3 = new o(),
            this._tempLookAt4 = new i(),
            this._tempValue = new i(),
            this._tempPos = new o(),
            this._tempLightUp = new o(),
            this._tempMin = new i(),
            this._tempMax = new i(),
            this._tempMatrix44 = new I(),
            this._splitFrustumCulling = new be(I.DEFAULT),
            this._tempScaleMatrix44 = new I(),
            this._shadowPCFOffset = new n(1 / 1024,1 / 1024),
            this._shaderValueDistance = new i(),
            this._shaderValueLightVP = null,
            this.cameras = [],
            this._shaderValueVPs = [],
            e = 0; e < this._spiltDistance.length; e++)
                this._spiltDistance[e] = 0;
            for (e = 0; e < this._dimension.length; e++)
                this._dimension[e] = new n();
            for (e = 0; e < this._frustumPos.length; e++)
                this._frustumPos[e] = new o();
            for (e = 0; e < this._boundingBox.length; e++)
                this._boundingBox[e] = new ot(new o(),new o());
            for (e = 0; e < this._boundingSphere.length; e++)
                this._boundingSphere[e] = new Wt(new o(),0);
            I.createScaling(new o(.5,.5,1), this._tempScaleMatrix44),
            this._tempScaleMatrix44.elements[12] = .5,
            this._tempScaleMatrix44.elements[13] = .5;
        }
        return _createClass(ParallelSplitShadowMap, [{
            key: "setInfo",
            value: function(e, t, r, n, i, a) {
                i > ParallelSplitShadowMap.MAX_PSSM_COUNT && (this._shadowMapCount = ParallelSplitShadowMap.MAX_PSSM_COUNT),
                this._scene = e,
                this._maxDistance = t,
                this.shadowMapCount = i,
                this._globalParallelLightDir = r,
                this._ratioOfDistance = 1 / this._shadowMapCount;
                for (var o = 0; o < this._spiltDistance.length; o++)
                    this._spiltDistance[o] = 0;
                this._shadowMapTextureSize = n,
                this._shadowPCFOffset.x = 1 / this._shadowMapTextureSize,
                this._shadowPCFOffset.y = 1 / this._shadowMapTextureSize,
                this.setPCFType(a),
                this._statesDirty = !0;
            }
        }, {
            key: "setPCFType",
            value: function(e) {
                this._PCFType = e;
                var t = this._scene._shaderValues;
                switch (this._PCFType) {
                case 0:
                    t.addDefine(Je.SHADERDEFINE_SHADOW_PCF_NO),
                    t.removeDefine(Je.SHADERDEFINE_SHADOW_PCF1),
                    t.removeDefine(Je.SHADERDEFINE_SHADOW_PCF2),
                    t.removeDefine(Je.SHADERDEFINE_SHADOW_PCF3);
                    break;
                case 1:
                    t.addDefine(Je.SHADERDEFINE_SHADOW_PCF1),
                    t.removeDefine(Je.SHADERDEFINE_SHADOW_PCF_NO),
                    t.removeDefine(Je.SHADERDEFINE_SHADOW_PCF2),
                    t.removeDefine(Je.SHADERDEFINE_SHADOW_PCF3);
                    break;
                case 2:
                    t.addDefine(Je.SHADERDEFINE_SHADOW_PCF2),
                    t.removeDefine(Je.SHADERDEFINE_SHADOW_PCF_NO),
                    t.removeDefine(Je.SHADERDEFINE_SHADOW_PCF1),
                    t.removeDefine(Je.SHADERDEFINE_SHADOW_PCF3);
                    break;
                case 3:
                    t.addDefine(Je.SHADERDEFINE_SHADOW_PCF3),
                    t.removeDefine(Je.SHADERDEFINE_SHADOW_PCF_NO),
                    t.removeDefine(Je.SHADERDEFINE_SHADOW_PCF1),
                    t.removeDefine(Je.SHADERDEFINE_SHADOW_PCF2);
                }
            }
        }, {
            key: "getPCFType",
            value: function() {
                return this._PCFType;
            }
        }, {
            key: "setFarDistance",
            value: function(e) {
                this._maxDistance != e && (this._maxDistance = e,
                this._statesDirty = !0);
            }
        }, {
            key: "getFarDistance",
            value: function() {
                return this._maxDistance;
            }
        }, {
            key: "_beginSampler",
            value: function(e, t) {
                if (e < 0 || e > this._shadowMapCount)
                    throw new Error("ParallelSplitShadowMap: beginSample invalid index");
                this._currentPSSM = e,
                this._update(t);
            }
        }, {
            key: "endSampler",
            value: function(e) {
                this._currentPSSM = -1;
            }
        }, {
            key: "_calcAllLightCameraInfo",
            value: function(e) {
                if (1 === this._shadowMapCount)
                    this._beginSampler(0, e),
                    this.endSampler(e);
                else
                    for (var t = 0, r = this._shadowMapCount + 1; t < r; t++)
                        this._beginSampler(t, e),
                        this.endSampler(e);
            }
        }, {
            key: "_recalculate",
            value: function(e, t, r) {
                this._calcSplitDistance(e),
                this._calcBoundingBox(t, r),
                this._rebuildRenderInfo();
            }
        }, {
            key: "_update",
            value: function(e) {
                var t = e.nearPlane
                  , r = e.fieldOfView
                  , n = e.aspectRatio;
                (this._statesDirty || this.lastNearPlane !== t || this.lastFieldOfView !== r || this.lastAspectRatio !== n) && (this._recalculate(t, r, n),
                this._uploadShaderValue(),
                this._statesDirty = !1,
                this.lastNearPlane = t,
                this.lastFieldOfView = r,
                this.lastAspectRatio = n),
                this._calcLightViewProject(e);
            }
        }, {
            key: "_uploadShaderValue",
            value: function() {
                var e = this._scene._shaderValues;
                switch (this._shadowMapCount) {
                case 1:
                    e.addDefine(Je.SHADERDEFINE_SHADOW_PSSM1),
                    e.removeDefine(Je.SHADERDEFINE_SHADOW_PSSM2),
                    e.removeDefine(Je.SHADERDEFINE_SHADOW_PSSM3);
                    break;
                case 2:
                    e.addDefine(Je.SHADERDEFINE_SHADOW_PSSM2),
                    e.removeDefine(Je.SHADERDEFINE_SHADOW_PSSM1),
                    e.removeDefine(Je.SHADERDEFINE_SHADOW_PSSM3);
                    break;
                case 3:
                    e.addDefine(Je.SHADERDEFINE_SHADOW_PSSM3),
                    e.removeDefine(Je.SHADERDEFINE_SHADOW_PSSM1),
                    e.removeDefine(Je.SHADERDEFINE_SHADOW_PSSM2);
                }
                switch (e.setVector(l.Scene3D.SHADOWDISTANCE, this._shaderValueDistance),
                e.setBuffer(l.Scene3D.SHADOWLIGHTVIEWPROJECT, this._shaderValueLightVP),
                e.setVector2(l.Scene3D.SHADOWMAPPCFOFFSET, this._shadowPCFOffset),
                this._shadowMapCount) {
                case 3:
                    e.setTexture(l.Scene3D.SHADOWMAPTEXTURE1, this.cameras[1].renderTarget),
                    e.setTexture(l.Scene3D.SHADOWMAPTEXTURE2, this.cameras[2].renderTarget),
                    e.setTexture(l.Scene3D.SHADOWMAPTEXTURE3, this.cameras[3].renderTarget);
                    break;
                case 2:
                    e.setTexture(l.Scene3D.SHADOWMAPTEXTURE1, this.cameras[1].renderTarget),
                    e.setTexture(l.Scene3D.SHADOWMAPTEXTURE2, this.cameras[2].renderTarget);
                    break;
                case 1:
                    e.setTexture(l.Scene3D.SHADOWMAPTEXTURE1, this.cameras[1].renderTarget);
                }
            }
        }, {
            key: "_calcSplitDistance",
            value: function(e) {
                var t, r = this._maxDistance, n = 1 / this._shadowMapCount;
                for (t = 0; t <= this._shadowMapCount; t++)
                    this._uniformDistance[t] = e + (r - e) * t * n;
                var i = r / e;
                for (t = 0; t <= this._shadowMapCount; t++) {
                    var a = Math.pow(i, t * n);
                    this._logDistance[t] = e * a;
                }
                for (t = 0; t <= this._shadowMapCount; t++)
                    this._spiltDistance[t] = this._uniformDistance[t] * this._ratioOfDistance + this._logDistance[t] * (1 - this._ratioOfDistance);
                this._shaderValueDistance.x = null != this._spiltDistance[1] && this._spiltDistance[1],
                this._shaderValueDistance.y = null != this._spiltDistance[2] && this._spiltDistance[2],
                this._shaderValueDistance.z = null != this._spiltDistance[3] && this._spiltDistance[3],
                this._shaderValueDistance.w = null != this._spiltDistance[4] && this._spiltDistance[4];
            }
        }, {
            key: "_calcBoundingBox",
            value: function(e, t) {
                var r, n, i, a, o, s, l, u, c = 3.1415926 * e / 180, h = Math.tan(c / 2);
                for (a = 0; a <= this._shadowMapCount; a++) {
                    n = (r = (i = this._spiltDistance[a]) * h) * t;
                    var _ = this._frustumPos[4 * a + 0];
                    _.x = -n,
                    _.y = -r,
                    _.z = -i,
                    (_ = this._frustumPos[4 * a + 1]).x = n,
                    _.y = -r,
                    _.z = -i,
                    (_ = this._frustumPos[4 * a + 2]).x = -n,
                    _.y = r,
                    _.z = -i,
                    (_ = this._frustumPos[4 * a + 3]).x = n,
                    _.y = r,
                    _.z = -i,
                    (_ = this._dimension[a]).x = n,
                    _.y = r;
                }
                for (a = 1; a <= this._shadowMapCount; a++)
                    o = this._dimension[a],
                    (s = this._boundingBox[a].min).x = -o.x,
                    s.y = -o.y,
                    s.z = -this._spiltDistance[a],
                    (l = this._boundingBox[a].max).x = o.x,
                    l.y = o.y,
                    l.z = -this._spiltDistance[a - 1],
                    (u = this._boundingSphere[a].center).x = .5 * (s.x + l.x),
                    u.y = .5 * (s.y + l.y),
                    u.z = .5 * (s.z + l.z),
                    this._boundingSphere[a].radius = .5 * Math.sqrt(Math.pow(l.x - s.x, 2) + Math.pow(l.y - s.y, 2) + Math.pow(l.z - s.z, 2));
                s = this._boundingBox[0].min,
                o = this._dimension[this._shadowMapCount],
                s.x = -o.x,
                s.y = -o.y,
                s.z = -this._spiltDistance[this._shadowMapCount],
                (l = this._boundingBox[0].max).x = o.x,
                l.y = o.y,
                l.z = -this._spiltDistance[0],
                (u = this._boundingSphere[0].center).x = .5 * (s.x + l.x),
                u.y = .5 * (s.y + l.y),
                u.z = .5 * (s.z + l.z),
                this._boundingSphere[0].radius = .5 * Math.sqrt(Math.pow(l.x - s.x, 2) + Math.pow(l.y - s.y, 2) + Math.pow(l.z - s.z, 2));
            }
        }, {
            key: "calcSplitFrustum",
            value: function(e) {
                this._currentPSSM > 0 ? I.createPerspective(3.1416 * e.fieldOfView / 180, e.aspectRatio, this._spiltDistance[this._currentPSSM - 1], this._spiltDistance[this._currentPSSM], this._tempMatrix44) : I.createPerspective(3.1416 * e.fieldOfView / 180, e.aspectRatio, this._spiltDistance[0], this._spiltDistance[this._shadowMapCount], this._tempMatrix44),
                I.multiply(this._tempMatrix44, e.viewMatrix, this._tempMatrix44),
                this._splitFrustumCulling.matrix = this._tempMatrix44;
            }
        }, {
            key: "_rebuildRenderInfo",
            value: function() {
                var e, r = this._shadowMapCount + 1;
                for (this.cameras.length = r,
                e = 0; e < r; e++) {
                    if (!this.cameras[e]) {
                        var n = new $e();
                        n.name = "lightCamera" + e,
                        n.clearColor = new i(1,1,1,1),
                        this.cameras[e] = n;
                    }
                    var a = this.cameras[e].renderTarget;
                    null != a && a.width == this._shadowMapTextureSize && a.height == this._shadowMapTextureSize || (a && a.destroy(),
                    (a = new V(this._shadowMapTextureSize,this._shadowMapTextureSize,t.RenderTextureFormat.R8G8B8A8,t.RenderTextureDepthFormat.DEPTH_16)).filterMode = t.FilterMode.Point,
                    this.cameras[e].renderTarget = a);
                }
            }
        }, {
            key: "_calcLightViewProject",
            value: function(e) {
                var t = this._boundingSphere[this._currentPSSM]
                  , r = e.transform.worldMatrix;
                t.radius;
                t.center.cloneTo(this._tempLookAt3),
                o.transformV3ToV4(this._tempLookAt3, r, this._tempLookAt4);
                var n = this._tempLookAt3
                  , a = this._tempLookAt4;
                n.x = a.x,
                n.y = a.y,
                n.z = a.z;
                var s = this._tempLightUp;
                e.transform.worldMatrix.getForward(ParallelSplitShadowMap._tempVector30);
                var u = ParallelSplitShadowMap._tempVector30;
                s.x = u.x,
                s.y = 1,
                s.z = u.z,
                o.normalize(this._tempLightUp, this._tempLightUp),
                o.scale(this._globalParallelLightDir, 4 * t.radius, this._tempPos),
                o.subtract(this._tempLookAt3, this._tempPos, this._tempPos);
                var c = this.cameras[this._currentPSSM];
                c.transform.position = this._tempPos,
                c.transform.lookAt(this._tempLookAt3, this._tempLightUp, !1);
                var h = this._tempMax
                  , _ = this._tempMin;
                h.x = h.y = h.z = -1e5,
                h.w = 1,
                _.x = _.y = _.z = 1e5,
                _.w = 1,
                I.multiply(c.viewMatrix, r, this._tempMatrix44);
                var d = this._tempValue
                  , f = [];
                f.length = 8,
                this._boundingBox[this._currentPSSM].getCorners(f);
                for (var m = 0; m < 8; m++) {
                    var p = f[m];
                    d.x = p.x,
                    d.y = p.y,
                    d.z = p.z,
                    d.w = 1,
                    i.transformByM4x4(this._tempValue, this._tempMatrix44, this._tempValue),
                    _.x = d.x < _.x ? d.x : _.x,
                    _.y = d.y < _.y ? d.y : _.y,
                    _.z = d.z < _.z ? d.z : _.z,
                    h.x = d.x > h.x ? d.x : h.x,
                    h.y = d.y > h.y ? d.y : h.y,
                    h.z = d.z > h.z ? d.z : h.z;
                }
                i.add(this._tempMax, this._tempMin, this._tempValue),
                d.x *= .5,
                d.y *= .5,
                d.z *= .5,
                d.w = 1,
                i.transformByM4x4(this._tempValue, c.transform.worldMatrix, this._tempValue);
                var v = Math.abs(-this._tempMax.z)
                  , T = v > this._maxDistance ? v : this._maxDistance;
                o.scale(this._globalParallelLightDir, T, this._tempPos);
                var E = this._tempPos;
                E.x = d.x - E.x,
                E.y = d.y - E.y,
                E.z = d.z - E.z,
                c.transform.position = this._tempPos,
                c.transform.lookAt(this._tempLookAt3, this._tempLightUp, !1),
                I.createOrthoOffCenter(_.x, h.x, _.y, h.y, 1, T + .5 * (h.z - _.z), c.projectionMatrix);
                var y = c.projectionViewMatrix;
                ParallelSplitShadowMap.multiplyMatrixOutFloat32Array(this._tempScaleMatrix44, y, this._shaderValueVPs[this._currentPSSM]),
                this._scene._shaderValues.setBuffer(l.Scene3D.SHADOWLIGHTVIEWPROJECT, this._shaderValueLightVP);
            }
        }, {
            key: "setShadowMapTextureSize",
            value: function(e) {
                e !== this._shadowMapTextureSize && (this._shadowMapTextureSize = e,
                this._shadowPCFOffset.x = 1 / this._shadowMapTextureSize,
                this._shadowPCFOffset.y = 1 / this._shadowMapTextureSize,
                this._statesDirty = !0);
            }
        }, {
            key: "disposeAllRenderTarget",
            value: function() {
                for (var e = 0, t = this._shadowMapCount + 1; e < t; e++)
                    this.cameras[e].renderTarget && (this.cameras[e].renderTarget.destroy(),
                    this.cameras[e].renderTarget = null);
            }
        }, {
            key: "shadowMapCount",
            set: function(e) {
                if (e = (e = e > 0 ? e : 1) <= ParallelSplitShadowMap.MAX_PSSM_COUNT ? e : ParallelSplitShadowMap.MAX_PSSM_COUNT,
                this._shadowMapCount != e) {
                    this._shadowMapCount = e,
                    this._ratioOfDistance = 1 / this._shadowMapCount,
                    this._statesDirty = !0,
                    this._shaderValueLightVP = new Float32Array(16 * e),
                    this._shaderValueVPs.length = e;
                    for (var t = 0; t < e; t++)
                        this._shaderValueVPs[t] = new Float32Array(this._shaderValueLightVP.buffer,64 * t);
                }
            },
            get: function() {
                return this._shadowMapCount;
            }
        }], [{
            key: "multiplyMatrixOutFloat32Array",
            value: function(e, t, r) {
                var n, i, a, o, s, l, u;
                for (i = e.elements,
                a = t.elements,
                n = 0; n < 4; n++)
                    o = i[n],
                    s = i[n + 4],
                    l = i[n + 8],
                    u = i[n + 12],
                    r[n] = o * a[0] + s * a[1] + l * a[2] + u * a[3],
                    r[n + 4] = o * a[4] + s * a[5] + l * a[6] + u * a[7],
                    r[n + 8] = o * a[8] + s * a[9] + l * a[10] + u * a[11],
                    r[n + 12] = o * a[12] + s * a[13] + l * a[14] + u * a[15];
            }
        }]),
        ParallelSplitShadowMap;
    }();
    an.MAX_PSSM_COUNT = 3,
    an._tempVector30 = new o();
    var on = function(e) {
        function LightSprite() {
            var e;
            return _classCallCheck(this, LightSprite),
            (e = _possibleConstructorReturn(this, _getPrototypeOf(LightSprite).call(this)))._isAlternate = !1,
            e._intensity = 1,
            e._intensityColor = new o(),
            e.color = new o(1,1,1),
            e._shadow = !1,
            e._shadowFarPlane = 8,
            e._shadowMapSize = 512,
            e._shadowMapCount = 1,
            e._shadowMapPCFType = 0,
            e._lightmapBakedType = LightSprite.LIGHTMAPBAKEDTYPE_REALTIME,
            e;
        }
        return _inherits(LightSprite, ye),
        _createClass(LightSprite, [{
            key: "_parse",
            value: function(e, t) {
                _get(_getPrototypeOf(LightSprite.prototype), "_parse", this).call(this, e, t);
                var r = e.color;
                this.color.fromArray(r),
                this.intensity = e.intensity,
                this.lightmapBakedType = e.lightmapBakedType;
            }
        }, {
            key: "_addToScene",
            value: function() {
                var e = this._scene
                  , t = s._config.maxLightCount;
                e._lightCount < t ? (e._lightCount++,
                this._addToLightQueue(),
                this._isAlternate = !1) : (e._alternateLights.add(this),
                this._isAlternate = !0,
                console.warn("LightSprite:light count has large than maxLightCount,the latest added light will be ignore."));
            }
        }, {
            key: "_removeFromScene",
            value: function() {
                var e = this._scene;
                if (this._isAlternate)
                    e._alternateLights.remove(this);
                else if (e._lightCount--,
                this._removeFromLightQueue(),
                e._alternateLights._length > 0) {
                    var t = e._alternateLights.shift();
                    t._addToLightQueue(),
                    t._isAlternate = !1,
                    e._lightCount++;
                }
            }
        }, {
            key: "_addToLightQueue",
            value: function() {}
        }, {
            key: "_removeFromLightQueue",
            value: function() {}
        }, {
            key: "_onActive",
            value: function() {
                _get(_getPrototypeOf(LightSprite.prototype), "_onActive", this).call(this),
                this.lightmapBakedType !== LightSprite.LIGHTMAPBAKEDTYPE_BAKED && this._addToScene();
            }
        }, {
            key: "_onInActive",
            value: function() {
                _get(_getPrototypeOf(LightSprite.prototype), "_onInActive", this).call(this),
                this.lightmapBakedType !== LightSprite.LIGHTMAPBAKEDTYPE_BAKED && this._removeFromScene();
            }
        }, {
            key: "_create",
            value: function() {
                return new LightSprite();
            }
        }, {
            key: "intensity",
            get: function() {
                return this._intensity;
            },
            set: function(e) {
                this._intensity = e;
            }
        }, {
            key: "shadow",
            get: function() {
                return this._shadow;
            },
            set: function(e) {
                throw new Error("LightSprite: must override it.");
            }
        }, {
            key: "shadowDistance",
            get: function() {
                return this._shadowFarPlane;
            },
            set: function(e) {
                this._shadowFarPlane = e,
                this._parallelSplitShadowMap && this._parallelSplitShadowMap.setFarDistance(e);
            }
        }, {
            key: "shadowResolution",
            get: function() {
                return this._shadowMapSize;
            },
            set: function(e) {
                this._shadowMapSize = e,
                this._parallelSplitShadowMap && this._parallelSplitShadowMap.setShadowMapTextureSize(e);
            }
        }, {
            key: "shadowPSSMCount",
            get: function() {
                return this._shadowMapCount;
            },
            set: function(e) {
                this._shadowMapCount = e,
                this._parallelSplitShadowMap && (this._parallelSplitShadowMap.shadowMapCount = e);
            }
        }, {
            key: "shadowPCFType",
            get: function() {
                return this._shadowMapPCFType;
            },
            set: function(e) {
                this._shadowMapPCFType = e,
                this._parallelSplitShadowMap && this._parallelSplitShadowMap.setPCFType(e);
            }
        }, {
            key: "lightmapBakedType",
            get: function() {
                return this._lightmapBakedType;
            },
            set: function(e) {
                this._lightmapBakedType !== e && (this._lightmapBakedType = e,
                this.activeInHierarchy && (e !== LightSprite.LIGHTMAPBAKEDTYPE_BAKED ? this._addToScene() : this._removeFromScene()));
            }
        }, {
            key: "diffuseColor",
            get: function() {
                return console.log("LightSprite: discard property,please use color property instead."),
                this.color;
            },
            set: function(e) {
                console.log("LightSprite: discard property,please use color property instead."),
                this.color = e;
            }
        }]),
        LightSprite;
    }();
    on.LIGHTMAPBAKEDTYPE_REALTIME = 0,
    on.LIGHTMAPBAKEDTYPE_MIXED = 1,
    on.LIGHTMAPBAKEDTYPE_BAKED = 2;
    var sn = function(e) {
        function DirectionLight() {
            var e;
            return _classCallCheck(this, DirectionLight),
            (e = _possibleConstructorReturn(this, _getPrototypeOf(DirectionLight).call(this)))._direction = new o(),
            e;
        }
        return _inherits(DirectionLight, on),
        _createClass(DirectionLight, [{
            key: "shadow",
            set: function(e) {
                this._shadow !== e && (this._shadow = e,
                this.scene && this._initShadow());
            }
        }]),
        _createClass(DirectionLight, [{
            key: "_initShadow",
            value: function() {
                if (this._shadow)
                    this._parallelSplitShadowMap = new an(),
                    this.scene.parallelSplitShadowMaps.push(this._parallelSplitShadowMap),
                    this.transform.worldMatrix.getForward(this._direction),
                    o.normalize(this._direction, this._direction),
                    this._parallelSplitShadowMap.setInfo(this.scene, this._shadowFarPlane, this._direction, this._shadowMapSize, this._shadowMapCount, this._shadowMapPCFType);
                else {
                    var e = this._scene._shaderValues
                      , t = this.scene.parallelSplitShadowMaps;
                    t.splice(t.indexOf(this._parallelSplitShadowMap), 1),
                    this._parallelSplitShadowMap.disposeAllRenderTarget(),
                    this._parallelSplitShadowMap = null,
                    e.removeDefine(Je.SHADERDEFINE_SHADOW_PSSM1),
                    e.removeDefine(Je.SHADERDEFINE_SHADOW_PSSM2),
                    e.removeDefine(Je.SHADERDEFINE_SHADOW_PSSM3);
                }
            }
        }, {
            key: "_addToLightQueue",
            value: function() {
                this._scene._directionLights.add(this);
            }
        }, {
            key: "_removeFromLightQueue",
            value: function() {
                this._scene._directionLights.remove(this);
            }
        }]),
        DirectionLight;
    }()
      , ln = function(e) {
        function PointLight() {
            var e;
            return _classCallCheck(this, PointLight),
            (e = _possibleConstructorReturn(this, _getPrototypeOf(PointLight).call(this)))._range = 6,
            e;
        }
        return _inherits(PointLight, on),
        _createClass(PointLight, [{
            key: "range",
            get: function() {
                return this._range;
            },
            set: function(e) {
                this._range = e;
            }
        }]),
        _createClass(PointLight, [{
            key: "_addToLightQueue",
            value: function() {
                this._scene._pointLights.add(this);
            }
        }, {
            key: "_removeFromLightQueue",
            value: function() {
                this._scene._pointLights.remove(this);
            }
        }, {
            key: "_parse",
            value: function(e, t) {
                _get(_getPrototypeOf(PointLight.prototype), "_parse", this).call(this, e, t),
                this.range = e.range;
            }
        }]),
        PointLight;
    }()
      , un = function(e) {
        function SpotLight() {
            var e;
            return _classCallCheck(this, SpotLight),
            (e = _possibleConstructorReturn(this, _getPrototypeOf(SpotLight).call(this)))._spotAngle = 30,
            e._range = 10,
            e._direction = new o(),
            e;
        }
        return _inherits(SpotLight, on),
        _createClass(SpotLight, [{
            key: "spotAngle",
            get: function() {
                return this._spotAngle;
            },
            set: function(e) {
                this._spotAngle = Math.max(Math.min(e, 179), 0);
            }
        }, {
            key: "range",
            get: function() {
                return this._range;
            },
            set: function(e) {
                this._range = e;
            }
        }]),
        _createClass(SpotLight, [{
            key: "_addToLightQueue",
            value: function() {
                this._scene._spotLights.add(this);
            }
        }, {
            key: "_removeFromLightQueue",
            value: function() {
                this._scene._spotLights.remove(this);
            }
        }, {
            key: "_parse",
            value: function(e, t) {
                _get(_getPrototypeOf(SpotLight.prototype), "_parse", this).call(this, e, t),
                this.range = e.range,
                this.spotAngle = e.spotAngle;
            }
        }]),
        SpotLight;
    }()
      , cn = function() {
        function Scene3DUtils() {
            _classCallCheck(this, Scene3DUtils);
        }
        return _createClass(Scene3DUtils, null, [{
            key: "_createSprite3DInstance",
            value: function(e, t, r) {
                var n;
                switch (e.type) {
                case "Scene3D":
                    n = new Nr();
                    break;
                case "Sprite3D":
                    n = new ye();
                    break;
                case "MeshSprite3D":
                    n = new dt(),
                    r && e.props.isStatic && r.push(n);
                    break;
                case "SkinnedMeshSprite3D":
                    n = new Vr();
                    break;
                case "ShuriKenParticle3D":
                    n = new Qt();
                    break;
                case "Camera":
                    n = new $e();
                    break;
                case "DirectionLight":
                    n = new sn();
                    break;
                case "PointLight":
                    n = new ln();
                    break;
                case "SpotLight":
                    n = new un();
                    break;
                case "TrailSprite3D":
                    n = new Wr();
                    break;
                default:
                    throw new Error("Utils3D:unidentified class type in (.lh) file.");
                }
                var i = e.child;
                if (i)
                    for (var a = 0, o = i.length; a < o; a++) {
                        var s = Scene3DUtils._createSprite3DInstance(i[a], t, r);
                        n.addChild(s);
                    }
                return t[e.instanceID] = n,
                n;
            }
        }, {
            key: "_createComponentInstance",
            value: function(e, r) {
                var n = r[e.instanceID];
                n._parse(e.props, r);
                var i = e.child;
                if (i)
                    for (var a = 0, o = i.length; a < o; a++)
                        Scene3DUtils._createComponentInstance(i[a], r);
                var s = e.components;
                if (s)
                    for (var l = 0, u = s.length; l < u; l++) {
                        var c = s[l]
                          , h = t.ClassUtils.getRegClass(c.type);
                        if (h)
                            n.addComponent(h)._parse(c);
                        else
                            console.warn("Unkown component type.");
                    }
            }
        }, {
            key: "_createNodeByJson02",
            value: function(e, t) {
                var r = {}
                  , n = Scene3DUtils._createSprite3DInstance(e, r, t);
                return Scene3DUtils._createComponentInstance(e, r),
                n;
            }
        }, {
            key: "_parse",
            value: function(e) {
                arguments.length > 1 && void 0 !== arguments[1] && arguments[1],
                arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
                var t, r = e.data, n = [];
                switch (e.version) {
                case "LAYAHIERARCHY:02":
                    t = Scene3DUtils._createNodeByJson02(r, n);
                    break;
                default:
                    t = Scene3DUtils._createNodeByJson(r, n);
                }
                return Se.combine(t, n),
                t;
            }
        }, {
            key: "_parseScene",
            value: function(e) {
                arguments.length > 1 && void 0 !== arguments[1] && arguments[1],
                arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
                var t, r = e.data, n = [];
                switch (e.version) {
                case "LAYASCENE3D:02":
                    t = Scene3DUtils._createNodeByJson02(r, n);
                    break;
                default:
                    t = Scene3DUtils._createNodeByJson(r, n);
                }
                return Se.combine(null, n),
                t;
            }
        }, {
            key: "_createNodeByJson",
            value: function(e, r) {
                var n;
                switch (e.type) {
                case "Scene3D":
                    n = new Nr();
                    break;
                case "Sprite3D":
                    n = new ye();
                    break;
                case "MeshSprite3D":
                    n = new dt(),
                    r && e.props.isStatic && r.push(n);
                    break;
                case "SkinnedMeshSprite3D":
                    n = new Vr();
                    break;
                case "ShuriKenParticle3D":
                    n = new Qt();
                    break;
                case "Camera":
                    n = new $e();
                    break;
                case "DirectionLight":
                    n = new sn();
                    break;
                case "PointLight":
                    n = new ln();
                    break;
                case "SpotLight":
                    n = new un();
                    break;
                case "TrailSprite3D":
                    n = new Wr();
                    break;
                default:
                    throw new Error("Utils3D:unidentified class type in (.lh) file.");
                }
                var i = e.child;
                if (i)
                    for (var a = 0, o = i.length; a < o; a++) {
                        var s = Scene3DUtils._createNodeByJson(i[a], r);
                        n.addChild(s);
                    }
                var l = e.components;
                if (l)
                    for (var u = 0, c = l.length; u < c; u++) {
                        var h = l[u]
                          , _ = t.ClassUtils.getRegClass(h.type);
                        if (_)
                            n.addComponent(_)._parse(h);
                        else
                            console.warn("Unkown component type.");
                    }
                return n._parse(e.props, null),
                n;
            }
        }]),
        Scene3DUtils;
    }()
      , hn = function() {
        function LoadModelV04() {
            _classCallCheck(this, LoadModelV04);
        }
        return _createClass(LoadModelV04, null, [{
            key: "parse",
            value: function(e, t, r, n) {
                LoadModelV04._mesh = r,
                LoadModelV04._subMeshes = n,
                LoadModelV04._version = t,
                LoadModelV04._readData = e,
                LoadModelV04.READ_DATA(),
                LoadModelV04.READ_BLOCK(),
                LoadModelV04.READ_STRINGS();
                for (var i = 0, a = LoadModelV04._BLOCK.count; i < a; i++) {
                    LoadModelV04._readData.pos = LoadModelV04._BLOCK.blockStarts[i];
                    var o = LoadModelV04._readData.getUint16()
                      , s = LoadModelV04._strings[o]
                      , l = LoadModelV04["READ_" + s];
                    if (null == l)
                        throw new Error("model file err,no this function:" + o + " " + s);
                    l.call(null);
                }
                LoadModelV04._strings.length = 0,
                LoadModelV04._readData = null,
                LoadModelV04._version = null,
                LoadModelV04._mesh = null,
                LoadModelV04._subMeshes = null;
            }
        }, {
            key: "_readString",
            value: function() {
                return LoadModelV04._strings[LoadModelV04._readData.getUint16()];
            }
        }, {
            key: "READ_DATA",
            value: function() {
                LoadModelV04._DATA.offset = LoadModelV04._readData.getUint32(),
                LoadModelV04._DATA.size = LoadModelV04._readData.getUint32();
            }
        }, {
            key: "READ_BLOCK",
            value: function() {
                for (var e = LoadModelV04._BLOCK.count = LoadModelV04._readData.getUint16(), t = LoadModelV04._BLOCK.blockStarts = [], r = LoadModelV04._BLOCK.blockLengths = [], n = 0; n < e; n++)
                    t.push(LoadModelV04._readData.getUint32()),
                    r.push(LoadModelV04._readData.getUint32());
            }
        }, {
            key: "READ_STRINGS",
            value: function() {
                var e = LoadModelV04._readData.getUint32()
                  , t = LoadModelV04._readData.getUint16()
                  , r = LoadModelV04._readData.pos;
                LoadModelV04._readData.pos = e + LoadModelV04._DATA.offset;
                for (var n = 0; n < t; n++)
                    LoadModelV04._strings[n] = LoadModelV04._readData.readUTFString();
                LoadModelV04._readData.pos = r;
            }
        }, {
            key: "READ_MESH",
            value: function() {
                var r, n = t.LayaGL.instance, i = (LoadModelV04._readString(),
                LoadModelV04._readData.__getBuffer()), a = 0, o = LoadModelV04._readData.getInt16(), s = LoadModelV04._DATA.offset;
                for (r = 0; r < o; r++) {
                    var l, u = s + LoadModelV04._readData.getUint32(), c = LoadModelV04._readData.getUint32(), h = i.slice(u, u + c), _ = new Float32Array(h), d = LoadModelV04._readString();
                    switch (LoadModelV04._version) {
                    case "LAYAMODEL:0301":
                    case "LAYAMODEL:0400":
                        l = ue.getVertexDeclaration(d);
                        break;
                    case "LAYAMODEL:0401":
                        l = ue.getVertexDeclaration(d, !1);
                        break;
                    default:
                        throw new Error("LoadModelV03: unknown version.");
                    }
                    if (!l)
                        throw new Error("LoadModelV03: unknown vertexDeclaration.");
                    var f = new De(4 * _.length,n.STATIC_DRAW,!0);
                    f.vertexDeclaration = l,
                    f.setData(_.buffer),
                    LoadModelV04._mesh._vertexBuffer = f,
                    LoadModelV04._mesh._vertexCount += f._byteLength / l.vertexStride,
                    a += 4 * _.length;
                }
                var m = s + LoadModelV04._readData.getUint32()
                  , p = LoadModelV04._readData.getUint32()
                  , v = new Uint16Array(i.slice(m, m + p))
                  , T = new Fe(e.IndexFormat.UInt16,p / 2,n.STATIC_DRAW,!0);
                T.setData(v),
                LoadModelV04._mesh._indexBuffer = T,
                a += 2 * T.indexCount,
                LoadModelV04._mesh._setBuffer(LoadModelV04._mesh._vertexBuffer, T),
                LoadModelV04._mesh._setCPUMemory(a),
                LoadModelV04._mesh._setGPUMemory(a);
                var E = LoadModelV04._mesh._boneNames = []
                  , y = LoadModelV04._readData.getUint16();
                for (E.length = y,
                r = 0; r < y; r++)
                    E[r] = LoadModelV04._strings[LoadModelV04._readData.getUint16()];
                LoadModelV04._readData.pos += 8;
                var g = LoadModelV04._readData.getUint32()
                  , S = LoadModelV04._readData.getUint32()
                  , R = new Float32Array(i.slice(s + g, s + g + S))
                  , C = R.length
                  , M = LoadModelV04._mesh._inverseBindPosesBuffer = new ArrayBuffer(4 * C);
                for (LoadModelV04._mesh._inverseBindPoses = [],
                r = 0; r < C; r += 16) {
                    var D = new I(R[r + 0],R[r + 1],R[r + 2],R[r + 3],R[r + 4],R[r + 5],R[r + 6],R[r + 7],R[r + 8],R[r + 9],R[r + 10],R[r + 11],R[r + 12],R[r + 13],R[r + 14],R[r + 15],new Float32Array(M,4 * r,16));
                    LoadModelV04._mesh._inverseBindPoses[r / 16] = D;
                }
                return !0;
            }
        }, {
            key: "READ_SUBMESH",
            value: function() {
                var e = LoadModelV04._readData.__getBuffer()
                  , t = new Jr(LoadModelV04._mesh);
                LoadModelV04._readData.getInt16(),
                LoadModelV04._readData.getUint32(),
                LoadModelV04._readData.getUint32();
                var r = LoadModelV04._readData.getUint32()
                  , n = LoadModelV04._readData.getUint32()
                  , i = LoadModelV04._mesh._indexBuffer;
                t._indexBuffer = i,
                t._setIndexRange(r, n);
                var a = LoadModelV04._mesh._vertexBuffer;
                t._vertexBuffer = a;
                var o = LoadModelV04._DATA.offset
                  , s = t._subIndexBufferStart
                  , l = t._subIndexBufferCount
                  , u = t._boneIndicesList
                  , c = LoadModelV04._readData.getUint16();
                s.length = c,
                l.length = c,
                u.length = c;
                var h = LoadModelV04._mesh._skinnedMatrixCaches
                  , _ = LoadModelV04._subMeshes.length;
                h.length = LoadModelV04._mesh._inverseBindPoses.length;
                for (var d = 0; d < c; d++) {
                    s[d] = LoadModelV04._readData.getUint32(),
                    l[d] = LoadModelV04._readData.getUint32();
                    for (var f = LoadModelV04._readData.getUint32(), m = LoadModelV04._readData.getUint32(), p = u[d] = new Uint16Array(e.slice(o + f, o + f + m)), v = p.length, T = 0; T < v; T++) {
                        var E = p[T];
                        h[E] || (h[E] = new $r(_,d,T));
                    }
                }
                return LoadModelV04._subMeshes.push(t),
                !0;
            }
        }]),
        LoadModelV04;
    }();
    hn._BLOCK = {
        count: 0
    },
    hn._DATA = {
        offset: 0,
        size: 0
    },
    hn._strings = [];
    var _n = function() {
        function LoadModelV05() {
            _classCallCheck(this, LoadModelV05);
        }
        return _createClass(LoadModelV05, null, [{
            key: "parse",
            value: function(e, t, r, n) {
                LoadModelV05._mesh = r,
                LoadModelV05._subMeshes = n,
                LoadModelV05._version = t,
                LoadModelV05._readData = e,
                LoadModelV05.READ_DATA(),
                LoadModelV05.READ_BLOCK(),
                LoadModelV05.READ_STRINGS();
                for (var i = 0, a = LoadModelV05._BLOCK.count; i < a; i++) {
                    LoadModelV05._readData.pos = LoadModelV05._BLOCK.blockStarts[i];
                    var o = LoadModelV05._readData.getUint16()
                      , s = LoadModelV05._strings[o]
                      , l = LoadModelV05["READ_" + s];
                    if (null == l)
                        throw new Error("model file err,no this function:" + o + " " + s);
                    l.call(null);
                }
                LoadModelV05._strings.length = 0,
                LoadModelV05._readData = null,
                LoadModelV05._version = null,
                LoadModelV05._mesh = null,
                LoadModelV05._subMeshes = null;
            }
        }, {
            key: "_readString",
            value: function() {
                return LoadModelV05._strings[LoadModelV05._readData.getUint16()];
            }
        }, {
            key: "READ_DATA",
            value: function() {
                LoadModelV05._DATA.offset = LoadModelV05._readData.getUint32(),
                LoadModelV05._DATA.size = LoadModelV05._readData.getUint32();
            }
        }, {
            key: "READ_BLOCK",
            value: function() {
                for (var e = LoadModelV05._BLOCK.count = LoadModelV05._readData.getUint16(), t = LoadModelV05._BLOCK.blockStarts = [], r = LoadModelV05._BLOCK.blockLengths = [], n = 0; n < e; n++)
                    t.push(LoadModelV05._readData.getUint32()),
                    r.push(LoadModelV05._readData.getUint32());
            }
        }, {
            key: "READ_STRINGS",
            value: function() {
                var e = LoadModelV05._readData.getUint32()
                  , t = LoadModelV05._readData.getUint16()
                  , r = LoadModelV05._readData.pos;
                LoadModelV05._readData.pos = e + LoadModelV05._DATA.offset;
                for (var n = 0; n < t; n++)
                    LoadModelV05._strings[n] = LoadModelV05._readData.readUTFString();
                LoadModelV05._readData.pos = r;
            }
        }, {
            key: "READ_MESH",
            value: function() {
                var r, n = t.LayaGL.instance, i = 0, a = (LoadModelV05._readString(),
                LoadModelV05._readData), o = a.__getBuffer(), s = a.getInt16(), l = LoadModelV05._DATA.offset;
                for (r = 0; r < s; r++) {
                    var u, c, h, _ = l + a.getUint32(), d = a.getUint32(), f = LoadModelV05._readString(), m = ue.getVertexDeclaration(f, !1), p = m.vertexStride, v = f.split(","), E = v.length, y = LoadModelV05._mesh;
                    switch (LoadModelV05._version) {
                    case "LAYAMODEL:05":
                    case "LAYAMODEL:0501":
                        u = o.slice(_, _ + d * p),
                        c = new Float32Array(u),
                        h = new Uint8Array(u);
                        break;
                    case "LAYAMODEL:COMPRESSION_05":
                    case "LAYAMODEL:COMPRESSION_0501":
                        u = new ArrayBuffer(p * d),
                        c = new Float32Array(u),
                        h = new Uint8Array(u);
                        var g = a.pos;
                        a.pos = _;
                        for (var S = 0; S < d; S++)
                            for (var R, C = S * p, M = 0; M < E; M++)
                                switch (v[M]) {
                                case "POSITION":
                                    c[R = C / 4] = T.convertToNumber(a.getUint16()),
                                    c[R + 1] = T.convertToNumber(a.getUint16()),
                                    c[R + 2] = T.convertToNumber(a.getUint16()),
                                    C += 12;
                                    break;
                                case "NORMAL":
                                    c[R = C / 4] = a.getUint8() / 127.5 - 1,
                                    c[R + 1] = a.getUint8() / 127.5 - 1,
                                    c[R + 2] = a.getUint8() / 127.5 - 1,
                                    C += 12;
                                    break;
                                case "COLOR":
                                    c[R = C / 4] = a.getUint8() / 255,
                                    c[R + 1] = a.getUint8() / 255,
                                    c[R + 2] = a.getUint8() / 255,
                                    c[R + 3] = a.getUint8() / 255,
                                    C += 16;
                                    break;
                                case "UV":
                                case "UV1":
                                    c[R = C / 4] = T.convertToNumber(a.getUint16()),
                                    c[R + 1] = T.convertToNumber(a.getUint16()),
                                    C += 8;
                                    break;
                                case "BLENDWEIGHT":
                                    c[R = C / 4] = a.getUint8() / 255,
                                    c[R + 1] = a.getUint8() / 255,
                                    c[R + 2] = a.getUint8() / 255,
                                    c[R + 3] = a.getUint8() / 255,
                                    C += 16;
                                    break;
                                case "BLENDINDICES":
                                    h[C] = a.getUint8(),
                                    h[C + 1] = a.getUint8(),
                                    h[C + 2] = a.getUint8(),
                                    h[C + 3] = a.getUint8(),
                                    C += 4;
                                    break;
                                case "TANGENT":
                                    c[R = C / 4] = a.getUint8() / 127.5 - 1,
                                    c[R + 1] = a.getUint8() / 127.5 - 1,
                                    c[R + 2] = a.getUint8() / 127.5 - 1,
                                    c[R + 3] = a.getUint8() / 127.5 - 1,
                                    C += 16;
                                }
                        a.pos = g;
                    }
                    var D = new De(u.byteLength,n.STATIC_DRAW,!0);
                    D.vertexDeclaration = m,
                    D.setData(u);
                    d = D._byteLength / m.vertexStride;
                    y._indexFormat = d > 65535 ? e.IndexFormat.UInt32 : e.IndexFormat.UInt16,
                    y._vertexBuffer = D,
                    y._vertexCount += d,
                    i += 4 * c.length;
                }
                var x, A = l + a.getUint32(), L = a.getUint32();
                x = y.indexFormat == e.IndexFormat.UInt32 ? new Uint32Array(o.slice(A, A + L)) : new Uint16Array(o.slice(A, A + L));
                var P = new Fe(y.indexFormat,x.length,n.STATIC_DRAW,!0);
                if (P.setData(x),
                y._indexBuffer = P,
                y._setBuffer(y._vertexBuffer, P),
                i += 2 * P.indexCount,
                y._setCPUMemory(i),
                y._setGPUMemory(i),
                "LAYAMODEL:0501" == LoadModelV05._version || "LAYAMODEL:COMPRESSION_0501" == LoadModelV05._version) {
                    var O = y.bounds
                      , N = O.getMin()
                      , b = O.getMax();
                    N.setValue(a.getFloat32(), a.getFloat32(), a.getFloat32()),
                    b.setValue(a.getFloat32(), a.getFloat32(), a.getFloat32()),
                    O.setMin(N),
                    O.setMax(b),
                    y.bounds = O;
                }
                var k = y._boneNames = []
                  , V = a.getUint16();
                for (k.length = V,
                r = 0; r < V; r++)
                    k[r] = LoadModelV05._strings[a.getUint16()];
                var B = a.getUint32()
                  , w = a.getUint32()
                  , F = new Float32Array(o.slice(l + B, l + B + w))
                  , U = F.length
                  , G = y._inverseBindPosesBuffer = new ArrayBuffer(4 * U);
                for (y._inverseBindPoses = [],
                r = 0; r < U; r += 16) {
                    var z = new I(F[r + 0],F[r + 1],F[r + 2],F[r + 3],F[r + 4],F[r + 5],F[r + 6],F[r + 7],F[r + 8],F[r + 9],F[r + 10],F[r + 11],F[r + 12],F[r + 13],F[r + 14],F[r + 15],new Float32Array(G,4 * r,16));
                    y._inverseBindPoses[r / 16] = z;
                }
                return !0;
            }
        }, {
            key: "READ_SUBMESH",
            value: function() {
                var e = LoadModelV05._readData
                  , t = e.__getBuffer()
                  , r = new Jr(LoadModelV05._mesh);
                e.getInt16();
                var n = e.getUint32()
                  , i = e.getUint32()
                  , a = LoadModelV05._mesh._indexBuffer;
                r._indexBuffer = a,
                r._setIndexRange(n, i);
                var o = LoadModelV05._mesh._vertexBuffer;
                r._vertexBuffer = o;
                var s = LoadModelV05._DATA.offset
                  , l = r._subIndexBufferStart
                  , u = r._subIndexBufferCount
                  , c = r._boneIndicesList
                  , h = e.getUint16();
                l.length = h,
                u.length = h,
                c.length = h;
                var _ = LoadModelV05._mesh._skinnedMatrixCaches
                  , d = LoadModelV05._subMeshes.length;
                _.length = LoadModelV05._mesh._inverseBindPoses.length;
                for (var f = 0; f < h; f++) {
                    l[f] = e.getUint32(),
                    u[f] = e.getUint32();
                    for (var m = e.getUint32(), p = e.getUint32(), v = c[f] = new Uint16Array(t.slice(s + m, s + m + p)), T = 0, E = v.length; T < E; T++) {
                        var y = v[T];
                        _[y] || (_[y] = new $r(d,f,T));
                    }
                }
                return LoadModelV05._subMeshes.push(r),
                !0;
            }
        }]),
        LoadModelV05;
    }();
    _n._BLOCK = {
        count: 0
    },
    _n._DATA = {
        offset: 0,
        size: 0
    },
    _n._strings = [];
    var dn = function() {
        function MeshReader() {
            _classCallCheck(this, MeshReader);
        }
        return _createClass(MeshReader, null, [{
            key: "_parse",
            value: function(e) {
                arguments.length > 1 && void 0 !== arguments[1] && arguments[1],
                arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
                var t = new en();
                return MeshReader.read(e, t, t._subMeshes),
                t;
            }
        }, {
            key: "read",
            value: function(e, r, n) {
                var i = new t.Byte(e);
                i.pos = 0;
                var a = i.readUTFString();
                switch (a) {
                case "LAYAMODEL:0301":
                case "LAYAMODEL:0400":
                case "LAYAMODEL:0401":
                    hn.parse(i, a, r, n);
                    break;
                case "LAYAMODEL:05":
                case "LAYAMODEL:COMPRESSION_05":
                case "LAYAMODEL:0501":
                case "LAYAMODEL:COMPRESSION_0501":
                    _n.parse(i, a, r, n);
                    break;
                default:
                    throw new Error("MeshReader: unknown mesh version.");
                }
                r._setSubMeshes(n),
                "LAYAMODEL:0501" != a && "LAYAMODEL:COMPRESSION_0501" != a && r.calculateBounds();
            }
        }]),
        MeshReader;
    }()
      , fn = function(e) {
        function SkyPanoramicMaterial() {
            var e;
            _classCallCheck(this, SkyPanoramicMaterial),
            (e = _possibleConstructorReturn(this, _getPrototypeOf(SkyPanoramicMaterial).call(this)))._exposure = 1,
            e._textureDecodeFormat = t.TextureDecodeFormat.Normal,
            e._textureHDRParams = new i(1,0,0,1),
            e.setShaderName("SkyPanoramic");
            var r = e._shaderValues;
            return r.setVector(SkyPanoramicMaterial.TINTCOLOR, new i(.5,.5,.5,.5)),
            r.setNumber(SkyPanoramicMaterial.ROTATION, 0),
            r.setVector(SkyPanoramicMaterial.TEXTURE_HDR_PARAMS, e._textureHDRParams),
            e;
        }
        return _inherits(SkyPanoramicMaterial, Z),
        _createClass(SkyPanoramicMaterial, [{
            key: "tintColor",
            get: function() {
                return this._shaderValues.getVector(SkyPanoramicMaterial.TINTCOLOR);
            },
            set: function(e) {
                this._shaderValues.setVector(SkyPanoramicMaterial.TINTCOLOR, e);
            }
        }, {
            key: "exposure",
            get: function() {
                return this._exposure;
            },
            set: function(e) {
                this._exposure !== e && (this._exposure = e,
                this._textureDecodeFormat == t.TextureDecodeFormat.RGBM ? this._textureHDRParams.x = e * t.BaseTexture._rgbmRange : this._textureHDRParams.x = e);
            }
        }, {
            key: "rotation",
            get: function() {
                return this._shaderValues.getNumber(SkyPanoramicMaterial.ROTATION);
            },
            set: function(e) {
                this._shaderValues.setNumber(SkyPanoramicMaterial.ROTATION, e);
            }
        }, {
            key: "panoramicTexture",
            get: function() {
                return this._shaderValues.getTexture(SkyPanoramicMaterial.TEXTURE);
            },
            set: function(e) {
                this._shaderValues.setTexture(SkyPanoramicMaterial.TEXTURE, e);
            }
        }, {
            key: "panoramicTextureDecodeFormat",
            get: function() {
                return this._textureDecodeFormat;
            },
            set: function(e) {
                this._textureDecodeFormat !== e && (this._textureDecodeFormat = e,
                e == t.TextureDecodeFormat.RGBM ? this._textureHDRParams.x = this._exposure * t.BaseTexture._rgbmRange : this._textureHDRParams.x = this._exposure);
            }
        }], [{
            key: "__init__",
            value: function() {
                var e = {
                    a_Position: ue.MESH_POSITION0
                }
                  , t = {
                    u_TintColor: G.PERIOD_MATERIAL,
                    u_TextureHDRParams: G.PERIOD_MATERIAL,
                    u_Rotation: G.PERIOD_MATERIAL,
                    u_Texture: G.PERIOD_MATERIAL,
                    u_ViewProjection: G.PERIOD_CAMERA
                }
                  , r = G.add("SkyPanoramic")
                  , n = new ie(e,t);
                r.addSubShader(n),
                n.addShaderPass('#include "Lighting.glsl";\r\n\r\n#define PI 3.14159265359\r\n\r\nattribute vec4 a_Position;\r\n\r\nuniform mat4 u_ViewProjection;\r\nuniform float u_Rotation;\r\n\r\nvarying vec3 v_Texcoord;\r\nvarying vec2 v_Image180ScaleAndCutoff;\r\nvarying vec4 v_Layout3DScaleAndOffset;\r\n\r\nvec4 rotateAroundYInDegrees (vec4 vertex, float degrees)\r\n{\r\n\tfloat angle = degrees * PI / 180.0;\r\n\tfloat sina=sin(angle);\r\n\tfloat cosa=cos(angle);\r\n\tmat2 m = mat2(cosa, -sina, sina, cosa);\r\n\treturn vec4(m*vertex.xz, vertex.yw).xzyw;\r\n}\r\n\r\n\t\t\r\nvoid main()\r\n{\r\n\tvec4 position = rotateAroundYInDegrees(a_Position, u_Rotation);\r\n\tgl_Position = u_ViewProjection*position;\r\n\r\n\tv_Texcoord=vec3(-a_Position.x,-a_Position.y,a_Position.z);// NOTE: -a_Position.x convert coords system\r\n\r\n\t// Calculate constant horizontal scale and cutoff for 180 (vs 360) image type\r\n\tv_Image180ScaleAndCutoff = vec2(1.0, 1.0);// 360 degree mode\r\n\r\n\t// Calculate constant scale and offset for 3D layouts\r\n\tv_Layout3DScaleAndOffset = vec4(0,0,1,1);\r\n}\r\n', '#ifdef GL_FRAGMENT_PRECISION_HIGH\r\n\tprecision highp float;\r\n#else\r\n\tprecision mediump float;\r\n#endif\r\n\r\n#define PI 3.14159265359\r\n#include "Lighting.glsl";\r\n\r\nuniform sampler2D u_Texture;\r\nuniform vec4 u_TextureHDRParams;\r\nuniform vec4 u_TintColor;\r\n\r\nvarying vec3 v_Texcoord;\r\nvarying vec2 v_Image180ScaleAndCutoff;\r\nvarying vec4 v_Layout3DScaleAndOffset;\r\n\r\nvec2 ToRadialCoords(vec3 coords)\r\n{\r\n\tvec3 normalizedCoords = normalize(coords);\r\n\tfloat latitude = acos(normalizedCoords.y);\r\n\tfloat longitude = atan(normalizedCoords.z,normalizedCoords.x);\r\n\tvec2 sphereCoords = vec2(longitude, latitude) * vec2(0.5/PI, 1.0/PI);\r\n\treturn vec2(0.5,1.0) - sphereCoords;\r\n}\r\n\r\n\r\nvoid main()\r\n{\t\r\n\tvec2 tc = ToRadialCoords(v_Texcoord);\r\n\tif (tc.x > v_Image180ScaleAndCutoff.y)\r\n\t\tgl_FragColor=vec4(0,0,0,1);\r\n\ttc.x = mod(tc.x*v_Image180ScaleAndCutoff.x, 1.0);\r\n\ttc = (tc + v_Layout3DScaleAndOffset.xy) * v_Layout3DScaleAndOffset.zw;\r\n\r\n\tmediump vec4 tex = texture2D (u_Texture, tc);\r\n\tmediump vec3 c = decodeHDR (tex, u_TextureHDRParams.x);\r\n\tc = c * u_TintColor.rgb * 2.0;//Gamma Space is 2.0,linear space is 4.59479380\r\n\tgl_FragColor=vec4(c, 1.0);\r\n}\r\n\r\n');
            }
        }]),
        SkyPanoramicMaterial;
    }();
    fn.TINTCOLOR = G.propertyNameToID("u_TintColor"),
    fn.EXPOSURE = G.propertyNameToID("u_Exposure"),
    fn.ROTATION = G.propertyNameToID("u_Rotation"),
    fn.TEXTURE = G.propertyNameToID("u_Texture"),
    fn.TEXTURE_HDR_PARAMS = G.propertyNameToID("u_TextureHDRParams");
    var mn = function() {
        function Laya3D() {
            _classCallCheck(this, Laya3D);
        }
        return _createClass(Laya3D, null, [{
            key: "_cancelLoadByUrl",
            value: function(e) {
                t.Laya.loader.cancelLoadByUrl(e),
                Laya3D._innerFirstLevelLoaderManager.cancelLoadByUrl(e),
                Laya3D._innerSecondLevelLoaderManager.cancelLoadByUrl(e),
                Laya3D._innerThirdLevelLoaderManager.cancelLoadByUrl(e),
                Laya3D._innerFourthLevelLoaderManager.cancelLoadByUrl(e);
            }
        }, {
            key: "_changeWebGLSize",
            value: function(e, r) {
                t.WebGL.onStageResize(e, r),
                k.clientWidth = e,
                k.clientHeight = r;
            }
        }, {
            key: "__init__",
            value: function(e, r, n) {
                if (t.Config.isAntialias = n.isAntialias,
                t.Config.isAlpha = n.isAlpha,
                t.Config.premultipliedAlpha = n.premultipliedAlpha,
                t.Config.isStencil = n.isStencil,
                t.WebGL.enable()) {
                    t.RunDriver.changeWebGLSize = Laya3D._changeWebGLSize,
                    t.Render.is3DMode = !0,
                    t.Laya.init(e, r),
                    t.Render.supportWebGLPlusRendering || (t.LayaGL.instance = t.WebGLContext.mainContext,
                    t.LayaGL.instance.createCommandEncoder = function() {
                        var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 128
                          , r = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 64
                          , n = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
                        return new t.CommandEncoder(this,e,r,n);
                    }
                    ),
                    n._multiLighting = n.enableMultiLight && t.SystemUtils.supportTextureFormat(t.TextureFormat.R32G32B32A32),
                    l.Shader3D = G,
                    l.Scene3D = Nr,
                    l.MeshRenderStaticBatchManager = it,
                    l.MeshRenderDynamicBatchManager = _t,
                    l.SubMeshDynamicBatch = ht,
                    l.Laya3D = Laya3D,
                    l.Matrix4x4 = I,
                    Laya3D.enableNative3D(),
                    ae.__init__(),
                    ue.__init__(),
                    zt.__init__(),
                    Ht.__init__(),
                    Er.__init__(),
                    Ur.__init__(),
                    Xr.__init__(),
                    Kt.__init__(),
                    xe.__init__(),
                    ht.__init__(),
                    S._bullet = window.Physics3D,
                    S._bullet && (Kr.__init__(),
                    sr.__init__(),
                    cr.__init__(),
                    mr.__init__(),
                    pr.__init__(),
                    lr.__init__(),
                    _r.__init__(),
                    Zr.__init__(),
                    qr.__init__()),
                    nn.__init__(),
                    ee.__init__(),
                    _e.__init__(),
                    ce.__init__(),
                    fn.__init__(),
                    en.__init__(),
                    tn.__init__(),
                    ye.__init__(),
                    ge.__init__(),
                    dt.__init__(),
                    Vr.__init__(),
                    Qt.__init__(),
                    Wr.__init__(),
                    H.__init__(),
                    Nr.__init__(),
                    it.__init__(),
                    Z.__initDefine__(),
                    j.__initDefine__(),
                    q.__initDefine__(),
                    fe.__initDefine__(),
                    me.__initDefine__(),
                    Br.__initDefine__(),
                    K.__initDefine__(),
                    pe.__initDefine__(),
                    wt.__initDefine__(),
                    $.__initDefine__(),
                    qt.__initDefine__(),
                    de.__initDefine__(),
                    Ye.__init__(),
                    t.ClassUtils.regClass("Laya.SkyPanoramicMaterial", fn),
                    t.ClassUtils.regClass("Laya.EffectMaterial", K),
                    t.ClassUtils.regClass("Laya.UnlitMaterial", me),
                    t.ClassUtils.regClass("Laya.BlinnPhongMaterial", q),
                    t.ClassUtils.regClass("Laya.SkyProceduralMaterial", fe),
                    t.ClassUtils.regClass("Laya.PBRStandardMaterial", _e),
                    t.ClassUtils.regClass("Laya.PBRSpecularMaterial", ce),
                    t.ClassUtils.regClass("Laya.SkyBoxMaterial", de),
                    t.ClassUtils.regClass("Laya.WaterPrimaryMaterial", pe),
                    t.ClassUtils.regClass("Laya.ExtendTerrainMaterial", $),
                    t.ClassUtils.regClass("Laya.ShurikenParticleMaterial", wt),
                    t.ClassUtils.regClass("Laya.TrailMaterial", Br),
                    t.ClassUtils.regClass("Laya.PhysicsCollider", Qr),
                    t.ClassUtils.regClass("Laya.Rigidbody3D", qr),
                    t.ClassUtils.regClass("Laya.CharacterController", Zr),
                    t.ClassUtils.regClass("Laya.Animator", N),
                    t.ClassUtils.regClass("PhysicsCollider", Qr),
                    t.ClassUtils.regClass("CharacterController", Zr),
                    t.ClassUtils.regClass("Animator", N),
                    t.ClassUtils.regClass("Rigidbody3D", qr),
                    qt.defaultMaterial = new qt(),
                    q.defaultMaterial = new q(),
                    K.defaultMaterial = new K(),
                    me.defaultMaterial = new me(),
                    wt.defaultMaterial = new wt(),
                    Br.defaultMaterial = new Br(),
                    fe.defaultMaterial = new fe(),
                    de.defaultMaterial = new de(),
                    pe.defaultMaterial = new pe(),
                    qt.defaultMaterial.lock = !0,
                    q.defaultMaterial.lock = !0,
                    K.defaultMaterial.lock = !0,
                    me.defaultMaterial.lock = !0,
                    wt.defaultMaterial.lock = !0,
                    Br.defaultMaterial.lock = !0,
                    fe.defaultMaterial.lock = !0,
                    de.defaultMaterial.lock = !0,
                    pe.defaultMaterial.lock = !0,
                    t.Texture2D.__init__(),
                    gr.__init__(),
                    Ge.__init__(),
                    yr.__init__(),
                    We.__init__(),
                    Xe.__init__(),
                    Re.__init__(),
                    T.__init__();
                    var i = t.LoaderManager.createMap;
                    i.lh = [Laya3D.HIERARCHY, cn._parse],
                    i.ls = [Laya3D.HIERARCHY, cn._parseScene],
                    i.lm = [Laya3D.MESH, dn._parse],
                    i.lmat = [Laya3D.MATERIAL, Z._parse],
                    i.jpg = [Laya3D.TEXTURE2D, t.Texture2D._parse],
                    i.jpeg = [Laya3D.TEXTURE2D, t.Texture2D._parse],
                    i.bmp = [Laya3D.TEXTURE2D, t.Texture2D._parse],
                    i.gif = [Laya3D.TEXTURE2D, t.Texture2D._parse],
                    i.png = [Laya3D.TEXTURE2D, t.Texture2D._parse],
                    i.dds = [Laya3D.TEXTURE2D, t.Texture2D._parse],
                    i.ktx = [Laya3D.TEXTURE2D, t.Texture2D._parse],
                    i.pvr = [Laya3D.TEXTURE2D, t.Texture2D._parse],
                    i.lani = [Laya3D.ANIMATIONCLIP, C._parse],
                    i.lav = [Laya3D.AVATAR, Y._parse],
                    i.ltc = [Laya3D.TEXTURECUBE, gr._parse],
                    i.ltcb = [Laya3D.TEXTURECUBEBIN, gr._parseBin];
                    var a = t.Loader.parserMap;
                    a[Laya3D.HIERARCHY] = Laya3D._loadHierarchy,
                    a[Laya3D.MESH] = Laya3D._loadMesh,
                    a[Laya3D.MATERIAL] = Laya3D._loadMaterial,
                    a[Laya3D.TEXTURECUBE] = Laya3D._loadTextureCube,
                    a[Laya3D.TEXTURECUBEBIN] = Laya3D._loadTextureCubeBin,
                    a[Laya3D.TEXTURE2D] = Laya3D._loadTexture2D,
                    a[Laya3D.ANIMATIONCLIP] = Laya3D._loadAnimationClip,
                    a[Laya3D.AVATAR] = Laya3D._loadAvatar,
                    Laya3D._innerFirstLevelLoaderManager.on(t.Event.ERROR, null, Laya3D._eventLoadManagerError),
                    Laya3D._innerSecondLevelLoaderManager.on(t.Event.ERROR, null, Laya3D._eventLoadManagerError),
                    Laya3D._innerThirdLevelLoaderManager.on(t.Event.ERROR, null, Laya3D._eventLoadManagerError),
                    Laya3D._innerFourthLevelLoaderManager.on(t.Event.ERROR, null, Laya3D._eventLoadManagerError);
                } else
                    alert("Laya3D init error,must support webGL!");
            }
        }, {
            key: "enableNative3D",
            value: function() {
                var e = z
                  , r = re
                  , n = kr
                  , i = Y
                  , a = Re;
                if (t.Render.supportWebGLPlusRendering && (e.prototype._initData = e.prototype._initDataForNative,
                e.prototype.setBool = e.prototype.setBoolForNative,
                e.prototype.getBool = e.prototype.getBoolForNative,
                e.prototype.setInt = e.prototype.setIntForNative,
                e.prototype.getInt = e.prototype.getIntForNative,
                e.prototype.setNumber = e.prototype.setNumberForNative,
                e.prototype.getNumber = e.prototype.getNumberForNative,
                e.prototype.setVector = e.prototype.setVectorForNative,
                e.prototype.getVector = e.prototype.getVectorForNative,
                e.prototype.setVector2 = e.prototype.setVector2ForNative,
                e.prototype.getVector2 = e.prototype.getVector2ForNative,
                e.prototype.setVector3 = e.prototype.setVector3ForNative,
                e.prototype.getVector3 = e.prototype.getVector3ForNative,
                e.prototype.setQuaternion = e.prototype.setQuaternionForNative,
                e.prototype.getQuaternion = e.prototype.getQuaternionForNative,
                e.prototype.setMatrix4x4 = e.prototype.setMatrix4x4ForNative,
                e.prototype.getMatrix4x4 = e.prototype.getMatrix4x4ForNative,
                e.prototype.setBuffer = e.prototype.setBufferForNative,
                e.prototype.getBuffer = e.prototype.getBufferForNative,
                e.prototype.setTexture = e.prototype.setTextureForNative,
                e.prototype.getTexture = e.prototype.getTextureForNative,
                e.prototype.setAttribute = e.prototype.setAttributeForNative,
                e.prototype.getAttribute = e.prototype.getAttributeForNative,
                e.prototype.cloneTo = e.prototype.cloneToForNative,
                e.prototype.getData = e.prototype.getDataForNative,
                r.prototype._uniformMatrix2fv = r.prototype._uniformMatrix2fvForNative,
                r.prototype._uniformMatrix3fv = r.prototype._uniformMatrix3fvForNative,
                r.prototype._uniformMatrix4fv = r.prototype._uniformMatrix4fvForNative,
                t.LayaGLRunner.uploadShaderUniforms = t.LayaGLRunner.uploadShaderUniformsForNative),
                t.Render.supportWebGLPlusCulling && (a.renderObjectCulling = Re.renderObjectCullingNative),
                t.Render.supportWebGLPlusAnimation) {
                    i.prototype._cloneDatasToAnimator = i.prototype._cloneDatasToAnimatorNative;
                    var o = C;
                    o.prototype._evaluateClipDatasRealTime = o.prototype._evaluateClipDatasRealTimeForNative,
                    n.prototype._computeSkinnedData = n.prototype._computeSkinnedDataForNative;
                }
            }
        }, {
            key: "formatRelativePath",
            value: function(e, t) {
                var r;
                if (r = e + t,
                "." === t.charAt(0)) {
                    for (var n = r.split("/"), i = 0, a = n.length; i < a; i++)
                        if (".." == n[i]) {
                            var o = i - 1;
                            o > 0 && ".." !== n[o] && (n.splice(o, 2),
                            i -= 2);
                        }
                    r = n.join("/");
                }
                return r;
            }
        }, {
            key: "_endLoad",
            value: function(e) {
                var r = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null
                  , n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null;
                if (n)
                    for (var i = 0, a = n.length; i < a; i++) {
                        var o = t.Loader.getRes(n[i]);
                        o && o._removeReference();
                    }
                e.endLoad(r);
            }
        }, {
            key: "_eventLoadManagerError",
            value: function(e) {
                t.Laya.loader.event(t.Event.ERROR, e);
            }
        }, {
            key: "_addHierarchyInnerUrls",
            value: function(e, t, r, n, i, a) {
                var o = arguments.length > 6 && void 0 !== arguments[6] ? arguments[6] : null
                  , s = arguments.length > 7 && void 0 !== arguments[7] ? arguments[7] : null
                  , l = Laya3D.formatRelativePath(n, i);
                return r && (l += r),
                e.push({
                    url: l,
                    type: a,
                    constructParams: o,
                    propertyParams: s
                }),
                t.push(l),
                l;
            }
        }, {
            key: "_getSprite3DHierarchyInnerUrls",
            value: function(e, t, r, n, i, a, o, s) {
                var l, u, c = e.props;
                switch (e.type) {
                case "Scene3D":
                    var h = c.lightmaps;
                    for (l = 0,
                    u = h.length; l < u; l++) {
                        var _ = h[l];
                        _.path = Laya3D._addHierarchyInnerUrls(i, a, o, s, _.path, Laya3D.TEXTURE2D, _.constructParams, _.propertyParams);
                    }
                    var d = c.reflectionTexture;
                    d && (c.reflection = Laya3D._addHierarchyInnerUrls(n, a, o, s, d, Laya3D.TEXTURECUBE));
                    var f = c.reflection;
                    if (f && (c.reflection = Laya3D._addHierarchyInnerUrls(i, a, o, s, f, Laya3D.TEXTURECUBEBIN)),
                    c.sky) {
                        var m = c.sky.material;
                        m && (m.path = Laya3D._addHierarchyInnerUrls(r, a, o, s, m.path, Laya3D.MATERIAL));
                    }
                    break;
                case "Camera":
                    var p = c.skyboxMaterial;
                    p && (p.path = Laya3D._addHierarchyInnerUrls(r, a, o, s, p.path, Laya3D.MATERIAL));
                    break;
                case "TrailSprite3D":
                case "MeshSprite3D":
                case "SkinnedMeshSprite3D":
                    var v = c.meshPath;
                    v && (c.meshPath = Laya3D._addHierarchyInnerUrls(t, a, o, s, v, Laya3D.MESH));
                    var T = c.materials;
                    if (T)
                        for (l = 0,
                        u = T.length; l < u; l++)
                            T[l].path = Laya3D._addHierarchyInnerUrls(r, a, o, s, T[l].path, Laya3D.MATERIAL);
                    break;
                case "ShuriKenParticle3D":
                    if (c.main) {
                        var E = c.renderer.resources
                          , y = E.mesh
                          , g = E.material;
                        y && (E.mesh = Laya3D._addHierarchyInnerUrls(t, a, o, s, y, Laya3D.MESH)),
                        g && (E.material = Laya3D._addHierarchyInnerUrls(r, a, o, s, g, Laya3D.MATERIAL));
                    } else {
                        var S = c.meshPath;
                        S && (c.meshPath = Laya3D._addHierarchyInnerUrls(t, a, o, s, S, Laya3D.MESH)),
                        c.material.path = Laya3D._addHierarchyInnerUrls(r, a, o, s, c.material.path, Laya3D.MATERIAL);
                    }
                    break;
                case "Terrain":
                    Laya3D._addHierarchyInnerUrls(i, a, o, s, c.dataPath, Laya3D.TERRAINRES);
                }
                var R = e.components;
                if (R)
                    for (var C = 0, M = R.length; C < M; C++) {
                        var D = R[C];
                        switch (D.type) {
                        case "Animator":
                            D.avatarPath;
                            var x = D.avatar;
                            x && (x.path = Laya3D._addHierarchyInnerUrls(i, a, o, s, x.path, Laya3D.AVATAR));
                            var A = D.clipPaths;
                            if (A)
                                for (l = 0,
                                u = A.length; l < u; l++)
                                    A[l] = Laya3D._addHierarchyInnerUrls(i, a, o, s, A[l], Laya3D.ANIMATIONCLIP);
                            else {
                                var I = D.layers;
                                for (l = 0; l < I.length; l++)
                                    for (var L = I[l].states, P = 0, O = L.length; P < O; P++) {
                                        var N = L[P].clipPath;
                                        N && (L[P].clipPath = Laya3D._addHierarchyInnerUrls(i, a, o, s, N, Laya3D.ANIMATIONCLIP));
                                    }
                            }
                            break;
                        case "PhysicsCollider":
                        case "Rigidbody3D":
                        case "CharacterController":
                            var b = D.shapes;
                            for (l = 0; l < b.length; l++) {
                                var k = b[l];
                                if ("MeshColliderShape" === k.type)
                                    (y = k.mesh) && (k.mesh = Laya3D._addHierarchyInnerUrls(t, a, o, s, y, Laya3D.MESH));
                            }
                        }
                    }
                var V = e.child;
                for (l = 0,
                u = V.length; l < u; l++)
                    Laya3D._getSprite3DHierarchyInnerUrls(V[l], t, r, n, i, a, o, s);
            }
        }, {
            key: "_loadHierarchy",
            value: function(e) {
                e.on(t.Event.LOADED, null, Laya3D._onHierarchylhLoaded, [e]),
                e.load(e.url, t.Loader.JSON, !1, null, !0);
            }
        }, {
            key: "_onHierarchylhLoaded",
            value: function(e, r) {
                var n = e.url
                  , i = R.getURLVerion(n)
                  , a = t.URL.getPath(n)
                  , o = []
                  , s = []
                  , l = []
                  , u = []
                  , c = [];
                Laya3D._getSprite3DHierarchyInnerUrls(r.data, o, s, l, u, c, i, a);
                var h = o.length + s.length + u.length
                  , _ = h + 1
                  , d = 1 / _;
                if (Laya3D._onProcessChange(e, 0, d, 1),
                u.length > 0) {
                    var f = h / _
                      , m = t.Handler.create(null, Laya3D._onProcessChange, [e, d, f], !1);
                    Laya3D._innerFourthLevelLoaderManager._create(u, !1, t.Handler.create(null, Laya3D._onHierarchyInnerForthLevResouLoaded, [e, m, r, c, o, s, l, d + f * u.length, f]), m, null, null, null, 1, !0);
                } else
                    Laya3D._onHierarchyInnerForthLevResouLoaded(e, null, r, c, o, s, l, d, f);
            }
        }, {
            key: "_onHierarchyInnerForthLevResouLoaded",
            value: function(e, r, n, i, a, o, s, l, u) {
                if (r && r.recover(),
                s.length > 0) {
                    var c = t.Handler.create(null, Laya3D._onProcessChange, [e, l, u], !1);
                    Laya3D._innerThirdLevelLoaderManager._create(s, !1, t.Handler.create(null, Laya3D._onHierarchyInnerThirdLevResouLoaded, [e, c, n, i, a, o, l + u * o.length, u]), r, null, null, null, 1, !0);
                } else
                    Laya3D._onHierarchyInnerThirdLevResouLoaded(e, null, n, i, a, o, l, u);
            }
        }, {
            key: "_onHierarchyInnerThirdLevResouLoaded",
            value: function(e, r, n, i, a, o, s, l) {
                if (r && r.recover(),
                o.length > 0) {
                    var u = t.Handler.create(null, Laya3D._onProcessChange, [e, s, l], !1);
                    Laya3D._innerSecondLevelLoaderManager._create(o, !1, t.Handler.create(null, Laya3D._onHierarchyInnerSecondLevResouLoaded, [e, u, n, i, a, s + l * o.length, l]), r, null, null, null, 1, !0);
                } else
                    Laya3D._onHierarchyInnerSecondLevResouLoaded(e, null, n, i, a, s, l);
            }
        }, {
            key: "_onHierarchyInnerSecondLevResouLoaded",
            value: function(e, r, n, i, a, o, s) {
                if (r && r.recover(),
                a.length > 0) {
                    var l = t.Handler.create(null, Laya3D._onProcessChange, [e, o, s], !1);
                    Laya3D._innerFirstLevelLoaderManager._create(a, !1, t.Handler.create(null, Laya3D._onHierarchyInnerFirstLevResouLoaded, [e, l, n, i]), r, null, null, null, 1, !0);
                } else
                    Laya3D._onHierarchyInnerFirstLevResouLoaded(e, null, n, i);
            }
        }, {
            key: "_onHierarchyInnerFirstLevResouLoaded",
            value: function(e, t, r, n) {
                t && t.recover(),
                e._cache = e._createCache;
                var i = "Scene3D" === r.data.type ? cn._parseScene(r, e._propertyParams, e._constructParams) : cn._parse(r, e._propertyParams, e._constructParams);
                Laya3D._endLoad(e, i, n);
            }
        }, {
            key: "_loadMesh",
            value: function(e) {
                e.on(t.Event.LOADED, null, Laya3D._onMeshLmLoaded, [e]),
                e.load(e.url, t.Loader.BUFFER, !1, null, !0);
            }
        }, {
            key: "_onMeshLmLoaded",
            value: function(e, t) {
                e._cache = e._createCache;
                var r = dn._parse(t, e._propertyParams, e._constructParams);
                Laya3D._endLoad(e, r);
            }
        }, {
            key: "_loadMaterial",
            value: function(e) {
                e.on(t.Event.LOADED, null, Laya3D._onMaterilLmatLoaded, [e]),
                e.load(e.url, t.Loader.JSON, !1, null, !0);
            }
        }, {
            key: "_onMaterilLmatLoaded",
            value: function(e, r) {
                var n, i = e.url, a = R.getURLVerion(i), o = t.URL.getPath(i), s = [], l = [];
                r.customProps;
                switch (r.version) {
                case "LAYAMATERIAL:01":
                case "LAYAMATERIAL:02":
                    var u, c, h = r.props.textures;
                    if (h)
                        for (u = 0,
                        c = h.length; u < c; u++) {
                            var _ = h[u]
                              , d = _.path;
                            d && (n = Laya3D.formatRelativePath(o, d),
                            a && (n += a),
                            s.push({
                                url: n,
                                constructParams: _.constructParams,
                                propertyParams: _.propertyParams
                            }),
                            l.push(n),
                            _.path = n);
                        }
                    break;
                default:
                    throw new Error("Laya3D:unkonwn version.");
                }
                var f = s.length
                  , m = f + 1
                  , p = 1 / m;
                if (Laya3D._onProcessChange(e, 0, p, 1),
                f > 0) {
                    var v = t.Handler.create(null, Laya3D._onProcessChange, [e, p, f / m], !1);
                    Laya3D._innerFourthLevelLoaderManager._create(s, !1, t.Handler.create(null, Laya3D._onMateialTexturesLoaded, [e, v, r, l]), v, null, null, null, 1, !0);
                } else
                    Laya3D._onMateialTexturesLoaded(e, null, r, null);
            }
        }, {
            key: "_onMateialTexturesLoaded",
            value: function(e, t, r, n) {
                e._cache = e._createCache;
                var i = Z._parse(r, e._propertyParams, e._constructParams);
                Laya3D._endLoad(e, i, n),
                t && t.recover();
            }
        }, {
            key: "_loadAvatar",
            value: function(e) {
                e.on(t.Event.LOADED, null, function(t) {
                    e._cache = e._createCache;
                    var r = Y._parse(t, e._propertyParams, e._constructParams);
                    Laya3D._endLoad(e, r);
                }),
                e.load(e.url, t.Loader.JSON, !1, null, !0);
            }
        }, {
            key: "_loadAnimationClip",
            value: function(e) {
                e.on(t.Event.LOADED, null, function(t) {
                    e._cache = e._createCache;
                    var r = C._parse(t, e._propertyParams, e._constructParams);
                    Laya3D._endLoad(e, r);
                }),
                e.load(e.url, t.Loader.BUFFER, !1, null, !0);
            }
        }, {
            key: "_loadTexture2D",
            value: function(e) {
                var r, n = e.url, i = n.lastIndexOf(".") + 1, a = n.indexOf("?"), o = -1 == a ? n.length : a;
                switch (n.substr(i, o - i)) {
                case "jpg":
                case "jpeg":
                case "bmp":
                case "gif":
                case "png":
                    r = "nativeimage";
                    break;
                case "dds":
                case "ktx":
                case "pvr":
                    r = t.Loader.BUFFER;
                }
                e.on(t.Event.LOADED, null, function(r) {
                    e._cache = e._createCache;
                    var n = t.Texture2D._parse(r, e._propertyParams, e._constructParams);
                    Laya3D._endLoad(e, n);
                }),
                e.load(e.url, r, !1, null, !0);
            }
        }, {
            key: "_loadTextureCube",
            value: function(e) {
                e.on(t.Event.LOADED, null, Laya3D._onTextureCubeLtcLoaded, [e]),
                e.load(e.url, t.Loader.JSON, !1, null, !0);
            }
        }, {
            key: "_loadTextureCubeBin",
            value: function(e) {
                e.on(t.Event.LOADED, null, function(r) {
                    e._cache = e._createCache;
                    var n = new t.Byte(r);
                    if ("LAYATEXTURECUBE:0000" !== n.readUTFString())
                        throw "Laya3D:unknow version.";
                    var i = n.readUint8()
                      , a = n.getUint8()
                      , o = n.readUint16()
                      , s = n.getUint8()
                      , l = n.getUint8()
                      , u = n.getUint8()
                      , c = n.getUint8()
                      , h = new gr(o,i,a > 1);
                    h.filterMode = s,
                    h.wrapModeU = l,
                    h.wrapModeV = u,
                    h.anisoLevel = c;
                    for (var _ = n.pos, d = o, f = 0; f < a; f++) {
                        for (var m = new Array(6), p = d * d * h._getFormatByteCount(), v = 0; v < 6; v++)
                            m[v] = new Uint8Array(r,_,p),
                            _ += p;
                        h.setSixSidePixels(m, f),
                        d /= 2;
                    }
                    Laya3D._endLoad(e, h);
                }),
                e.load(e.url, t.Loader.BUFFER, !1, null, !0);
            }
        }, {
            key: "_onTextureCubeLtcLoaded",
            value: function(e, r) {
                var n = t.URL.getPath(e.url)
                  , i = [Laya3D.formatRelativePath(n, r.front), Laya3D.formatRelativePath(n, r.back), Laya3D.formatRelativePath(n, r.left), Laya3D.formatRelativePath(n, r.right), Laya3D.formatRelativePath(n, r.up), Laya3D.formatRelativePath(n, r.down)];
                Laya3D._onProcessChange(e, 0, 1 / 7, 1);
                var a = t.Handler.create(null, Laya3D._onProcessChange, [e, 1 / 7, 6 / 7], !1);
                Laya3D._innerFourthLevelLoaderManager.load(i, t.Handler.create(null, Laya3D._onTextureCubeImagesLoaded, [e, i, a]), a, "nativeimage");
            }
        }, {
            key: "_onTextureCubeImagesLoaded",
            value: function(e, r, n) {
                for (var i = new Array(6), a = 0; a < 6; a++)
                    i[a] = t.Loader.getRes(r[a]);
                e._cache = e._createCache;
                var o = gr._parse(i, e._propertyParams, e._constructParams);
                for (n.recover(),
                a = 0; a < 6; a++)
                    t.Loader.clearRes(r[a]);
                Laya3D._endLoad(e, o);
            }
        }, {
            key: "_onProcessChange",
            value: function(e, r, n, i) {
                (i = r + i * n) < 1 && e.event(t.Event.PROGRESS, i);
            }
        }, {
            key: "init",
            value: function(e, t) {
                var r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null
                  , n = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : null;
                if (Laya3D._isInit)
                    n && n.run();
                else {
                    Laya3D._isInit = !0,
                    r && r.cloneTo(s._config),
                    r = s._config,
                    Re.debugFrustumCulling = r.debugFrustumCulling,
                    Laya3D._editerEnvironment = r._editerEnvironment,
                    Nr.octreeCulling = r.octreeCulling,
                    Nr.octreeInitialSize = r.octreeInitialSize,
                    Nr.octreeInitialCenter = r.octreeInitialCenter,
                    Nr.octreeMinNodeSize = r.octreeMinNodeSize,
                    Nr.octreeLooseness = r.octreeLooseness;
                    var i = window.Physics3D;
                    null == i ? (S._enablePhysics = !1,
                    Laya3D.__init__(e, t, r),
                    n && n.run()) : (S._enablePhysics = !0,
                    i(16 * r.defaultPhysicsMemory, Yr._interactive).then(function() {
                        Laya3D.__init__(e, t, r),
                        n && n.run();
                    }));
                }
            }
        }, {
            key: "enablePhysics",
            get: function() {
                return S._enablePhysics;
            }
        }]),
        Laya3D;
    }();
    mn.HIERARCHY = "HIERARCHY",
    mn.MESH = "MESH",
    mn.MATERIAL = "MATERIAL",
    mn.TEXTURE2D = "TEXTURE2D",
    mn.TEXTURECUBE = "TEXTURECUBE",
    mn.TEXTURECUBEBIN = "TEXTURECUBEBIN",
    mn.ANIMATIONCLIP = "ANIMATIONCLIP",
    mn.AVATAR = "AVATAR",
    mn.TERRAINHEIGHTDATA = "TERRAINHEIGHTDATA",
    mn.TERRAINRES = "TERRAIN",
    mn._innerFirstLevelLoaderManager = new t.LoaderManager(),
    mn._innerSecondLevelLoaderManager = new t.LoaderManager(),
    mn._innerThirdLevelLoaderManager = new t.LoaderManager(),
    mn._innerFourthLevelLoaderManager = new t.LoaderManager(),
    mn._isInit = !1,
    mn._editerEnvironment = !1,
    mn.physicsSettings = new Tr(),
    window.Laya3D = mn;
    var pn = function(e) {
        function CastShadowList() {
            return _classCallCheck(this, CastShadowList),
            _possibleConstructorReturn(this, _getPrototypeOf(CastShadowList).call(this));
        }
        return _inherits(CastShadowList, nt),
        _createClass(CastShadowList, [{
            key: "add",
            value: function(e) {
                if (-1 !== e._indexInCastShadowList)
                    throw "CastShadowList:element has  in  CastShadowList.";
                this._add(e),
                e._indexInCastShadowList = this.length++;
            }
        }, {
            key: "remove",
            value: function(e) {
                var t = e._indexInCastShadowList;
                if (this.length--,
                t !== this.length) {
                    var r = this.elements[this.length];
                    this.elements[t] = r,
                    r._indexInCastShadowList = t;
                }
                e._indexInCastShadowList = -1;
            }
        }]),
        CastShadowList;
    }()
      , vn = function() {
        function AnimatorStateScript() {
            _classCallCheck(this, AnimatorStateScript);
        }
        return _createClass(AnimatorStateScript, [{
            key: "onStateEnter",
            value: function() {}
        }, {
            key: "onStateUpdate",
            value: function() {}
        }, {
            key: "onStateExit",
            value: function() {}
        }]),
        AnimatorStateScript;
    }()
      , Tn = function(e) {
        function Script3D() {
            var e;
            return _classCallCheck(this, Script3D),
            (e = _possibleConstructorReturn(this, _getPrototypeOf(Script3D).apply(this, arguments)))._indexInPool = -1,
            e;
        }
        return _inherits(Script3D, t.Component),
        _createClass(Script3D, [{
            key: "_checkProcessTriggers",
            value: function() {
                var e = Script3D.prototype;
                return this.onTriggerEnter !== e.onTriggerEnter || (this.onTriggerStay !== e.onTriggerStay || this.onTriggerExit !== e.onTriggerExit);
            }
        }, {
            key: "_checkProcessCollisions",
            value: function() {
                var e = Script3D.prototype;
                return this.onCollisionEnter !== e.onCollisionEnter || (this.onCollisionStay !== e.onCollisionStay || this.onCollisionExit !== e.onCollisionExit);
            }
        }, {
            key: "_onAwake",
            value: function() {
                this.onAwake(),
                this.onStart !== Script3D.prototype.onStart && t.Laya.startTimer.callLater(this, this.onStart);
            }
        }, {
            key: "_onEnable",
            value: function() {
                this.owner._scene._addScript(this),
                this.onEnable();
            }
        }, {
            key: "_onDisable",
            value: function() {
                this.owner._scene._removeScript(this),
                this.owner.offAllCaller(this),
                this.onDisable();
            }
        }, {
            key: "_onDestroy",
            value: function() {
                var e = this.owner._scripts;
                e.splice(e.indexOf(this), 1);
                var t = this.owner;
                t._needProcessTriggers = !1;
                for (var r = 0, n = e.length; r < n; r++)
                    if (e[r]._checkProcessTriggers()) {
                        t._needProcessTriggers = !0;
                        break;
                    }
                for (t._needProcessCollisions = !1,
                r = 0,
                n = e.length; r < n; r++)
                    if (e[r]._checkProcessCollisions()) {
                        t._needProcessCollisions = !0;
                        break;
                    }
                this.onDestroy();
            }
        }, {
            key: "_isScript",
            value: function() {
                return !0;
            }
        }, {
            key: "_onAdded",
            value: function() {
                var e = this.owner
                  , t = e._scripts;
                t || (e._scripts = t = []),
                t.push(this),
                e._needProcessCollisions || (e._needProcessCollisions = this._checkProcessCollisions()),
                e._needProcessTriggers || (e._needProcessTriggers = this._checkProcessTriggers());
            }
        }, {
            key: "onAwake",
            value: function() {}
        }, {
            key: "onEnable",
            value: function() {}
        }, {
            key: "onStart",
            value: function() {}
        }, {
            key: "onTriggerEnter",
            value: function(e) {}
        }, {
            key: "onTriggerStay",
            value: function(e) {}
        }, {
            key: "onTriggerExit",
            value: function(e) {}
        }, {
            key: "onCollisionEnter",
            value: function(e) {}
        }, {
            key: "onCollisionStay",
            value: function(e) {}
        }, {
            key: "onCollisionExit",
            value: function(e) {}
        }, {
            key: "onMouseDown",
            value: function() {}
        }, {
            key: "onMouseDrag",
            value: function() {}
        }, {
            key: "onMouseClick",
            value: function() {}
        }, {
            key: "onMouseUp",
            value: function() {}
        }, {
            key: "onMouseEnter",
            value: function() {}
        }, {
            key: "onMouseOver",
            value: function() {}
        }, {
            key: "onMouseOut",
            value: function() {}
        }, {
            key: "onUpdate",
            value: function() {}
        }, {
            key: "onLateUpdate",
            value: function() {}
        }, {
            key: "onPreRender",
            value: function() {}
        }, {
            key: "onPostRender",
            value: function() {}
        }, {
            key: "onDisable",
            value: function() {}
        }, {
            key: "onDestroy",
            value: function() {}
        }, {
            key: "isSingleton",
            get: function() {
                return !1;
            }
        }]),
        Script3D;
    }()
      , En = function() {
        function HeightMap(e, t, r, n) {
            _classCallCheck(this, HeightMap),
            this._datas = [],
            this._w = e,
            this._h = t,
            this._minHeight = r,
            this._maxHeight = n;
        }
        return _createClass(HeightMap, [{
            key: "_inBounds",
            value: function(e, t) {
                return e >= 0 && e < this._h && t >= 0 && t < this._w;
            }
        }, {
            key: "getHeight",
            value: function(e, t) {
                return this._inBounds(e, t) ? this._datas[e][t] : NaN;
            }
        }, {
            key: "width",
            get: function() {
                return this._w;
            }
        }, {
            key: "height",
            get: function() {
                return this._h;
            }
        }, {
            key: "maxHeight",
            get: function() {
                return this._maxHeight;
            }
        }, {
            key: "minHeight",
            get: function() {
                return this._minHeight;
            }
        }], [{
            key: "creatFromMesh",
            value: function(e, t, r, n) {
                for (var i = [], a = [], s = e.subMeshCount, l = 0; l < s; l++) {
                    for (var u = e.getSubMesh(l), c = u._vertexBuffer, h = c.getFloat32Data(), _ = [], d = 0; d < h.length; d += c.vertexDeclaration.vertexStride / 4) {
                        var f = new o(h[d + 0],h[d + 1],h[d + 2]);
                        _.push(f);
                    }
                    i.push(_);
                    var m = u._indexBuffer;
                    a.push(m.getData());
                }
                var p = e.bounds
                  , v = p.getMin().x
                  , T = p.getMin().z
                  , E = p.getMax().x
                  , y = p.getMax().z
                  , g = p.getMin().y
                  , S = p.getMax().y
                  , R = E - v
                  , C = y - T
                  , M = n.x = R / (t - 1)
                  , D = n.y = C / (r - 1)
                  , x = new HeightMap(t,r,g,S)
                  , A = HeightMap._tempRay
                  , I = A.direction;
                I.x = 0,
                I.y = -1,
                I.z = 0;
                var L = S + .1;
                A.origin.y = L;
                for (var P = 0; P < r; P++) {
                    var O = T + P * D;
                    x._datas[P] = [];
                    for (var N = 0; N < t; N++) {
                        var b = v + N * M
                          , k = A.origin;
                        k.x = b,
                        k.z = O;
                        var V = HeightMap._getPosition(A, i, a);
                        x._datas[P][N] = V === Number.MAX_VALUE ? NaN : L - V;
                    }
                }
                return x;
            }
        }, {
            key: "createFromImage",
            value: function(e, t, r) {
                for (var n = e.width, i = e.height, a = new HeightMap(n,i,t,r), o = (r - t) / 254, s = e.getPixels(), l = 0, u = 0; u < i; u++)
                    for (var c = a._datas[u] = [], h = 0; h < n; h++) {
                        var _ = s[l++]
                          , d = s[l++]
                          , f = s[l++]
                          , m = s[l++];
                        c[h] = 255 == _ && 255 == d && 255 == f && 255 == m ? NaN : (_ + d + f) / 3 * o + t;
                    }
                return a;
            }
        }, {
            key: "_getPosition",
            value: function(e, t, r) {
                for (var n = Number.MAX_VALUE, i = 0; i < t.length; i++)
                    for (var a = t[i], o = r[i], s = 0; s < o.length; s += 3) {
                        var l = a[o[s + 0]]
                          , u = a[o[s + 1]]
                          , c = a[o[s + 2]]
                          , h = Ve.rayIntersectsTriangle(e, l, u, c);
                        !isNaN(h) && h < n && (n = h);
                    }
                return n;
            }
        }]),
        HeightMap;
    }();
    En._tempRay = new Pe(new o(),new o());
    var yn = function(e) {
        function MeshTerrainSprite3D(e, t) {
            var r, i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null;
            return _classCallCheck(this, MeshTerrainSprite3D),
            (r = _possibleConstructorReturn(this, _getPrototypeOf(MeshTerrainSprite3D).call(this, e, i)))._heightMap = t,
            r._cellSize = new n(),
            r;
        }
        return _inherits(MeshTerrainSprite3D, dt),
        _createClass(MeshTerrainSprite3D, [{
            key: "_disableRotation",
            value: function() {
                var e = this.transform.rotation;
                e.x = 0,
                e.y = 0,
                e.z = 0,
                e.w = 1,
                this.transform.rotation = e;
            }
        }, {
            key: "_getScaleX",
            value: function() {
                var e = this.transform.worldMatrix.elements
                  , t = e[0]
                  , r = e[1]
                  , n = e[2];
                return Math.sqrt(t * t + r * r + n * n);
            }
        }, {
            key: "_getScaleZ",
            value: function() {
                var e = this.transform.worldMatrix.elements
                  , t = e[8]
                  , r = e[9]
                  , n = e[10];
                return Math.sqrt(t * t + r * r + n * n);
            }
        }, {
            key: "_initCreateFromMesh",
            value: function(e, t) {
                this._heightMap = En.creatFromMesh(this.meshFilter.sharedMesh, e, t, this._cellSize);
                var r = this.meshFilter.sharedMesh.bounds
                  , n = r.getMin();
                r.getMax();
                this._minX = n.x,
                this._minZ = n.z;
            }
        }, {
            key: "_initCreateFromMeshHeightMap",
            value: function(e, t, r) {
                var n = this.meshFilter.sharedMesh.bounds;
                this._heightMap = En.createFromImage(e, t, r),
                this._computeCellSize(n);
                var i = n.getMin();
                n.getMax();
                this._minX = i.x,
                this._minZ = i.z;
            }
        }, {
            key: "_computeCellSize",
            value: function(e) {
                var t = e.getMin()
                  , r = e.getMax()
                  , n = t.x
                  , i = t.z
                  , a = r.x - n
                  , o = r.z - i;
                this._cellSize.x = a / (this._heightMap.width - 1),
                this._cellSize.y = o / (this._heightMap.height - 1);
            }
        }, {
            key: "_update",
            value: function(e) {
                this._disableRotation();
            }
        }, {
            key: "getHeight",
            value: function(e, t) {
                MeshTerrainSprite3D._tempVector3.x = e,
                MeshTerrainSprite3D._tempVector3.y = 0,
                MeshTerrainSprite3D._tempVector3.z = t,
                this._disableRotation();
                var r = this.transform.worldMatrix;
                r.invert(MeshTerrainSprite3D._tempMatrix4x4),
                o.transformCoordinate(MeshTerrainSprite3D._tempVector3, MeshTerrainSprite3D._tempMatrix4x4, MeshTerrainSprite3D._tempVector3),
                e = MeshTerrainSprite3D._tempVector3.x,
                t = MeshTerrainSprite3D._tempVector3.z;
                var n = (e - this._minX) / this._cellSize.x
                  , i = (t - this._minZ) / this._cellSize.y
                  , a = Math.floor(i)
                  , s = Math.floor(n)
                  , l = n - s
                  , u = i - a
                  , c = r.elements
                  , h = c[4]
                  , _ = c[5]
                  , d = c[6]
                  , f = Math.sqrt(h * h + _ * _ + d * d)
                  , m = c[13]
                  , p = this._heightMap.getHeight(a, s + 1)
                  , v = this._heightMap.getHeight(a + 1, s);
                if (isNaN(p) || isNaN(v))
                    return NaN;
                if (l + u <= 1) {
                    var T = this._heightMap.getHeight(a, s);
                    return isNaN(T) ? NaN : (T + l * (p - T) + u * (v - T)) * f + m;
                }
                var E = this._heightMap.getHeight(a + 1, s + 1);
                return isNaN(E) ? NaN : (E + (1 - l) * (v - E) + (1 - u) * (p - E)) * f + m;
            }
        }, {
            key: "minX",
            get: function() {
                var e = this.transform.worldMatrix.elements;
                return this._minX * this._getScaleX() + e[12];
            }
        }, {
            key: "minZ",
            get: function() {
                var e = this.transform.worldMatrix.elements;
                return this._minZ * this._getScaleZ() + e[14];
            }
        }, {
            key: "width",
            get: function() {
                return (this._heightMap.width - 1) * this._cellSize.x * this._getScaleX();
            }
        }, {
            key: "depth",
            get: function() {
                return (this._heightMap.height - 1) * this._cellSize.y * this._getScaleZ();
            }
        }], [{
            key: "createFromMesh",
            value: function(e, t, r) {
                var n = new MeshTerrainSprite3D(e,null,arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : null);
                return n._initCreateFromMesh(t, r),
                n;
            }
        }, {
            key: "createFromMeshAndHeightMap",
            value: function(e, t, r, n) {
                var i = new MeshTerrainSprite3D(e,null,arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : null);
                return i._initCreateFromMeshHeightMap(t, r, n),
                i;
            }
        }]),
        MeshTerrainSprite3D;
    }();
    yn._tempVector3 = new o(),
    yn._tempMatrix4x4 = new I();
    var gn = function() {
        function GradientDataVector2() {
            _classCallCheck(this, GradientDataVector2),
            this._currentLength = 0,
            this._elements = new Float32Array(12);
        }
        return _createClass(GradientDataVector2, [{
            key: "add",
            value: function(e, t) {
                this._currentLength < 8 ? (6 === this._currentLength && 1 !== e && (e = 1,
                console.log("GradientDataVector2 warning:the forth key is  be force set to 1.")),
                this._elements[this._currentLength++] = e,
                this._elements[this._currentLength++] = t.x,
                this._elements[this._currentLength++] = t.y) : console.log("GradientDataVector2 warning:data count must lessEqual than 4");
            }
        }, {
            key: "cloneTo",
            value: function(e) {
                var t = e;
                t._currentLength = this._currentLength;
                for (var r = t._elements, n = 0, i = this._elements.length; n < i; n++)
                    r[n] = this._elements[n];
            }
        }, {
            key: "clone",
            value: function() {
                var e = new GradientDataVector2();
                return this.cloneTo(e),
                e;
            }
        }, {
            key: "gradientCount",
            get: function() {
                return this._currentLength / 3;
            }
        }]),
        GradientDataVector2;
    }()
      , Sn = function() {
        function PixelLineData() {
            _classCallCheck(this, PixelLineData),
            this.startPosition = new o(),
            this.endPosition = new o(),
            this.startColor = new ve(),
            this.endColor = new ve();
        }
        return _createClass(PixelLineData, [{
            key: "cloneTo",
            value: function(e) {
                this.startPosition.cloneTo(e.startPosition),
                this.endPosition.cloneTo(e.endPosition),
                this.startColor.cloneTo(e.startColor),
                this.endColor.cloneTo(e.endColor);
            }
        }]),
        PixelLineData;
    }()
      , Rn = function() {
        function PostProcessEffect() {
            _classCallCheck(this, PostProcessEffect);
        }
        return _createClass(PostProcessEffect, [{
            key: "render",
            value: function(e) {}
        }]),
        PostProcessEffect;
    }()
      , Cn = function(e) {
        function BloomEffect() {
            var e;
            return _classCallCheck(this, BloomEffect),
            (e = _possibleConstructorReturn(this, _getPrototypeOf(BloomEffect).call(this)))._shader = null,
            e._shaderData = new z(),
            e._linearColor = new ve(),
            e._bloomTextureTexelSize = new i(),
            e._shaderThreshold = new i(),
            e._shaderParams = new i(),
            e._pyramid = null,
            e._intensity = 0,
            e._threshold = 1,
            e._softKnee = .5,
            e._diffusion = 7,
            e._anamorphicRatio = 0,
            e._dirtIntensity = 0,
            e._shaderSetting = new i(),
            e._dirtTileOffset = new i(),
            e.clamp = 65472,
            e.color = new ve(1,1,1,1),
            e.fastMode = !1,
            e.dirtTexture = null,
            e._shader = G.find("PostProcessBloom"),
            e._pyramid = new Array(2 * BloomEffect.MAXPYRAMIDSIZE),
            e;
        }
        return _inherits(BloomEffect, Rn),
        _createClass(BloomEffect, [{
            key: "render",
            value: function(e) {
                var r = e.command
                  , n = e.camera.viewport;
                this._shaderData.setTexture(BloomEffect.SHADERVALUE_AUTOEXPOSURETEX, t.Texture2D.whiteTexture);
                var a, o = this._anamorphicRatio, s = o < 0 ? -o : 0, l = o > 0 ? o : 0, u = Math.floor(n.width / (2 - s)), c = Math.floor(n.height / (2 - l)), h = Math.max(u, c);
                a = Math.log2(h) + this._diffusion - 10;
                var _ = Math.floor(a)
                  , d = Math.min(Math.max(_, 1), BloomEffect.MAXPYRAMIDSIZE)
                  , f = .5 + a - _;
                this._shaderData.setNumber(BloomEffect.SHADERVALUE_SAMPLESCALE, f);
                var m = ve.gammaToLinearSpace(this.threshold)
                  , p = m * this._softKnee + 1e-5;
                this._shaderThreshold.setValue(m, m - p, 2 * p, .25 / p),
                this._shaderData.setVector(BloomEffect.SHADERVALUE_THRESHOLD, this._shaderThreshold);
                var v = ve.gammaToLinearSpace(this.clamp);
                this._shaderParams.setValue(v, 0, 0, 0),
                this._shaderData.setVector(BloomEffect.SHADERVALUE_PARAMS, this._shaderParams);
                for (var T = this.fastMode ? 1 : 0, E = e.source, y = 0; y < d; y++) {
                    var g = 2 * y
                      , S = g + 1
                      , R = 0 == y ? BloomEffect.SUBSHADER_PREFILTER13 + T : BloomEffect.SUBSHADER_DOWNSAMPLE13 + T
                      , C = V.createFromPool(u, c, t.RenderTextureFormat.R8G8B8, t.RenderTextureDepthFormat.DEPTHSTENCIL_NONE, t.FilterMode.Bilinear);
                    if (this._pyramid[g] = C,
                    y !== d - 1) {
                        var M = V.createFromPool(u, c, t.RenderTextureFormat.R8G8B8, t.RenderTextureDepthFormat.DEPTHSTENCIL_NONE, t.FilterMode.Bilinear);
                        this._pyramid[S] = M;
                    }
                    r.blitScreenTriangle(E, C, null, this._shader, this._shaderData, R),
                    E = C,
                    u = Math.max(Math.floor(u / 2), 1),
                    c = Math.max(Math.floor(c / 2), 1);
                }
                var D = this._pyramid[2 * (d - 1)];
                for (y = d - 2; y >= 0; y--)
                    S = (g = 2 * y) + 1,
                    C = this._pyramid[g],
                    M = this._pyramid[S],
                    r.setShaderDataTexture(this._shaderData, BloomEffect.SHADERVALUE_BLOOMTEX, C),
                    r.blitScreenTriangle(D, M, null, this._shader, this._shaderData, BloomEffect.SUBSHADER_UPSAMPLETENT + T),
                    D = M;
                var x = this._linearColor;
                this.color.toLinear(x);
                var A = Math.pow(2, this._intensity / 10) - 1
                  , I = this._shaderSetting;
                this._shaderSetting.setValue(f, A, this._dirtIntensity, d);
                var L = this.dirtTexture ? this.dirtTexture : t.Texture2D.blackTexture
                  , P = L.width / L.height
                  , O = n.width / n.height
                  , N = this._dirtTileOffset;
                P > O ? N.setValue(O / P, 1, .5 * (1 - N.x), 0) : P < O && N.setValue(1, P / O, 0, .5 * (1 - N.y));
                var b = e.compositeShaderData;
                for (this.fastMode ? b.addDefine(H.SHADERDEFINE_BLOOM_LOW) : b.addDefine(H.SHADERDEFINE_BLOOM),
                this._bloomTextureTexelSize.setValue(1 / D.width, 1 / D.height, D.width, D.height),
                b.setVector(H.SHADERVALUE_BLOOM_DIRTTILEOFFSET, N),
                b.setVector(H.SHADERVALUE_BLOOM_SETTINGS, I),
                b.setVector(H.SHADERVALUE_BLOOM_COLOR, new i(x.r,x.g,x.b,x.a)),
                b.setTexture(H.SHADERVALUE_BLOOM_DIRTTEX, L),
                b.setTexture(H.SHADERVALUE_BLOOMTEX, D),
                b.setVector(H.SHADERVALUE_BLOOMTEX_TEXELSIZE, this._bloomTextureTexelSize),
                y = 0; y < d; y++)
                    S = (g = 2 * y) + 1,
                    V.recoverToPool(this._pyramid[g]),
                    0 !== y && y !== d - 1 && V.recoverToPool(this._pyramid[S]);
                e.deferredReleaseTextures.push(D);
            }
        }, {
            key: "intensity",
            get: function() {
                return this._intensity;
            },
            set: function(e) {
                this._intensity = Math.max(e, 0);
            }
        }, {
            key: "threshold",
            get: function() {
                return this._threshold;
            },
            set: function(e) {
                this._threshold = Math.max(e, 0);
            }
        }, {
            key: "softKnee",
            get: function() {
                return this._softKnee;
            },
            set: function(e) {
                this._softKnee = Math.min(Math.max(e, 0), 1);
            }
        }, {
            key: "diffusion",
            get: function() {
                return this._diffusion;
            },
            set: function(e) {
                this._diffusion = Math.min(Math.max(e, 1), 10);
            }
        }, {
            key: "anamorphicRatio",
            get: function() {
                return this._anamorphicRatio;
            },
            set: function(e) {
                this._anamorphicRatio = Math.min(Math.max(e, -1), 1);
            }
        }, {
            key: "dirtIntensity",
            get: function() {
                return this._dirtIntensity;
            },
            set: function(e) {
                this._dirtIntensity = Math.max(e, 0);
            }
        }]),
        BloomEffect;
    }();
    Cn.SHADERVALUE_MAINTEX = G.propertyNameToID("u_MainTex"),
    Cn.SHADERVALUE_AUTOEXPOSURETEX = G.propertyNameToID("u_AutoExposureTex"),
    Cn.SHADERVALUE_SAMPLESCALE = G.propertyNameToID("u_SampleScale"),
    Cn.SHADERVALUE_THRESHOLD = G.propertyNameToID("u_Threshold"),
    Cn.SHADERVALUE_PARAMS = G.propertyNameToID("u_Params"),
    Cn.SHADERVALUE_BLOOMTEX = G.propertyNameToID("u_BloomTex"),
    Cn.SUBSHADER_PREFILTER13 = 0,
    Cn.SUBSHADER_PREFILTER4 = 1,
    Cn.SUBSHADER_DOWNSAMPLE13 = 2,
    Cn.SUBSHADER_DOWNSAMPLE4 = 3,
    Cn.SUBSHADER_UPSAMPLETENT = 4,
    Cn.SUBSHADER_UPSAMPLEBOX = 5,
    Cn.MAXPYRAMIDSIZE = 16;
    var Mn = function() {
        function RandX(e) {
            if (_classCallCheck(this, RandX),
            !(e instanceof Array) || 4 !== e.length)
                throw new Error("Rand:Seed must be an array with 4 numbers");
            this._state0U = 0 | e[0],
            this._state0L = 0 | e[1],
            this._state1U = 0 | e[2],
            this._state1L = 0 | e[3];
        }
        return _createClass(RandX, [{
            key: "randomint",
            value: function() {
                var e = this._state0U
                  , t = this._state0L
                  , r = this._state1U
                  , n = this._state1L
                  , i = (n >>> 0) + (t >>> 0)
                  , a = r + e + (i / 2 >>> 31) >>> 0
                  , o = i >>> 0;
                this._state0U = r,
                this._state0L = n;
                var s = 0
                  , l = 0;
                s = (e ^= s = e << 23 | (-512 & t) >>> 9) ^ r,
                l = (t ^= l = t << 23) ^ n;
                s ^= e >>> 18,
                l ^= t >>> 18 | (262143 & e) << 14;
                return s ^= r >>> 5,
                l ^= n >>> 5 | (31 & r) << 27,
                this._state1U = s,
                this._state1L = l,
                [a, o];
            }
        }, {
            key: "random",
            value: function() {
                var e = this.randomint()
                  , t = e[0]
                  , r = 1023 << 20 | t >>> 12
                  , n = 0 | (e[1] >>> 12 | (4095 & t) << 20);
                return RandX._CONVERTION_BUFFER.setUint32(0, r, !1),
                RandX._CONVERTION_BUFFER.setUint32(4, n, !1),
                RandX._CONVERTION_BUFFER.getFloat64(0, !1) - 1;
            }
        }]),
        RandX;
    }();
    Mn._CONVERTION_BUFFER = new DataView(new ArrayBuffer(8)),
    Mn.defaultRand = new Mn([0, Date.now() / 65536, 0, Date.now() % 65536]);
    var Dn = function(e) {
        function ConstraintComponent() {
            var e;
            return _classCallCheck(this, ConstraintComponent),
            (e = _possibleConstructorReturn(this, _getPrototypeOf(ConstraintComponent).call(this)))._feedbackEnabled = !1,
            e;
        }
        return _inherits(ConstraintComponent, t.Component),
        _createClass(ConstraintComponent, [{
            key: "_onDestroy",
            value: function() {
                S._bullet.destroy(this._btConstraint),
                this._btConstraint = null;
            }
        }, {
            key: "enabled",
            get: function() {
                return _get(_getPrototypeOf(ConstraintComponent.prototype), "enabled", this);
            },
            set: function(e) {
                this._btConstraint.IsEnabled = e,
                _set(_getPrototypeOf(ConstraintComponent.prototype), "enabled", e, this, !0);
            }
        }, {
            key: "breakingImpulseThreshold",
            get: function() {
                return this._breakingImpulseThreshold;
            },
            set: function(e) {
                this._btConstraint.BreakingImpulseThreshold = e,
                this._breakingImpulseThreshold = e;
            }
        }, {
            key: "appliedImpulse",
            get: function() {
                return this._feedbackEnabled || (this._btConstraint.EnableFeedback(!0),
                this._feedbackEnabled = !0),
                this._btConstraint.AppliedImpulse;
            }
        }, {
            key: "connectedBody",
            get: function() {
                return this._connectedBody;
            },
            set: function(e) {
                this._connectedBody = e;
            }
        }]),
        ConstraintComponent;
    }()
      , xn = function() {
        function Point2PointConstraint() {
            _classCallCheck(this, Point2PointConstraint),
            this._pivotInA = new o(),
            this._pivotInB = new o();
        }
        return _createClass(Point2PointConstraint, [{
            key: "pivotInA",
            get: function() {
                return this._pivotInA;
            },
            set: function(e) {
                this._pivotInA = e;
            }
        }, {
            key: "pivotInB",
            get: function() {
                return this._pivotInB;
            },
            set: function(e) {
                this._pivotInB = e;
            }
        }, {
            key: "damping",
            get: function() {
                return this._damping;
            },
            set: function(e) {
                this._damping = e;
            }
        }, {
            key: "impulseClamp",
            get: function() {
                return this._impulseClamp;
            },
            set: function(e) {
                this._impulseClamp = e;
            }
        }, {
            key: "tau",
            get: function() {
                return this._tau;
            },
            set: function(e) {
                this._tau = e;
            }
        }]),
        Point2PointConstraint;
    }()
      , An = function() {
        function TextMesh() {
            _classCallCheck(this, TextMesh);
        }
        return _createClass(TextMesh, [{
            key: "text",
            get: function() {
                return this._text;
            },
            set: function(e) {
                this._text = e;
            }
        }, {
            key: "fontSize",
            get: function() {
                return this._fontSize;
            },
            set: function(e) {
                this._fontSize = e;
            }
        }, {
            key: "color",
            get: function() {
                return this._color;
            },
            set: function(e) {
                this._color = e;
            }
        }]),
        _createClass(TextMesh, [{
            key: "_createVertexBuffer",
            value: function(e) {}
        }, {
            key: "_resizeVertexBuffer",
            value: function(e) {}
        }, {
            key: "_addChar",
            value: function() {}
        }]),
        TextMesh;
    }()
      , In = function() {
        function Size(e, t) {
            _classCallCheck(this, Size),
            this._width = 0,
            this._height = 0,
            this._width = e,
            this._height = t;
        }
        return _createClass(Size, [{
            key: "width",
            get: function() {
                return -1 === this._width ? k.clientWidth : this._width;
            }
        }, {
            key: "height",
            get: function() {
                return -1 === this._height ? k.clientHeight : this._height;
            }
        }], [{
            key: "fullScreen",
            get: function() {
                return new Size(-1,-1);
            }
        }]),
        Size;
    }();
    e.AlternateLightQueue = Cr,
    e.AnimationClip = C,
    e.AnimationClipParser03 = v,
    e.AnimationClipParser04 = E,
    e.AnimationEvent = c,
    e.AnimationNode = X,
    e.AnimationTransform3D = W,
    e.Animator = N,
    e.AnimatorControllerLayer = D,
    e.AnimatorPlayState = M,
    e.AnimatorState = P,
    e.AnimatorStateScript = vn,
    e.Avatar = Y,
    e.BaseCamera = He,
    e.BaseMaterial = j,
    e.BaseRender = lt,
    e.BaseShape = Dt,
    e.BatchMark = Ce,
    e.BlinnPhongMaterial = q,
    e.BlitScreenQuadCMD = Ze,
    e.BloomEffect = Cn,
    e.BoundBox = ot,
    e.BoundFrustum = be,
    e.BoundSphere = Wt,
    e.Bounds = st,
    e.BoundsOctree = Or,
    e.BoundsOctreeNode = Ir,
    e.BoxColliderShape = lr,
    e.BoxShape = At,
    e.BufferState = we,
    e.BulletInteractive = Yr,
    e.Burst = pt,
    e.Camera = $e,
    e.CapsuleColliderShape = ur,
    e.CastShadowList = pn,
    e.CharacterController = Zr,
    e.CircleShape = It,
    e.Cluster = Ie,
    e.ColliderShape = sr,
    e.Collision = ar,
    e.CollisionTool = or,
    e.CollisionUtils = Ne,
    e.Color = ve,
    e.ColorOverLifetime = Tt,
    e.Command = Ye,
    e.CommandBuffer = Ke,
    e.CompoundColliderShape = cr,
    e.ConchQuaternion = L,
    e.ConchVector3 = A,
    e.ConchVector4 = x,
    e.ConeColliderShape = hr,
    e.ConeShape = Lt,
    e.Config3D = s,
    e.Constraint3D = function Constraint3D() {
        _classCallCheck(this, Constraint3D);
    }
    ,
    e.ConstraintComponent = Dn,
    e.ContactPoint = ir,
    e.ContainmentType = Oe,
    e.CylinderColliderShape = _r,
    e.DefineDatas = B,
    e.DirectionLight = sn,
    e.DirectionLightQueue = Rr,
    e.DynamicBatchManager = Te,
    e.EffectMaterial = K,
    e.Emission = Yt,
    e.ExtendTerrainMaterial = $,
    e.FloatKeyframe = _,
    e.FrameOverTime = Et,
    e.FrustumCulling = Re,
    e.GeometryElement = Me,
    e.Gradient = mt,
    e.GradientAngularVelocity = yt,
    e.GradientColor = vt,
    e.GradientDataInt = gt,
    e.GradientDataNumber = St,
    e.GradientDataVector2 = gn,
    e.GradientMode = ft,
    e.GradientSize = Rt,
    e.GradientVelocity = Ct,
    e.HalfFloatUtils = T,
    e.HeightMap = En,
    e.HeightfieldColliderShape = function HeightfieldColliderShape() {
        _classCallCheck(this, HeightfieldColliderShape);
    }
    ,
    e.HemisphereShape = Pt,
    e.HitResult = rr,
    e.ILaya3D = l,
    e.IndexBuffer3D = Fe,
    e.Input3D = vr,
    e.Keyframe = h,
    e.KeyframeNode = u,
    e.KeyframeNodeList = y,
    e.KeyframeNodeOwner = O,
    e.Laya3D = mn,
    e.LightQueue = Sr,
    e.LightSprite = on,
    e.LoadModelV04 = hn,
    e.LoadModelV05 = _n,
    e.Material = Z,
    e.MathUtils3D = r,
    e.Matrix3x3 = d,
    e.Matrix4x4 = I,
    e.Mesh = en,
    e.MeshColliderShape = dr,
    e.MeshFilter = ct,
    e.MeshReader = dn,
    e.MeshRenderDynamicBatchManager = _t,
    e.MeshRenderStaticBatchManager = it,
    e.MeshRenderer = ut,
    e.MeshSprite3D = dt,
    e.MeshSprite3DShaderDeclaration = at,
    e.MeshTerrainSprite3D = yn,
    e.MouseTouch = er,
    e.OctreeMotionList = Pr,
    e.PBRMaterial = ee,
    e.PBRSpecularMaterial = ce,
    e.PBRStandardMaterial = _e,
    e.ParallelSplitShadowMap = an,
    e.Physics3D = S,
    e.Physics3DUtils = Ft,
    e.PhysicsCollider = Qr,
    e.PhysicsComponent = mr,
    e.PhysicsSettings = Tr,
    e.PhysicsSimulation = pr,
    e.PhysicsTriggerComponent = jr,
    e.PhysicsUpdateList = nr,
    e.Picker = Ve,
    e.PixelLineData = Sn,
    e.PixelLineFilter = Mr,
    e.PixelLineMaterial = qt,
    e.PixelLineRenderer = Dr,
    e.PixelLineSprite3D = xr,
    e.PixelLineVertex = Kt,
    e.Plane = Le,
    e.Point2PointConstraint = xn,
    e.PointLight = ln,
    e.PostProcess = H,
    e.PostProcessEffect = Rn,
    e.PostProcessRenderContext = b,
    e.PrimitiveMesh = tn,
    e.Quaternion = f,
    e.QuaternionKeyframe = m,
    e.Rand = Xt,
    e.RandX = Mn,
    e.Ray = Pe,
    e.RenderContext3D = k,
    e.RenderElement = et,
    e.RenderQueue = Ar,
    e.RenderState = Q,
    e.RenderTexture = V,
    e.RenderableSprite3D = ge,
    e.Rigidbody3D = qr,
    e.RotationOverLifetime = Mt,
    e.Scene3D = Nr,
    e.Scene3DShaderDeclaration = Je,
    e.Scene3DUtils = cn,
    e.SceneManager = function SceneManager() {
        _classCallCheck(this, SceneManager);
    }
    ,
    e.ScreenQuad = We,
    e.ScreenTriangle = Xe,
    e.Script3D = Tn,
    e.SetRenderTargetCMD = je,
    e.SetShaderDataTextureCMD = Qe,
    e.Shader3D = G,
    e.ShaderData = z,
    e.ShaderDefine = w,
    e.ShaderInit3D = nn,
    e.ShaderInstance = re,
    e.ShaderPass = ne,
    e.ShaderVariable = te,
    e.ShaderVariant = F,
    e.ShaderVariantCollection = U,
    e.ShapeUtils = xt,
    e.ShuriKenParticle3D = Qt,
    e.ShuriKenParticle3DShaderDeclaration = Bt,
    e.ShurikenParticleData = Zt,
    e.ShurikenParticleMaterial = wt,
    e.ShurikenParticleRenderer = Ut,
    e.ShurikenParticleSystem = jt,
    e.SimpleSingletonList = Jt,
    e.SingletonList = nt,
    e.Size = In,
    e.SizeOverLifetime = Nt,
    e.SkinnedMeshRenderer = kr,
    e.SkinnedMeshSprite3D = Vr,
    e.SkinnedMeshSprite3DShaderDeclaration = br,
    e.SkyBox = Ge,
    e.SkyBoxMaterial = de,
    e.SkyDome = yr,
    e.SkyMesh = Ue,
    e.SkyPanoramicMaterial = fn,
    e.SkyProceduralMaterial = fe,
    e.SkyRenderer = ze,
    e.SphereColliderShape = fr,
    e.SphereShape = Ot,
    e.SphericalHarmonicsL2 = $t,
    e.SpotLight = un,
    e.Sprite3D = ye,
    e.StartFrame = bt,
    e.StaticBatchManager = Se,
    e.StaticPlaneColliderShape = Kr,
    e.SubMesh = Jr,
    e.SubMeshDynamicBatch = ht,
    e.SubMeshInstanceBatch = xe,
    e.SubMeshRenderElement = tt,
    e.SubMeshStaticBatch = rt,
    e.SubShader = ie,
    e.TextMesh = An,
    e.TextureCube = gr,
    e.TextureGenerator = g,
    e.TextureMode = Fr,
    e.TextureSheetAnimation = kt,
    e.Touch = tr,
    e.TrailFilter = zr,
    e.TrailGeometry = Gr,
    e.TrailMaterial = Br,
    e.TrailRenderer = Hr,
    e.TrailSprite3D = Wr,
    e.Transform3D = Ee,
    e.UnlitMaterial = me,
    e.Utils3D = R,
    e.Vector2 = n,
    e.Vector3 = o,
    e.Vector3Keyframe = p,
    e.Vector4 = i,
    e.VelocityOverLifetime = Vt,
    e.VertexBuffer3D = De,
    e.VertexDeclaration = oe,
    e.VertexElement = le,
    e.VertexElementFormat = ae,
    e.VertexMesh = ue,
    e.VertexPositionTerrain = Xr,
    e.VertexPositionTexture0 = Er,
    e.VertexShuriKenParticle = Gt,
    e.VertexShurikenParticleBillboard = zt,
    e.VertexShurikenParticleMesh = Ht,
    e.VertexTrail = Ur,
    e.Viewport = ke,
    e.WaterPrimaryMaterial = pe,
    e.skinnedMatrixCache = $r;
}(window.Laya = window.Laya || {}, Laya);
